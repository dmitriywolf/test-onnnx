var LG=Object.defineProperty;var MG=(t,e,n)=>e in t?LG(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var PN=(t,e,n)=>MG(t,typeof e!="symbol"?e+"":e,n);function BG(t,e){for(var n=0;n<e.length;n++){const s=e[n];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in t)){const a=Object.getOwnPropertyDescriptor(s,r);a&&Object.defineProperty(t,r,a.get?a:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const a of r)if(a.type==="childList")for(const i of a.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function n(r){const a={};return r.integrity&&(a.integrity=r.integrity),r.referrerPolicy&&(a.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?a.credentials="include":r.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function s(r){if(r.ep)return;r.ep=!0;const a=n(r);fetch(r.href,a)}})();function ID(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function PG(t){if(Object.prototype.hasOwnProperty.call(t,"__esModule"))return t;var e=t.default;if(typeof e=="function"){var n=function s(){return this instanceof s?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};n.prototype=e.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(t).forEach(function(s){var r=Object.getOwnPropertyDescriptor(t,s);Object.defineProperty(n,s,r.get?r:{enumerable:!0,get:function(){return t[s]}})}),n}var Yw={exports:{}},Dp={};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var VN;function VG(){if(VN)return Dp;VN=1;var t=Symbol.for("react.transitional.element"),e=Symbol.for("react.fragment");function n(s,r,a){var i=null;if(a!==void 0&&(i=""+a),r.key!==void 0&&(i=""+r.key),"key"in r){a={};for(var o in r)o!=="key"&&(a[o]=r[o])}else a=r;return r=a.ref,{$$typeof:t,type:s,key:i,ref:r!==void 0?r:null,props:a}}return Dp.Fragment=e,Dp.jsx=n,Dp.jsxs=n,Dp}var UN;function UG(){return UN||(UN=1,Yw.exports=VG()),Yw.exports}var Kt=UG(),Zw={exports:{}},vt={};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var WN;function WG(){if(WN)return vt;WN=1;var t=Symbol.for("react.transitional.element"),e=Symbol.for("react.portal"),n=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),a=Symbol.for("react.consumer"),i=Symbol.for("react.context"),o=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),c=Symbol.for("react.memo"),h=Symbol.for("react.lazy"),p=Symbol.iterator;function f(U){return U===null||typeof U!="object"?null:(U=p&&U[p]||U["@@iterator"],typeof U=="function"?U:null)}var g={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},y=Object.assign,x={};function w(U,G,Y){this.props=U,this.context=G,this.refs=x,this.updater=Y||g}w.prototype.isReactComponent={},w.prototype.setState=function(U,G){if(typeof U!="object"&&typeof U!="function"&&U!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,U,G,"setState")},w.prototype.forceUpdate=function(U){this.updater.enqueueForceUpdate(this,U,"forceUpdate")};function v(){}v.prototype=w.prototype;function $(U,G,Y){this.props=U,this.context=G,this.refs=x,this.updater=Y||g}var T=$.prototype=new v;T.constructor=$,y(T,w.prototype),T.isPureReactComponent=!0;var C=Array.isArray,I={H:null,A:null,T:null,S:null},A=Object.prototype.hasOwnProperty;function O(U,G,Y,ce,pe,J){return Y=J.ref,{$$typeof:t,type:U,key:G,ref:Y!==void 0?Y:null,props:J}}function B(U,G){return O(U.type,G,void 0,void 0,void 0,U.props)}function z(U){return typeof U=="object"&&U!==null&&U.$$typeof===t}function P(U){var G={"=":"=0",":":"=2"};return"$"+U.replace(/[=:]/g,function(Y){return G[Y]})}var F=/\/+/g;function K(U,G){return typeof U=="object"&&U!==null&&U.key!=null?P(""+U.key):G.toString(36)}function X(){}function te(U){switch(U.status){case"fulfilled":return U.value;case"rejected":throw U.reason;default:switch(typeof U.status=="string"?U.then(X,X):(U.status="pending",U.then(function(G){U.status==="pending"&&(U.status="fulfilled",U.value=G)},function(G){U.status==="pending"&&(U.status="rejected",U.reason=G)})),U.status){case"fulfilled":return U.value;case"rejected":throw U.reason}}throw U}function Q(U,G,Y,ce,pe){var J=typeof U;(J==="undefined"||J==="boolean")&&(U=null);var we=!1;if(U===null)we=!0;else switch(J){case"bigint":case"string":case"number":we=!0;break;case"object":switch(U.$$typeof){case t:case e:we=!0;break;case h:return we=U._init,Q(we(U._payload),G,Y,ce,pe)}}if(we)return pe=pe(U),we=ce===""?"."+K(U,0):ce,C(pe)?(Y="",we!=null&&(Y=we.replace(F,"$&/")+"/"),Q(pe,G,Y,"",function(Ve){return Ve})):pe!=null&&(z(pe)&&(pe=B(pe,Y+(pe.key==null||U&&U.key===pe.key?"":(""+pe.key).replace(F,"$&/")+"/")+we)),G.push(pe)),1;we=0;var Be=ce===""?".":ce+":";if(C(U))for(var Fe=0;Fe<U.length;Fe++)ce=U[Fe],J=Be+K(ce,Fe),we+=Q(ce,G,Y,J,pe);else if(Fe=f(U),typeof Fe=="function")for(U=Fe.call(U),Fe=0;!(ce=U.next()).done;)ce=ce.value,J=Be+K(ce,Fe++),we+=Q(ce,G,Y,J,pe);else if(J==="object"){if(typeof U.then=="function")return Q(te(U),G,Y,ce,pe);throw G=String(U),Error("Objects are not valid as a React child (found: "+(G==="[object Object]"?"object with keys {"+Object.keys(U).join(", ")+"}":G)+"). If you meant to render a collection of children, use an array instead.")}return we}function q(U,G,Y){if(U==null)return U;var ce=[],pe=0;return Q(U,ce,"","",function(J){return G.call(Y,J,pe++)}),ce}function oe(U){if(U._status===-1){var G=U._result;G=G(),G.then(function(Y){(U._status===0||U._status===-1)&&(U._status=1,U._result=Y)},function(Y){(U._status===0||U._status===-1)&&(U._status=2,U._result=Y)}),U._status===-1&&(U._status=0,U._result=G)}if(U._status===1)return U._result.default;throw U._result}var se=typeof reportError=="function"?reportError:function(U){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var G=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof U=="object"&&U!==null&&typeof U.message=="string"?String(U.message):String(U),error:U});if(!window.dispatchEvent(G))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",U);return}console.error(U)};function ee(){}return vt.Children={map:q,forEach:function(U,G,Y){q(U,function(){G.apply(this,arguments)},Y)},count:function(U){var G=0;return q(U,function(){G++}),G},toArray:function(U){return q(U,function(G){return G})||[]},only:function(U){if(!z(U))throw Error("React.Children.only expected to receive a single React element child.");return U}},vt.Component=w,vt.Fragment=n,vt.Profiler=r,vt.PureComponent=$,vt.StrictMode=s,vt.Suspense=l,vt.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=I,vt.act=function(){throw Error("act(...) is not supported in production builds of React.")},vt.cache=function(U){return function(){return U.apply(null,arguments)}},vt.cloneElement=function(U,G,Y){if(U==null)throw Error("The argument must be a React element, but you passed "+U+".");var ce=y({},U.props),pe=U.key,J=void 0;if(G!=null)for(we in G.ref!==void 0&&(J=void 0),G.key!==void 0&&(pe=""+G.key),G)!A.call(G,we)||we==="key"||we==="__self"||we==="__source"||we==="ref"&&G.ref===void 0||(ce[we]=G[we]);var we=arguments.length-2;if(we===1)ce.children=Y;else if(1<we){for(var Be=Array(we),Fe=0;Fe<we;Fe++)Be[Fe]=arguments[Fe+2];ce.children=Be}return O(U.type,pe,void 0,void 0,J,ce)},vt.createContext=function(U){return U={$$typeof:i,_currentValue:U,_currentValue2:U,_threadCount:0,Provider:null,Consumer:null},U.Provider=U,U.Consumer={$$typeof:a,_context:U},U},vt.createElement=function(U,G,Y){var ce,pe={},J=null;if(G!=null)for(ce in G.key!==void 0&&(J=""+G.key),G)A.call(G,ce)&&ce!=="key"&&ce!=="__self"&&ce!=="__source"&&(pe[ce]=G[ce]);var we=arguments.length-2;if(we===1)pe.children=Y;else if(1<we){for(var Be=Array(we),Fe=0;Fe<we;Fe++)Be[Fe]=arguments[Fe+2];pe.children=Be}if(U&&U.defaultProps)for(ce in we=U.defaultProps,we)pe[ce]===void 0&&(pe[ce]=we[ce]);return O(U,J,void 0,void 0,null,pe)},vt.createRef=function(){return{current:null}},vt.forwardRef=function(U){return{$$typeof:o,render:U}},vt.isValidElement=z,vt.lazy=function(U){return{$$typeof:h,_payload:{_status:-1,_result:U},_init:oe}},vt.memo=function(U,G){return{$$typeof:c,type:U,compare:G===void 0?null:G}},vt.startTransition=function(U){var G=I.T,Y={};I.T=Y;try{var ce=U(),pe=I.S;pe!==null&&pe(Y,ce),typeof ce=="object"&&ce!==null&&typeof ce.then=="function"&&ce.then(ee,se)}catch(J){se(J)}finally{I.T=G}},vt.unstable_useCacheRefresh=function(){return I.H.useCacheRefresh()},vt.use=function(U){return I.H.use(U)},vt.useActionState=function(U,G,Y){return I.H.useActionState(U,G,Y)},vt.useCallback=function(U,G){return I.H.useCallback(U,G)},vt.useContext=function(U){return I.H.useContext(U)},vt.useDebugValue=function(){},vt.useDeferredValue=function(U,G){return I.H.useDeferredValue(U,G)},vt.useEffect=function(U,G){return I.H.useEffect(U,G)},vt.useId=function(){return I.H.useId()},vt.useImperativeHandle=function(U,G,Y){return I.H.useImperativeHandle(U,G,Y)},vt.useInsertionEffect=function(U,G){return I.H.useInsertionEffect(U,G)},vt.useLayoutEffect=function(U,G){return I.H.useLayoutEffect(U,G)},vt.useMemo=function(U,G){return I.H.useMemo(U,G)},vt.useOptimistic=function(U,G){return I.H.useOptimistic(U,G)},vt.useReducer=function(U,G,Y){return I.H.useReducer(U,G,Y)},vt.useRef=function(U){return I.H.useRef(U)},vt.useState=function(U){return I.H.useState(U)},vt.useSyncExternalStore=function(U,G,Y){return I.H.useSyncExternalStore(U,G,Y)},vt.useTransition=function(){return I.H.useTransition()},vt.version="19.0.0",vt}var GN;function A2(){return GN||(GN=1,Zw.exports=WG()),Zw.exports}var Ce=A2(),Qw={exports:{}},Op={},Jw={exports:{}},ev={};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var HN;function GG(){return HN||(HN=1,function(t){function e(q,oe){var se=q.length;q.push(oe);e:for(;0<se;){var ee=se-1>>>1,U=q[ee];if(0<r(U,oe))q[ee]=oe,q[se]=U,se=ee;else break e}}function n(q){return q.length===0?null:q[0]}function s(q){if(q.length===0)return null;var oe=q[0],se=q.pop();if(se!==oe){q[0]=se;e:for(var ee=0,U=q.length,G=U>>>1;ee<G;){var Y=2*(ee+1)-1,ce=q[Y],pe=Y+1,J=q[pe];if(0>r(ce,se))pe<U&&0>r(J,ce)?(q[ee]=J,q[pe]=se,ee=pe):(q[ee]=ce,q[Y]=se,ee=Y);else if(pe<U&&0>r(J,se))q[ee]=J,q[pe]=se,ee=pe;else break e}}return oe}function r(q,oe){var se=q.sortIndex-oe.sortIndex;return se!==0?se:q.id-oe.id}if(t.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var a=performance;t.unstable_now=function(){return a.now()}}else{var i=Date,o=i.now();t.unstable_now=function(){return i.now()-o}}var l=[],c=[],h=1,p=null,f=3,g=!1,y=!1,x=!1,w=typeof setTimeout=="function"?setTimeout:null,v=typeof clearTimeout=="function"?clearTimeout:null,$=typeof setImmediate<"u"?setImmediate:null;function T(q){for(var oe=n(c);oe!==null;){if(oe.callback===null)s(c);else if(oe.startTime<=q)s(c),oe.sortIndex=oe.expirationTime,e(l,oe);else break;oe=n(c)}}function C(q){if(x=!1,T(q),!y)if(n(l)!==null)y=!0,te();else{var oe=n(c);oe!==null&&Q(C,oe.startTime-q)}}var I=!1,A=-1,O=5,B=-1;function z(){return!(t.unstable_now()-B<O)}function P(){if(I){var q=t.unstable_now();B=q;var oe=!0;try{e:{y=!1,x&&(x=!1,v(A),A=-1),g=!0;var se=f;try{t:{for(T(q),p=n(l);p!==null&&!(p.expirationTime>q&&z());){var ee=p.callback;if(typeof ee=="function"){p.callback=null,f=p.priorityLevel;var U=ee(p.expirationTime<=q);if(q=t.unstable_now(),typeof U=="function"){p.callback=U,T(q),oe=!0;break t}p===n(l)&&s(l),T(q)}else s(l);p=n(l)}if(p!==null)oe=!0;else{var G=n(c);G!==null&&Q(C,G.startTime-q),oe=!1}}break e}finally{p=null,f=se,g=!1}oe=void 0}}finally{oe?F():I=!1}}}var F;if(typeof $=="function")F=function(){$(P)};else if(typeof MessageChannel<"u"){var K=new MessageChannel,X=K.port2;K.port1.onmessage=P,F=function(){X.postMessage(null)}}else F=function(){w(P,0)};function te(){I||(I=!0,F())}function Q(q,oe){A=w(function(){q(t.unstable_now())},oe)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(q){q.callback=null},t.unstable_continueExecution=function(){y||g||(y=!0,te())},t.unstable_forceFrameRate=function(q){0>q||125<q?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):O=0<q?Math.floor(1e3/q):5},t.unstable_getCurrentPriorityLevel=function(){return f},t.unstable_getFirstCallbackNode=function(){return n(l)},t.unstable_next=function(q){switch(f){case 1:case 2:case 3:var oe=3;break;default:oe=f}var se=f;f=oe;try{return q()}finally{f=se}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(q,oe){switch(q){case 1:case 2:case 3:case 4:case 5:break;default:q=3}var se=f;f=q;try{return oe()}finally{f=se}},t.unstable_scheduleCallback=function(q,oe,se){var ee=t.unstable_now();switch(typeof se=="object"&&se!==null?(se=se.delay,se=typeof se=="number"&&0<se?ee+se:ee):se=ee,q){case 1:var U=-1;break;case 2:U=250;break;case 5:U=1073741823;break;case 4:U=1e4;break;default:U=5e3}return U=se+U,q={id:h++,callback:oe,priorityLevel:q,startTime:se,expirationTime:U,sortIndex:-1},se>ee?(q.sortIndex=se,e(c,q),n(l)===null&&q===n(c)&&(x?(v(A),A=-1):x=!0,Q(C,se-ee))):(q.sortIndex=U,e(l,q),y||g||(y=!0,te())),q},t.unstable_shouldYield=z,t.unstable_wrapCallback=function(q){var oe=f;return function(){var se=f;f=oe;try{return q.apply(this,arguments)}finally{f=se}}}}(ev)),ev}var qN;function HG(){return qN||(qN=1,Jw.exports=GG()),Jw.exports}var tv={exports:{}},Bs={};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var jN;function qG(){if(jN)return Bs;jN=1;var t=A2();function e(l){var c="https://react.dev/errors/"+l;if(1<arguments.length){c+="?args[]="+encodeURIComponent(arguments[1]);for(var h=2;h<arguments.length;h++)c+="&args[]="+encodeURIComponent(arguments[h])}return"Minified React error #"+l+"; visit "+c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function n(){}var s={d:{f:n,r:function(){throw Error(e(522))},D:n,C:n,L:n,m:n,X:n,S:n,M:n},p:0,findDOMNode:null},r=Symbol.for("react.portal");function a(l,c,h){var p=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:r,key:p==null?null:""+p,children:l,containerInfo:c,implementation:h}}var i=t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function o(l,c){if(l==="font")return"";if(typeof c=="string")return c==="use-credentials"?c:""}return Bs.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=s,Bs.createPortal=function(l,c){var h=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!c||c.nodeType!==1&&c.nodeType!==9&&c.nodeType!==11)throw Error(e(299));return a(l,c,null,h)},Bs.flushSync=function(l){var c=i.T,h=s.p;try{if(i.T=null,s.p=2,l)return l()}finally{i.T=c,s.p=h,s.d.f()}},Bs.preconnect=function(l,c){typeof l=="string"&&(c?(c=c.crossOrigin,c=typeof c=="string"?c==="use-credentials"?c:"":void 0):c=null,s.d.C(l,c))},Bs.prefetchDNS=function(l){typeof l=="string"&&s.d.D(l)},Bs.preinit=function(l,c){if(typeof l=="string"&&c&&typeof c.as=="string"){var h=c.as,p=o(h,c.crossOrigin),f=typeof c.integrity=="string"?c.integrity:void 0,g=typeof c.fetchPriority=="string"?c.fetchPriority:void 0;h==="style"?s.d.S(l,typeof c.precedence=="string"?c.precedence:void 0,{crossOrigin:p,integrity:f,fetchPriority:g}):h==="script"&&s.d.X(l,{crossOrigin:p,integrity:f,fetchPriority:g,nonce:typeof c.nonce=="string"?c.nonce:void 0})}},Bs.preinitModule=function(l,c){if(typeof l=="string")if(typeof c=="object"&&c!==null){if(c.as==null||c.as==="script"){var h=o(c.as,c.crossOrigin);s.d.M(l,{crossOrigin:h,integrity:typeof c.integrity=="string"?c.integrity:void 0,nonce:typeof c.nonce=="string"?c.nonce:void 0})}}else c==null&&s.d.M(l)},Bs.preload=function(l,c){if(typeof l=="string"&&typeof c=="object"&&c!==null&&typeof c.as=="string"){var h=c.as,p=o(h,c.crossOrigin);s.d.L(l,h,{crossOrigin:p,integrity:typeof c.integrity=="string"?c.integrity:void 0,nonce:typeof c.nonce=="string"?c.nonce:void 0,type:typeof c.type=="string"?c.type:void 0,fetchPriority:typeof c.fetchPriority=="string"?c.fetchPriority:void 0,referrerPolicy:typeof c.referrerPolicy=="string"?c.referrerPolicy:void 0,imageSrcSet:typeof c.imageSrcSet=="string"?c.imageSrcSet:void 0,imageSizes:typeof c.imageSizes=="string"?c.imageSizes:void 0,media:typeof c.media=="string"?c.media:void 0})}},Bs.preloadModule=function(l,c){if(typeof l=="string")if(c){var h=o(c.as,c.crossOrigin);s.d.m(l,{as:typeof c.as=="string"&&c.as!=="script"?c.as:void 0,crossOrigin:h,integrity:typeof c.integrity=="string"?c.integrity:void 0})}else s.d.m(l)},Bs.requestFormReset=function(l){s.d.r(l)},Bs.unstable_batchedUpdates=function(l,c){return l(c)},Bs.useFormState=function(l,c,h){return i.H.useFormState(l,c,h)},Bs.useFormStatus=function(){return i.H.useHostTransitionStatus()},Bs.version="19.0.0",Bs}var KN;function jG(){if(KN)return tv.exports;KN=1;function t(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)}catch(e){console.error(e)}}return t(),tv.exports=qG(),tv.exports}/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var XN;function KG(){if(XN)return Op;XN=1;var t=HG(),e=A2(),n=jG();function s(u){var d="https://react.dev/errors/"+u;if(1<arguments.length){d+="?args[]="+encodeURIComponent(arguments[1]);for(var m=2;m<arguments.length;m++)d+="&args[]="+encodeURIComponent(arguments[m])}return"Minified React error #"+u+"; visit "+d+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function r(u){return!(!u||u.nodeType!==1&&u.nodeType!==9&&u.nodeType!==11)}var a=Symbol.for("react.element"),i=Symbol.for("react.transitional.element"),o=Symbol.for("react.portal"),l=Symbol.for("react.fragment"),c=Symbol.for("react.strict_mode"),h=Symbol.for("react.profiler"),p=Symbol.for("react.provider"),f=Symbol.for("react.consumer"),g=Symbol.for("react.context"),y=Symbol.for("react.forward_ref"),x=Symbol.for("react.suspense"),w=Symbol.for("react.suspense_list"),v=Symbol.for("react.memo"),$=Symbol.for("react.lazy"),T=Symbol.for("react.offscreen"),C=Symbol.for("react.memo_cache_sentinel"),I=Symbol.iterator;function A(u){return u===null||typeof u!="object"?null:(u=I&&u[I]||u["@@iterator"],typeof u=="function"?u:null)}var O=Symbol.for("react.client.reference");function B(u){if(u==null)return null;if(typeof u=="function")return u.$$typeof===O?null:u.displayName||u.name||null;if(typeof u=="string")return u;switch(u){case l:return"Fragment";case o:return"Portal";case h:return"Profiler";case c:return"StrictMode";case x:return"Suspense";case w:return"SuspenseList"}if(typeof u=="object")switch(u.$$typeof){case g:return(u.displayName||"Context")+".Provider";case f:return(u._context.displayName||"Context")+".Consumer";case y:var d=u.render;return u=u.displayName,u||(u=d.displayName||d.name||"",u=u!==""?"ForwardRef("+u+")":"ForwardRef"),u;case v:return d=u.displayName||null,d!==null?d:B(u.type)||"Memo";case $:d=u._payload,u=u._init;try{return B(u(d))}catch{}}return null}var z=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,P=Object.assign,F,K;function X(u){if(F===void 0)try{throw Error()}catch(m){var d=m.stack.trim().match(/\n( *(at )?)/);F=d&&d[1]||"",K=-1<m.stack.indexOf(`
    at`)?" (<anonymous>)":-1<m.stack.indexOf("@")?"@unknown:0:0":""}return`
`+F+u+K}var te=!1;function Q(u,d){if(!u||te)return"";te=!0;var m=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var b={DetermineComponentFrameRoot:function(){try{if(d){var Oe=function(){throw Error()};if(Object.defineProperty(Oe.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(Oe,[])}catch(ke){var xe=ke}Reflect.construct(u,[],Oe)}else{try{Oe.call()}catch(ke){xe=ke}u.call(Oe.prototype)}}else{try{throw Error()}catch(ke){xe=ke}(Oe=u())&&typeof Oe.catch=="function"&&Oe.catch(function(){})}}catch(ke){if(ke&&xe&&typeof ke.stack=="string")return[ke.stack,xe.stack]}return[null,null]}};b.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var _=Object.getOwnPropertyDescriptor(b.DetermineComponentFrameRoot,"name");_&&_.configurable&&Object.defineProperty(b.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var N=b.DetermineComponentFrameRoot(),M=N[0],H=N[1];if(M&&H){var Z=M.split(`
`),he=H.split(`
`);for(_=b=0;b<Z.length&&!Z[b].includes("DetermineComponentFrameRoot");)b++;for(;_<he.length&&!he[_].includes("DetermineComponentFrameRoot");)_++;if(b===Z.length||_===he.length)for(b=Z.length-1,_=he.length-1;1<=b&&0<=_&&Z[b]!==he[_];)_--;for(;1<=b&&0<=_;b--,_--)if(Z[b]!==he[_]){if(b!==1||_!==1)do if(b--,_--,0>_||Z[b]!==he[_]){var Ne=`
`+Z[b].replace(" at new "," at ");return u.displayName&&Ne.includes("<anonymous>")&&(Ne=Ne.replace("<anonymous>",u.displayName)),Ne}while(1<=b&&0<=_);break}}}finally{te=!1,Error.prepareStackTrace=m}return(m=u?u.displayName||u.name:"")?X(m):""}function q(u){switch(u.tag){case 26:case 27:case 5:return X(u.type);case 16:return X("Lazy");case 13:return X("Suspense");case 19:return X("SuspenseList");case 0:case 15:return u=Q(u.type,!1),u;case 11:return u=Q(u.type.render,!1),u;case 1:return u=Q(u.type,!0),u;default:return""}}function oe(u){try{var d="";do d+=q(u),u=u.return;while(u);return d}catch(m){return`
Error generating stack: `+m.message+`
`+m.stack}}function se(u){var d=u,m=u;if(u.alternate)for(;d.return;)d=d.return;else{u=d;do d=u,(d.flags&4098)!==0&&(m=d.return),u=d.return;while(u)}return d.tag===3?m:null}function ee(u){if(u.tag===13){var d=u.memoizedState;if(d===null&&(u=u.alternate,u!==null&&(d=u.memoizedState)),d!==null)return d.dehydrated}return null}function U(u){if(se(u)!==u)throw Error(s(188))}function G(u){var d=u.alternate;if(!d){if(d=se(u),d===null)throw Error(s(188));return d!==u?null:u}for(var m=u,b=d;;){var _=m.return;if(_===null)break;var N=_.alternate;if(N===null){if(b=_.return,b!==null){m=b;continue}break}if(_.child===N.child){for(N=_.child;N;){if(N===m)return U(_),u;if(N===b)return U(_),d;N=N.sibling}throw Error(s(188))}if(m.return!==b.return)m=_,b=N;else{for(var M=!1,H=_.child;H;){if(H===m){M=!0,m=_,b=N;break}if(H===b){M=!0,b=_,m=N;break}H=H.sibling}if(!M){for(H=N.child;H;){if(H===m){M=!0,m=N,b=_;break}if(H===b){M=!0,b=N,m=_;break}H=H.sibling}if(!M)throw Error(s(189))}}if(m.alternate!==b)throw Error(s(190))}if(m.tag!==3)throw Error(s(188));return m.stateNode.current===m?u:d}function Y(u){var d=u.tag;if(d===5||d===26||d===27||d===6)return u;for(u=u.child;u!==null;){if(d=Y(u),d!==null)return d;u=u.sibling}return null}var ce=Array.isArray,pe=n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,J={pending:!1,data:null,method:null,action:null},we=[],Be=-1;function Fe(u){return{current:u}}function Ve(u){0>Be||(u.current=we[Be],we[Be]=null,Be--)}function Me(u,d){Be++,we[Be]=u.current,u.current=d}var Pe=Fe(null),pt=Fe(null),yt=Fe(null),Dt=Fe(null);function kt(u,d){switch(Me(yt,d),Me(pt,u),Me(Pe,null),u=d.nodeType,u){case 9:case 11:d=(d=d.documentElement)&&(d=d.namespaceURI)?mN(d):0;break;default:if(u=u===8?d.parentNode:d,d=u.tagName,u=u.namespaceURI)u=mN(u),d=gN(u,d);else switch(d){case"svg":d=1;break;case"math":d=2;break;default:d=0}}Ve(Pe),Me(Pe,d)}function Ct(){Ve(Pe),Ve(pt),Ve(yt)}function Nt(u){u.memoizedState!==null&&Me(Dt,u);var d=Pe.current,m=gN(d,u.type);d!==m&&(Me(pt,u),Me(Pe,m))}function Gt(u){pt.current===u&&(Ve(Pe),Ve(pt)),Dt.current===u&&(Ve(Dt),Np._currentValue=J)}var Ss=Object.prototype.hasOwnProperty,mn=t.unstable_scheduleCallback,ur=t.unstable_cancelCallback,Jn=t.unstable_shouldYield,Qr=t.unstable_requestPaint,ln=t.unstable_now,cr=t.unstable_getCurrentPriorityLevel,Pn=t.unstable_ImmediatePriority,Et=t.unstable_UserBlockingPriority,_s=t.unstable_NormalPriority,ti=t.unstable_LowPriority,ni=t.unstable_IdlePriority,dr=t.log,Li=t.unstable_setDisableYieldValue,Rr=null,vn=null;function Dc(u){if(vn&&typeof vn.onCommitFiberRoot=="function")try{vn.onCommitFiberRoot(Rr,u,void 0,(u.current.flags&128)===128)}catch{}}function ka(u){if(typeof dr=="function"&&Li(u),vn&&typeof vn.setStrictMode=="function")try{vn.setStrictMode(Rr,u)}catch{}}var zs=Math.clz32?Math.clz32:Zx,Qm=Math.log,Yx=Math.LN2;function Zx(u){return u>>>=0,u===0?32:31-(Qm(u)/Yx|0)|0}var Mi=128,Oc=4194304;function hr(u){var d=u&42;if(d!==0)return d;switch(u&-u){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return u&4194176;case 4194304:case 8388608:case 16777216:case 33554432:return u&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return u}}function zc(u,d){var m=u.pendingLanes;if(m===0)return 0;var b=0,_=u.suspendedLanes,N=u.pingedLanes,M=u.warmLanes;u=u.finishedLanes!==0;var H=m&134217727;return H!==0?(m=H&~_,m!==0?b=hr(m):(N&=H,N!==0?b=hr(N):u||(M=H&~M,M!==0&&(b=hr(M))))):(H=m&~_,H!==0?b=hr(H):N!==0?b=hr(N):u||(M=m&~M,M!==0&&(b=hr(M)))),b===0?0:d!==0&&d!==b&&(d&_)===0&&(_=b&-b,M=d&-d,_>=M||_===32&&(M&4194176)!==0)?d:b}function Bi(u,d){return(u.pendingLanes&~(u.suspendedLanes&~u.pingedLanes)&d)===0}function Qx(u,d){switch(u){case 1:case 2:case 4:case 8:return d+250;case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return d+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Fc(){var u=Mi;return Mi<<=1,(Mi&4194176)===0&&(Mi=128),u}function Jm(){var u=Oc;return Oc<<=1,(Oc&62914560)===0&&(Oc=4194304),u}function gh(u){for(var d=[],m=0;31>m;m++)d.push(u);return d}function nu(u,d){u.pendingLanes|=d,d!==268435456&&(u.suspendedLanes=0,u.pingedLanes=0,u.warmLanes=0)}function Jx(u,d,m,b,_,N){var M=u.pendingLanes;u.pendingLanes=m,u.suspendedLanes=0,u.pingedLanes=0,u.warmLanes=0,u.expiredLanes&=m,u.entangledLanes&=m,u.errorRecoveryDisabledLanes&=m,u.shellSuspendCounter=0;var H=u.entanglements,Z=u.expirationTimes,he=u.hiddenUpdates;for(m=M&~m;0<m;){var Ne=31-zs(m),Oe=1<<Ne;H[Ne]=0,Z[Ne]=-1;var xe=he[Ne];if(xe!==null)for(he[Ne]=null,Ne=0;Ne<xe.length;Ne++){var ke=xe[Ne];ke!==null&&(ke.lane&=-536870913)}m&=~Oe}b!==0&&eg(u,b,0),N!==0&&_===0&&u.tag!==0&&(u.suspendedLanes|=N&~(M&~d))}function eg(u,d,m){u.pendingLanes|=d,u.suspendedLanes&=~d;var b=31-zs(d);u.entangledLanes|=d,u.entanglements[b]=u.entanglements[b]|1073741824|m&4194218}function yh(u,d){var m=u.entangledLanes|=d;for(u=u.entanglements;m;){var b=31-zs(m),_=1<<b;_&d|u[b]&d&&(u[b]|=d),m&=~_}}function bh(u){return u&=-u,2<u?8<u?(u&134217727)!==0?32:268435456:8:2}function xh(){var u=pe.p;return u!==0?u:(u=window.event,u===void 0?32:ON(u.type))}function tg(u,d){var m=pe.p;try{return pe.p=u,d()}finally{pe.p=m}}var Yt=Math.random().toString(36).slice(2),es="__reactFiber$"+Yt,Cs="__reactProps$"+Yt,Pi="__reactContainer$"+Yt,si="__reactEvents$"+Yt,ng="__reactListeners$"+Yt,sg="__reactHandles$"+Yt,wh="__reactResources$"+Yt,Fo="__reactMarker$"+Yt;function Lc(u){delete u[es],delete u[Cs],delete u[si],delete u[ng],delete u[sg]}function ri(u){var d=u[es];if(d)return d;for(var m=u.parentNode;m;){if(d=m[Pi]||m[es]){if(m=d.alternate,d.child!==null||m!==null&&m.child!==null)for(u=xN(u);u!==null;){if(m=u[es])return m;u=xN(u)}return d}u=m,m=u.parentNode}return null}function Vi(u){if(u=u[es]||u[Pi]){var d=u.tag;if(d===5||d===6||d===13||d===26||d===27||d===3)return u}return null}function Lo(u){var d=u.tag;if(d===5||d===26||d===27||d===6)return u.stateNode;throw Error(s(33))}function Ui(u){var d=u[wh];return d||(d=u[wh]={hoistableStyles:new Map,hoistableScripts:new Map}),d}function Fn(u){u[Fo]=!0}var vh=new Set,$h={};function Fs(u,d){Mo(u,d),Mo(u+"Capture",d)}function Mo(u,d){for($h[u]=d,u=0;u<d.length;u++)vh.add(d[u])}var Vn=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Sh=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),Mc={},Jr={};function rg(u){return Ss.call(Jr,u)?!0:Ss.call(Mc,u)?!1:Sh.test(u)?Jr[u]=!0:(Mc[u]=!0,!1)}function Bc(u,d,m){if(rg(d))if(m===null)u.removeAttribute(d);else{switch(typeof m){case"undefined":case"function":case"symbol":u.removeAttribute(d);return;case"boolean":var b=d.toLowerCase().slice(0,5);if(b!=="data-"&&b!=="aria-"){u.removeAttribute(d);return}}u.setAttribute(d,""+m)}}function Dr(u,d,m){if(m===null)u.removeAttribute(d);else{switch(typeof m){case"undefined":case"function":case"symbol":case"boolean":u.removeAttribute(d);return}u.setAttribute(d,""+m)}}function Na(u,d,m,b){if(b===null)u.removeAttribute(m);else{switch(typeof b){case"undefined":case"function":case"symbol":case"boolean":u.removeAttribute(m);return}u.setAttributeNS(d,m,""+b)}}function Ls(u){switch(typeof u){case"bigint":case"boolean":case"number":case"string":case"undefined":return u;case"object":return u;default:return""}}function ea(u){var d=u.type;return(u=u.nodeName)&&u.toLowerCase()==="input"&&(d==="checkbox"||d==="radio")}function _h(u){var d=ea(u)?"checked":"value",m=Object.getOwnPropertyDescriptor(u.constructor.prototype,d),b=""+u[d];if(!u.hasOwnProperty(d)&&typeof m<"u"&&typeof m.get=="function"&&typeof m.set=="function"){var _=m.get,N=m.set;return Object.defineProperty(u,d,{configurable:!0,get:function(){return _.call(this)},set:function(M){b=""+M,N.call(this,M)}}),Object.defineProperty(u,d,{enumerable:m.enumerable}),{getValue:function(){return b},setValue:function(M){b=""+M},stopTracking:function(){u._valueTracker=null,delete u[d]}}}}function us(u){u._valueTracker||(u._valueTracker=_h(u))}function Xs(u){if(!u)return!1;var d=u._valueTracker;if(!d)return!0;var m=d.getValue(),b="";return u&&(b=ea(u)?u.checked?"true":"false":u.value),u=b,u!==m?(d.setValue(u),!0):!1}function Bo(u){if(u=u||(typeof document<"u"?document:void 0),typeof u>"u")return null;try{return u.activeElement||u.body}catch{return u.body}}var e1=/[\n"\\]/g;function pr(u){return u.replace(e1,function(d){return"\\"+d.charCodeAt(0).toString(16)+" "})}function Ch(u,d,m,b,_,N,M,H){u.name="",M!=null&&typeof M!="function"&&typeof M!="symbol"&&typeof M!="boolean"?u.type=M:u.removeAttribute("type"),d!=null?M==="number"?(d===0&&u.value===""||u.value!=d)&&(u.value=""+Ls(d)):u.value!==""+Ls(d)&&(u.value=""+Ls(d)):M!=="submit"&&M!=="reset"||u.removeAttribute("value"),d!=null?Th(u,M,Ls(d)):m!=null?Th(u,M,Ls(m)):b!=null&&u.removeAttribute("value"),_==null&&N!=null&&(u.defaultChecked=!!N),_!=null&&(u.checked=_&&typeof _!="function"&&typeof _!="symbol"),H!=null&&typeof H!="function"&&typeof H!="symbol"&&typeof H!="boolean"?u.name=""+Ls(H):u.removeAttribute("name")}function ag(u,d,m,b,_,N,M,H){if(N!=null&&typeof N!="function"&&typeof N!="symbol"&&typeof N!="boolean"&&(u.type=N),d!=null||m!=null){if(!(N!=="submit"&&N!=="reset"||d!=null))return;m=m!=null?""+Ls(m):"",d=d!=null?""+Ls(d):m,H||d===u.value||(u.value=d),u.defaultValue=d}b=b??_,b=typeof b!="function"&&typeof b!="symbol"&&!!b,u.checked=H?u.checked:!!b,u.defaultChecked=!!b,M!=null&&typeof M!="function"&&typeof M!="symbol"&&typeof M!="boolean"&&(u.name=M)}function Th(u,d,m){d==="number"&&Bo(u.ownerDocument)===u||u.defaultValue===""+m||(u.defaultValue=""+m)}function Po(u,d,m,b){if(u=u.options,d){d={};for(var _=0;_<m.length;_++)d["$"+m[_]]=!0;for(m=0;m<u.length;m++)_=d.hasOwnProperty("$"+u[m].value),u[m].selected!==_&&(u[m].selected=_),_&&b&&(u[m].defaultSelected=!0)}else{for(m=""+Ls(m),d=null,_=0;_<u.length;_++){if(u[_].value===m){u[_].selected=!0,b&&(u[_].defaultSelected=!0);return}d!==null||u[_].disabled||(d=u[_])}d!==null&&(d.selected=!0)}}function ig(u,d,m){if(d!=null&&(d=""+Ls(d),d!==u.value&&(u.value=d),m==null)){u.defaultValue!==d&&(u.defaultValue=d);return}u.defaultValue=m!=null?""+Ls(m):""}function kh(u,d,m,b){if(d==null){if(b!=null){if(m!=null)throw Error(s(92));if(ce(b)){if(1<b.length)throw Error(s(93));b=b[0]}m=b}m==null&&(m=""),d=m}m=Ls(d),u.defaultValue=m,b=u.textContent,b===m&&b!==""&&b!==null&&(u.value=b)}function Vo(u,d){if(d){var m=u.firstChild;if(m&&m===u.lastChild&&m.nodeType===3){m.nodeValue=d;return}}u.textContent=d}var t1=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function og(u,d,m){var b=d.indexOf("--")===0;m==null||typeof m=="boolean"||m===""?b?u.setProperty(d,""):d==="float"?u.cssFloat="":u[d]="":b?u.setProperty(d,m):typeof m!="number"||m===0||t1.has(d)?d==="float"?u.cssFloat=m:u[d]=(""+m).trim():u[d]=m+"px"}function lg(u,d,m){if(d!=null&&typeof d!="object")throw Error(s(62));if(u=u.style,m!=null){for(var b in m)!m.hasOwnProperty(b)||d!=null&&d.hasOwnProperty(b)||(b.indexOf("--")===0?u.setProperty(b,""):b==="float"?u.cssFloat="":u[b]="");for(var _ in d)b=d[_],d.hasOwnProperty(_)&&m[_]!==b&&og(u,_,b)}else for(var N in d)d.hasOwnProperty(N)&&og(u,N,d[N])}function Nh(u){if(u.indexOf("-")===-1)return!1;switch(u){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var n1=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),s1=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function Pc(u){return s1.test(""+u)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":u}var Ih=null;function su(u){return u=u.target||u.srcElement||window,u.correspondingUseElement&&(u=u.correspondingUseElement),u.nodeType===3?u.parentNode:u}var ai=null,Ia=null;function ug(u){var d=Vi(u);if(d&&(u=d.stateNode)){var m=u[Cs]||null;e:switch(u=d.stateNode,d.type){case"input":if(Ch(u,m.value,m.defaultValue,m.defaultValue,m.checked,m.defaultChecked,m.type,m.name),d=m.name,m.type==="radio"&&d!=null){for(m=u;m.parentNode;)m=m.parentNode;for(m=m.querySelectorAll('input[name="'+pr(""+d)+'"][type="radio"]'),d=0;d<m.length;d++){var b=m[d];if(b!==u&&b.form===u.form){var _=b[Cs]||null;if(!_)throw Error(s(90));Ch(b,_.value,_.defaultValue,_.defaultValue,_.checked,_.defaultChecked,_.type,_.name)}}for(d=0;d<m.length;d++)b=m[d],b.form===u.form&&Xs(b)}break e;case"textarea":ig(u,m.value,m.defaultValue);break e;case"select":d=m.value,d!=null&&Po(u,!!m.multiple,d,!1)}}}var ru=!1;function cg(u,d,m){if(ru)return u(d,m);ru=!0;try{var b=u(d);return b}finally{if(ru=!1,(ai!==null||Ia!==null)&&(ry(),ai&&(d=ai,u=Ia,Ia=ai=null,ug(d),u)))for(d=0;d<u.length;d++)ug(u[d])}}function au(u,d){var m=u.stateNode;if(m===null)return null;var b=m[Cs]||null;if(b===null)return null;m=b[d];e:switch(d){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(b=!b.disabled)||(u=u.type,b=!(u==="button"||u==="input"||u==="select"||u==="textarea")),u=!b;break e;default:u=!1}if(u)return null;if(m&&typeof m!="function")throw Error(s(231,d,typeof m));return m}var Eh=!1;if(Vn)try{var iu={};Object.defineProperty(iu,"passive",{get:function(){Eh=!0}}),window.addEventListener("test",iu,iu),window.removeEventListener("test",iu,iu)}catch{Eh=!1}var Or=null,Vc=null,Uc=null;function dg(){if(Uc)return Uc;var u,d=Vc,m=d.length,b,_="value"in Or?Or.value:Or.textContent,N=_.length;for(u=0;u<m&&d[u]===_[u];u++);var M=m-u;for(b=1;b<=M&&d[m-b]===_[N-b];b++);return Uc=_.slice(u,1<b?1-b:void 0)}function Wi(u){var d=u.keyCode;return"charCode"in u?(u=u.charCode,u===0&&d===13&&(u=13)):u=d,u===10&&(u=13),32<=u||u===13?u:0}function zr(){return!0}function Fr(){return!1}function Ts(u){function d(m,b,_,N,M){this._reactName=m,this._targetInst=_,this.type=b,this.nativeEvent=N,this.target=M,this.currentTarget=null;for(var H in u)u.hasOwnProperty(H)&&(m=u[H],this[H]=m?m(N):N[H]);return this.isDefaultPrevented=(N.defaultPrevented!=null?N.defaultPrevented:N.returnValue===!1)?zr:Fr,this.isPropagationStopped=Fr,this}return P(d.prototype,{preventDefault:function(){this.defaultPrevented=!0;var m=this.nativeEvent;m&&(m.preventDefault?m.preventDefault():typeof m.returnValue!="unknown"&&(m.returnValue=!1),this.isDefaultPrevented=zr)},stopPropagation:function(){var m=this.nativeEvent;m&&(m.stopPropagation?m.stopPropagation():typeof m.cancelBubble!="unknown"&&(m.cancelBubble=!0),this.isPropagationStopped=zr)},persist:function(){},isPersistent:zr}),d}var ta={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(u){return u.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},ou=Ts(ta),Uo=P({},ta,{view:0,detail:0}),r1=Ts(Uo),lu,Ah,Wo,Wc=P({},Uo,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Dh,button:0,buttons:0,relatedTarget:function(u){return u.relatedTarget===void 0?u.fromElement===u.srcElement?u.toElement:u.fromElement:u.relatedTarget},movementX:function(u){return"movementX"in u?u.movementX:(u!==Wo&&(Wo&&u.type==="mousemove"?(lu=u.screenX-Wo.screenX,Ah=u.screenY-Wo.screenY):Ah=lu=0,Wo=u),lu)},movementY:function(u){return"movementY"in u?u.movementY:Ah}}),uu=Ts(Wc),a1=P({},Wc,{dataTransfer:0}),i1=Ts(a1),Gc=P({},Uo,{relatedTarget:0}),Rh=Ts(Gc),hg=P({},ta,{animationName:0,elapsedTime:0,pseudoElement:0}),o1=Ts(hg),l1=P({},ta,{clipboardData:function(u){return"clipboardData"in u?u.clipboardData:window.clipboardData}}),u1=Ts(l1),pg=P({},ta,{data:0}),fg=Ts(pg),c1={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},d1={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},h1={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function p1(u){var d=this.nativeEvent;return d.getModifierState?d.getModifierState(u):(u=h1[u])?!!d[u]:!1}function Dh(){return p1}var f1=P({},Uo,{key:function(u){if(u.key){var d=c1[u.key]||u.key;if(d!=="Unidentified")return d}return u.type==="keypress"?(u=Wi(u),u===13?"Enter":String.fromCharCode(u)):u.type==="keydown"||u.type==="keyup"?d1[u.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Dh,charCode:function(u){return u.type==="keypress"?Wi(u):0},keyCode:function(u){return u.type==="keydown"||u.type==="keyup"?u.keyCode:0},which:function(u){return u.type==="keypress"?Wi(u):u.type==="keydown"||u.type==="keyup"?u.keyCode:0}}),m1=Ts(f1),g1=P({},Wc,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),mg=Ts(g1),y1=P({},Uo,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Dh}),b1=Ts(y1),gg=P({},ta,{propertyName:0,elapsedTime:0,pseudoElement:0}),yg=Ts(gg),bg=P({},Wc,{deltaX:function(u){return"deltaX"in u?u.deltaX:"wheelDeltaX"in u?-u.wheelDeltaX:0},deltaY:function(u){return"deltaY"in u?u.deltaY:"wheelDeltaY"in u?-u.wheelDeltaY:"wheelDelta"in u?-u.wheelDelta:0},deltaZ:0,deltaMode:0}),x1=Ts(bg),w1=P({},ta,{newState:0,oldState:0}),xg=Ts(w1),wg=[9,13,27,32],Gi=Vn&&"CompositionEvent"in window,cu=null;Vn&&"documentMode"in document&&(cu=document.documentMode);var vg=Vn&&"TextEvent"in window&&!cu,$g=Vn&&(!Gi||cu&&8<cu&&11>=cu),Sg=" ",_g=!1;function Hc(u,d){switch(u){case"keyup":return wg.indexOf(d.keyCode)!==-1;case"keydown":return d.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Oh(u){return u=u.detail,typeof u=="object"&&"data"in u?u.data:null}var Go=!1;function v1(u,d){switch(u){case"compositionend":return Oh(d);case"keypress":return d.which!==32?null:(_g=!0,Sg);case"textInput":return u=d.data,u===Sg&&_g?null:u;default:return null}}function $1(u,d){if(Go)return u==="compositionend"||!Gi&&Hc(u,d)?(u=dg(),Uc=Vc=Or=null,Go=!1,u):null;switch(u){case"paste":return null;case"keypress":if(!(d.ctrlKey||d.altKey||d.metaKey)||d.ctrlKey&&d.altKey){if(d.char&&1<d.char.length)return d.char;if(d.which)return String.fromCharCode(d.which)}return null;case"compositionend":return $g&&d.locale!=="ko"?null:d.data;default:return null}}var S1={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Cg(u){var d=u&&u.nodeName&&u.nodeName.toLowerCase();return d==="input"?!!S1[u.type]:d==="textarea"}function Tg(u,d,m,b){ai?Ia?Ia.push(b):Ia=[b]:ai=b,d=uy(d,"onChange"),0<d.length&&(m=new ou("onChange","change",null,m,b),u.push({event:m,listeners:d}))}var du=null,hu=null;function _1(u){cN(u,0)}function Hi(u){var d=Lo(u);if(Xs(d))return u}function Ho(u,d){if(u==="change")return d}var zh=!1;if(Vn){var Fh;if(Vn){var Lh="oninput"in document;if(!Lh){var qc=document.createElement("div");qc.setAttribute("oninput","return;"),Lh=typeof qc.oninput=="function"}Fh=Lh}else Fh=!1;zh=Fh&&(!document.documentMode||9<document.documentMode)}function jc(){du&&(du.detachEvent("onpropertychange",Mh),hu=du=null)}function Mh(u){if(u.propertyName==="value"&&Hi(hu)){var d=[];Tg(d,hu,u,su(u)),cg(_1,d)}}function kg(u,d,m){u==="focusin"?(jc(),du=d,hu=m,du.attachEvent("onpropertychange",Mh)):u==="focusout"&&jc()}function Ng(u){if(u==="selectionchange"||u==="keyup"||u==="keydown")return Hi(hu)}function Ig(u,d){if(u==="click")return Hi(d)}function Eg(u,d){if(u==="input"||u==="change")return Hi(d)}function Ag(u,d){return u===d&&(u!==0||1/u===1/d)||u!==u&&d!==d}var Ys=typeof Object.is=="function"?Object.is:Ag;function qo(u,d){if(Ys(u,d))return!0;if(typeof u!="object"||u===null||typeof d!="object"||d===null)return!1;var m=Object.keys(u),b=Object.keys(d);if(m.length!==b.length)return!1;for(b=0;b<m.length;b++){var _=m[b];if(!Ss.call(d,_)||!Ys(u[_],d[_]))return!1}return!0}function Rg(u){for(;u&&u.firstChild;)u=u.firstChild;return u}function Bh(u,d){var m=Rg(u);u=0;for(var b;m;){if(m.nodeType===3){if(b=u+m.textContent.length,u<=d&&b>=d)return{node:m,offset:d-u};u=b}e:{for(;m;){if(m.nextSibling){m=m.nextSibling;break e}m=m.parentNode}m=void 0}m=Rg(m)}}function pu(u,d){return u&&d?u===d?!0:u&&u.nodeType===3?!1:d&&d.nodeType===3?pu(u,d.parentNode):"contains"in u?u.contains(d):u.compareDocumentPosition?!!(u.compareDocumentPosition(d)&16):!1:!1}function Ie(u){u=u!=null&&u.ownerDocument!=null&&u.ownerDocument.defaultView!=null?u.ownerDocument.defaultView:window;for(var d=Bo(u.document);d instanceof u.HTMLIFrameElement;){try{var m=typeof d.contentWindow.location.href=="string"}catch{m=!1}if(m)u=d.contentWindow;else break;d=Bo(u.document)}return d}function Ph(u){var d=u&&u.nodeName&&u.nodeName.toLowerCase();return d&&(d==="input"&&(u.type==="text"||u.type==="search"||u.type==="tel"||u.type==="url"||u.type==="password")||d==="textarea"||u.contentEditable==="true")}function Dg(u,d){var m=Ie(d);d=u.focusedElem;var b=u.selectionRange;if(m!==d&&d&&d.ownerDocument&&pu(d.ownerDocument.documentElement,d)){if(b!==null&&Ph(d)){if(u=b.start,m=b.end,m===void 0&&(m=u),"selectionStart"in d)d.selectionStart=u,d.selectionEnd=Math.min(m,d.value.length);else if(m=(u=d.ownerDocument||document)&&u.defaultView||window,m.getSelection){m=m.getSelection();var _=d.textContent.length,N=Math.min(b.start,_);b=b.end===void 0?N:Math.min(b.end,_),!m.extend&&N>b&&(_=b,b=N,N=_),_=Bh(d,N);var M=Bh(d,b);_&&M&&(m.rangeCount!==1||m.anchorNode!==_.node||m.anchorOffset!==_.offset||m.focusNode!==M.node||m.focusOffset!==M.offset)&&(u=u.createRange(),u.setStart(_.node,_.offset),m.removeAllRanges(),N>b?(m.addRange(u),m.extend(M.node,M.offset)):(u.setEnd(M.node,M.offset),m.addRange(u)))}}for(u=[],m=d;m=m.parentNode;)m.nodeType===1&&u.push({element:m,left:m.scrollLeft,top:m.scrollTop});for(typeof d.focus=="function"&&d.focus(),d=0;d<u.length;d++)m=u[d],m.element.scrollLeft=m.left,m.element.scrollTop=m.top}}var Og=Vn&&"documentMode"in document&&11>=document.documentMode,Ea=null,fr=null,ii=null,fu=!1;function Vh(u,d,m){var b=m.window===m?m.document:m.nodeType===9?m:m.ownerDocument;fu||Ea==null||Ea!==Bo(b)||(b=Ea,"selectionStart"in b&&Ph(b)?b={start:b.selectionStart,end:b.selectionEnd}:(b=(b.ownerDocument&&b.ownerDocument.defaultView||window).getSelection(),b={anchorNode:b.anchorNode,anchorOffset:b.anchorOffset,focusNode:b.focusNode,focusOffset:b.focusOffset}),ii&&qo(ii,b)||(ii=b,b=uy(fr,"onSelect"),0<b.length&&(d=new ou("onSelect","select",null,d,m),u.push({event:d,listeners:b}),d.target=Ea)))}function oi(u,d){var m={};return m[u.toLowerCase()]=d.toLowerCase(),m["Webkit"+u]="webkit"+d,m["Moz"+u]="moz"+d,m}var qi={animationend:oi("Animation","AnimationEnd"),animationiteration:oi("Animation","AnimationIteration"),animationstart:oi("Animation","AnimationStart"),transitionrun:oi("Transition","TransitionRun"),transitionstart:oi("Transition","TransitionStart"),transitioncancel:oi("Transition","TransitionCancel"),transitionend:oi("Transition","TransitionEnd")},mu={},Uh={};Vn&&(Uh=document.createElement("div").style,"AnimationEvent"in window||(delete qi.animationend.animation,delete qi.animationiteration.animation,delete qi.animationstart.animation),"TransitionEvent"in window||delete qi.transitionend.transition);function li(u){if(mu[u])return mu[u];if(!qi[u])return u;var d=qi[u],m;for(m in d)if(d.hasOwnProperty(m)&&m in Uh)return mu[u]=d[m];return u}var lt=li("animationend"),jo=li("animationiteration"),Wh=li("animationstart"),ot=li("transitionrun"),Gh=li("transitionstart"),ut=li("transitioncancel"),Hh=li("transitionend"),qh=new Map,jh="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(" ");function mr(u,d){qh.set(u,d),Fs(d,[u])}var Zs=[],ji=0,gu=0;function yu(){for(var u=ji,d=gu=ji=0;d<u;){var m=Zs[d];Zs[d++]=null;var b=Zs[d];Zs[d++]=null;var _=Zs[d];Zs[d++]=null;var N=Zs[d];if(Zs[d++]=null,b!==null&&_!==null){var M=b.pending;M===null?_.next=_:(_.next=M.next,M.next=_),b.pending=_}N!==0&&Kh(m,_,N)}}function bu(u,d,m,b){Zs[ji++]=u,Zs[ji++]=d,Zs[ji++]=m,Zs[ji++]=b,gu|=b,u.lanes|=b,u=u.alternate,u!==null&&(u.lanes|=b)}function Kc(u,d,m,b){return bu(u,d,m,b),xu(u)}function Aa(u,d){return bu(u,null,null,d),xu(u)}function Kh(u,d,m){u.lanes|=m;var b=u.alternate;b!==null&&(b.lanes|=m);for(var _=!1,N=u.return;N!==null;)N.childLanes|=m,b=N.alternate,b!==null&&(b.childLanes|=m),N.tag===22&&(u=N.stateNode,u===null||u._visibility&1||(_=!0)),u=N,N=N.return;_&&d!==null&&u.tag===3&&(N=u.stateNode,_=31-zs(m),N=N.hiddenUpdates,u=N[_],u===null?N[_]=[d]:u.push(d),d.lane=m|536870912)}function xu(u){if(50<vp)throw vp=0,ww=null,Error(s(185));for(var d=u.return;d!==null;)u=d,d=u.return;return u.tag===3?u.stateNode:null}var Ki={},Xh=new WeakMap;function Qs(u,d){if(typeof u=="object"&&u!==null){var m=Xh.get(u);return m!==void 0?m:(d={value:u,source:d,stack:oe(d)},Xh.set(u,d),d)}return{value:u,source:d,stack:oe(d)}}var Xi=[],Yi=0,wu=null,vu=0,Js=[],er=0,ui=null,na=1,sa="";function ci(u,d){Xi[Yi++]=vu,Xi[Yi++]=wu,wu=u,vu=d}function Yh(u,d,m){Js[er++]=na,Js[er++]=sa,Js[er++]=ui,ui=u;var b=na;u=sa;var _=32-zs(b)-1;b&=~(1<<_),m+=1;var N=32-zs(d)+_;if(30<N){var M=_-_%5;N=(b&(1<<M)-1).toString(32),b>>=M,_-=M,na=1<<32-zs(d)+_|m<<_|b,sa=N+u}else na=1<<N|m<<_|b,sa=u}function Xc(u){u.return!==null&&(ci(u,1),Yh(u,1,0))}function Yc(u){for(;u===wu;)wu=Xi[--Yi],Xi[Yi]=null,vu=Xi[--Yi],Xi[Yi]=null;for(;u===ui;)ui=Js[--er],Js[er]=null,sa=Js[--er],Js[er]=null,na=Js[--er],Js[er]=null}var cs=null,Un=null,Mt=!1,gr=null,Lr=!1,Zc=Error(s(519));function di(u){var d=Error(s(418,""));throw Yo(Qs(d,u)),Zc}function Zh(u){var d=u.stateNode,m=u.type,b=u.memoizedProps;switch(d[es]=u,d[Cs]=b,m){case"dialog":Bt("cancel",d),Bt("close",d);break;case"iframe":case"object":case"embed":Bt("load",d);break;case"video":case"audio":for(m=0;m<Sp.length;m++)Bt(Sp[m],d);break;case"source":Bt("error",d);break;case"img":case"image":case"link":Bt("error",d),Bt("load",d);break;case"details":Bt("toggle",d);break;case"input":Bt("invalid",d),ag(d,b.value,b.defaultValue,b.checked,b.defaultChecked,b.type,b.name,!0),us(d);break;case"select":Bt("invalid",d);break;case"textarea":Bt("invalid",d),kh(d,b.value,b.defaultValue,b.children),us(d)}m=b.children,typeof m!="string"&&typeof m!="number"&&typeof m!="bigint"||d.textContent===""+m||b.suppressHydrationWarning===!0||fN(d.textContent,m)?(b.popover!=null&&(Bt("beforetoggle",d),Bt("toggle",d)),b.onScroll!=null&&Bt("scroll",d),b.onScrollEnd!=null&&Bt("scrollend",d),b.onClick!=null&&(d.onclick=cy),d=!0):d=!1,d||di(u)}function Qh(u){for(cs=u.return;cs;)switch(cs.tag){case 3:case 27:Lr=!0;return;case 5:case 13:Lr=!1;return;default:cs=cs.return}}function Ko(u){if(u!==cs)return!1;if(!Mt)return Qh(u),Mt=!0,!1;var d=!1,m;if((m=u.tag!==3&&u.tag!==27)&&((m=u.tag===5)&&(m=u.type,m=!(m!=="form"&&m!=="button")||Lw(u.type,u.memoizedProps)),m=!m),m&&(d=!0),d&&Un&&di(u),Qh(u),u.tag===13){if(u=u.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(s(317));e:{for(u=u.nextSibling,d=0;u;){if(u.nodeType===8)if(m=u.data,m==="/$"){if(d===0){Un=Oa(u.nextSibling);break e}d--}else m!=="$"&&m!=="$!"&&m!=="$?"||d++;u=u.nextSibling}Un=null}}else Un=cs?Oa(u.stateNode.nextSibling):null;return!0}function Xo(){Un=cs=null,Mt=!1}function Yo(u){gr===null?gr=[u]:gr.push(u)}var Zo=Error(s(460)),Jh=Error(s(474)),Qc={then:function(){}};function ep(u){return u=u.status,u==="fulfilled"||u==="rejected"}function $u(){}function tp(u,d,m){switch(m=u[m],m===void 0?u.push(d):m!==d&&(d.then($u,$u),d=m),d.status){case"fulfilled":return d.value;case"rejected":throw u=d.reason,u===Zo?Error(s(483)):u;default:if(typeof d.status=="string")d.then($u,$u);else{if(u=un,u!==null&&100<u.shellSuspendCounter)throw Error(s(482));u=d,u.status="pending",u.then(function(b){if(d.status==="pending"){var _=d;_.status="fulfilled",_.value=b}},function(b){if(d.status==="pending"){var _=d;_.status="rejected",_.reason=b}})}switch(d.status){case"fulfilled":return d.value;case"rejected":throw u=d.reason,u===Zo?Error(s(483)):u}throw Qo=d,Zo}}var Qo=null;function np(){if(Qo===null)throw Error(s(459));var u=Qo;return Qo=null,u}var Zi=null,Jo=0;function Su(u){var d=Jo;return Jo+=1,Zi===null&&(Zi=[]),tp(Zi,u,d)}function el(u,d){d=d.props.ref,u.ref=d!==void 0?d:null}function Jc(u,d){throw d.$$typeof===a?Error(s(525)):(u=Object.prototype.toString.call(d),Error(s(31,u==="[object Object]"?"object with keys {"+Object.keys(d).join(", ")+"}":u)))}function zg(u){var d=u._init;return d(u._payload)}function Fg(u){function d(fe,de){if(u){var be=fe.deletions;be===null?(fe.deletions=[de],fe.flags|=16):be.push(de)}}function m(fe,de){if(!u)return null;for(;de!==null;)d(fe,de),de=de.sibling;return null}function b(fe){for(var de=new Map;fe!==null;)fe.key!==null?de.set(fe.key,fe):de.set(fe.index,fe),fe=fe.sibling;return de}function _(fe,de){return fe=pl(fe,de),fe.index=0,fe.sibling=null,fe}function N(fe,de,be){return fe.index=be,u?(be=fe.alternate,be!==null?(be=be.index,be<de?(fe.flags|=33554434,de):be):(fe.flags|=33554434,de)):(fe.flags|=1048576,de)}function M(fe){return u&&fe.alternate===null&&(fe.flags|=33554434),fe}function H(fe,de,be,Ee){return de===null||de.tag!==6?(de=hw(be,fe.mode,Ee),de.return=fe,de):(de=_(de,be),de.return=fe,de)}function Z(fe,de,be,Ee){var Ze=be.type;return Ze===l?Ne(fe,de,be.props.children,Ee,be.key):de!==null&&(de.elementType===Ze||typeof Ze=="object"&&Ze!==null&&Ze.$$typeof===$&&zg(Ze)===de.type)?(de=_(de,be.props),el(de,be),de.return=fe,de):(de=Jg(be.type,be.key,be.props,null,fe.mode,Ee),el(de,be),de.return=fe,de)}function he(fe,de,be,Ee){return de===null||de.tag!==4||de.stateNode.containerInfo!==be.containerInfo||de.stateNode.implementation!==be.implementation?(de=pw(be,fe.mode,Ee),de.return=fe,de):(de=_(de,be.children||[]),de.return=fe,de)}function Ne(fe,de,be,Ee,Ze){return de===null||de.tag!==7?(de=Du(be,fe.mode,Ee,Ze),de.return=fe,de):(de=_(de,be),de.return=fe,de)}function Oe(fe,de,be){if(typeof de=="string"&&de!==""||typeof de=="number"||typeof de=="bigint")return de=hw(""+de,fe.mode,be),de.return=fe,de;if(typeof de=="object"&&de!==null){switch(de.$$typeof){case i:return be=Jg(de.type,de.key,de.props,null,fe.mode,be),el(be,de),be.return=fe,be;case o:return de=pw(de,fe.mode,be),de.return=fe,de;case $:var Ee=de._init;return de=Ee(de._payload),Oe(fe,de,be)}if(ce(de)||A(de))return de=Du(de,fe.mode,be,null),de.return=fe,de;if(typeof de.then=="function")return Oe(fe,Su(de),be);if(de.$$typeof===g)return Oe(fe,Yg(fe,de),be);Jc(fe,de)}return null}function xe(fe,de,be,Ee){var Ze=de!==null?de.key:null;if(typeof be=="string"&&be!==""||typeof be=="number"||typeof be=="bigint")return Ze!==null?null:H(fe,de,""+be,Ee);if(typeof be=="object"&&be!==null){switch(be.$$typeof){case i:return be.key===Ze?Z(fe,de,be,Ee):null;case o:return be.key===Ze?he(fe,de,be,Ee):null;case $:return Ze=be._init,be=Ze(be._payload),xe(fe,de,be,Ee)}if(ce(be)||A(be))return Ze!==null?null:Ne(fe,de,be,Ee,null);if(typeof be.then=="function")return xe(fe,de,Su(be),Ee);if(be.$$typeof===g)return xe(fe,de,Yg(fe,be),Ee);Jc(fe,be)}return null}function ke(fe,de,be,Ee,Ze){if(typeof Ee=="string"&&Ee!==""||typeof Ee=="number"||typeof Ee=="bigint")return fe=fe.get(be)||null,H(de,fe,""+Ee,Ze);if(typeof Ee=="object"&&Ee!==null){switch(Ee.$$typeof){case i:return fe=fe.get(Ee.key===null?be:Ee.key)||null,Z(de,fe,Ee,Ze);case o:return fe=fe.get(Ee.key===null?be:Ee.key)||null,he(de,fe,Ee,Ze);case $:var It=Ee._init;return Ee=It(Ee._payload),ke(fe,de,be,Ee,Ze)}if(ce(Ee)||A(Ee))return fe=fe.get(be)||null,Ne(de,fe,Ee,Ze,null);if(typeof Ee.then=="function")return ke(fe,de,be,Su(Ee),Ze);if(Ee.$$typeof===g)return ke(fe,de,be,Yg(de,Ee),Ze);Jc(de,Ee)}return null}function tt(fe,de,be,Ee){for(var Ze=null,It=null,rt=de,ct=de=0,ps=null;rt!==null&&ct<be.length;ct++){rt.index>ct?(ps=rt,rt=null):ps=rt.sibling;var jt=xe(fe,rt,be[ct],Ee);if(jt===null){rt===null&&(rt=ps);break}u&&rt&&jt.alternate===null&&d(fe,rt),de=N(jt,de,ct),It===null?Ze=jt:It.sibling=jt,It=jt,rt=ps}if(ct===be.length)return m(fe,rt),Mt&&ci(fe,ct),Ze;if(rt===null){for(;ct<be.length;ct++)rt=Oe(fe,be[ct],Ee),rt!==null&&(de=N(rt,de,ct),It===null?Ze=rt:It.sibling=rt,It=rt);return Mt&&ci(fe,ct),Ze}for(rt=b(rt);ct<be.length;ct++)ps=ke(rt,fe,ct,be[ct],Ee),ps!==null&&(u&&ps.alternate!==null&&rt.delete(ps.key===null?ct:ps.key),de=N(ps,de,ct),It===null?Ze=ps:It.sibling=ps,It=ps);return u&&rt.forEach(function(wl){return d(fe,wl)}),Mt&&ci(fe,ct),Ze}function gt(fe,de,be,Ee){if(be==null)throw Error(s(151));for(var Ze=null,It=null,rt=de,ct=de=0,ps=null,jt=be.next();rt!==null&&!jt.done;ct++,jt=be.next()){rt.index>ct?(ps=rt,rt=null):ps=rt.sibling;var wl=xe(fe,rt,jt.value,Ee);if(wl===null){rt===null&&(rt=ps);break}u&&rt&&wl.alternate===null&&d(fe,rt),de=N(wl,de,ct),It===null?Ze=wl:It.sibling=wl,It=wl,rt=ps}if(jt.done)return m(fe,rt),Mt&&ci(fe,ct),Ze;if(rt===null){for(;!jt.done;ct++,jt=be.next())jt=Oe(fe,jt.value,Ee),jt!==null&&(de=N(jt,de,ct),It===null?Ze=jt:It.sibling=jt,It=jt);return Mt&&ci(fe,ct),Ze}for(rt=b(rt);!jt.done;ct++,jt=be.next())jt=ke(rt,fe,ct,jt.value,Ee),jt!==null&&(u&&jt.alternate!==null&&rt.delete(jt.key===null?ct:jt.key),de=N(jt,de,ct),It===null?Ze=jt:It.sibling=jt,It=jt);return u&&rt.forEach(function(FG){return d(fe,FG)}),Mt&&ci(fe,ct),Ze}function En(fe,de,be,Ee){if(typeof be=="object"&&be!==null&&be.type===l&&be.key===null&&(be=be.props.children),typeof be=="object"&&be!==null){switch(be.$$typeof){case i:e:{for(var Ze=be.key;de!==null;){if(de.key===Ze){if(Ze=be.type,Ze===l){if(de.tag===7){m(fe,de.sibling),Ee=_(de,be.props.children),Ee.return=fe,fe=Ee;break e}}else if(de.elementType===Ze||typeof Ze=="object"&&Ze!==null&&Ze.$$typeof===$&&zg(Ze)===de.type){m(fe,de.sibling),Ee=_(de,be.props),el(Ee,be),Ee.return=fe,fe=Ee;break e}m(fe,de);break}else d(fe,de);de=de.sibling}be.type===l?(Ee=Du(be.props.children,fe.mode,Ee,be.key),Ee.return=fe,fe=Ee):(Ee=Jg(be.type,be.key,be.props,null,fe.mode,Ee),el(Ee,be),Ee.return=fe,fe=Ee)}return M(fe);case o:e:{for(Ze=be.key;de!==null;){if(de.key===Ze)if(de.tag===4&&de.stateNode.containerInfo===be.containerInfo&&de.stateNode.implementation===be.implementation){m(fe,de.sibling),Ee=_(de,be.children||[]),Ee.return=fe,fe=Ee;break e}else{m(fe,de);break}else d(fe,de);de=de.sibling}Ee=pw(be,fe.mode,Ee),Ee.return=fe,fe=Ee}return M(fe);case $:return Ze=be._init,be=Ze(be._payload),En(fe,de,be,Ee)}if(ce(be))return tt(fe,de,be,Ee);if(A(be)){if(Ze=A(be),typeof Ze!="function")throw Error(s(150));return be=Ze.call(be),gt(fe,de,be,Ee)}if(typeof be.then=="function")return En(fe,de,Su(be),Ee);if(be.$$typeof===g)return En(fe,de,Yg(fe,be),Ee);Jc(fe,be)}return typeof be=="string"&&be!==""||typeof be=="number"||typeof be=="bigint"?(be=""+be,de!==null&&de.tag===6?(m(fe,de.sibling),Ee=_(de,be),Ee.return=fe,fe=Ee):(m(fe,de),Ee=hw(be,fe.mode,Ee),Ee.return=fe,fe=Ee),M(fe)):m(fe,de)}return function(fe,de,be,Ee){try{Jo=0;var Ze=En(fe,de,be,Ee);return Zi=null,Ze}catch(rt){if(rt===Zo)throw rt;var It=oa(29,rt,null,fe.mode);return It.lanes=Ee,It.return=fe,It}finally{}}}var Qi=Fg(!0),Lg=Fg(!1),tl=Fe(null),ed=Fe(0);function Mg(u,d){u=po,Me(ed,u),Me(tl,d),po=u|d.baseLanes}function sp(){Me(ed,po),Me(tl,tl.current)}function rp(){po=ed.current,Ve(tl),Ve(ed)}var yr=Fe(null),ra=null;function hi(u){var d=u.alternate;Me(Ln,Ln.current&1),Me(yr,u),ra===null&&(d===null||tl.current!==null||d.memoizedState!==null)&&(ra=u)}function Bg(u){if(u.tag===22){if(Me(Ln,Ln.current),Me(yr,u),ra===null){var d=u.alternate;d!==null&&d.memoizedState!==null&&(ra=u)}}else pi()}function pi(){Me(Ln,Ln.current),Me(yr,yr.current)}function Ra(u){Ve(yr),ra===u&&(ra=null),Ve(Ln)}var Ln=Fe(0);function td(u){for(var d=u;d!==null;){if(d.tag===13){var m=d.memoizedState;if(m!==null&&(m=m.dehydrated,m===null||m.data==="$?"||m.data==="$!"))return d}else if(d.tag===19&&d.memoizedProps.revealOrder!==void 0){if((d.flags&128)!==0)return d}else if(d.child!==null){d.child.return=d,d=d.child;continue}if(d===u)break;for(;d.sibling===null;){if(d.return===null||d.return===u)return null;d=d.return}d.sibling.return=d.return,d=d.sibling}return null}var C1=typeof AbortController<"u"?AbortController:function(){var u=[],d=this.signal={aborted:!1,addEventListener:function(m,b){u.push(b)}};this.abort=function(){d.aborted=!0,u.forEach(function(m){return m()})}},T1=t.unstable_scheduleCallback,k1=t.unstable_NormalPriority,Mn={$$typeof:g,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function ap(){return{controller:new C1,data:new Map,refCount:0}}function _u(u){u.refCount--,u.refCount===0&&T1(k1,function(){u.controller.abort()})}var Cu=null,ip=0,nl=0,sl=null;function N1(u,d){if(Cu===null){var m=Cu=[];ip=0,nl=Nw(),sl={status:"pending",value:void 0,then:function(b){m.push(b)}}}return ip++,d.then(Pg,Pg),d}function Pg(){if(--ip===0&&Cu!==null){sl!==null&&(sl.status="fulfilled");var u=Cu;Cu=null,nl=0,sl=null;for(var d=0;d<u.length;d++)(0,u[d])()}}function I1(u,d){var m=[],b={status:"pending",value:null,reason:null,then:function(_){m.push(_)}};return u.then(function(){b.status="fulfilled",b.value=d;for(var _=0;_<m.length;_++)(0,m[_])(d)},function(_){for(b.status="rejected",b.reason=_,_=0;_<m.length;_++)(0,m[_])(void 0)}),b}var Vg=z.S;z.S=function(u,d){typeof d=="object"&&d!==null&&typeof d.then=="function"&&N1(u,d),Vg!==null&&Vg(u,d)};var Ji=Fe(null);function op(){var u=Ji.current;return u!==null?u:un.pooledCache}function nd(u,d){d===null?Me(Ji,Ji.current):Me(Ji,d.pool)}function Ug(){var u=op();return u===null?null:{parent:Mn._currentValue,pool:u}}var fi=0,wt=null,Zt=null,kn=null,sd=!1,rl=!1,eo=!1,rd=0,Tu=0,to=null,S=0;function k(){throw Error(s(321))}function E(u,d){if(d===null)return!1;for(var m=0;m<d.length&&m<u.length;m++)if(!Ys(u[m],d[m]))return!1;return!0}function R(u,d,m,b,_,N){return fi=N,wt=d,d.memoizedState=null,d.updateQueue=null,d.lanes=0,z.H=u===null||u.memoizedState===null?ku:al,eo=!1,N=m(b,_),eo=!1,rl&&(N=j(d,m,b,_)),L(u),N}function L(u){z.H=mi;var d=Zt!==null&&Zt.next!==null;if(fi=0,kn=Zt=wt=null,sd=!1,Tu=0,to=null,d)throw Error(s(300));u===null||ds||(u=u.dependencies,u!==null&&Xg(u)&&(ds=!0))}function j(u,d,m,b){wt=u;var _=0;do{if(rl&&(to=null),Tu=0,rl=!1,25<=_)throw Error(s(301));if(_+=1,kn=Zt=null,u.updateQueue!=null){var N=u.updateQueue;N.lastEffect=null,N.events=null,N.stores=null,N.memoCache!=null&&(N.memoCache.index=0)}z.H=Nu,N=d(m,b)}while(rl);return N}function re(){var u=z.H,d=u.useState()[0];return d=typeof d.then=="function"?Ht(d):d,u=u.useState()[0],(Zt!==null?Zt.memoizedState:null)!==u&&(wt.flags|=1024),d}function ge(){var u=rd!==0;return rd=0,u}function Se(u,d,m){d.updateQueue=u.updateQueue,d.flags&=-2053,u.lanes&=~m}function Re(u){if(sd){for(u=u.memoizedState;u!==null;){var d=u.queue;d!==null&&(d.pending=null),u=u.next}sd=!1}fi=0,kn=Zt=wt=null,rl=!1,Tu=rd=0,to=null}function Le(){var u={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return kn===null?wt.memoizedState=kn=u:kn=kn.next=u,kn}function We(){if(Zt===null){var u=wt.alternate;u=u!==null?u.memoizedState:null}else u=Zt.next;var d=kn===null?wt.memoizedState:kn.next;if(d!==null)kn=d,Zt=u;else{if(u===null)throw wt.alternate===null?Error(s(467)):Error(s(310));Zt=u,u={memoizedState:Zt.memoizedState,baseState:Zt.baseState,baseQueue:Zt.baseQueue,queue:Zt.queue,next:null},kn===null?wt.memoizedState=kn=u:kn=kn.next=u}return kn}var at;at=function(){return{lastEffect:null,events:null,stores:null,memoCache:null}};function Ht(u){var d=Tu;return Tu+=1,to===null&&(to=[]),u=tp(to,u,d),d=wt,(kn===null?d.memoizedState:kn.next)===null&&(d=d.alternate,z.H=d===null||d.memoizedState===null?ku:al),u}function ks(u){if(u!==null&&typeof u=="object"){if(typeof u.then=="function")return Ht(u);if(u.$$typeof===g)return Ms(u)}throw Error(s(438,String(u)))}function no(u){var d=null,m=wt.updateQueue;if(m!==null&&(d=m.memoCache),d==null){var b=wt.alternate;b!==null&&(b=b.updateQueue,b!==null&&(b=b.memoCache,b!=null&&(d={data:b.data.map(function(_){return _.slice()}),index:0})))}if(d==null&&(d={data:[],index:0}),m===null&&(m=at(),wt.updateQueue=m),m.memoCache=d,m=d.data[d.index],m===void 0)for(m=d.data[d.index]=Array(u),b=0;b<u;b++)m[b]=C;return d.index++,m}function so(u,d){return typeof d=="function"?d(u):d}function Wg(u){var d=We();return E1(d,Zt,u)}function E1(u,d,m){var b=u.queue;if(b===null)throw Error(s(311));b.lastRenderedReducer=m;var _=u.baseQueue,N=b.pending;if(N!==null){if(_!==null){var M=_.next;_.next=N.next,N.next=M}d.baseQueue=_=N,b.pending=null}if(N=u.baseState,_===null)u.memoizedState=N;else{d=_.next;var H=M=null,Z=null,he=d,Ne=!1;do{var Oe=he.lane&-536870913;if(Oe!==he.lane?(Vt&Oe)===Oe:(fi&Oe)===Oe){var xe=he.revertLane;if(xe===0)Z!==null&&(Z=Z.next={lane:0,revertLane:0,action:he.action,hasEagerState:he.hasEagerState,eagerState:he.eagerState,next:null}),Oe===nl&&(Ne=!0);else if((fi&xe)===xe){he=he.next,xe===nl&&(Ne=!0);continue}else Oe={lane:0,revertLane:he.revertLane,action:he.action,hasEagerState:he.hasEagerState,eagerState:he.eagerState,next:null},Z===null?(H=Z=Oe,M=N):Z=Z.next=Oe,wt.lanes|=xe,fl|=xe;Oe=he.action,eo&&m(N,Oe),N=he.hasEagerState?he.eagerState:m(N,Oe)}else xe={lane:Oe,revertLane:he.revertLane,action:he.action,hasEagerState:he.hasEagerState,eagerState:he.eagerState,next:null},Z===null?(H=Z=xe,M=N):Z=Z.next=xe,wt.lanes|=Oe,fl|=Oe;he=he.next}while(he!==null&&he!==d);if(Z===null?M=N:Z.next=H,!Ys(N,u.memoizedState)&&(ds=!0,Ne&&(m=sl,m!==null)))throw m;u.memoizedState=N,u.baseState=M,u.baseQueue=Z,b.lastRenderedState=N}return _===null&&(b.lanes=0),[u.memoizedState,b.dispatch]}function A1(u){var d=We(),m=d.queue;if(m===null)throw Error(s(311));m.lastRenderedReducer=u;var b=m.dispatch,_=m.pending,N=d.memoizedState;if(_!==null){m.pending=null;var M=_=_.next;do N=u(N,M.action),M=M.next;while(M!==_);Ys(N,d.memoizedState)||(ds=!0),d.memoizedState=N,d.baseQueue===null&&(d.baseState=N),m.lastRenderedState=N}return[N,b]}function vT(u,d,m){var b=wt,_=We(),N=Mt;if(N){if(m===void 0)throw Error(s(407));m=m()}else m=d();var M=!Ys((Zt||_).memoizedState,m);if(M&&(_.memoizedState=m,ds=!0),_=_.queue,O1(_T.bind(null,b,_,u),[u]),_.getSnapshot!==d||M||kn!==null&&kn.memoizedState.tag&1){if(b.flags|=2048,ad(9,ST.bind(null,b,_,m,d),{destroy:void 0},null),un===null)throw Error(s(349));N||(fi&60)!==0||$T(b,d,m)}return m}function $T(u,d,m){u.flags|=16384,u={getSnapshot:d,value:m},d=wt.updateQueue,d===null?(d=at(),wt.updateQueue=d,d.stores=[u]):(m=d.stores,m===null?d.stores=[u]:m.push(u))}function ST(u,d,m,b){d.value=m,d.getSnapshot=b,CT(d)&&TT(u)}function _T(u,d,m){return m(function(){CT(d)&&TT(u)})}function CT(u){var d=u.getSnapshot;u=u.value;try{var m=d();return!Ys(u,m)}catch{return!0}}function TT(u){var d=Aa(u,2);d!==null&&tr(d,u,2)}function R1(u){var d=Le();if(typeof u=="function"){var m=u;if(u=m(),eo){ka(!0);try{m()}finally{ka(!1)}}}return d.memoizedState=d.baseState=u,d.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:so,lastRenderedState:u},d}function kT(u,d,m,b){return u.baseState=m,E1(u,Zt,typeof b=="function"?b:so)}function EW(u,d,m,b,_){if(qg(u))throw Error(s(485));if(u=d.action,u!==null){var N={payload:_,action:u,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(M){N.listeners.push(M)}};z.T!==null?m(!0):N.isTransition=!1,b(N),m=d.pending,m===null?(N.next=d.pending=N,NT(d,N)):(N.next=m.next,d.pending=m.next=N)}}function NT(u,d){var m=d.action,b=d.payload,_=u.state;if(d.isTransition){var N=z.T,M={};z.T=M;try{var H=m(_,b),Z=z.S;Z!==null&&Z(M,H),IT(u,d,H)}catch(he){D1(u,d,he)}finally{z.T=N}}else try{N=m(_,b),IT(u,d,N)}catch(he){D1(u,d,he)}}function IT(u,d,m){m!==null&&typeof m=="object"&&typeof m.then=="function"?m.then(function(b){ET(u,d,b)},function(b){return D1(u,d,b)}):ET(u,d,m)}function ET(u,d,m){d.status="fulfilled",d.value=m,AT(d),u.state=m,d=u.pending,d!==null&&(m=d.next,m===d?u.pending=null:(m=m.next,d.next=m,NT(u,m)))}function D1(u,d,m){var b=u.pending;if(u.pending=null,b!==null){b=b.next;do d.status="rejected",d.reason=m,AT(d),d=d.next;while(d!==b)}u.action=null}function AT(u){u=u.listeners;for(var d=0;d<u.length;d++)(0,u[d])()}function RT(u,d){return d}function DT(u,d){if(Mt){var m=un.formState;if(m!==null){e:{var b=wt;if(Mt){if(Un){t:{for(var _=Un,N=Lr;_.nodeType!==8;){if(!N){_=null;break t}if(_=Oa(_.nextSibling),_===null){_=null;break t}}N=_.data,_=N==="F!"||N==="F"?_:null}if(_){Un=Oa(_.nextSibling),b=_.data==="F!";break e}}di(b)}b=!1}b&&(d=m[0])}}return m=Le(),m.memoizedState=m.baseState=d,b={pending:null,lanes:0,dispatch:null,lastRenderedReducer:RT,lastRenderedState:d},m.queue=b,m=ZT.bind(null,wt,b),b.dispatch=m,b=R1(!1),N=B1.bind(null,wt,!1,b.queue),b=Le(),_={state:d,dispatch:null,action:u,pending:null},b.queue=_,m=EW.bind(null,wt,_,N,m),_.dispatch=m,b.memoizedState=u,[d,m,!1]}function OT(u){var d=We();return zT(d,Zt,u)}function zT(u,d,m){d=E1(u,d,RT)[0],u=Wg(so)[0],d=typeof d=="object"&&d!==null&&typeof d.then=="function"?Ht(d):d;var b=We(),_=b.queue,N=_.dispatch;return m!==b.memoizedState&&(wt.flags|=2048,ad(9,AW.bind(null,_,m),{destroy:void 0},null)),[d,N,u]}function AW(u,d){u.action=d}function FT(u){var d=We(),m=Zt;if(m!==null)return zT(d,m,u);We(),d=d.memoizedState,m=We();var b=m.queue.dispatch;return m.memoizedState=u,[d,b,!1]}function ad(u,d,m,b){return u={tag:u,create:d,inst:m,deps:b,next:null},d=wt.updateQueue,d===null&&(d=at(),wt.updateQueue=d),m=d.lastEffect,m===null?d.lastEffect=u.next=u:(b=m.next,m.next=u,u.next=b,d.lastEffect=u),u}function LT(){return We().memoizedState}function Gg(u,d,m,b){var _=Le();wt.flags|=u,_.memoizedState=ad(1|d,m,{destroy:void 0},b===void 0?null:b)}function Hg(u,d,m,b){var _=We();b=b===void 0?null:b;var N=_.memoizedState.inst;Zt!==null&&b!==null&&E(b,Zt.memoizedState.deps)?_.memoizedState=ad(d,m,N,b):(wt.flags|=u,_.memoizedState=ad(1|d,m,N,b))}function MT(u,d){Gg(8390656,8,u,d)}function O1(u,d){Hg(2048,8,u,d)}function BT(u,d){return Hg(4,2,u,d)}function PT(u,d){return Hg(4,4,u,d)}function VT(u,d){if(typeof d=="function"){u=u();var m=d(u);return function(){typeof m=="function"?m():d(null)}}if(d!=null)return u=u(),d.current=u,function(){d.current=null}}function UT(u,d,m){m=m!=null?m.concat([u]):null,Hg(4,4,VT.bind(null,d,u),m)}function z1(){}function WT(u,d){var m=We();d=d===void 0?null:d;var b=m.memoizedState;return d!==null&&E(d,b[1])?b[0]:(m.memoizedState=[u,d],u)}function GT(u,d){var m=We();d=d===void 0?null:d;var b=m.memoizedState;if(d!==null&&E(d,b[1]))return b[0];if(b=u(),eo){ka(!0);try{u()}finally{ka(!1)}}return m.memoizedState=[b,d],b}function F1(u,d,m){return m===void 0||(fi&1073741824)!==0?u.memoizedState=d:(u.memoizedState=m,u=qk(),wt.lanes|=u,fl|=u,m)}function HT(u,d,m,b){return Ys(m,d)?m:tl.current!==null?(u=F1(u,m,b),Ys(u,d)||(ds=!0),u):(fi&42)===0?(ds=!0,u.memoizedState=m):(u=qk(),wt.lanes|=u,fl|=u,d)}function qT(u,d,m,b,_){var N=pe.p;pe.p=N!==0&&8>N?N:8;var M=z.T,H={};z.T=H,B1(u,!1,d,m);try{var Z=_(),he=z.S;if(he!==null&&he(H,Z),Z!==null&&typeof Z=="object"&&typeof Z.then=="function"){var Ne=I1(Z,b);lp(u,d,Ne,Vr(u))}else lp(u,d,b,Vr(u))}catch(Oe){lp(u,d,{then:function(){},status:"rejected",reason:Oe},Vr())}finally{pe.p=N,z.T=M}}function RW(){}function L1(u,d,m,b){if(u.tag!==5)throw Error(s(476));var _=jT(u).queue;qT(u,_,d,J,m===null?RW:function(){return KT(u),m(b)})}function jT(u){var d=u.memoizedState;if(d!==null)return d;d={memoizedState:J,baseState:J,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:so,lastRenderedState:J},next:null};var m={};return d.next={memoizedState:m,baseState:m,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:so,lastRenderedState:m},next:null},u.memoizedState=d,u=u.alternate,u!==null&&(u.memoizedState=d),d}function KT(u){var d=jT(u).next.queue;lp(u,d,{},Vr())}function M1(){return Ms(Np)}function XT(){return We().memoizedState}function YT(){return We().memoizedState}function DW(u){for(var d=u.return;d!==null;){switch(d.tag){case 24:case 3:var m=Vr();u=ll(m);var b=ul(d,u,m);b!==null&&(tr(b,d,m),dp(b,d,m)),d={cache:ap()},u.payload=d;return}d=d.return}}function OW(u,d,m){var b=Vr();m={lane:b,revertLane:0,action:m,hasEagerState:!1,eagerState:null,next:null},qg(u)?QT(d,m):(m=Kc(u,d,m,b),m!==null&&(tr(m,u,b),JT(m,d,b)))}function ZT(u,d,m){var b=Vr();lp(u,d,m,b)}function lp(u,d,m,b){var _={lane:b,revertLane:0,action:m,hasEagerState:!1,eagerState:null,next:null};if(qg(u))QT(d,_);else{var N=u.alternate;if(u.lanes===0&&(N===null||N.lanes===0)&&(N=d.lastRenderedReducer,N!==null))try{var M=d.lastRenderedState,H=N(M,m);if(_.hasEagerState=!0,_.eagerState=H,Ys(H,M))return bu(u,d,_,0),un===null&&yu(),!1}catch{}finally{}if(m=Kc(u,d,_,b),m!==null)return tr(m,u,b),JT(m,d,b),!0}return!1}function B1(u,d,m,b){if(b={lane:2,revertLane:Nw(),action:b,hasEagerState:!1,eagerState:null,next:null},qg(u)){if(d)throw Error(s(479))}else d=Kc(u,m,b,2),d!==null&&tr(d,u,2)}function qg(u){var d=u.alternate;return u===wt||d!==null&&d===wt}function QT(u,d){rl=sd=!0;var m=u.pending;m===null?d.next=d:(d.next=m.next,m.next=d),u.pending=d}function JT(u,d,m){if((m&4194176)!==0){var b=d.lanes;b&=u.pendingLanes,m|=b,d.lanes=m,yh(u,m)}}var mi={readContext:Ms,use:ks,useCallback:k,useContext:k,useEffect:k,useImperativeHandle:k,useLayoutEffect:k,useInsertionEffect:k,useMemo:k,useReducer:k,useRef:k,useState:k,useDebugValue:k,useDeferredValue:k,useTransition:k,useSyncExternalStore:k,useId:k};mi.useCacheRefresh=k,mi.useMemoCache=k,mi.useHostTransitionStatus=k,mi.useFormState=k,mi.useActionState=k,mi.useOptimistic=k;var ku={readContext:Ms,use:ks,useCallback:function(u,d){return Le().memoizedState=[u,d===void 0?null:d],u},useContext:Ms,useEffect:MT,useImperativeHandle:function(u,d,m){m=m!=null?m.concat([u]):null,Gg(4194308,4,VT.bind(null,d,u),m)},useLayoutEffect:function(u,d){return Gg(4194308,4,u,d)},useInsertionEffect:function(u,d){Gg(4,2,u,d)},useMemo:function(u,d){var m=Le();d=d===void 0?null:d;var b=u();if(eo){ka(!0);try{u()}finally{ka(!1)}}return m.memoizedState=[b,d],b},useReducer:function(u,d,m){var b=Le();if(m!==void 0){var _=m(d);if(eo){ka(!0);try{m(d)}finally{ka(!1)}}}else _=d;return b.memoizedState=b.baseState=_,u={pending:null,lanes:0,dispatch:null,lastRenderedReducer:u,lastRenderedState:_},b.queue=u,u=u.dispatch=OW.bind(null,wt,u),[b.memoizedState,u]},useRef:function(u){var d=Le();return u={current:u},d.memoizedState=u},useState:function(u){u=R1(u);var d=u.queue,m=ZT.bind(null,wt,d);return d.dispatch=m,[u.memoizedState,m]},useDebugValue:z1,useDeferredValue:function(u,d){var m=Le();return F1(m,u,d)},useTransition:function(){var u=R1(!1);return u=qT.bind(null,wt,u.queue,!0,!1),Le().memoizedState=u,[!1,u]},useSyncExternalStore:function(u,d,m){var b=wt,_=Le();if(Mt){if(m===void 0)throw Error(s(407));m=m()}else{if(m=d(),un===null)throw Error(s(349));(Vt&60)!==0||$T(b,d,m)}_.memoizedState=m;var N={value:m,getSnapshot:d};return _.queue=N,MT(_T.bind(null,b,N,u),[u]),b.flags|=2048,ad(9,ST.bind(null,b,N,m,d),{destroy:void 0},null),m},useId:function(){var u=Le(),d=un.identifierPrefix;if(Mt){var m=sa,b=na;m=(b&~(1<<32-zs(b)-1)).toString(32)+m,d=":"+d+"R"+m,m=rd++,0<m&&(d+="H"+m.toString(32)),d+=":"}else m=S++,d=":"+d+"r"+m.toString(32)+":";return u.memoizedState=d},useCacheRefresh:function(){return Le().memoizedState=DW.bind(null,wt)}};ku.useMemoCache=no,ku.useHostTransitionStatus=M1,ku.useFormState=DT,ku.useActionState=DT,ku.useOptimistic=function(u){var d=Le();d.memoizedState=d.baseState=u;var m={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return d.queue=m,d=B1.bind(null,wt,!0,m),m.dispatch=d,[u,d]};var al={readContext:Ms,use:ks,useCallback:WT,useContext:Ms,useEffect:O1,useImperativeHandle:UT,useInsertionEffect:BT,useLayoutEffect:PT,useMemo:GT,useReducer:Wg,useRef:LT,useState:function(){return Wg(so)},useDebugValue:z1,useDeferredValue:function(u,d){var m=We();return HT(m,Zt.memoizedState,u,d)},useTransition:function(){var u=Wg(so)[0],d=We().memoizedState;return[typeof u=="boolean"?u:Ht(u),d]},useSyncExternalStore:vT,useId:XT};al.useCacheRefresh=YT,al.useMemoCache=no,al.useHostTransitionStatus=M1,al.useFormState=OT,al.useActionState=OT,al.useOptimistic=function(u,d){var m=We();return kT(m,Zt,u,d)};var Nu={readContext:Ms,use:ks,useCallback:WT,useContext:Ms,useEffect:O1,useImperativeHandle:UT,useInsertionEffect:BT,useLayoutEffect:PT,useMemo:GT,useReducer:A1,useRef:LT,useState:function(){return A1(so)},useDebugValue:z1,useDeferredValue:function(u,d){var m=We();return Zt===null?F1(m,u,d):HT(m,Zt.memoizedState,u,d)},useTransition:function(){var u=A1(so)[0],d=We().memoizedState;return[typeof u=="boolean"?u:Ht(u),d]},useSyncExternalStore:vT,useId:XT};Nu.useCacheRefresh=YT,Nu.useMemoCache=no,Nu.useHostTransitionStatus=M1,Nu.useFormState=FT,Nu.useActionState=FT,Nu.useOptimistic=function(u,d){var m=We();return Zt!==null?kT(m,Zt,u,d):(m.baseState=u,[u,m.queue.dispatch])};function P1(u,d,m,b){d=u.memoizedState,m=m(b,d),m=m==null?d:P({},d,m),u.memoizedState=m,u.lanes===0&&(u.updateQueue.baseState=m)}var V1={isMounted:function(u){return(u=u._reactInternals)?se(u)===u:!1},enqueueSetState:function(u,d,m){u=u._reactInternals;var b=Vr(),_=ll(b);_.payload=d,m!=null&&(_.callback=m),d=ul(u,_,b),d!==null&&(tr(d,u,b),dp(d,u,b))},enqueueReplaceState:function(u,d,m){u=u._reactInternals;var b=Vr(),_=ll(b);_.tag=1,_.payload=d,m!=null&&(_.callback=m),d=ul(u,_,b),d!==null&&(tr(d,u,b),dp(d,u,b))},enqueueForceUpdate:function(u,d){u=u._reactInternals;var m=Vr(),b=ll(m);b.tag=2,d!=null&&(b.callback=d),d=ul(u,b,m),d!==null&&(tr(d,u,m),dp(d,u,m))}};function ek(u,d,m,b,_,N,M){return u=u.stateNode,typeof u.shouldComponentUpdate=="function"?u.shouldComponentUpdate(b,N,M):d.prototype&&d.prototype.isPureReactComponent?!qo(m,b)||!qo(_,N):!0}function tk(u,d,m,b){u=d.state,typeof d.componentWillReceiveProps=="function"&&d.componentWillReceiveProps(m,b),typeof d.UNSAFE_componentWillReceiveProps=="function"&&d.UNSAFE_componentWillReceiveProps(m,b),d.state!==u&&V1.enqueueReplaceState(d,d.state,null)}function Iu(u,d){var m=d;if("ref"in d){m={};for(var b in d)b!=="ref"&&(m[b]=d[b])}if(u=u.defaultProps){m===d&&(m=P({},m));for(var _ in u)m[_]===void 0&&(m[_]=u[_])}return m}var jg=typeof reportError=="function"?reportError:function(u){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var d=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof u=="object"&&u!==null&&typeof u.message=="string"?String(u.message):String(u),error:u});if(!window.dispatchEvent(d))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",u);return}console.error(u)};function nk(u){jg(u)}function sk(u){console.error(u)}function rk(u){jg(u)}function Kg(u,d){try{var m=u.onUncaughtError;m(d.value,{componentStack:d.stack})}catch(b){setTimeout(function(){throw b})}}function ak(u,d,m){try{var b=u.onCaughtError;b(m.value,{componentStack:m.stack,errorBoundary:d.tag===1?d.stateNode:null})}catch(_){setTimeout(function(){throw _})}}function U1(u,d,m){return m=ll(m),m.tag=3,m.payload={element:null},m.callback=function(){Kg(u,d)},m}function ik(u){return u=ll(u),u.tag=3,u}function ok(u,d,m,b){var _=m.type.getDerivedStateFromError;if(typeof _=="function"){var N=b.value;u.payload=function(){return _(N)},u.callback=function(){ak(d,m,b)}}var M=m.stateNode;M!==null&&typeof M.componentDidCatch=="function"&&(u.callback=function(){ak(d,m,b),typeof _!="function"&&(ml===null?ml=new Set([this]):ml.add(this));var H=b.stack;this.componentDidCatch(b.value,{componentStack:H!==null?H:""})})}function zW(u,d,m,b,_){if(m.flags|=32768,b!==null&&typeof b=="object"&&typeof b.then=="function"){if(d=m.alternate,d!==null&&cp(d,m,_,!0),m=yr.current,m!==null){switch(m.tag){case 13:return ra===null?Sw():m.alternate===null&&In===0&&(In=3),m.flags&=-257,m.flags|=65536,m.lanes=_,b===Qc?m.flags|=16384:(d=m.updateQueue,d===null?m.updateQueue=new Set([b]):d.add(b),Cw(u,b,_)),!1;case 22:return m.flags|=65536,b===Qc?m.flags|=16384:(d=m.updateQueue,d===null?(d={transitions:null,markerInstances:null,retryQueue:new Set([b])},m.updateQueue=d):(m=d.retryQueue,m===null?d.retryQueue=new Set([b]):m.add(b)),Cw(u,b,_)),!1}throw Error(s(435,m.tag))}return Cw(u,b,_),Sw(),!1}if(Mt)return d=yr.current,d!==null?((d.flags&65536)===0&&(d.flags|=256),d.flags|=65536,d.lanes=_,b!==Zc&&(u=Error(s(422),{cause:b}),Yo(Qs(u,m)))):(b!==Zc&&(d=Error(s(423),{cause:b}),Yo(Qs(d,m))),u=u.current.alternate,u.flags|=65536,_&=-_,u.lanes|=_,b=Qs(b,m),_=U1(u.stateNode,b,_),sw(u,_),In!==4&&(In=2)),!1;var N=Error(s(520),{cause:b});if(N=Qs(N,m),xp===null?xp=[N]:xp.push(N),In!==4&&(In=2),d===null)return!0;b=Qs(b,m),m=d;do{switch(m.tag){case 3:return m.flags|=65536,u=_&-_,m.lanes|=u,u=U1(m.stateNode,b,u),sw(m,u),!1;case 1:if(d=m.type,N=m.stateNode,(m.flags&128)===0&&(typeof d.getDerivedStateFromError=="function"||N!==null&&typeof N.componentDidCatch=="function"&&(ml===null||!ml.has(N))))return m.flags|=65536,_&=-_,m.lanes|=_,_=ik(_),ok(_,u,m,b),sw(m,_),!1}m=m.return}while(m!==null);return!1}var lk=Error(s(461)),ds=!1;function Ns(u,d,m,b){d.child=u===null?Lg(d,null,m,b):Qi(d,u.child,m,b)}function uk(u,d,m,b,_){m=m.render;var N=d.ref;if("ref"in b){var M={};for(var H in b)H!=="ref"&&(M[H]=b[H])}else M=b;return Au(d),b=R(u,d,m,M,N,_),H=ge(),u!==null&&!ds?(Se(u,d,_),ro(u,d,_)):(Mt&&H&&Xc(d),d.flags|=1,Ns(u,d,b,_),d.child)}function ck(u,d,m,b,_){if(u===null){var N=m.type;return typeof N=="function"&&!dw(N)&&N.defaultProps===void 0&&m.compare===null?(d.tag=15,d.type=N,dk(u,d,N,b,_)):(u=Jg(m.type,null,b,d,d.mode,_),u.ref=d.ref,u.return=d,d.child=u)}if(N=u.child,!Z1(u,_)){var M=N.memoizedProps;if(m=m.compare,m=m!==null?m:qo,m(M,b)&&u.ref===d.ref)return ro(u,d,_)}return d.flags|=1,u=pl(N,b),u.ref=d.ref,u.return=d,d.child=u}function dk(u,d,m,b,_){if(u!==null){var N=u.memoizedProps;if(qo(N,b)&&u.ref===d.ref)if(ds=!1,d.pendingProps=b=N,Z1(u,_))(u.flags&131072)!==0&&(ds=!0);else return d.lanes=u.lanes,ro(u,d,_)}return W1(u,d,m,b,_)}function hk(u,d,m){var b=d.pendingProps,_=b.children,N=(d.stateNode._pendingVisibility&2)!==0,M=u!==null?u.memoizedState:null;if(up(u,d),b.mode==="hidden"||N){if((d.flags&128)!==0){if(b=M!==null?M.baseLanes|m:m,u!==null){for(_=d.child=u.child,N=0;_!==null;)N=N|_.lanes|_.childLanes,_=_.sibling;d.childLanes=N&~b}else d.childLanes=0,d.child=null;return pk(u,d,b,m)}if((m&536870912)!==0)d.memoizedState={baseLanes:0,cachePool:null},u!==null&&nd(d,M!==null?M.cachePool:null),M!==null?Mg(d,M):sp(),Bg(d);else return d.lanes=d.childLanes=536870912,pk(u,d,M!==null?M.baseLanes|m:m,m)}else M!==null?(nd(d,M.cachePool),Mg(d,M),pi(),d.memoizedState=null):(u!==null&&nd(d,null),sp(),pi());return Ns(u,d,_,m),d.child}function pk(u,d,m,b){var _=op();return _=_===null?null:{parent:Mn._currentValue,pool:_},d.memoizedState={baseLanes:m,cachePool:_},u!==null&&nd(d,null),sp(),Bg(d),u!==null&&cp(u,d,b,!0),null}function up(u,d){var m=d.ref;if(m===null)u!==null&&u.ref!==null&&(d.flags|=2097664);else{if(typeof m!="function"&&typeof m!="object")throw Error(s(284));(u===null||u.ref!==m)&&(d.flags|=2097664)}}function W1(u,d,m,b,_){return Au(d),m=R(u,d,m,b,void 0,_),b=ge(),u!==null&&!ds?(Se(u,d,_),ro(u,d,_)):(Mt&&b&&Xc(d),d.flags|=1,Ns(u,d,m,_),d.child)}function fk(u,d,m,b,_,N){return Au(d),d.updateQueue=null,m=j(d,b,m,_),L(u),b=ge(),u!==null&&!ds?(Se(u,d,N),ro(u,d,N)):(Mt&&b&&Xc(d),d.flags|=1,Ns(u,d,m,N),d.child)}function mk(u,d,m,b,_){if(Au(d),d.stateNode===null){var N=Ki,M=m.contextType;typeof M=="object"&&M!==null&&(N=Ms(M)),N=new m(b,N),d.memoizedState=N.state!==null&&N.state!==void 0?N.state:null,N.updater=V1,d.stateNode=N,N._reactInternals=d,N=d.stateNode,N.props=b,N.state=d.memoizedState,N.refs={},tw(d),M=m.contextType,N.context=typeof M=="object"&&M!==null?Ms(M):Ki,N.state=d.memoizedState,M=m.getDerivedStateFromProps,typeof M=="function"&&(P1(d,m,M,b),N.state=d.memoizedState),typeof m.getDerivedStateFromProps=="function"||typeof N.getSnapshotBeforeUpdate=="function"||typeof N.UNSAFE_componentWillMount!="function"&&typeof N.componentWillMount!="function"||(M=N.state,typeof N.componentWillMount=="function"&&N.componentWillMount(),typeof N.UNSAFE_componentWillMount=="function"&&N.UNSAFE_componentWillMount(),M!==N.state&&V1.enqueueReplaceState(N,N.state,null),pp(d,b,N,_),hp(),N.state=d.memoizedState),typeof N.componentDidMount=="function"&&(d.flags|=4194308),b=!0}else if(u===null){N=d.stateNode;var H=d.memoizedProps,Z=Iu(m,H);N.props=Z;var he=N.context,Ne=m.contextType;M=Ki,typeof Ne=="object"&&Ne!==null&&(M=Ms(Ne));var Oe=m.getDerivedStateFromProps;Ne=typeof Oe=="function"||typeof N.getSnapshotBeforeUpdate=="function",H=d.pendingProps!==H,Ne||typeof N.UNSAFE_componentWillReceiveProps!="function"&&typeof N.componentWillReceiveProps!="function"||(H||he!==M)&&tk(d,N,b,M),ol=!1;var xe=d.memoizedState;N.state=xe,pp(d,b,N,_),hp(),he=d.memoizedState,H||xe!==he||ol?(typeof Oe=="function"&&(P1(d,m,Oe,b),he=d.memoizedState),(Z=ol||ek(d,m,Z,b,xe,he,M))?(Ne||typeof N.UNSAFE_componentWillMount!="function"&&typeof N.componentWillMount!="function"||(typeof N.componentWillMount=="function"&&N.componentWillMount(),typeof N.UNSAFE_componentWillMount=="function"&&N.UNSAFE_componentWillMount()),typeof N.componentDidMount=="function"&&(d.flags|=4194308)):(typeof N.componentDidMount=="function"&&(d.flags|=4194308),d.memoizedProps=b,d.memoizedState=he),N.props=b,N.state=he,N.context=M,b=Z):(typeof N.componentDidMount=="function"&&(d.flags|=4194308),b=!1)}else{N=d.stateNode,nw(u,d),M=d.memoizedProps,Ne=Iu(m,M),N.props=Ne,Oe=d.pendingProps,xe=N.context,he=m.contextType,Z=Ki,typeof he=="object"&&he!==null&&(Z=Ms(he)),H=m.getDerivedStateFromProps,(he=typeof H=="function"||typeof N.getSnapshotBeforeUpdate=="function")||typeof N.UNSAFE_componentWillReceiveProps!="function"&&typeof N.componentWillReceiveProps!="function"||(M!==Oe||xe!==Z)&&tk(d,N,b,Z),ol=!1,xe=d.memoizedState,N.state=xe,pp(d,b,N,_),hp();var ke=d.memoizedState;M!==Oe||xe!==ke||ol||u!==null&&u.dependencies!==null&&Xg(u.dependencies)?(typeof H=="function"&&(P1(d,m,H,b),ke=d.memoizedState),(Ne=ol||ek(d,m,Ne,b,xe,ke,Z)||u!==null&&u.dependencies!==null&&Xg(u.dependencies))?(he||typeof N.UNSAFE_componentWillUpdate!="function"&&typeof N.componentWillUpdate!="function"||(typeof N.componentWillUpdate=="function"&&N.componentWillUpdate(b,ke,Z),typeof N.UNSAFE_componentWillUpdate=="function"&&N.UNSAFE_componentWillUpdate(b,ke,Z)),typeof N.componentDidUpdate=="function"&&(d.flags|=4),typeof N.getSnapshotBeforeUpdate=="function"&&(d.flags|=1024)):(typeof N.componentDidUpdate!="function"||M===u.memoizedProps&&xe===u.memoizedState||(d.flags|=4),typeof N.getSnapshotBeforeUpdate!="function"||M===u.memoizedProps&&xe===u.memoizedState||(d.flags|=1024),d.memoizedProps=b,d.memoizedState=ke),N.props=b,N.state=ke,N.context=Z,b=Ne):(typeof N.componentDidUpdate!="function"||M===u.memoizedProps&&xe===u.memoizedState||(d.flags|=4),typeof N.getSnapshotBeforeUpdate!="function"||M===u.memoizedProps&&xe===u.memoizedState||(d.flags|=1024),b=!1)}return N=b,up(u,d),b=(d.flags&128)!==0,N||b?(N=d.stateNode,m=b&&typeof m.getDerivedStateFromError!="function"?null:N.render(),d.flags|=1,u!==null&&b?(d.child=Qi(d,u.child,null,_),d.child=Qi(d,null,m,_)):Ns(u,d,m,_),d.memoizedState=N.state,u=d.child):u=ro(u,d,_),u}function gk(u,d,m,b){return Xo(),d.flags|=256,Ns(u,d,m,b),d.child}var G1={dehydrated:null,treeContext:null,retryLane:0};function H1(u){return{baseLanes:u,cachePool:Ug()}}function q1(u,d,m){return u=u!==null?u.childLanes&~m:0,d&&(u|=la),u}function yk(u,d,m){var b=d.pendingProps,_=!1,N=(d.flags&128)!==0,M;if((M=N)||(M=u!==null&&u.memoizedState===null?!1:(Ln.current&2)!==0),M&&(_=!0,d.flags&=-129),M=(d.flags&32)!==0,d.flags&=-33,u===null){if(Mt){if(_?hi(d):pi(),Mt){var H=Un,Z;if(Z=H){e:{for(Z=H,H=Lr;Z.nodeType!==8;){if(!H){H=null;break e}if(Z=Oa(Z.nextSibling),Z===null){H=null;break e}}H=Z}H!==null?(d.memoizedState={dehydrated:H,treeContext:ui!==null?{id:na,overflow:sa}:null,retryLane:536870912},Z=oa(18,null,null,0),Z.stateNode=H,Z.return=d,d.child=Z,cs=d,Un=null,Z=!0):Z=!1}Z||di(d)}if(H=d.memoizedState,H!==null&&(H=H.dehydrated,H!==null))return H.data==="$!"?d.lanes=16:d.lanes=536870912,null;Ra(d)}return H=b.children,b=b.fallback,_?(pi(),_=d.mode,H=K1({mode:"hidden",children:H},_),b=Du(b,_,m,null),H.return=d,b.return=d,H.sibling=b,d.child=H,_=d.child,_.memoizedState=H1(m),_.childLanes=q1(u,M,m),d.memoizedState=G1,b):(hi(d),j1(d,H))}if(Z=u.memoizedState,Z!==null&&(H=Z.dehydrated,H!==null)){if(N)d.flags&256?(hi(d),d.flags&=-257,d=X1(u,d,m)):d.memoizedState!==null?(pi(),d.child=u.child,d.flags|=128,d=null):(pi(),_=b.fallback,H=d.mode,b=K1({mode:"visible",children:b.children},H),_=Du(_,H,m,null),_.flags|=2,b.return=d,_.return=d,b.sibling=_,d.child=b,Qi(d,u.child,null,m),b=d.child,b.memoizedState=H1(m),b.childLanes=q1(u,M,m),d.memoizedState=G1,d=_);else if(hi(d),H.data==="$!"){if(M=H.nextSibling&&H.nextSibling.dataset,M)var he=M.dgst;M=he,b=Error(s(419)),b.stack="",b.digest=M,Yo({value:b,source:null,stack:null}),d=X1(u,d,m)}else if(ds||cp(u,d,m,!1),M=(m&u.childLanes)!==0,ds||M){if(M=un,M!==null){if(b=m&-m,(b&42)!==0)b=1;else switch(b){case 2:b=1;break;case 8:b=4;break;case 32:b=16;break;case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:b=64;break;case 268435456:b=134217728;break;default:b=0}if(b=(b&(M.suspendedLanes|m))!==0?0:b,b!==0&&b!==Z.retryLane)throw Z.retryLane=b,Aa(u,b),tr(M,u,b),lk}H.data==="$?"||Sw(),d=X1(u,d,m)}else H.data==="$?"?(d.flags|=128,d.child=u.child,d=YW.bind(null,u),H._reactRetry=d,d=null):(u=Z.treeContext,Un=Oa(H.nextSibling),cs=d,Mt=!0,gr=null,Lr=!1,u!==null&&(Js[er++]=na,Js[er++]=sa,Js[er++]=ui,na=u.id,sa=u.overflow,ui=d),d=j1(d,b.children),d.flags|=4096);return d}return _?(pi(),_=b.fallback,H=d.mode,Z=u.child,he=Z.sibling,b=pl(Z,{mode:"hidden",children:b.children}),b.subtreeFlags=Z.subtreeFlags&31457280,he!==null?_=pl(he,_):(_=Du(_,H,m,null),_.flags|=2),_.return=d,b.return=d,b.sibling=_,d.child=b,b=_,_=d.child,H=u.child.memoizedState,H===null?H=H1(m):(Z=H.cachePool,Z!==null?(he=Mn._currentValue,Z=Z.parent!==he?{parent:he,pool:he}:Z):Z=Ug(),H={baseLanes:H.baseLanes|m,cachePool:Z}),_.memoizedState=H,_.childLanes=q1(u,M,m),d.memoizedState=G1,b):(hi(d),m=u.child,u=m.sibling,m=pl(m,{mode:"visible",children:b.children}),m.return=d,m.sibling=null,u!==null&&(M=d.deletions,M===null?(d.deletions=[u],d.flags|=16):M.push(u)),d.child=m,d.memoizedState=null,m)}function j1(u,d){return d=K1({mode:"visible",children:d},u.mode),d.return=u,u.child=d}function K1(u,d){return Wk(u,d,0,null)}function X1(u,d,m){return Qi(d,u.child,null,m),u=j1(d,d.pendingProps.children),u.flags|=2,d.memoizedState=null,u}function bk(u,d,m){u.lanes|=d;var b=u.alternate;b!==null&&(b.lanes|=d),J1(u.return,d,m)}function Y1(u,d,m,b,_){var N=u.memoizedState;N===null?u.memoizedState={isBackwards:d,rendering:null,renderingStartTime:0,last:b,tail:m,tailMode:_}:(N.isBackwards=d,N.rendering=null,N.renderingStartTime=0,N.last=b,N.tail=m,N.tailMode=_)}function xk(u,d,m){var b=d.pendingProps,_=b.revealOrder,N=b.tail;if(Ns(u,d,b.children,m),b=Ln.current,(b&2)!==0)b=b&1|2,d.flags|=128;else{if(u!==null&&(u.flags&128)!==0)e:for(u=d.child;u!==null;){if(u.tag===13)u.memoizedState!==null&&bk(u,m,d);else if(u.tag===19)bk(u,m,d);else if(u.child!==null){u.child.return=u,u=u.child;continue}if(u===d)break e;for(;u.sibling===null;){if(u.return===null||u.return===d)break e;u=u.return}u.sibling.return=u.return,u=u.sibling}b&=1}switch(Me(Ln,b),_){case"forwards":for(m=d.child,_=null;m!==null;)u=m.alternate,u!==null&&td(u)===null&&(_=m),m=m.sibling;m=_,m===null?(_=d.child,d.child=null):(_=m.sibling,m.sibling=null),Y1(d,!1,_,m,N);break;case"backwards":for(m=null,_=d.child,d.child=null;_!==null;){if(u=_.alternate,u!==null&&td(u)===null){d.child=_;break}u=_.sibling,_.sibling=m,m=_,_=u}Y1(d,!0,m,null,N);break;case"together":Y1(d,!1,null,null,void 0);break;default:d.memoizedState=null}return d.child}function ro(u,d,m){if(u!==null&&(d.dependencies=u.dependencies),fl|=d.lanes,(m&d.childLanes)===0)if(u!==null){if(cp(u,d,m,!1),(m&d.childLanes)===0)return null}else return null;if(u!==null&&d.child!==u.child)throw Error(s(153));if(d.child!==null){for(u=d.child,m=pl(u,u.pendingProps),d.child=m,m.return=d;u.sibling!==null;)u=u.sibling,m=m.sibling=pl(u,u.pendingProps),m.return=d;m.sibling=null}return d.child}function Z1(u,d){return(u.lanes&d)!==0?!0:(u=u.dependencies,!!(u!==null&&Xg(u)))}function FW(u,d,m){switch(d.tag){case 3:kt(d,d.stateNode.containerInfo),il(d,Mn,u.memoizedState.cache),Xo();break;case 27:case 5:Nt(d);break;case 4:kt(d,d.stateNode.containerInfo);break;case 10:il(d,d.type,d.memoizedProps.value);break;case 13:var b=d.memoizedState;if(b!==null)return b.dehydrated!==null?(hi(d),d.flags|=128,null):(m&d.child.childLanes)!==0?yk(u,d,m):(hi(d),u=ro(u,d,m),u!==null?u.sibling:null);hi(d);break;case 19:var _=(u.flags&128)!==0;if(b=(m&d.childLanes)!==0,b||(cp(u,d,m,!1),b=(m&d.childLanes)!==0),_){if(b)return xk(u,d,m);d.flags|=128}if(_=d.memoizedState,_!==null&&(_.rendering=null,_.tail=null,_.lastEffect=null),Me(Ln,Ln.current),b)break;return null;case 22:case 23:return d.lanes=0,hk(u,d,m);case 24:il(d,Mn,u.memoizedState.cache)}return ro(u,d,m)}function wk(u,d,m){if(u!==null)if(u.memoizedProps!==d.pendingProps)ds=!0;else{if(!Z1(u,m)&&(d.flags&128)===0)return ds=!1,FW(u,d,m);ds=(u.flags&131072)!==0}else ds=!1,Mt&&(d.flags&1048576)!==0&&Yh(d,vu,d.index);switch(d.lanes=0,d.tag){case 16:e:{u=d.pendingProps;var b=d.elementType,_=b._init;if(b=_(b._payload),d.type=b,typeof b=="function")dw(b)?(u=Iu(b,u),d.tag=1,d=mk(null,d,b,u,m)):(d.tag=0,d=W1(null,d,b,u,m));else{if(b!=null){if(_=b.$$typeof,_===y){d.tag=11,d=uk(null,d,b,u,m);break e}else if(_===v){d.tag=14,d=ck(null,d,b,u,m);break e}}throw d=B(b)||b,Error(s(306,d,""))}}return d;case 0:return W1(u,d,d.type,d.pendingProps,m);case 1:return b=d.type,_=Iu(b,d.pendingProps),mk(u,d,b,_,m);case 3:e:{if(kt(d,d.stateNode.containerInfo),u===null)throw Error(s(387));var N=d.pendingProps;_=d.memoizedState,b=_.element,nw(u,d),pp(d,N,null,m);var M=d.memoizedState;if(N=M.cache,il(d,Mn,N),N!==_.cache&&ew(d,[Mn],m,!0),hp(),N=M.element,_.isDehydrated)if(_={element:N,isDehydrated:!1,cache:M.cache},d.updateQueue.baseState=_,d.memoizedState=_,d.flags&256){d=gk(u,d,N,m);break e}else if(N!==b){b=Qs(Error(s(424)),d),Yo(b),d=gk(u,d,N,m);break e}else for(Un=Oa(d.stateNode.containerInfo.firstChild),cs=d,Mt=!0,gr=null,Lr=!0,m=Lg(d,null,N,m),d.child=m;m;)m.flags=m.flags&-3|4096,m=m.sibling;else{if(Xo(),N===b){d=ro(u,d,m);break e}Ns(u,d,N,m)}d=d.child}return d;case 26:return up(u,d),u===null?(m=SN(d.type,null,d.pendingProps,null))?d.memoizedState=m:Mt||(m=d.type,u=d.pendingProps,b=dy(yt.current).createElement(m),b[es]=d,b[Cs]=u,Is(b,m,u),Fn(b),d.stateNode=b):d.memoizedState=SN(d.type,u.memoizedProps,d.pendingProps,u.memoizedState),null;case 27:return Nt(d),u===null&&Mt&&(b=d.stateNode=wN(d.type,d.pendingProps,yt.current),cs=d,Lr=!0,Un=Oa(b.firstChild)),b=d.pendingProps.children,u!==null||Mt?Ns(u,d,b,m):d.child=Qi(d,null,b,m),up(u,d),d.child;case 5:return u===null&&Mt&&((_=b=Un)&&(b=hG(b,d.type,d.pendingProps,Lr),b!==null?(d.stateNode=b,cs=d,Un=Oa(b.firstChild),Lr=!1,_=!0):_=!1),_||di(d)),Nt(d),_=d.type,N=d.pendingProps,M=u!==null?u.memoizedProps:null,b=N.children,Lw(_,N)?b=null:M!==null&&Lw(_,M)&&(d.flags|=32),d.memoizedState!==null&&(_=R(u,d,re,null,null,m),Np._currentValue=_),up(u,d),Ns(u,d,b,m),d.child;case 6:return u===null&&Mt&&((u=m=Un)&&(m=pG(m,d.pendingProps,Lr),m!==null?(d.stateNode=m,cs=d,Un=null,u=!0):u=!1),u||di(d)),null;case 13:return yk(u,d,m);case 4:return kt(d,d.stateNode.containerInfo),b=d.pendingProps,u===null?d.child=Qi(d,null,b,m):Ns(u,d,b,m),d.child;case 11:return uk(u,d,d.type,d.pendingProps,m);case 7:return Ns(u,d,d.pendingProps,m),d.child;case 8:return Ns(u,d,d.pendingProps.children,m),d.child;case 12:return Ns(u,d,d.pendingProps.children,m),d.child;case 10:return b=d.pendingProps,il(d,d.type,b.value),Ns(u,d,b.children,m),d.child;case 9:return _=d.type._context,b=d.pendingProps.children,Au(d),_=Ms(_),b=b(_),d.flags|=1,Ns(u,d,b,m),d.child;case 14:return ck(u,d,d.type,d.pendingProps,m);case 15:return dk(u,d,d.type,d.pendingProps,m);case 19:return xk(u,d,m);case 22:return hk(u,d,m);case 24:return Au(d),b=Ms(Mn),u===null?(_=op(),_===null&&(_=un,N=ap(),_.pooledCache=N,N.refCount++,N!==null&&(_.pooledCacheLanes|=m),_=N),d.memoizedState={parent:b,cache:_},tw(d),il(d,Mn,_)):((u.lanes&m)!==0&&(nw(u,d),pp(d,null,null,m),hp()),_=u.memoizedState,N=d.memoizedState,_.parent!==b?(_={parent:b,cache:b},d.memoizedState=_,d.lanes===0&&(d.memoizedState=d.updateQueue.baseState=_),il(d,Mn,b)):(b=N.cache,il(d,Mn,b),b!==_.cache&&ew(d,[Mn],m,!0))),Ns(u,d,d.pendingProps.children,m),d.child;case 29:throw d.pendingProps}throw Error(s(156,d.tag))}var Q1=Fe(null),Eu=null,ao=null;function il(u,d,m){Me(Q1,d._currentValue),d._currentValue=m}function io(u){u._currentValue=Q1.current,Ve(Q1)}function J1(u,d,m){for(;u!==null;){var b=u.alternate;if((u.childLanes&d)!==d?(u.childLanes|=d,b!==null&&(b.childLanes|=d)):b!==null&&(b.childLanes&d)!==d&&(b.childLanes|=d),u===m)break;u=u.return}}function ew(u,d,m,b){var _=u.child;for(_!==null&&(_.return=u);_!==null;){var N=_.dependencies;if(N!==null){var M=_.child;N=N.firstContext;e:for(;N!==null;){var H=N;N=_;for(var Z=0;Z<d.length;Z++)if(H.context===d[Z]){N.lanes|=m,H=N.alternate,H!==null&&(H.lanes|=m),J1(N.return,m,u),b||(M=null);break e}N=H.next}}else if(_.tag===18){if(M=_.return,M===null)throw Error(s(341));M.lanes|=m,N=M.alternate,N!==null&&(N.lanes|=m),J1(M,m,u),M=null}else M=_.child;if(M!==null)M.return=_;else for(M=_;M!==null;){if(M===u){M=null;break}if(_=M.sibling,_!==null){_.return=M.return,M=_;break}M=M.return}_=M}}function cp(u,d,m,b){u=null;for(var _=d,N=!1;_!==null;){if(!N){if((_.flags&524288)!==0)N=!0;else if((_.flags&262144)!==0)break}if(_.tag===10){var M=_.alternate;if(M===null)throw Error(s(387));if(M=M.memoizedProps,M!==null){var H=_.type;Ys(_.pendingProps.value,M.value)||(u!==null?u.push(H):u=[H])}}else if(_===Dt.current){if(M=_.alternate,M===null)throw Error(s(387));M.memoizedState.memoizedState!==_.memoizedState.memoizedState&&(u!==null?u.push(Np):u=[Np])}_=_.return}u!==null&&ew(d,u,m,b),d.flags|=262144}function Xg(u){for(u=u.firstContext;u!==null;){if(!Ys(u.context._currentValue,u.memoizedValue))return!0;u=u.next}return!1}function Au(u){Eu=u,ao=null,u=u.dependencies,u!==null&&(u.firstContext=null)}function Ms(u){return vk(Eu,u)}function Yg(u,d){return Eu===null&&Au(u),vk(u,d)}function vk(u,d){var m=d._currentValue;if(d={context:d,memoizedValue:m,next:null},ao===null){if(u===null)throw Error(s(308));ao=d,u.dependencies={lanes:0,firstContext:d},u.flags|=524288}else ao=ao.next=d;return m}var ol=!1;function tw(u){u.updateQueue={baseState:u.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function nw(u,d){u=u.updateQueue,d.updateQueue===u&&(d.updateQueue={baseState:u.baseState,firstBaseUpdate:u.firstBaseUpdate,lastBaseUpdate:u.lastBaseUpdate,shared:u.shared,callbacks:null})}function ll(u){return{lane:u,tag:0,payload:null,callback:null,next:null}}function ul(u,d,m){var b=u.updateQueue;if(b===null)return null;if(b=b.shared,(Sn&2)!==0){var _=b.pending;return _===null?d.next=d:(d.next=_.next,_.next=d),b.pending=d,d=xu(u),Kh(u,null,m),d}return bu(u,b,d,m),xu(u)}function dp(u,d,m){if(d=d.updateQueue,d!==null&&(d=d.shared,(m&4194176)!==0)){var b=d.lanes;b&=u.pendingLanes,m|=b,d.lanes=m,yh(u,m)}}function sw(u,d){var m=u.updateQueue,b=u.alternate;if(b!==null&&(b=b.updateQueue,m===b)){var _=null,N=null;if(m=m.firstBaseUpdate,m!==null){do{var M={lane:m.lane,tag:m.tag,payload:m.payload,callback:null,next:null};N===null?_=N=M:N=N.next=M,m=m.next}while(m!==null);N===null?_=N=d:N=N.next=d}else _=N=d;m={baseState:b.baseState,firstBaseUpdate:_,lastBaseUpdate:N,shared:b.shared,callbacks:b.callbacks},u.updateQueue=m;return}u=m.lastBaseUpdate,u===null?m.firstBaseUpdate=d:u.next=d,m.lastBaseUpdate=d}var rw=!1;function hp(){if(rw){var u=sl;if(u!==null)throw u}}function pp(u,d,m,b){rw=!1;var _=u.updateQueue;ol=!1;var N=_.firstBaseUpdate,M=_.lastBaseUpdate,H=_.shared.pending;if(H!==null){_.shared.pending=null;var Z=H,he=Z.next;Z.next=null,M===null?N=he:M.next=he,M=Z;var Ne=u.alternate;Ne!==null&&(Ne=Ne.updateQueue,H=Ne.lastBaseUpdate,H!==M&&(H===null?Ne.firstBaseUpdate=he:H.next=he,Ne.lastBaseUpdate=Z))}if(N!==null){var Oe=_.baseState;M=0,Ne=he=Z=null,H=N;do{var xe=H.lane&-536870913,ke=xe!==H.lane;if(ke?(Vt&xe)===xe:(b&xe)===xe){xe!==0&&xe===nl&&(rw=!0),Ne!==null&&(Ne=Ne.next={lane:0,tag:H.tag,payload:H.payload,callback:null,next:null});e:{var tt=u,gt=H;xe=d;var En=m;switch(gt.tag){case 1:if(tt=gt.payload,typeof tt=="function"){Oe=tt.call(En,Oe,xe);break e}Oe=tt;break e;case 3:tt.flags=tt.flags&-65537|128;case 0:if(tt=gt.payload,xe=typeof tt=="function"?tt.call(En,Oe,xe):tt,xe==null)break e;Oe=P({},Oe,xe);break e;case 2:ol=!0}}xe=H.callback,xe!==null&&(u.flags|=64,ke&&(u.flags|=8192),ke=_.callbacks,ke===null?_.callbacks=[xe]:ke.push(xe))}else ke={lane:xe,tag:H.tag,payload:H.payload,callback:H.callback,next:null},Ne===null?(he=Ne=ke,Z=Oe):Ne=Ne.next=ke,M|=xe;if(H=H.next,H===null){if(H=_.shared.pending,H===null)break;ke=H,H=ke.next,ke.next=null,_.lastBaseUpdate=ke,_.shared.pending=null}}while(!0);Ne===null&&(Z=Oe),_.baseState=Z,_.firstBaseUpdate=he,_.lastBaseUpdate=Ne,N===null&&(_.shared.lanes=0),fl|=M,u.lanes=M,u.memoizedState=Oe}}function $k(u,d){if(typeof u!="function")throw Error(s(191,u));u.call(d)}function Sk(u,d){var m=u.callbacks;if(m!==null)for(u.callbacks=null,u=0;u<m.length;u++)$k(m[u],d)}function fp(u,d){try{var m=d.updateQueue,b=m!==null?m.lastEffect:null;if(b!==null){var _=b.next;m=_;do{if((m.tag&u)===u){b=void 0;var N=m.create,M=m.inst;b=N(),M.destroy=b}m=m.next}while(m!==_)}}catch(H){rn(d,d.return,H)}}function cl(u,d,m){try{var b=d.updateQueue,_=b!==null?b.lastEffect:null;if(_!==null){var N=_.next;b=N;do{if((b.tag&u)===u){var M=b.inst,H=M.destroy;if(H!==void 0){M.destroy=void 0,_=d;var Z=m;try{H()}catch(he){rn(_,Z,he)}}}b=b.next}while(b!==N)}}catch(he){rn(d,d.return,he)}}function _k(u){var d=u.updateQueue;if(d!==null){var m=u.stateNode;try{Sk(d,m)}catch(b){rn(u,u.return,b)}}}function Ck(u,d,m){m.props=Iu(u.type,u.memoizedProps),m.state=u.memoizedState;try{m.componentWillUnmount()}catch(b){rn(u,d,b)}}function Ru(u,d){try{var m=u.ref;if(m!==null){var b=u.stateNode;switch(u.tag){case 26:case 27:case 5:var _=b;break;default:_=b}typeof m=="function"?u.refCleanup=m(_):m.current=_}}catch(N){rn(u,d,N)}}function Mr(u,d){var m=u.ref,b=u.refCleanup;if(m!==null)if(typeof b=="function")try{b()}catch(_){rn(u,d,_)}finally{u.refCleanup=null,u=u.alternate,u!=null&&(u.refCleanup=null)}else if(typeof m=="function")try{m(null)}catch(_){rn(u,d,_)}else m.current=null}function Tk(u){var d=u.type,m=u.memoizedProps,b=u.stateNode;try{e:switch(d){case"button":case"input":case"select":case"textarea":m.autoFocus&&b.focus();break e;case"img":m.src?b.src=m.src:m.srcSet&&(b.srcset=m.srcSet)}}catch(_){rn(u,u.return,_)}}function kk(u,d,m){try{var b=u.stateNode;oG(b,u.type,m,d),b[Cs]=d}catch(_){rn(u,u.return,_)}}function Nk(u){return u.tag===5||u.tag===3||u.tag===26||u.tag===27||u.tag===4}function aw(u){e:for(;;){for(;u.sibling===null;){if(u.return===null||Nk(u.return))return null;u=u.return}for(u.sibling.return=u.return,u=u.sibling;u.tag!==5&&u.tag!==6&&u.tag!==27&&u.tag!==18;){if(u.flags&2||u.child===null||u.tag===4)continue e;u.child.return=u,u=u.child}if(!(u.flags&2))return u.stateNode}}function iw(u,d,m){var b=u.tag;if(b===5||b===6)u=u.stateNode,d?m.nodeType===8?m.parentNode.insertBefore(u,d):m.insertBefore(u,d):(m.nodeType===8?(d=m.parentNode,d.insertBefore(u,m)):(d=m,d.appendChild(u)),m=m._reactRootContainer,m!=null||d.onclick!==null||(d.onclick=cy));else if(b!==4&&b!==27&&(u=u.child,u!==null))for(iw(u,d,m),u=u.sibling;u!==null;)iw(u,d,m),u=u.sibling}function Zg(u,d,m){var b=u.tag;if(b===5||b===6)u=u.stateNode,d?m.insertBefore(u,d):m.appendChild(u);else if(b!==4&&b!==27&&(u=u.child,u!==null))for(Zg(u,d,m),u=u.sibling;u!==null;)Zg(u,d,m),u=u.sibling}var oo=!1,Nn=!1,ow=!1,Ik=typeof WeakSet=="function"?WeakSet:Set,hs=null,Ek=!1;function LW(u,d){if(u=u.containerInfo,zw=yy,u=Ie(u),Ph(u)){if("selectionStart"in u)var m={start:u.selectionStart,end:u.selectionEnd};else e:{m=(m=u.ownerDocument)&&m.defaultView||window;var b=m.getSelection&&m.getSelection();if(b&&b.rangeCount!==0){m=b.anchorNode;var _=b.anchorOffset,N=b.focusNode;b=b.focusOffset;try{m.nodeType,N.nodeType}catch{m=null;break e}var M=0,H=-1,Z=-1,he=0,Ne=0,Oe=u,xe=null;t:for(;;){for(var ke;Oe!==m||_!==0&&Oe.nodeType!==3||(H=M+_),Oe!==N||b!==0&&Oe.nodeType!==3||(Z=M+b),Oe.nodeType===3&&(M+=Oe.nodeValue.length),(ke=Oe.firstChild)!==null;)xe=Oe,Oe=ke;for(;;){if(Oe===u)break t;if(xe===m&&++he===_&&(H=M),xe===N&&++Ne===b&&(Z=M),(ke=Oe.nextSibling)!==null)break;Oe=xe,xe=Oe.parentNode}Oe=ke}m=H===-1||Z===-1?null:{start:H,end:Z}}else m=null}m=m||{start:0,end:0}}else m=null;for(Fw={focusedElem:u,selectionRange:m},yy=!1,hs=d;hs!==null;)if(d=hs,u=d.child,(d.subtreeFlags&1028)!==0&&u!==null)u.return=d,hs=u;else for(;hs!==null;){switch(d=hs,N=d.alternate,u=d.flags,d.tag){case 0:break;case 11:case 15:break;case 1:if((u&1024)!==0&&N!==null){u=void 0,m=d,_=N.memoizedProps,N=N.memoizedState,b=m.stateNode;try{var tt=Iu(m.type,_,m.elementType===m.type);u=b.getSnapshotBeforeUpdate(tt,N),b.__reactInternalSnapshotBeforeUpdate=u}catch(gt){rn(m,m.return,gt)}}break;case 3:if((u&1024)!==0){if(u=d.stateNode.containerInfo,m=u.nodeType,m===9)Pw(u);else if(m===1)switch(u.nodeName){case"HEAD":case"HTML":case"BODY":Pw(u);break;default:u.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((u&1024)!==0)throw Error(s(163))}if(u=d.sibling,u!==null){u.return=d.return,hs=u;break}hs=d.return}return tt=Ek,Ek=!1,tt}function Ak(u,d,m){var b=m.flags;switch(m.tag){case 0:case 11:case 15:uo(u,m),b&4&&fp(5,m);break;case 1:if(uo(u,m),b&4)if(u=m.stateNode,d===null)try{u.componentDidMount()}catch(H){rn(m,m.return,H)}else{var _=Iu(m.type,d.memoizedProps);d=d.memoizedState;try{u.componentDidUpdate(_,d,u.__reactInternalSnapshotBeforeUpdate)}catch(H){rn(m,m.return,H)}}b&64&&_k(m),b&512&&Ru(m,m.return);break;case 3:if(uo(u,m),b&64&&(b=m.updateQueue,b!==null)){if(u=null,m.child!==null)switch(m.child.tag){case 27:case 5:u=m.child.stateNode;break;case 1:u=m.child.stateNode}try{Sk(b,u)}catch(H){rn(m,m.return,H)}}break;case 26:uo(u,m),b&512&&Ru(m,m.return);break;case 27:case 5:uo(u,m),d===null&&b&4&&Tk(m),b&512&&Ru(m,m.return);break;case 12:uo(u,m);break;case 13:uo(u,m),b&4&&Ok(u,m);break;case 22:if(_=m.memoizedState!==null||oo,!_){d=d!==null&&d.memoizedState!==null||Nn;var N=oo,M=Nn;oo=_,(Nn=d)&&!M?dl(u,m,(m.subtreeFlags&8772)!==0):uo(u,m),oo=N,Nn=M}b&512&&(m.memoizedProps.mode==="manual"?Ru(m,m.return):Mr(m,m.return));break;default:uo(u,m)}}function Rk(u){var d=u.alternate;d!==null&&(u.alternate=null,Rk(d)),u.child=null,u.deletions=null,u.sibling=null,u.tag===5&&(d=u.stateNode,d!==null&&Lc(d)),u.stateNode=null,u.return=null,u.dependencies=null,u.memoizedProps=null,u.memoizedState=null,u.pendingProps=null,u.stateNode=null,u.updateQueue=null}var Wn=null,Br=!1;function lo(u,d,m){for(m=m.child;m!==null;)Dk(u,d,m),m=m.sibling}function Dk(u,d,m){if(vn&&typeof vn.onCommitFiberUnmount=="function")try{vn.onCommitFiberUnmount(Rr,m)}catch{}switch(m.tag){case 26:Nn||Mr(m,d),lo(u,d,m),m.memoizedState?m.memoizedState.count--:m.stateNode&&(m=m.stateNode,m.parentNode.removeChild(m));break;case 27:Nn||Mr(m,d);var b=Wn,_=Br;for(Wn=m.stateNode,lo(u,d,m),m=m.stateNode,d=m.attributes;d.length;)m.removeAttributeNode(d[0]);Lc(m),Wn=b,Br=_;break;case 5:Nn||Mr(m,d);case 6:_=Wn;var N=Br;if(Wn=null,lo(u,d,m),Wn=_,Br=N,Wn!==null)if(Br)try{u=Wn,b=m.stateNode,u.nodeType===8?u.parentNode.removeChild(b):u.removeChild(b)}catch(M){rn(m,d,M)}else try{Wn.removeChild(m.stateNode)}catch(M){rn(m,d,M)}break;case 18:Wn!==null&&(Br?(d=Wn,m=m.stateNode,d.nodeType===8?Bw(d.parentNode,m):d.nodeType===1&&Bw(d,m),Rp(d)):Bw(Wn,m.stateNode));break;case 4:b=Wn,_=Br,Wn=m.stateNode.containerInfo,Br=!0,lo(u,d,m),Wn=b,Br=_;break;case 0:case 11:case 14:case 15:Nn||cl(2,m,d),Nn||cl(4,m,d),lo(u,d,m);break;case 1:Nn||(Mr(m,d),b=m.stateNode,typeof b.componentWillUnmount=="function"&&Ck(m,d,b)),lo(u,d,m);break;case 21:lo(u,d,m);break;case 22:Nn||Mr(m,d),Nn=(b=Nn)||m.memoizedState!==null,lo(u,d,m),Nn=b;break;default:lo(u,d,m)}}function Ok(u,d){if(d.memoizedState===null&&(u=d.alternate,u!==null&&(u=u.memoizedState,u!==null&&(u=u.dehydrated,u!==null))))try{Rp(u)}catch(m){rn(d,d.return,m)}}function MW(u){switch(u.tag){case 13:case 19:var d=u.stateNode;return d===null&&(d=u.stateNode=new Ik),d;case 22:return u=u.stateNode,d=u._retryCache,d===null&&(d=u._retryCache=new Ik),d;default:throw Error(s(435,u.tag))}}function lw(u,d){var m=MW(u);d.forEach(function(b){var _=ZW.bind(null,u,b);m.has(b)||(m.add(b),b.then(_,_))})}function aa(u,d){var m=d.deletions;if(m!==null)for(var b=0;b<m.length;b++){var _=m[b],N=u,M=d,H=M;e:for(;H!==null;){switch(H.tag){case 27:case 5:Wn=H.stateNode,Br=!1;break e;case 3:Wn=H.stateNode.containerInfo,Br=!0;break e;case 4:Wn=H.stateNode.containerInfo,Br=!0;break e}H=H.return}if(Wn===null)throw Error(s(160));Dk(N,M,_),Wn=null,Br=!1,N=_.alternate,N!==null&&(N.return=null),_.return=null}if(d.subtreeFlags&13878)for(d=d.child;d!==null;)zk(d,u),d=d.sibling}var Da=null;function zk(u,d){var m=u.alternate,b=u.flags;switch(u.tag){case 0:case 11:case 14:case 15:aa(d,u),ia(u),b&4&&(cl(3,u,u.return),fp(3,u),cl(5,u,u.return));break;case 1:aa(d,u),ia(u),b&512&&(Nn||m===null||Mr(m,m.return)),b&64&&oo&&(u=u.updateQueue,u!==null&&(b=u.callbacks,b!==null&&(m=u.shared.hiddenCallbacks,u.shared.hiddenCallbacks=m===null?b:m.concat(b))));break;case 26:var _=Da;if(aa(d,u),ia(u),b&512&&(Nn||m===null||Mr(m,m.return)),b&4){var N=m!==null?m.memoizedState:null;if(b=u.memoizedState,m===null)if(b===null)if(u.stateNode===null){e:{b=u.type,m=u.memoizedProps,_=_.ownerDocument||_;t:switch(b){case"title":N=_.getElementsByTagName("title")[0],(!N||N[Fo]||N[es]||N.namespaceURI==="http://www.w3.org/2000/svg"||N.hasAttribute("itemprop"))&&(N=_.createElement(b),_.head.insertBefore(N,_.querySelector("head > title"))),Is(N,b,m),N[es]=u,Fn(N),b=N;break e;case"link":var M=TN("link","href",_).get(b+(m.href||""));if(M){for(var H=0;H<M.length;H++)if(N=M[H],N.getAttribute("href")===(m.href==null?null:m.href)&&N.getAttribute("rel")===(m.rel==null?null:m.rel)&&N.getAttribute("title")===(m.title==null?null:m.title)&&N.getAttribute("crossorigin")===(m.crossOrigin==null?null:m.crossOrigin)){M.splice(H,1);break t}}N=_.createElement(b),Is(N,b,m),_.head.appendChild(N);break;case"meta":if(M=TN("meta","content",_).get(b+(m.content||""))){for(H=0;H<M.length;H++)if(N=M[H],N.getAttribute("content")===(m.content==null?null:""+m.content)&&N.getAttribute("name")===(m.name==null?null:m.name)&&N.getAttribute("property")===(m.property==null?null:m.property)&&N.getAttribute("http-equiv")===(m.httpEquiv==null?null:m.httpEquiv)&&N.getAttribute("charset")===(m.charSet==null?null:m.charSet)){M.splice(H,1);break t}}N=_.createElement(b),Is(N,b,m),_.head.appendChild(N);break;default:throw Error(s(468,b))}N[es]=u,Fn(N),b=N}u.stateNode=b}else kN(_,u.type,u.stateNode);else u.stateNode=CN(_,b,u.memoizedProps);else N!==b?(N===null?m.stateNode!==null&&(m=m.stateNode,m.parentNode.removeChild(m)):N.count--,b===null?kN(_,u.type,u.stateNode):CN(_,b,u.memoizedProps)):b===null&&u.stateNode!==null&&kk(u,u.memoizedProps,m.memoizedProps)}break;case 27:if(b&4&&u.alternate===null){_=u.stateNode,N=u.memoizedProps;try{for(var Z=_.firstChild;Z;){var he=Z.nextSibling,Ne=Z.nodeName;Z[Fo]||Ne==="HEAD"||Ne==="BODY"||Ne==="SCRIPT"||Ne==="STYLE"||Ne==="LINK"&&Z.rel.toLowerCase()==="stylesheet"||_.removeChild(Z),Z=he}for(var Oe=u.type,xe=_.attributes;xe.length;)_.removeAttributeNode(xe[0]);Is(_,Oe,N),_[es]=u,_[Cs]=N}catch(tt){rn(u,u.return,tt)}}case 5:if(aa(d,u),ia(u),b&512&&(Nn||m===null||Mr(m,m.return)),u.flags&32){_=u.stateNode;try{Vo(_,"")}catch(tt){rn(u,u.return,tt)}}b&4&&u.stateNode!=null&&(_=u.memoizedProps,kk(u,_,m!==null?m.memoizedProps:_)),b&1024&&(ow=!0);break;case 6:if(aa(d,u),ia(u),b&4){if(u.stateNode===null)throw Error(s(162));b=u.memoizedProps,m=u.stateNode;try{m.nodeValue=b}catch(tt){rn(u,u.return,tt)}}break;case 3:if(fy=null,_=Da,Da=hy(d.containerInfo),aa(d,u),Da=_,ia(u),b&4&&m!==null&&m.memoizedState.isDehydrated)try{Rp(d.containerInfo)}catch(tt){rn(u,u.return,tt)}ow&&(ow=!1,Fk(u));break;case 4:b=Da,Da=hy(u.stateNode.containerInfo),aa(d,u),ia(u),Da=b;break;case 12:aa(d,u),ia(u);break;case 13:aa(d,u),ia(u),u.child.flags&8192&&u.memoizedState!==null!=(m!==null&&m.memoizedState!==null)&&(yw=ln()),b&4&&(b=u.updateQueue,b!==null&&(u.updateQueue=null,lw(u,b)));break;case 22:if(b&512&&(Nn||m===null||Mr(m,m.return)),Z=u.memoizedState!==null,he=m!==null&&m.memoizedState!==null,Ne=oo,Oe=Nn,oo=Ne||Z,Nn=Oe||he,aa(d,u),Nn=Oe,oo=Ne,ia(u),d=u.stateNode,d._current=u,d._visibility&=-3,d._visibility|=d._pendingVisibility&2,b&8192&&(d._visibility=Z?d._visibility&-2:d._visibility|1,Z&&(d=oo||Nn,m===null||he||d||id(u)),u.memoizedProps===null||u.memoizedProps.mode!=="manual"))e:for(m=null,d=u;;){if(d.tag===5||d.tag===26||d.tag===27){if(m===null){he=m=d;try{if(_=he.stateNode,Z)N=_.style,typeof N.setProperty=="function"?N.setProperty("display","none","important"):N.display="none";else{M=he.stateNode,H=he.memoizedProps.style;var ke=H!=null&&H.hasOwnProperty("display")?H.display:null;M.style.display=ke==null||typeof ke=="boolean"?"":(""+ke).trim()}}catch(tt){rn(he,he.return,tt)}}}else if(d.tag===6){if(m===null){he=d;try{he.stateNode.nodeValue=Z?"":he.memoizedProps}catch(tt){rn(he,he.return,tt)}}}else if((d.tag!==22&&d.tag!==23||d.memoizedState===null||d===u)&&d.child!==null){d.child.return=d,d=d.child;continue}if(d===u)break e;for(;d.sibling===null;){if(d.return===null||d.return===u)break e;m===d&&(m=null),d=d.return}m===d&&(m=null),d.sibling.return=d.return,d=d.sibling}b&4&&(b=u.updateQueue,b!==null&&(m=b.retryQueue,m!==null&&(b.retryQueue=null,lw(u,m))));break;case 19:aa(d,u),ia(u),b&4&&(b=u.updateQueue,b!==null&&(u.updateQueue=null,lw(u,b)));break;case 21:break;default:aa(d,u),ia(u)}}function ia(u){var d=u.flags;if(d&2){try{if(u.tag!==27){e:{for(var m=u.return;m!==null;){if(Nk(m)){var b=m;break e}m=m.return}throw Error(s(160))}switch(b.tag){case 27:var _=b.stateNode,N=aw(u);Zg(u,N,_);break;case 5:var M=b.stateNode;b.flags&32&&(Vo(M,""),b.flags&=-33);var H=aw(u);Zg(u,H,M);break;case 3:case 4:var Z=b.stateNode.containerInfo,he=aw(u);iw(u,he,Z);break;default:throw Error(s(161))}}}catch(Ne){rn(u,u.return,Ne)}u.flags&=-3}d&4096&&(u.flags&=-4097)}function Fk(u){if(u.subtreeFlags&1024)for(u=u.child;u!==null;){var d=u;Fk(d),d.tag===5&&d.flags&1024&&d.stateNode.reset(),u=u.sibling}}function uo(u,d){if(d.subtreeFlags&8772)for(d=d.child;d!==null;)Ak(u,d.alternate,d),d=d.sibling}function id(u){for(u=u.child;u!==null;){var d=u;switch(d.tag){case 0:case 11:case 14:case 15:cl(4,d,d.return),id(d);break;case 1:Mr(d,d.return);var m=d.stateNode;typeof m.componentWillUnmount=="function"&&Ck(d,d.return,m),id(d);break;case 26:case 27:case 5:Mr(d,d.return),id(d);break;case 22:Mr(d,d.return),d.memoizedState===null&&id(d);break;default:id(d)}u=u.sibling}}function dl(u,d,m){for(m=m&&(d.subtreeFlags&8772)!==0,d=d.child;d!==null;){var b=d.alternate,_=u,N=d,M=N.flags;switch(N.tag){case 0:case 11:case 15:dl(_,N,m),fp(4,N);break;case 1:if(dl(_,N,m),b=N,_=b.stateNode,typeof _.componentDidMount=="function")try{_.componentDidMount()}catch(he){rn(b,b.return,he)}if(b=N,_=b.updateQueue,_!==null){var H=b.stateNode;try{var Z=_.shared.hiddenCallbacks;if(Z!==null)for(_.shared.hiddenCallbacks=null,_=0;_<Z.length;_++)$k(Z[_],H)}catch(he){rn(b,b.return,he)}}m&&M&64&&_k(N),Ru(N,N.return);break;case 26:case 27:case 5:dl(_,N,m),m&&b===null&&M&4&&Tk(N),Ru(N,N.return);break;case 12:dl(_,N,m);break;case 13:dl(_,N,m),m&&M&4&&Ok(_,N);break;case 22:N.memoizedState===null&&dl(_,N,m),Ru(N,N.return);break;default:dl(_,N,m)}d=d.sibling}}function uw(u,d){var m=null;u!==null&&u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(m=u.memoizedState.cachePool.pool),u=null,d.memoizedState!==null&&d.memoizedState.cachePool!==null&&(u=d.memoizedState.cachePool.pool),u!==m&&(u!=null&&u.refCount++,m!=null&&_u(m))}function cw(u,d){u=null,d.alternate!==null&&(u=d.alternate.memoizedState.cache),d=d.memoizedState.cache,d!==u&&(d.refCount++,u!=null&&_u(u))}function hl(u,d,m,b){if(d.subtreeFlags&10256)for(d=d.child;d!==null;)Lk(u,d,m,b),d=d.sibling}function Lk(u,d,m,b){var _=d.flags;switch(d.tag){case 0:case 11:case 15:hl(u,d,m,b),_&2048&&fp(9,d);break;case 3:hl(u,d,m,b),_&2048&&(u=null,d.alternate!==null&&(u=d.alternate.memoizedState.cache),d=d.memoizedState.cache,d!==u&&(d.refCount++,u!=null&&_u(u)));break;case 12:if(_&2048){hl(u,d,m,b),u=d.stateNode;try{var N=d.memoizedProps,M=N.id,H=N.onPostCommit;typeof H=="function"&&H(M,d.alternate===null?"mount":"update",u.passiveEffectDuration,-0)}catch(Z){rn(d,d.return,Z)}}else hl(u,d,m,b);break;case 23:break;case 22:N=d.stateNode,d.memoizedState!==null?N._visibility&4?hl(u,d,m,b):mp(u,d):N._visibility&4?hl(u,d,m,b):(N._visibility|=4,od(u,d,m,b,(d.subtreeFlags&10256)!==0)),_&2048&&uw(d.alternate,d);break;case 24:hl(u,d,m,b),_&2048&&cw(d.alternate,d);break;default:hl(u,d,m,b)}}function od(u,d,m,b,_){for(_=_&&(d.subtreeFlags&10256)!==0,d=d.child;d!==null;){var N=u,M=d,H=m,Z=b,he=M.flags;switch(M.tag){case 0:case 11:case 15:od(N,M,H,Z,_),fp(8,M);break;case 23:break;case 22:var Ne=M.stateNode;M.memoizedState!==null?Ne._visibility&4?od(N,M,H,Z,_):mp(N,M):(Ne._visibility|=4,od(N,M,H,Z,_)),_&&he&2048&&uw(M.alternate,M);break;case 24:od(N,M,H,Z,_),_&&he&2048&&cw(M.alternate,M);break;default:od(N,M,H,Z,_)}d=d.sibling}}function mp(u,d){if(d.subtreeFlags&10256)for(d=d.child;d!==null;){var m=u,b=d,_=b.flags;switch(b.tag){case 22:mp(m,b),_&2048&&uw(b.alternate,b);break;case 24:mp(m,b),_&2048&&cw(b.alternate,b);break;default:mp(m,b)}d=d.sibling}}var gp=8192;function ld(u){if(u.subtreeFlags&gp)for(u=u.child;u!==null;)Mk(u),u=u.sibling}function Mk(u){switch(u.tag){case 26:ld(u),u.flags&gp&&u.memoizedState!==null&&TG(Da,u.memoizedState,u.memoizedProps);break;case 5:ld(u);break;case 3:case 4:var d=Da;Da=hy(u.stateNode.containerInfo),ld(u),Da=d;break;case 22:u.memoizedState===null&&(d=u.alternate,d!==null&&d.memoizedState!==null?(d=gp,gp=16777216,ld(u),gp=d):ld(u));break;default:ld(u)}}function Bk(u){var d=u.alternate;if(d!==null&&(u=d.child,u!==null)){d.child=null;do d=u.sibling,u.sibling=null,u=d;while(u!==null)}}function yp(u){var d=u.deletions;if((u.flags&16)!==0){if(d!==null)for(var m=0;m<d.length;m++){var b=d[m];hs=b,Vk(b,u)}Bk(u)}if(u.subtreeFlags&10256)for(u=u.child;u!==null;)Pk(u),u=u.sibling}function Pk(u){switch(u.tag){case 0:case 11:case 15:yp(u),u.flags&2048&&cl(9,u,u.return);break;case 3:yp(u);break;case 12:yp(u);break;case 22:var d=u.stateNode;u.memoizedState!==null&&d._visibility&4&&(u.return===null||u.return.tag!==13)?(d._visibility&=-5,Qg(u)):yp(u);break;default:yp(u)}}function Qg(u){var d=u.deletions;if((u.flags&16)!==0){if(d!==null)for(var m=0;m<d.length;m++){var b=d[m];hs=b,Vk(b,u)}Bk(u)}for(u=u.child;u!==null;){switch(d=u,d.tag){case 0:case 11:case 15:cl(8,d,d.return),Qg(d);break;case 22:m=d.stateNode,m._visibility&4&&(m._visibility&=-5,Qg(d));break;default:Qg(d)}u=u.sibling}}function Vk(u,d){for(;hs!==null;){var m=hs;switch(m.tag){case 0:case 11:case 15:cl(8,m,d);break;case 23:case 22:if(m.memoizedState!==null&&m.memoizedState.cachePool!==null){var b=m.memoizedState.cachePool.pool;b!=null&&b.refCount++}break;case 24:_u(m.memoizedState.cache)}if(b=m.child,b!==null)b.return=m,hs=b;else e:for(m=u;hs!==null;){b=hs;var _=b.sibling,N=b.return;if(Rk(b),b===m){hs=null;break e}if(_!==null){_.return=N,hs=_;break e}hs=N}}}function BW(u,d,m,b){this.tag=u,this.key=m,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=d,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=b,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function oa(u,d,m,b){return new BW(u,d,m,b)}function dw(u){return u=u.prototype,!(!u||!u.isReactComponent)}function pl(u,d){var m=u.alternate;return m===null?(m=oa(u.tag,d,u.key,u.mode),m.elementType=u.elementType,m.type=u.type,m.stateNode=u.stateNode,m.alternate=u,u.alternate=m):(m.pendingProps=d,m.type=u.type,m.flags=0,m.subtreeFlags=0,m.deletions=null),m.flags=u.flags&31457280,m.childLanes=u.childLanes,m.lanes=u.lanes,m.child=u.child,m.memoizedProps=u.memoizedProps,m.memoizedState=u.memoizedState,m.updateQueue=u.updateQueue,d=u.dependencies,m.dependencies=d===null?null:{lanes:d.lanes,firstContext:d.firstContext},m.sibling=u.sibling,m.index=u.index,m.ref=u.ref,m.refCleanup=u.refCleanup,m}function Uk(u,d){u.flags&=31457282;var m=u.alternate;return m===null?(u.childLanes=0,u.lanes=d,u.child=null,u.subtreeFlags=0,u.memoizedProps=null,u.memoizedState=null,u.updateQueue=null,u.dependencies=null,u.stateNode=null):(u.childLanes=m.childLanes,u.lanes=m.lanes,u.child=m.child,u.subtreeFlags=0,u.deletions=null,u.memoizedProps=m.memoizedProps,u.memoizedState=m.memoizedState,u.updateQueue=m.updateQueue,u.type=m.type,d=m.dependencies,u.dependencies=d===null?null:{lanes:d.lanes,firstContext:d.firstContext}),u}function Jg(u,d,m,b,_,N){var M=0;if(b=u,typeof u=="function")dw(u)&&(M=1);else if(typeof u=="string")M=_G(u,m,Pe.current)?26:u==="html"||u==="head"||u==="body"?27:5;else e:switch(u){case l:return Du(m.children,_,N,d);case c:M=8,_|=24;break;case h:return u=oa(12,m,d,_|2),u.elementType=h,u.lanes=N,u;case x:return u=oa(13,m,d,_),u.elementType=x,u.lanes=N,u;case w:return u=oa(19,m,d,_),u.elementType=w,u.lanes=N,u;case T:return Wk(m,_,N,d);default:if(typeof u=="object"&&u!==null)switch(u.$$typeof){case p:case g:M=10;break e;case f:M=9;break e;case y:M=11;break e;case v:M=14;break e;case $:M=16,b=null;break e}M=29,m=Error(s(130,u===null?"null":typeof u,"")),b=null}return d=oa(M,m,d,_),d.elementType=u,d.type=b,d.lanes=N,d}function Du(u,d,m,b){return u=oa(7,u,b,d),u.lanes=m,u}function Wk(u,d,m,b){u=oa(22,u,b,d),u.elementType=T,u.lanes=m;var _={_visibility:1,_pendingVisibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null,_current:null,detach:function(){var N=_._current;if(N===null)throw Error(s(456));if((_._pendingVisibility&2)===0){var M=Aa(N,2);M!==null&&(_._pendingVisibility|=2,tr(M,N,2))}},attach:function(){var N=_._current;if(N===null)throw Error(s(456));if((_._pendingVisibility&2)!==0){var M=Aa(N,2);M!==null&&(_._pendingVisibility&=-3,tr(M,N,2))}}};return u.stateNode=_,u}function hw(u,d,m){return u=oa(6,u,null,d),u.lanes=m,u}function pw(u,d,m){return d=oa(4,u.children!==null?u.children:[],u.key,d),d.lanes=m,d.stateNode={containerInfo:u.containerInfo,pendingChildren:null,implementation:u.implementation},d}function co(u){u.flags|=4}function Gk(u,d){if(d.type!=="stylesheet"||(d.state.loading&4)!==0)u.flags&=-16777217;else if(u.flags|=16777216,!NN(d)){if(d=yr.current,d!==null&&((Vt&4194176)===Vt?ra!==null:(Vt&62914560)!==Vt&&(Vt&536870912)===0||d!==ra))throw Qo=Qc,Jh;u.flags|=8192}}function ey(u,d){d!==null&&(u.flags|=4),u.flags&16384&&(d=u.tag!==22?Jm():536870912,u.lanes|=d,cd|=d)}function bp(u,d){if(!Mt)switch(u.tailMode){case"hidden":d=u.tail;for(var m=null;d!==null;)d.alternate!==null&&(m=d),d=d.sibling;m===null?u.tail=null:m.sibling=null;break;case"collapsed":m=u.tail;for(var b=null;m!==null;)m.alternate!==null&&(b=m),m=m.sibling;b===null?d||u.tail===null?u.tail=null:u.tail.sibling=null:b.sibling=null}}function $n(u){var d=u.alternate!==null&&u.alternate.child===u.child,m=0,b=0;if(d)for(var _=u.child;_!==null;)m|=_.lanes|_.childLanes,b|=_.subtreeFlags&31457280,b|=_.flags&31457280,_.return=u,_=_.sibling;else for(_=u.child;_!==null;)m|=_.lanes|_.childLanes,b|=_.subtreeFlags,b|=_.flags,_.return=u,_=_.sibling;return u.subtreeFlags|=b,u.childLanes=m,d}function PW(u,d,m){var b=d.pendingProps;switch(Yc(d),d.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return $n(d),null;case 1:return $n(d),null;case 3:return m=d.stateNode,b=null,u!==null&&(b=u.memoizedState.cache),d.memoizedState.cache!==b&&(d.flags|=2048),io(Mn),Ct(),m.pendingContext&&(m.context=m.pendingContext,m.pendingContext=null),(u===null||u.child===null)&&(Ko(d)?co(d):u===null||u.memoizedState.isDehydrated&&(d.flags&256)===0||(d.flags|=1024,gr!==null&&(vw(gr),gr=null))),$n(d),null;case 26:return m=d.memoizedState,u===null?(co(d),m!==null?($n(d),Gk(d,m)):($n(d),d.flags&=-16777217)):m?m!==u.memoizedState?(co(d),$n(d),Gk(d,m)):($n(d),d.flags&=-16777217):(u.memoizedProps!==b&&co(d),$n(d),d.flags&=-16777217),null;case 27:Gt(d),m=yt.current;var _=d.type;if(u!==null&&d.stateNode!=null)u.memoizedProps!==b&&co(d);else{if(!b){if(d.stateNode===null)throw Error(s(166));return $n(d),null}u=Pe.current,Ko(d)?Zh(d):(u=wN(_,b,m),d.stateNode=u,co(d))}return $n(d),null;case 5:if(Gt(d),m=d.type,u!==null&&d.stateNode!=null)u.memoizedProps!==b&&co(d);else{if(!b){if(d.stateNode===null)throw Error(s(166));return $n(d),null}if(u=Pe.current,Ko(d))Zh(d);else{switch(_=dy(yt.current),u){case 1:u=_.createElementNS("http://www.w3.org/2000/svg",m);break;case 2:u=_.createElementNS("http://www.w3.org/1998/Math/MathML",m);break;default:switch(m){case"svg":u=_.createElementNS("http://www.w3.org/2000/svg",m);break;case"math":u=_.createElementNS("http://www.w3.org/1998/Math/MathML",m);break;case"script":u=_.createElement("div"),u.innerHTML="<script><\/script>",u=u.removeChild(u.firstChild);break;case"select":u=typeof b.is=="string"?_.createElement("select",{is:b.is}):_.createElement("select"),b.multiple?u.multiple=!0:b.size&&(u.size=b.size);break;default:u=typeof b.is=="string"?_.createElement(m,{is:b.is}):_.createElement(m)}}u[es]=d,u[Cs]=b;e:for(_=d.child;_!==null;){if(_.tag===5||_.tag===6)u.appendChild(_.stateNode);else if(_.tag!==4&&_.tag!==27&&_.child!==null){_.child.return=_,_=_.child;continue}if(_===d)break e;for(;_.sibling===null;){if(_.return===null||_.return===d)break e;_=_.return}_.sibling.return=_.return,_=_.sibling}d.stateNode=u;e:switch(Is(u,m,b),m){case"button":case"input":case"select":case"textarea":u=!!b.autoFocus;break e;case"img":u=!0;break e;default:u=!1}u&&co(d)}}return $n(d),d.flags&=-16777217,null;case 6:if(u&&d.stateNode!=null)u.memoizedProps!==b&&co(d);else{if(typeof b!="string"&&d.stateNode===null)throw Error(s(166));if(u=yt.current,Ko(d)){if(u=d.stateNode,m=d.memoizedProps,b=null,_=cs,_!==null)switch(_.tag){case 27:case 5:b=_.memoizedProps}u[es]=d,u=!!(u.nodeValue===m||b!==null&&b.suppressHydrationWarning===!0||fN(u.nodeValue,m)),u||di(d)}else u=dy(u).createTextNode(b),u[es]=d,d.stateNode=u}return $n(d),null;case 13:if(b=d.memoizedState,u===null||u.memoizedState!==null&&u.memoizedState.dehydrated!==null){if(_=Ko(d),b!==null&&b.dehydrated!==null){if(u===null){if(!_)throw Error(s(318));if(_=d.memoizedState,_=_!==null?_.dehydrated:null,!_)throw Error(s(317));_[es]=d}else Xo(),(d.flags&128)===0&&(d.memoizedState=null),d.flags|=4;$n(d),_=!1}else gr!==null&&(vw(gr),gr=null),_=!0;if(!_)return d.flags&256?(Ra(d),d):(Ra(d),null)}if(Ra(d),(d.flags&128)!==0)return d.lanes=m,d;if(m=b!==null,u=u!==null&&u.memoizedState!==null,m){b=d.child,_=null,b.alternate!==null&&b.alternate.memoizedState!==null&&b.alternate.memoizedState.cachePool!==null&&(_=b.alternate.memoizedState.cachePool.pool);var N=null;b.memoizedState!==null&&b.memoizedState.cachePool!==null&&(N=b.memoizedState.cachePool.pool),N!==_&&(b.flags|=2048)}return m!==u&&m&&(d.child.flags|=8192),ey(d,d.updateQueue),$n(d),null;case 4:return Ct(),u===null&&Rw(d.stateNode.containerInfo),$n(d),null;case 10:return io(d.type),$n(d),null;case 19:if(Ve(Ln),_=d.memoizedState,_===null)return $n(d),null;if(b=(d.flags&128)!==0,N=_.rendering,N===null)if(b)bp(_,!1);else{if(In!==0||u!==null&&(u.flags&128)!==0)for(u=d.child;u!==null;){if(N=td(u),N!==null){for(d.flags|=128,bp(_,!1),u=N.updateQueue,d.updateQueue=u,ey(d,u),d.subtreeFlags=0,u=m,m=d.child;m!==null;)Uk(m,u),m=m.sibling;return Me(Ln,Ln.current&1|2),d.child}u=u.sibling}_.tail!==null&&ln()>ty&&(d.flags|=128,b=!0,bp(_,!1),d.lanes=4194304)}else{if(!b)if(u=td(N),u!==null){if(d.flags|=128,b=!0,u=u.updateQueue,d.updateQueue=u,ey(d,u),bp(_,!0),_.tail===null&&_.tailMode==="hidden"&&!N.alternate&&!Mt)return $n(d),null}else 2*ln()-_.renderingStartTime>ty&&m!==536870912&&(d.flags|=128,b=!0,bp(_,!1),d.lanes=4194304);_.isBackwards?(N.sibling=d.child,d.child=N):(u=_.last,u!==null?u.sibling=N:d.child=N,_.last=N)}return _.tail!==null?(d=_.tail,_.rendering=d,_.tail=d.sibling,_.renderingStartTime=ln(),d.sibling=null,u=Ln.current,Me(Ln,b?u&1|2:u&1),d):($n(d),null);case 22:case 23:return Ra(d),rp(),b=d.memoizedState!==null,u!==null?u.memoizedState!==null!==b&&(d.flags|=8192):b&&(d.flags|=8192),b?(m&536870912)!==0&&(d.flags&128)===0&&($n(d),d.subtreeFlags&6&&(d.flags|=8192)):$n(d),m=d.updateQueue,m!==null&&ey(d,m.retryQueue),m=null,u!==null&&u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(m=u.memoizedState.cachePool.pool),b=null,d.memoizedState!==null&&d.memoizedState.cachePool!==null&&(b=d.memoizedState.cachePool.pool),b!==m&&(d.flags|=2048),u!==null&&Ve(Ji),null;case 24:return m=null,u!==null&&(m=u.memoizedState.cache),d.memoizedState.cache!==m&&(d.flags|=2048),io(Mn),$n(d),null;case 25:return null}throw Error(s(156,d.tag))}function VW(u,d){switch(Yc(d),d.tag){case 1:return u=d.flags,u&65536?(d.flags=u&-65537|128,d):null;case 3:return io(Mn),Ct(),u=d.flags,(u&65536)!==0&&(u&128)===0?(d.flags=u&-65537|128,d):null;case 26:case 27:case 5:return Gt(d),null;case 13:if(Ra(d),u=d.memoizedState,u!==null&&u.dehydrated!==null){if(d.alternate===null)throw Error(s(340));Xo()}return u=d.flags,u&65536?(d.flags=u&-65537|128,d):null;case 19:return Ve(Ln),null;case 4:return Ct(),null;case 10:return io(d.type),null;case 22:case 23:return Ra(d),rp(),u!==null&&Ve(Ji),u=d.flags,u&65536?(d.flags=u&-65537|128,d):null;case 24:return io(Mn),null;case 25:return null;default:return null}}function Hk(u,d){switch(Yc(d),d.tag){case 3:io(Mn),Ct();break;case 26:case 27:case 5:Gt(d);break;case 4:Ct();break;case 13:Ra(d);break;case 19:Ve(Ln);break;case 10:io(d.type);break;case 22:case 23:Ra(d),rp(),u!==null&&Ve(Ji);break;case 24:io(Mn)}}var UW={getCacheForType:function(u){var d=Ms(Mn),m=d.data.get(u);return m===void 0&&(m=u(),d.data.set(u,m)),m}},WW=typeof WeakMap=="function"?WeakMap:Map,Sn=0,un=null,At=null,Vt=0,cn=0,Pr=null,ho=!1,ud=!1,fw=!1,po=0,In=0,fl=0,Ou=0,mw=0,la=0,cd=0,xp=null,gi=null,gw=!1,yw=0,ty=1/0,ny=null,ml=null,sy=!1,zu=null,wp=0,bw=0,xw=null,vp=0,ww=null;function Vr(){if((Sn&2)!==0&&Vt!==0)return Vt&-Vt;if(z.T!==null){var u=nl;return u!==0?u:Nw()}return xh()}function qk(){la===0&&(la=(Vt&536870912)===0||Mt?Fc():536870912);var u=yr.current;return u!==null&&(u.flags|=32),la}function tr(u,d,m){(u===un&&cn===2||u.cancelPendingCommit!==null)&&(dd(u,0),fo(u,Vt,la,!1)),nu(u,m),((Sn&2)===0||u!==un)&&(u===un&&((Sn&2)===0&&(Ou|=m),In===4&&fo(u,Vt,la,!1)),yi(u))}function jk(u,d,m){if((Sn&6)!==0)throw Error(s(327));var b=!m&&(d&60)===0&&(d&u.expiredLanes)===0||Bi(u,d),_=b?qW(u,d):_w(u,d,!0),N=b;do{if(_===0){ud&&!b&&fo(u,d,0,!1);break}else if(_===6)fo(u,d,0,!ho);else{if(m=u.current.alternate,N&&!GW(m)){_=_w(u,d,!1),N=!1;continue}if(_===2){if(N=d,u.errorRecoveryDisabledLanes&N)var M=0;else M=u.pendingLanes&-536870913,M=M!==0?M:M&536870912?536870912:0;if(M!==0){d=M;e:{var H=u;_=xp;var Z=H.current.memoizedState.isDehydrated;if(Z&&(dd(H,M).flags|=256),M=_w(H,M,!1),M!==2){if(fw&&!Z){H.errorRecoveryDisabledLanes|=N,Ou|=N,_=4;break e}N=gi,gi=_,N!==null&&vw(N)}_=M}if(N=!1,_!==2)continue}}if(_===1){dd(u,0),fo(u,d,0,!0);break}e:{switch(b=u,_){case 0:case 1:throw Error(s(345));case 4:if((d&4194176)===d){fo(b,d,la,!ho);break e}break;case 2:gi=null;break;case 3:case 5:break;default:throw Error(s(329))}if(b.finishedWork=m,b.finishedLanes=d,(d&62914560)===d&&(N=yw+300-ln(),10<N)){if(fo(b,d,la,!ho),zc(b,0)!==0)break e;b.timeoutHandle=yN(Kk.bind(null,b,m,gi,ny,gw,d,la,Ou,cd,ho,2,-0,0),N);break e}Kk(b,m,gi,ny,gw,d,la,Ou,cd,ho,0,-0,0)}}break}while(!0);yi(u)}function vw(u){gi===null?gi=u:gi.push.apply(gi,u)}function Kk(u,d,m,b,_,N,M,H,Z,he,Ne,Oe,xe){var ke=d.subtreeFlags;if((ke&8192||(ke&16785408)===16785408)&&(kp={stylesheets:null,count:0,unsuspend:CG},Mk(d),d=kG(),d!==null)){u.cancelPendingCommit=d(tN.bind(null,u,m,b,_,M,H,Z,1,Oe,xe)),fo(u,N,M,!he);return}tN(u,m,b,_,M,H,Z,Ne,Oe,xe)}function GW(u){for(var d=u;;){var m=d.tag;if((m===0||m===11||m===15)&&d.flags&16384&&(m=d.updateQueue,m!==null&&(m=m.stores,m!==null)))for(var b=0;b<m.length;b++){var _=m[b],N=_.getSnapshot;_=_.value;try{if(!Ys(N(),_))return!1}catch{return!1}}if(m=d.child,d.subtreeFlags&16384&&m!==null)m.return=d,d=m;else{if(d===u)break;for(;d.sibling===null;){if(d.return===null||d.return===u)return!0;d=d.return}d.sibling.return=d.return,d=d.sibling}}return!0}function fo(u,d,m,b){d&=~mw,d&=~Ou,u.suspendedLanes|=d,u.pingedLanes&=~d,b&&(u.warmLanes|=d),b=u.expirationTimes;for(var _=d;0<_;){var N=31-zs(_),M=1<<N;b[N]=-1,_&=~M}m!==0&&eg(u,m,d)}function ry(){return(Sn&6)===0?($p(0),!1):!0}function $w(){if(At!==null){if(cn===0)var u=At.return;else u=At,ao=Eu=null,Re(u),Zi=null,Jo=0,u=At;for(;u!==null;)Hk(u.alternate,u),u=u.return;At=null}}function dd(u,d){u.finishedWork=null,u.finishedLanes=0;var m=u.timeoutHandle;m!==-1&&(u.timeoutHandle=-1,uG(m)),m=u.cancelPendingCommit,m!==null&&(u.cancelPendingCommit=null,m()),$w(),un=u,At=m=pl(u.current,null),Vt=d,cn=0,Pr=null,ho=!1,ud=Bi(u,d),fw=!1,cd=la=mw=Ou=fl=In=0,gi=xp=null,gw=!1,(d&8)!==0&&(d|=d&32);var b=u.entangledLanes;if(b!==0)for(u=u.entanglements,b&=d;0<b;){var _=31-zs(b),N=1<<_;d|=u[_],b&=~N}return po=d,yu(),m}function Xk(u,d){wt=null,z.H=mi,d===Zo?(d=np(),cn=3):d===Jh?(d=np(),cn=4):cn=d===lk?8:d!==null&&typeof d=="object"&&typeof d.then=="function"?6:1,Pr=d,At===null&&(In=1,Kg(u,Qs(d,u.current)))}function Yk(){var u=z.H;return z.H=mi,u===null?mi:u}function Zk(){var u=z.A;return z.A=UW,u}function Sw(){In=4,ho||(Vt&4194176)!==Vt&&yr.current!==null||(ud=!0),(fl&134217727)===0&&(Ou&134217727)===0||un===null||fo(un,Vt,la,!1)}function _w(u,d,m){var b=Sn;Sn|=2;var _=Yk(),N=Zk();(un!==u||Vt!==d)&&(ny=null,dd(u,d)),d=!1;var M=In;e:do try{if(cn!==0&&At!==null){var H=At,Z=Pr;switch(cn){case 8:$w(),M=6;break e;case 3:case 2:case 6:yr.current===null&&(d=!0);var he=cn;if(cn=0,Pr=null,hd(u,H,Z,he),m&&ud){M=0;break e}break;default:he=cn,cn=0,Pr=null,hd(u,H,Z,he)}}HW(),M=In;break}catch(Ne){Xk(u,Ne)}while(!0);return d&&u.shellSuspendCounter++,ao=Eu=null,Sn=b,z.H=_,z.A=N,At===null&&(un=null,Vt=0,yu()),M}function HW(){for(;At!==null;)Qk(At)}function qW(u,d){var m=Sn;Sn|=2;var b=Yk(),_=Zk();un!==u||Vt!==d?(ny=null,ty=ln()+500,dd(u,d)):ud=Bi(u,d);e:do try{if(cn!==0&&At!==null){d=At;var N=Pr;t:switch(cn){case 1:cn=0,Pr=null,hd(u,d,N,1);break;case 2:if(ep(N)){cn=0,Pr=null,Jk(d);break}d=function(){cn===2&&un===u&&(cn=7),yi(u)},N.then(d,d);break e;case 3:cn=7;break e;case 4:cn=5;break e;case 7:ep(N)?(cn=0,Pr=null,Jk(d)):(cn=0,Pr=null,hd(u,d,N,7));break;case 5:var M=null;switch(At.tag){case 26:M=At.memoizedState;case 5:case 27:var H=At;if(!M||NN(M)){cn=0,Pr=null;var Z=H.sibling;if(Z!==null)At=Z;else{var he=H.return;he!==null?(At=he,ay(he)):At=null}break t}}cn=0,Pr=null,hd(u,d,N,5);break;case 6:cn=0,Pr=null,hd(u,d,N,6);break;case 8:$w(),In=6;break e;default:throw Error(s(462))}}jW();break}catch(Ne){Xk(u,Ne)}while(!0);return ao=Eu=null,z.H=b,z.A=_,Sn=m,At!==null?0:(un=null,Vt=0,yu(),In)}function jW(){for(;At!==null&&!Jn();)Qk(At)}function Qk(u){var d=wk(u.alternate,u,po);u.memoizedProps=u.pendingProps,d===null?ay(u):At=d}function Jk(u){var d=u,m=d.alternate;switch(d.tag){case 15:case 0:d=fk(m,d,d.pendingProps,d.type,void 0,Vt);break;case 11:d=fk(m,d,d.pendingProps,d.type.render,d.ref,Vt);break;case 5:Re(d);default:Hk(m,d),d=At=Uk(d,po),d=wk(m,d,po)}u.memoizedProps=u.pendingProps,d===null?ay(u):At=d}function hd(u,d,m,b){ao=Eu=null,Re(d),Zi=null,Jo=0;var _=d.return;try{if(zW(u,_,d,m,Vt)){In=1,Kg(u,Qs(m,u.current)),At=null;return}}catch(N){if(_!==null)throw At=_,N;In=1,Kg(u,Qs(m,u.current)),At=null;return}d.flags&32768?(Mt||b===1?u=!0:ud||(Vt&536870912)!==0?u=!1:(ho=u=!0,(b===2||b===3||b===6)&&(b=yr.current,b!==null&&b.tag===13&&(b.flags|=16384))),eN(d,u)):ay(d)}function ay(u){var d=u;do{if((d.flags&32768)!==0){eN(d,ho);return}u=d.return;var m=PW(d.alternate,d,po);if(m!==null){At=m;return}if(d=d.sibling,d!==null){At=d;return}At=d=u}while(d!==null);In===0&&(In=5)}function eN(u,d){do{var m=VW(u.alternate,u);if(m!==null){m.flags&=32767,At=m;return}if(m=u.return,m!==null&&(m.flags|=32768,m.subtreeFlags=0,m.deletions=null),!d&&(u=u.sibling,u!==null)){At=u;return}At=u=m}while(u!==null);In=6,At=null}function tN(u,d,m,b,_,N,M,H,Z,he){var Ne=z.T,Oe=pe.p;try{pe.p=2,z.T=null,KW(u,d,m,b,Oe,_,N,M,H,Z,he)}finally{z.T=Ne,pe.p=Oe}}function KW(u,d,m,b,_,N,M,H){do pd();while(zu!==null);if((Sn&6)!==0)throw Error(s(327));var Z=u.finishedWork;if(b=u.finishedLanes,Z===null)return null;if(u.finishedWork=null,u.finishedLanes=0,Z===u.current)throw Error(s(177));u.callbackNode=null,u.callbackPriority=0,u.cancelPendingCommit=null;var he=Z.lanes|Z.childLanes;if(he|=gu,Jx(u,b,he,N,M,H),u===un&&(At=un=null,Vt=0),(Z.subtreeFlags&10256)===0&&(Z.flags&10256)===0||sy||(sy=!0,bw=he,xw=m,QW(_s,function(){return pd(),null})),m=(Z.flags&15990)!==0,(Z.subtreeFlags&15990)!==0||m?(m=z.T,z.T=null,N=pe.p,pe.p=2,M=Sn,Sn|=4,LW(u,Z),zk(Z,u),Dg(Fw,u.containerInfo),yy=!!zw,Fw=zw=null,u.current=Z,Ak(u,Z.alternate,Z),Qr(),Sn=M,pe.p=N,z.T=m):u.current=Z,sy?(sy=!1,zu=u,wp=b):nN(u,he),he=u.pendingLanes,he===0&&(ml=null),Dc(Z.stateNode),yi(u),d!==null)for(_=u.onRecoverableError,Z=0;Z<d.length;Z++)he=d[Z],_(he.value,{componentStack:he.stack});return(wp&3)!==0&&pd(),he=u.pendingLanes,(b&4194218)!==0&&(he&42)!==0?u===ww?vp++:(vp=0,ww=u):vp=0,$p(0),null}function nN(u,d){(u.pooledCacheLanes&=d)===0&&(d=u.pooledCache,d!=null&&(u.pooledCache=null,_u(d)))}function pd(){if(zu!==null){var u=zu,d=bw;bw=0;var m=bh(wp),b=z.T,_=pe.p;try{if(pe.p=32>m?32:m,z.T=null,zu===null)var N=!1;else{m=xw,xw=null;var M=zu,H=wp;if(zu=null,wp=0,(Sn&6)!==0)throw Error(s(331));var Z=Sn;if(Sn|=4,Pk(M.current),Lk(M,M.current,H,m),Sn=Z,$p(0,!1),vn&&typeof vn.onPostCommitFiberRoot=="function")try{vn.onPostCommitFiberRoot(Rr,M)}catch{}N=!0}return N}finally{pe.p=_,z.T=b,nN(u,d)}}return!1}function sN(u,d,m){d=Qs(m,d),d=U1(u.stateNode,d,2),u=ul(u,d,2),u!==null&&(nu(u,2),yi(u))}function rn(u,d,m){if(u.tag===3)sN(u,u,m);else for(;d!==null;){if(d.tag===3){sN(d,u,m);break}else if(d.tag===1){var b=d.stateNode;if(typeof d.type.getDerivedStateFromError=="function"||typeof b.componentDidCatch=="function"&&(ml===null||!ml.has(b))){u=Qs(m,u),m=ik(2),b=ul(d,m,2),b!==null&&(ok(m,b,d,u),nu(b,2),yi(b));break}}d=d.return}}function Cw(u,d,m){var b=u.pingCache;if(b===null){b=u.pingCache=new WW;var _=new Set;b.set(d,_)}else _=b.get(d),_===void 0&&(_=new Set,b.set(d,_));_.has(m)||(fw=!0,_.add(m),u=XW.bind(null,u,d,m),d.then(u,u))}function XW(u,d,m){var b=u.pingCache;b!==null&&b.delete(d),u.pingedLanes|=u.suspendedLanes&m,u.warmLanes&=~m,un===u&&(Vt&m)===m&&(In===4||In===3&&(Vt&62914560)===Vt&&300>ln()-yw?(Sn&2)===0&&dd(u,0):mw|=m,cd===Vt&&(cd=0)),yi(u)}function rN(u,d){d===0&&(d=Jm()),u=Aa(u,d),u!==null&&(nu(u,d),yi(u))}function YW(u){var d=u.memoizedState,m=0;d!==null&&(m=d.retryLane),rN(u,m)}function ZW(u,d){var m=0;switch(u.tag){case 13:var b=u.stateNode,_=u.memoizedState;_!==null&&(m=_.retryLane);break;case 19:b=u.stateNode;break;case 22:b=u.stateNode._retryCache;break;default:throw Error(s(314))}b!==null&&b.delete(d),rN(u,m)}function QW(u,d){return mn(u,d)}var iy=null,fd=null,Tw=!1,oy=!1,kw=!1,Fu=0;function yi(u){u!==fd&&u.next===null&&(fd===null?iy=fd=u:fd=fd.next=u),oy=!0,Tw||(Tw=!0,eG(JW))}function $p(u,d){if(!kw&&oy){kw=!0;do for(var m=!1,b=iy;b!==null;){if(u!==0){var _=b.pendingLanes;if(_===0)var N=0;else{var M=b.suspendedLanes,H=b.pingedLanes;N=(1<<31-zs(42|u)+1)-1,N&=_&~(M&~H),N=N&201326677?N&201326677|1:N?N|2:0}N!==0&&(m=!0,oN(b,N))}else N=Vt,N=zc(b,b===un?N:0),(N&3)===0||Bi(b,N)||(m=!0,oN(b,N));b=b.next}while(m);kw=!1}}function JW(){oy=Tw=!1;var u=0;Fu!==0&&(lG()&&(u=Fu),Fu=0);for(var d=ln(),m=null,b=iy;b!==null;){var _=b.next,N=aN(b,d);N===0?(b.next=null,m===null?iy=_:m.next=_,_===null&&(fd=m)):(m=b,(u!==0||(N&3)!==0)&&(oy=!0)),b=_}$p(u)}function aN(u,d){for(var m=u.suspendedLanes,b=u.pingedLanes,_=u.expirationTimes,N=u.pendingLanes&-62914561;0<N;){var M=31-zs(N),H=1<<M,Z=_[M];Z===-1?((H&m)===0||(H&b)!==0)&&(_[M]=Qx(H,d)):Z<=d&&(u.expiredLanes|=H),N&=~H}if(d=un,m=Vt,m=zc(u,u===d?m:0),b=u.callbackNode,m===0||u===d&&cn===2||u.cancelPendingCommit!==null)return b!==null&&b!==null&&ur(b),u.callbackNode=null,u.callbackPriority=0;if((m&3)===0||Bi(u,m)){if(d=m&-m,d===u.callbackPriority)return d;switch(b!==null&&ur(b),bh(m)){case 2:case 8:m=Et;break;case 32:m=_s;break;case 268435456:m=ni;break;default:m=_s}return b=iN.bind(null,u),m=mn(m,b),u.callbackPriority=d,u.callbackNode=m,d}return b!==null&&b!==null&&ur(b),u.callbackPriority=2,u.callbackNode=null,2}function iN(u,d){var m=u.callbackNode;if(pd()&&u.callbackNode!==m)return null;var b=Vt;return b=zc(u,u===un?b:0),b===0?null:(jk(u,b,d),aN(u,ln()),u.callbackNode!=null&&u.callbackNode===m?iN.bind(null,u):null)}function oN(u,d){if(pd())return null;jk(u,d,!0)}function eG(u){cG(function(){(Sn&6)!==0?mn(Pn,u):u()})}function Nw(){return Fu===0&&(Fu=Fc()),Fu}function lN(u){return u==null||typeof u=="symbol"||typeof u=="boolean"?null:typeof u=="function"?u:Pc(""+u)}function uN(u,d){var m=d.ownerDocument.createElement("input");return m.name=d.name,m.value=d.value,u.id&&m.setAttribute("form",u.id),d.parentNode.insertBefore(m,d),u=new FormData(u),m.parentNode.removeChild(m),u}function tG(u,d,m,b,_){if(d==="submit"&&m&&m.stateNode===_){var N=lN((_[Cs]||null).action),M=b.submitter;M&&(d=(d=M[Cs]||null)?lN(d.formAction):M.getAttribute("formAction"),d!==null&&(N=d,M=null));var H=new ou("action","action",null,b,_);u.push({event:H,listeners:[{instance:null,listener:function(){if(b.defaultPrevented){if(Fu!==0){var Z=M?uN(_,M):new FormData(_);L1(m,{pending:!0,data:Z,method:_.method,action:N},null,Z)}}else typeof N=="function"&&(H.preventDefault(),Z=M?uN(_,M):new FormData(_),L1(m,{pending:!0,data:Z,method:_.method,action:N},N,Z))},currentTarget:_}]})}}for(var Iw=0;Iw<jh.length;Iw++){var Ew=jh[Iw],nG=Ew.toLowerCase(),sG=Ew[0].toUpperCase()+Ew.slice(1);mr(nG,"on"+sG)}mr(lt,"onAnimationEnd"),mr(jo,"onAnimationIteration"),mr(Wh,"onAnimationStart"),mr("dblclick","onDoubleClick"),mr("focusin","onFocus"),mr("focusout","onBlur"),mr(ot,"onTransitionRun"),mr(Gh,"onTransitionStart"),mr(ut,"onTransitionCancel"),mr(Hh,"onTransitionEnd"),Mo("onMouseEnter",["mouseout","mouseover"]),Mo("onMouseLeave",["mouseout","mouseover"]),Mo("onPointerEnter",["pointerout","pointerover"]),Mo("onPointerLeave",["pointerout","pointerover"]),Fs("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),Fs("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),Fs("onBeforeInput",["compositionend","keypress","textInput","paste"]),Fs("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),Fs("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),Fs("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Sp="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),rG=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Sp));function cN(u,d){d=(d&4)!==0;for(var m=0;m<u.length;m++){var b=u[m],_=b.event;b=b.listeners;e:{var N=void 0;if(d)for(var M=b.length-1;0<=M;M--){var H=b[M],Z=H.instance,he=H.currentTarget;if(H=H.listener,Z!==N&&_.isPropagationStopped())break e;N=H,_.currentTarget=he;try{N(_)}catch(Ne){jg(Ne)}_.currentTarget=null,N=Z}else for(M=0;M<b.length;M++){if(H=b[M],Z=H.instance,he=H.currentTarget,H=H.listener,Z!==N&&_.isPropagationStopped())break e;N=H,_.currentTarget=he;try{N(_)}catch(Ne){jg(Ne)}_.currentTarget=null,N=Z}}}}function Bt(u,d){var m=d[si];m===void 0&&(m=d[si]=new Set);var b=u+"__bubble";m.has(b)||(dN(d,u,2,!1),m.add(b))}function Aw(u,d,m){var b=0;d&&(b|=4),dN(m,u,b,d)}var ly="_reactListening"+Math.random().toString(36).slice(2);function Rw(u){if(!u[ly]){u[ly]=!0,vh.forEach(function(m){m!=="selectionchange"&&(rG.has(m)||Aw(m,!1,u),Aw(m,!0,u))});var d=u.nodeType===9?u:u.ownerDocument;d===null||d[ly]||(d[ly]=!0,Aw("selectionchange",!1,d))}}function dN(u,d,m,b){switch(ON(d)){case 2:var _=EG;break;case 8:_=AG;break;default:_=Hw}m=_.bind(null,d,m,u),_=void 0,!Eh||d!=="touchstart"&&d!=="touchmove"&&d!=="wheel"||(_=!0),b?_!==void 0?u.addEventListener(d,m,{capture:!0,passive:_}):u.addEventListener(d,m,!0):_!==void 0?u.addEventListener(d,m,{passive:_}):u.addEventListener(d,m,!1)}function Dw(u,d,m,b,_){var N=b;if((d&1)===0&&(d&2)===0&&b!==null)e:for(;;){if(b===null)return;var M=b.tag;if(M===3||M===4){var H=b.stateNode.containerInfo;if(H===_||H.nodeType===8&&H.parentNode===_)break;if(M===4)for(M=b.return;M!==null;){var Z=M.tag;if((Z===3||Z===4)&&(Z=M.stateNode.containerInfo,Z===_||Z.nodeType===8&&Z.parentNode===_))return;M=M.return}for(;H!==null;){if(M=ri(H),M===null)return;if(Z=M.tag,Z===5||Z===6||Z===26||Z===27){b=N=M;continue e}H=H.parentNode}}b=b.return}cg(function(){var he=N,Ne=su(m),Oe=[];e:{var xe=qh.get(u);if(xe!==void 0){var ke=ou,tt=u;switch(u){case"keypress":if(Wi(m)===0)break e;case"keydown":case"keyup":ke=m1;break;case"focusin":tt="focus",ke=Rh;break;case"focusout":tt="blur",ke=Rh;break;case"beforeblur":case"afterblur":ke=Rh;break;case"click":if(m.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":ke=uu;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":ke=i1;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":ke=b1;break;case lt:case jo:case Wh:ke=o1;break;case Hh:ke=yg;break;case"scroll":case"scrollend":ke=r1;break;case"wheel":ke=x1;break;case"copy":case"cut":case"paste":ke=u1;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":ke=mg;break;case"toggle":case"beforetoggle":ke=xg}var gt=(d&4)!==0,En=!gt&&(u==="scroll"||u==="scrollend"),fe=gt?xe!==null?xe+"Capture":null:xe;gt=[];for(var de=he,be;de!==null;){var Ee=de;if(be=Ee.stateNode,Ee=Ee.tag,Ee!==5&&Ee!==26&&Ee!==27||be===null||fe===null||(Ee=au(de,fe),Ee!=null&&gt.push(_p(de,Ee,be))),En)break;de=de.return}0<gt.length&&(xe=new ke(xe,tt,null,m,Ne),Oe.push({event:xe,listeners:gt}))}}if((d&7)===0){e:{if(xe=u==="mouseover"||u==="pointerover",ke=u==="mouseout"||u==="pointerout",xe&&m!==Ih&&(tt=m.relatedTarget||m.fromElement)&&(ri(tt)||tt[Pi]))break e;if((ke||xe)&&(xe=Ne.window===Ne?Ne:(xe=Ne.ownerDocument)?xe.defaultView||xe.parentWindow:window,ke?(tt=m.relatedTarget||m.toElement,ke=he,tt=tt?ri(tt):null,tt!==null&&(En=se(tt),gt=tt.tag,tt!==En||gt!==5&&gt!==27&&gt!==6)&&(tt=null)):(ke=null,tt=he),ke!==tt)){if(gt=uu,Ee="onMouseLeave",fe="onMouseEnter",de="mouse",(u==="pointerout"||u==="pointerover")&&(gt=mg,Ee="onPointerLeave",fe="onPointerEnter",de="pointer"),En=ke==null?xe:Lo(ke),be=tt==null?xe:Lo(tt),xe=new gt(Ee,de+"leave",ke,m,Ne),xe.target=En,xe.relatedTarget=be,Ee=null,ri(Ne)===he&&(gt=new gt(fe,de+"enter",tt,m,Ne),gt.target=be,gt.relatedTarget=En,Ee=gt),En=Ee,ke&&tt)t:{for(gt=ke,fe=tt,de=0,be=gt;be;be=md(be))de++;for(be=0,Ee=fe;Ee;Ee=md(Ee))be++;for(;0<de-be;)gt=md(gt),de--;for(;0<be-de;)fe=md(fe),be--;for(;de--;){if(gt===fe||fe!==null&&gt===fe.alternate)break t;gt=md(gt),fe=md(fe)}gt=null}else gt=null;ke!==null&&hN(Oe,xe,ke,gt,!1),tt!==null&&En!==null&&hN(Oe,En,tt,gt,!0)}}e:{if(xe=he?Lo(he):window,ke=xe.nodeName&&xe.nodeName.toLowerCase(),ke==="select"||ke==="input"&&xe.type==="file")var Ze=Ho;else if(Cg(xe))if(zh)Ze=Eg;else{Ze=Ng;var It=kg}else ke=xe.nodeName,!ke||ke.toLowerCase()!=="input"||xe.type!=="checkbox"&&xe.type!=="radio"?he&&Nh(he.elementType)&&(Ze=Ho):Ze=Ig;if(Ze&&(Ze=Ze(u,he))){Tg(Oe,Ze,m,Ne);break e}It&&It(u,xe,he),u==="focusout"&&he&&xe.type==="number"&&he.memoizedProps.value!=null&&Th(xe,"number",xe.value)}switch(It=he?Lo(he):window,u){case"focusin":(Cg(It)||It.contentEditable==="true")&&(Ea=It,fr=he,ii=null);break;case"focusout":ii=fr=Ea=null;break;case"mousedown":fu=!0;break;case"contextmenu":case"mouseup":case"dragend":fu=!1,Vh(Oe,m,Ne);break;case"selectionchange":if(Og)break;case"keydown":case"keyup":Vh(Oe,m,Ne)}var rt;if(Gi)e:{switch(u){case"compositionstart":var ct="onCompositionStart";break e;case"compositionend":ct="onCompositionEnd";break e;case"compositionupdate":ct="onCompositionUpdate";break e}ct=void 0}else Go?Hc(u,m)&&(ct="onCompositionEnd"):u==="keydown"&&m.keyCode===229&&(ct="onCompositionStart");ct&&($g&&m.locale!=="ko"&&(Go||ct!=="onCompositionStart"?ct==="onCompositionEnd"&&Go&&(rt=dg()):(Or=Ne,Vc="value"in Or?Or.value:Or.textContent,Go=!0)),It=uy(he,ct),0<It.length&&(ct=new fg(ct,u,null,m,Ne),Oe.push({event:ct,listeners:It}),rt?ct.data=rt:(rt=Oh(m),rt!==null&&(ct.data=rt)))),(rt=vg?v1(u,m):$1(u,m))&&(ct=uy(he,"onBeforeInput"),0<ct.length&&(It=new fg("onBeforeInput","beforeinput",null,m,Ne),Oe.push({event:It,listeners:ct}),It.data=rt)),tG(Oe,u,he,m,Ne)}cN(Oe,d)})}function _p(u,d,m){return{instance:u,listener:d,currentTarget:m}}function uy(u,d){for(var m=d+"Capture",b=[];u!==null;){var _=u,N=_.stateNode;_=_.tag,_!==5&&_!==26&&_!==27||N===null||(_=au(u,m),_!=null&&b.unshift(_p(u,_,N)),_=au(u,d),_!=null&&b.push(_p(u,_,N))),u=u.return}return b}function md(u){if(u===null)return null;do u=u.return;while(u&&u.tag!==5&&u.tag!==27);return u||null}function hN(u,d,m,b,_){for(var N=d._reactName,M=[];m!==null&&m!==b;){var H=m,Z=H.alternate,he=H.stateNode;if(H=H.tag,Z!==null&&Z===b)break;H!==5&&H!==26&&H!==27||he===null||(Z=he,_?(he=au(m,N),he!=null&&M.unshift(_p(m,he,Z))):_||(he=au(m,N),he!=null&&M.push(_p(m,he,Z)))),m=m.return}M.length!==0&&u.push({event:d,listeners:M})}var aG=/\r\n?/g,iG=/\u0000|\uFFFD/g;function pN(u){return(typeof u=="string"?u:""+u).replace(aG,`
`).replace(iG,"")}function fN(u,d){return d=pN(d),pN(u)===d}function cy(){}function tn(u,d,m,b,_,N){switch(m){case"children":typeof b=="string"?d==="body"||d==="textarea"&&b===""||Vo(u,b):(typeof b=="number"||typeof b=="bigint")&&d!=="body"&&Vo(u,""+b);break;case"className":Dr(u,"class",b);break;case"tabIndex":Dr(u,"tabindex",b);break;case"dir":case"role":case"viewBox":case"width":case"height":Dr(u,m,b);break;case"style":lg(u,b,N);break;case"data":if(d!=="object"){Dr(u,"data",b);break}case"src":case"href":if(b===""&&(d!=="a"||m!=="href")){u.removeAttribute(m);break}if(b==null||typeof b=="function"||typeof b=="symbol"||typeof b=="boolean"){u.removeAttribute(m);break}b=Pc(""+b),u.setAttribute(m,b);break;case"action":case"formAction":if(typeof b=="function"){u.setAttribute(m,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof N=="function"&&(m==="formAction"?(d!=="input"&&tn(u,d,"name",_.name,_,null),tn(u,d,"formEncType",_.formEncType,_,null),tn(u,d,"formMethod",_.formMethod,_,null),tn(u,d,"formTarget",_.formTarget,_,null)):(tn(u,d,"encType",_.encType,_,null),tn(u,d,"method",_.method,_,null),tn(u,d,"target",_.target,_,null)));if(b==null||typeof b=="symbol"||typeof b=="boolean"){u.removeAttribute(m);break}b=Pc(""+b),u.setAttribute(m,b);break;case"onClick":b!=null&&(u.onclick=cy);break;case"onScroll":b!=null&&Bt("scroll",u);break;case"onScrollEnd":b!=null&&Bt("scrollend",u);break;case"dangerouslySetInnerHTML":if(b!=null){if(typeof b!="object"||!("__html"in b))throw Error(s(61));if(m=b.__html,m!=null){if(_.children!=null)throw Error(s(60));u.innerHTML=m}}break;case"multiple":u.multiple=b&&typeof b!="function"&&typeof b!="symbol";break;case"muted":u.muted=b&&typeof b!="function"&&typeof b!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(b==null||typeof b=="function"||typeof b=="boolean"||typeof b=="symbol"){u.removeAttribute("xlink:href");break}m=Pc(""+b),u.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",m);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":b!=null&&typeof b!="function"&&typeof b!="symbol"?u.setAttribute(m,""+b):u.removeAttribute(m);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":b&&typeof b!="function"&&typeof b!="symbol"?u.setAttribute(m,""):u.removeAttribute(m);break;case"capture":case"download":b===!0?u.setAttribute(m,""):b!==!1&&b!=null&&typeof b!="function"&&typeof b!="symbol"?u.setAttribute(m,b):u.removeAttribute(m);break;case"cols":case"rows":case"size":case"span":b!=null&&typeof b!="function"&&typeof b!="symbol"&&!isNaN(b)&&1<=b?u.setAttribute(m,b):u.removeAttribute(m);break;case"rowSpan":case"start":b==null||typeof b=="function"||typeof b=="symbol"||isNaN(b)?u.removeAttribute(m):u.setAttribute(m,b);break;case"popover":Bt("beforetoggle",u),Bt("toggle",u),Bc(u,"popover",b);break;case"xlinkActuate":Na(u,"http://www.w3.org/1999/xlink","xlink:actuate",b);break;case"xlinkArcrole":Na(u,"http://www.w3.org/1999/xlink","xlink:arcrole",b);break;case"xlinkRole":Na(u,"http://www.w3.org/1999/xlink","xlink:role",b);break;case"xlinkShow":Na(u,"http://www.w3.org/1999/xlink","xlink:show",b);break;case"xlinkTitle":Na(u,"http://www.w3.org/1999/xlink","xlink:title",b);break;case"xlinkType":Na(u,"http://www.w3.org/1999/xlink","xlink:type",b);break;case"xmlBase":Na(u,"http://www.w3.org/XML/1998/namespace","xml:base",b);break;case"xmlLang":Na(u,"http://www.w3.org/XML/1998/namespace","xml:lang",b);break;case"xmlSpace":Na(u,"http://www.w3.org/XML/1998/namespace","xml:space",b);break;case"is":Bc(u,"is",b);break;case"innerText":case"textContent":break;default:(!(2<m.length)||m[0]!=="o"&&m[0]!=="O"||m[1]!=="n"&&m[1]!=="N")&&(m=n1.get(m)||m,Bc(u,m,b))}}function Ow(u,d,m,b,_,N){switch(m){case"style":lg(u,b,N);break;case"dangerouslySetInnerHTML":if(b!=null){if(typeof b!="object"||!("__html"in b))throw Error(s(61));if(m=b.__html,m!=null){if(_.children!=null)throw Error(s(60));u.innerHTML=m}}break;case"children":typeof b=="string"?Vo(u,b):(typeof b=="number"||typeof b=="bigint")&&Vo(u,""+b);break;case"onScroll":b!=null&&Bt("scroll",u);break;case"onScrollEnd":b!=null&&Bt("scrollend",u);break;case"onClick":b!=null&&(u.onclick=cy);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!$h.hasOwnProperty(m))e:{if(m[0]==="o"&&m[1]==="n"&&(_=m.endsWith("Capture"),d=m.slice(2,_?m.length-7:void 0),N=u[Cs]||null,N=N!=null?N[m]:null,typeof N=="function"&&u.removeEventListener(d,N,_),typeof b=="function")){typeof N!="function"&&N!==null&&(m in u?u[m]=null:u.hasAttribute(m)&&u.removeAttribute(m)),u.addEventListener(d,b,_);break e}m in u?u[m]=b:b===!0?u.setAttribute(m,""):Bc(u,m,b)}}}function Is(u,d,m){switch(d){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":Bt("error",u),Bt("load",u);var b=!1,_=!1,N;for(N in m)if(m.hasOwnProperty(N)){var M=m[N];if(M!=null)switch(N){case"src":b=!0;break;case"srcSet":_=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(s(137,d));default:tn(u,d,N,M,m,null)}}_&&tn(u,d,"srcSet",m.srcSet,m,null),b&&tn(u,d,"src",m.src,m,null);return;case"input":Bt("invalid",u);var H=N=M=_=null,Z=null,he=null;for(b in m)if(m.hasOwnProperty(b)){var Ne=m[b];if(Ne!=null)switch(b){case"name":_=Ne;break;case"type":M=Ne;break;case"checked":Z=Ne;break;case"defaultChecked":he=Ne;break;case"value":N=Ne;break;case"defaultValue":H=Ne;break;case"children":case"dangerouslySetInnerHTML":if(Ne!=null)throw Error(s(137,d));break;default:tn(u,d,b,Ne,m,null)}}ag(u,N,H,Z,he,M,_,!1),us(u);return;case"select":Bt("invalid",u),b=M=N=null;for(_ in m)if(m.hasOwnProperty(_)&&(H=m[_],H!=null))switch(_){case"value":N=H;break;case"defaultValue":M=H;break;case"multiple":b=H;default:tn(u,d,_,H,m,null)}d=N,m=M,u.multiple=!!b,d!=null?Po(u,!!b,d,!1):m!=null&&Po(u,!!b,m,!0);return;case"textarea":Bt("invalid",u),N=_=b=null;for(M in m)if(m.hasOwnProperty(M)&&(H=m[M],H!=null))switch(M){case"value":b=H;break;case"defaultValue":_=H;break;case"children":N=H;break;case"dangerouslySetInnerHTML":if(H!=null)throw Error(s(91));break;default:tn(u,d,M,H,m,null)}kh(u,b,_,N),us(u);return;case"option":for(Z in m)if(m.hasOwnProperty(Z)&&(b=m[Z],b!=null))switch(Z){case"selected":u.selected=b&&typeof b!="function"&&typeof b!="symbol";break;default:tn(u,d,Z,b,m,null)}return;case"dialog":Bt("cancel",u),Bt("close",u);break;case"iframe":case"object":Bt("load",u);break;case"video":case"audio":for(b=0;b<Sp.length;b++)Bt(Sp[b],u);break;case"image":Bt("error",u),Bt("load",u);break;case"details":Bt("toggle",u);break;case"embed":case"source":case"link":Bt("error",u),Bt("load",u);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(he in m)if(m.hasOwnProperty(he)&&(b=m[he],b!=null))switch(he){case"children":case"dangerouslySetInnerHTML":throw Error(s(137,d));default:tn(u,d,he,b,m,null)}return;default:if(Nh(d)){for(Ne in m)m.hasOwnProperty(Ne)&&(b=m[Ne],b!==void 0&&Ow(u,d,Ne,b,m,void 0));return}}for(H in m)m.hasOwnProperty(H)&&(b=m[H],b!=null&&tn(u,d,H,b,m,null))}function oG(u,d,m,b){switch(d){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var _=null,N=null,M=null,H=null,Z=null,he=null,Ne=null;for(ke in m){var Oe=m[ke];if(m.hasOwnProperty(ke)&&Oe!=null)switch(ke){case"checked":break;case"value":break;case"defaultValue":Z=Oe;default:b.hasOwnProperty(ke)||tn(u,d,ke,null,b,Oe)}}for(var xe in b){var ke=b[xe];if(Oe=m[xe],b.hasOwnProperty(xe)&&(ke!=null||Oe!=null))switch(xe){case"type":N=ke;break;case"name":_=ke;break;case"checked":he=ke;break;case"defaultChecked":Ne=ke;break;case"value":M=ke;break;case"defaultValue":H=ke;break;case"children":case"dangerouslySetInnerHTML":if(ke!=null)throw Error(s(137,d));break;default:ke!==Oe&&tn(u,d,xe,ke,b,Oe)}}Ch(u,M,H,Z,he,Ne,N,_);return;case"select":ke=M=H=xe=null;for(N in m)if(Z=m[N],m.hasOwnProperty(N)&&Z!=null)switch(N){case"value":break;case"multiple":ke=Z;default:b.hasOwnProperty(N)||tn(u,d,N,null,b,Z)}for(_ in b)if(N=b[_],Z=m[_],b.hasOwnProperty(_)&&(N!=null||Z!=null))switch(_){case"value":xe=N;break;case"defaultValue":H=N;break;case"multiple":M=N;default:N!==Z&&tn(u,d,_,N,b,Z)}d=H,m=M,b=ke,xe!=null?Po(u,!!m,xe,!1):!!b!=!!m&&(d!=null?Po(u,!!m,d,!0):Po(u,!!m,m?[]:"",!1));return;case"textarea":ke=xe=null;for(H in m)if(_=m[H],m.hasOwnProperty(H)&&_!=null&&!b.hasOwnProperty(H))switch(H){case"value":break;case"children":break;default:tn(u,d,H,null,b,_)}for(M in b)if(_=b[M],N=m[M],b.hasOwnProperty(M)&&(_!=null||N!=null))switch(M){case"value":xe=_;break;case"defaultValue":ke=_;break;case"children":break;case"dangerouslySetInnerHTML":if(_!=null)throw Error(s(91));break;default:_!==N&&tn(u,d,M,_,b,N)}ig(u,xe,ke);return;case"option":for(var tt in m)if(xe=m[tt],m.hasOwnProperty(tt)&&xe!=null&&!b.hasOwnProperty(tt))switch(tt){case"selected":u.selected=!1;break;default:tn(u,d,tt,null,b,xe)}for(Z in b)if(xe=b[Z],ke=m[Z],b.hasOwnProperty(Z)&&xe!==ke&&(xe!=null||ke!=null))switch(Z){case"selected":u.selected=xe&&typeof xe!="function"&&typeof xe!="symbol";break;default:tn(u,d,Z,xe,b,ke)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var gt in m)xe=m[gt],m.hasOwnProperty(gt)&&xe!=null&&!b.hasOwnProperty(gt)&&tn(u,d,gt,null,b,xe);for(he in b)if(xe=b[he],ke=m[he],b.hasOwnProperty(he)&&xe!==ke&&(xe!=null||ke!=null))switch(he){case"children":case"dangerouslySetInnerHTML":if(xe!=null)throw Error(s(137,d));break;default:tn(u,d,he,xe,b,ke)}return;default:if(Nh(d)){for(var En in m)xe=m[En],m.hasOwnProperty(En)&&xe!==void 0&&!b.hasOwnProperty(En)&&Ow(u,d,En,void 0,b,xe);for(Ne in b)xe=b[Ne],ke=m[Ne],!b.hasOwnProperty(Ne)||xe===ke||xe===void 0&&ke===void 0||Ow(u,d,Ne,xe,b,ke);return}}for(var fe in m)xe=m[fe],m.hasOwnProperty(fe)&&xe!=null&&!b.hasOwnProperty(fe)&&tn(u,d,fe,null,b,xe);for(Oe in b)xe=b[Oe],ke=m[Oe],!b.hasOwnProperty(Oe)||xe===ke||xe==null&&ke==null||tn(u,d,Oe,xe,b,ke)}var zw=null,Fw=null;function dy(u){return u.nodeType===9?u:u.ownerDocument}function mN(u){switch(u){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function gN(u,d){if(u===0)switch(d){case"svg":return 1;case"math":return 2;default:return 0}return u===1&&d==="foreignObject"?0:u}function Lw(u,d){return u==="textarea"||u==="noscript"||typeof d.children=="string"||typeof d.children=="number"||typeof d.children=="bigint"||typeof d.dangerouslySetInnerHTML=="object"&&d.dangerouslySetInnerHTML!==null&&d.dangerouslySetInnerHTML.__html!=null}var Mw=null;function lG(){var u=window.event;return u&&u.type==="popstate"?u===Mw?!1:(Mw=u,!0):(Mw=null,!1)}var yN=typeof setTimeout=="function"?setTimeout:void 0,uG=typeof clearTimeout=="function"?clearTimeout:void 0,bN=typeof Promise=="function"?Promise:void 0,cG=typeof queueMicrotask=="function"?queueMicrotask:typeof bN<"u"?function(u){return bN.resolve(null).then(u).catch(dG)}:yN;function dG(u){setTimeout(function(){throw u})}function Bw(u,d){var m=d,b=0;do{var _=m.nextSibling;if(u.removeChild(m),_&&_.nodeType===8)if(m=_.data,m==="/$"){if(b===0){u.removeChild(_),Rp(d);return}b--}else m!=="$"&&m!=="$?"&&m!=="$!"||b++;m=_}while(m);Rp(d)}function Pw(u){var d=u.firstChild;for(d&&d.nodeType===10&&(d=d.nextSibling);d;){var m=d;switch(d=d.nextSibling,m.nodeName){case"HTML":case"HEAD":case"BODY":Pw(m),Lc(m);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(m.rel.toLowerCase()==="stylesheet")continue}u.removeChild(m)}}function hG(u,d,m,b){for(;u.nodeType===1;){var _=m;if(u.nodeName.toLowerCase()!==d.toLowerCase()){if(!b&&(u.nodeName!=="INPUT"||u.type!=="hidden"))break}else if(b){if(!u[Fo])switch(d){case"meta":if(!u.hasAttribute("itemprop"))break;return u;case"link":if(N=u.getAttribute("rel"),N==="stylesheet"&&u.hasAttribute("data-precedence"))break;if(N!==_.rel||u.getAttribute("href")!==(_.href==null?null:_.href)||u.getAttribute("crossorigin")!==(_.crossOrigin==null?null:_.crossOrigin)||u.getAttribute("title")!==(_.title==null?null:_.title))break;return u;case"style":if(u.hasAttribute("data-precedence"))break;return u;case"script":if(N=u.getAttribute("src"),(N!==(_.src==null?null:_.src)||u.getAttribute("type")!==(_.type==null?null:_.type)||u.getAttribute("crossorigin")!==(_.crossOrigin==null?null:_.crossOrigin))&&N&&u.hasAttribute("async")&&!u.hasAttribute("itemprop"))break;return u;default:return u}}else if(d==="input"&&u.type==="hidden"){var N=_.name==null?null:""+_.name;if(_.type==="hidden"&&u.getAttribute("name")===N)return u}else return u;if(u=Oa(u.nextSibling),u===null)break}return null}function pG(u,d,m){if(d==="")return null;for(;u.nodeType!==3;)if((u.nodeType!==1||u.nodeName!=="INPUT"||u.type!=="hidden")&&!m||(u=Oa(u.nextSibling),u===null))return null;return u}function Oa(u){for(;u!=null;u=u.nextSibling){var d=u.nodeType;if(d===1||d===3)break;if(d===8){if(d=u.data,d==="$"||d==="$!"||d==="$?"||d==="F!"||d==="F")break;if(d==="/$")return null}}return u}function xN(u){u=u.previousSibling;for(var d=0;u;){if(u.nodeType===8){var m=u.data;if(m==="$"||m==="$!"||m==="$?"){if(d===0)return u;d--}else m==="/$"&&d++}u=u.previousSibling}return null}function wN(u,d,m){switch(d=dy(m),u){case"html":if(u=d.documentElement,!u)throw Error(s(452));return u;case"head":if(u=d.head,!u)throw Error(s(453));return u;case"body":if(u=d.body,!u)throw Error(s(454));return u;default:throw Error(s(451))}}var ua=new Map,vN=new Set;function hy(u){return typeof u.getRootNode=="function"?u.getRootNode():u.ownerDocument}var mo=pe.d;pe.d={f:fG,r:mG,D:gG,C:yG,L:bG,m:xG,X:vG,S:wG,M:$G};function fG(){var u=mo.f(),d=ry();return u||d}function mG(u){var d=Vi(u);d!==null&&d.tag===5&&d.type==="form"?KT(d):mo.r(u)}var gd=typeof document>"u"?null:document;function $N(u,d,m){var b=gd;if(b&&typeof d=="string"&&d){var _=pr(d);_='link[rel="'+u+'"][href="'+_+'"]',typeof m=="string"&&(_+='[crossorigin="'+m+'"]'),vN.has(_)||(vN.add(_),u={rel:u,crossOrigin:m,href:d},b.querySelector(_)===null&&(d=b.createElement("link"),Is(d,"link",u),Fn(d),b.head.appendChild(d)))}}function gG(u){mo.D(u),$N("dns-prefetch",u,null)}function yG(u,d){mo.C(u,d),$N("preconnect",u,d)}function bG(u,d,m){mo.L(u,d,m);var b=gd;if(b&&u&&d){var _='link[rel="preload"][as="'+pr(d)+'"]';d==="image"&&m&&m.imageSrcSet?(_+='[imagesrcset="'+pr(m.imageSrcSet)+'"]',typeof m.imageSizes=="string"&&(_+='[imagesizes="'+pr(m.imageSizes)+'"]')):_+='[href="'+pr(u)+'"]';var N=_;switch(d){case"style":N=yd(u);break;case"script":N=bd(u)}ua.has(N)||(u=P({rel:"preload",href:d==="image"&&m&&m.imageSrcSet?void 0:u,as:d},m),ua.set(N,u),b.querySelector(_)!==null||d==="style"&&b.querySelector(Cp(N))||d==="script"&&b.querySelector(Tp(N))||(d=b.createElement("link"),Is(d,"link",u),Fn(d),b.head.appendChild(d)))}}function xG(u,d){mo.m(u,d);var m=gd;if(m&&u){var b=d&&typeof d.as=="string"?d.as:"script",_='link[rel="modulepreload"][as="'+pr(b)+'"][href="'+pr(u)+'"]',N=_;switch(b){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":N=bd(u)}if(!ua.has(N)&&(u=P({rel:"modulepreload",href:u},d),ua.set(N,u),m.querySelector(_)===null)){switch(b){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(m.querySelector(Tp(N)))return}b=m.createElement("link"),Is(b,"link",u),Fn(b),m.head.appendChild(b)}}}function wG(u,d,m){mo.S(u,d,m);var b=gd;if(b&&u){var _=Ui(b).hoistableStyles,N=yd(u);d=d||"default";var M=_.get(N);if(!M){var H={loading:0,preload:null};if(M=b.querySelector(Cp(N)))H.loading=5;else{u=P({rel:"stylesheet",href:u,"data-precedence":d},m),(m=ua.get(N))&&Vw(u,m);var Z=M=b.createElement("link");Fn(Z),Is(Z,"link",u),Z._p=new Promise(function(he,Ne){Z.onload=he,Z.onerror=Ne}),Z.addEventListener("load",function(){H.loading|=1}),Z.addEventListener("error",function(){H.loading|=2}),H.loading|=4,py(M,d,b)}M={type:"stylesheet",instance:M,count:1,state:H},_.set(N,M)}}}function vG(u,d){mo.X(u,d);var m=gd;if(m&&u){var b=Ui(m).hoistableScripts,_=bd(u),N=b.get(_);N||(N=m.querySelector(Tp(_)),N||(u=P({src:u,async:!0},d),(d=ua.get(_))&&Uw(u,d),N=m.createElement("script"),Fn(N),Is(N,"link",u),m.head.appendChild(N)),N={type:"script",instance:N,count:1,state:null},b.set(_,N))}}function $G(u,d){mo.M(u,d);var m=gd;if(m&&u){var b=Ui(m).hoistableScripts,_=bd(u),N=b.get(_);N||(N=m.querySelector(Tp(_)),N||(u=P({src:u,async:!0,type:"module"},d),(d=ua.get(_))&&Uw(u,d),N=m.createElement("script"),Fn(N),Is(N,"link",u),m.head.appendChild(N)),N={type:"script",instance:N,count:1,state:null},b.set(_,N))}}function SN(u,d,m,b){var _=(_=yt.current)?hy(_):null;if(!_)throw Error(s(446));switch(u){case"meta":case"title":return null;case"style":return typeof m.precedence=="string"&&typeof m.href=="string"?(d=yd(m.href),m=Ui(_).hoistableStyles,b=m.get(d),b||(b={type:"style",instance:null,count:0,state:null},m.set(d,b)),b):{type:"void",instance:null,count:0,state:null};case"link":if(m.rel==="stylesheet"&&typeof m.href=="string"&&typeof m.precedence=="string"){u=yd(m.href);var N=Ui(_).hoistableStyles,M=N.get(u);if(M||(_=_.ownerDocument||_,M={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},N.set(u,M),(N=_.querySelector(Cp(u)))&&!N._p&&(M.instance=N,M.state.loading=5),ua.has(u)||(m={rel:"preload",as:"style",href:m.href,crossOrigin:m.crossOrigin,integrity:m.integrity,media:m.media,hrefLang:m.hrefLang,referrerPolicy:m.referrerPolicy},ua.set(u,m),N||SG(_,u,m,M.state))),d&&b===null)throw Error(s(528,""));return M}if(d&&b!==null)throw Error(s(529,""));return null;case"script":return d=m.async,m=m.src,typeof m=="string"&&d&&typeof d!="function"&&typeof d!="symbol"?(d=bd(m),m=Ui(_).hoistableScripts,b=m.get(d),b||(b={type:"script",instance:null,count:0,state:null},m.set(d,b)),b):{type:"void",instance:null,count:0,state:null};default:throw Error(s(444,u))}}function yd(u){return'href="'+pr(u)+'"'}function Cp(u){return'link[rel="stylesheet"]['+u+"]"}function _N(u){return P({},u,{"data-precedence":u.precedence,precedence:null})}function SG(u,d,m,b){u.querySelector('link[rel="preload"][as="style"]['+d+"]")?b.loading=1:(d=u.createElement("link"),b.preload=d,d.addEventListener("load",function(){return b.loading|=1}),d.addEventListener("error",function(){return b.loading|=2}),Is(d,"link",m),Fn(d),u.head.appendChild(d))}function bd(u){return'[src="'+pr(u)+'"]'}function Tp(u){return"script[async]"+u}function CN(u,d,m){if(d.count++,d.instance===null)switch(d.type){case"style":var b=u.querySelector('style[data-href~="'+pr(m.href)+'"]');if(b)return d.instance=b,Fn(b),b;var _=P({},m,{"data-href":m.href,"data-precedence":m.precedence,href:null,precedence:null});return b=(u.ownerDocument||u).createElement("style"),Fn(b),Is(b,"style",_),py(b,m.precedence,u),d.instance=b;case"stylesheet":_=yd(m.href);var N=u.querySelector(Cp(_));if(N)return d.state.loading|=4,d.instance=N,Fn(N),N;b=_N(m),(_=ua.get(_))&&Vw(b,_),N=(u.ownerDocument||u).createElement("link"),Fn(N);var M=N;return M._p=new Promise(function(H,Z){M.onload=H,M.onerror=Z}),Is(N,"link",b),d.state.loading|=4,py(N,m.precedence,u),d.instance=N;case"script":return N=bd(m.src),(_=u.querySelector(Tp(N)))?(d.instance=_,Fn(_),_):(b=m,(_=ua.get(N))&&(b=P({},m),Uw(b,_)),u=u.ownerDocument||u,_=u.createElement("script"),Fn(_),Is(_,"link",b),u.head.appendChild(_),d.instance=_);case"void":return null;default:throw Error(s(443,d.type))}else d.type==="stylesheet"&&(d.state.loading&4)===0&&(b=d.instance,d.state.loading|=4,py(b,m.precedence,u));return d.instance}function py(u,d,m){for(var b=m.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),_=b.length?b[b.length-1]:null,N=_,M=0;M<b.length;M++){var H=b[M];if(H.dataset.precedence===d)N=H;else if(N!==_)break}N?N.parentNode.insertBefore(u,N.nextSibling):(d=m.nodeType===9?m.head:m,d.insertBefore(u,d.firstChild))}function Vw(u,d){u.crossOrigin==null&&(u.crossOrigin=d.crossOrigin),u.referrerPolicy==null&&(u.referrerPolicy=d.referrerPolicy),u.title==null&&(u.title=d.title)}function Uw(u,d){u.crossOrigin==null&&(u.crossOrigin=d.crossOrigin),u.referrerPolicy==null&&(u.referrerPolicy=d.referrerPolicy),u.integrity==null&&(u.integrity=d.integrity)}var fy=null;function TN(u,d,m){if(fy===null){var b=new Map,_=fy=new Map;_.set(m,b)}else _=fy,b=_.get(m),b||(b=new Map,_.set(m,b));if(b.has(u))return b;for(b.set(u,null),m=m.getElementsByTagName(u),_=0;_<m.length;_++){var N=m[_];if(!(N[Fo]||N[es]||u==="link"&&N.getAttribute("rel")==="stylesheet")&&N.namespaceURI!=="http://www.w3.org/2000/svg"){var M=N.getAttribute(d)||"";M=u+M;var H=b.get(M);H?H.push(N):b.set(M,[N])}}return b}function kN(u,d,m){u=u.ownerDocument||u,u.head.insertBefore(m,d==="title"?u.querySelector("head > title"):null)}function _G(u,d,m){if(m===1||d.itemProp!=null)return!1;switch(u){case"meta":case"title":return!0;case"style":if(typeof d.precedence!="string"||typeof d.href!="string"||d.href==="")break;return!0;case"link":if(typeof d.rel!="string"||typeof d.href!="string"||d.href===""||d.onLoad||d.onError)break;switch(d.rel){case"stylesheet":return u=d.disabled,typeof d.precedence=="string"&&u==null;default:return!0}case"script":if(d.async&&typeof d.async!="function"&&typeof d.async!="symbol"&&!d.onLoad&&!d.onError&&d.src&&typeof d.src=="string")return!0}return!1}function NN(u){return!(u.type==="stylesheet"&&(u.state.loading&3)===0)}var kp=null;function CG(){}function TG(u,d,m){if(kp===null)throw Error(s(475));var b=kp;if(d.type==="stylesheet"&&(typeof m.media!="string"||matchMedia(m.media).matches!==!1)&&(d.state.loading&4)===0){if(d.instance===null){var _=yd(m.href),N=u.querySelector(Cp(_));if(N){u=N._p,u!==null&&typeof u=="object"&&typeof u.then=="function"&&(b.count++,b=my.bind(b),u.then(b,b)),d.state.loading|=4,d.instance=N,Fn(N);return}N=u.ownerDocument||u,m=_N(m),(_=ua.get(_))&&Vw(m,_),N=N.createElement("link"),Fn(N);var M=N;M._p=new Promise(function(H,Z){M.onload=H,M.onerror=Z}),Is(N,"link",m),d.instance=N}b.stylesheets===null&&(b.stylesheets=new Map),b.stylesheets.set(d,u),(u=d.state.preload)&&(d.state.loading&3)===0&&(b.count++,d=my.bind(b),u.addEventListener("load",d),u.addEventListener("error",d))}}function kG(){if(kp===null)throw Error(s(475));var u=kp;return u.stylesheets&&u.count===0&&Ww(u,u.stylesheets),0<u.count?function(d){var m=setTimeout(function(){if(u.stylesheets&&Ww(u,u.stylesheets),u.unsuspend){var b=u.unsuspend;u.unsuspend=null,b()}},6e4);return u.unsuspend=d,function(){u.unsuspend=null,clearTimeout(m)}}:null}function my(){if(this.count--,this.count===0){if(this.stylesheets)Ww(this,this.stylesheets);else if(this.unsuspend){var u=this.unsuspend;this.unsuspend=null,u()}}}var gy=null;function Ww(u,d){u.stylesheets=null,u.unsuspend!==null&&(u.count++,gy=new Map,d.forEach(NG,u),gy=null,my.call(u))}function NG(u,d){if(!(d.state.loading&4)){var m=gy.get(u);if(m)var b=m.get(null);else{m=new Map,gy.set(u,m);for(var _=u.querySelectorAll("link[data-precedence],style[data-precedence]"),N=0;N<_.length;N++){var M=_[N];(M.nodeName==="LINK"||M.getAttribute("media")!=="not all")&&(m.set(M.dataset.precedence,M),b=M)}b&&m.set(null,b)}_=d.instance,M=_.getAttribute("data-precedence"),N=m.get(M)||b,N===b&&m.set(null,_),m.set(M,_),this.count++,b=my.bind(this),_.addEventListener("load",b),_.addEventListener("error",b),N?N.parentNode.insertBefore(_,N.nextSibling):(u=u.nodeType===9?u.head:u,u.insertBefore(_,u.firstChild)),d.state.loading|=4}}var Np={$$typeof:g,Provider:null,Consumer:null,_currentValue:J,_currentValue2:J,_threadCount:0};function IG(u,d,m,b,_,N,M,H){this.tag=1,this.containerInfo=u,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=gh(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.finishedLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=gh(0),this.hiddenUpdates=gh(null),this.identifierPrefix=b,this.onUncaughtError=_,this.onCaughtError=N,this.onRecoverableError=M,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=H,this.incompleteTransitions=new Map}function IN(u,d,m,b,_,N,M,H,Z,he,Ne,Oe){return u=new IG(u,d,m,M,H,Z,he,Oe),d=1,N===!0&&(d|=24),N=oa(3,null,null,d),u.current=N,N.stateNode=u,d=ap(),d.refCount++,u.pooledCache=d,d.refCount++,N.memoizedState={element:b,isDehydrated:m,cache:d},tw(N),u}function EN(u){return u?(u=Ki,u):Ki}function AN(u,d,m,b,_,N){_=EN(_),b.context===null?b.context=_:b.pendingContext=_,b=ll(d),b.payload={element:m},N=N===void 0?null:N,N!==null&&(b.callback=N),m=ul(u,b,d),m!==null&&(tr(m,u,d),dp(m,u,d))}function RN(u,d){if(u=u.memoizedState,u!==null&&u.dehydrated!==null){var m=u.retryLane;u.retryLane=m!==0&&m<d?m:d}}function Gw(u,d){RN(u,d),(u=u.alternate)&&RN(u,d)}function DN(u){if(u.tag===13){var d=Aa(u,67108864);d!==null&&tr(d,u,67108864),Gw(u,67108864)}}var yy=!0;function EG(u,d,m,b){var _=z.T;z.T=null;var N=pe.p;try{pe.p=2,Hw(u,d,m,b)}finally{pe.p=N,z.T=_}}function AG(u,d,m,b){var _=z.T;z.T=null;var N=pe.p;try{pe.p=8,Hw(u,d,m,b)}finally{pe.p=N,z.T=_}}function Hw(u,d,m,b){if(yy){var _=qw(b);if(_===null)Dw(u,d,b,by,m),zN(u,b);else if(DG(_,u,d,m,b))b.stopPropagation();else if(zN(u,b),d&4&&-1<RG.indexOf(u)){for(;_!==null;){var N=Vi(_);if(N!==null)switch(N.tag){case 3:if(N=N.stateNode,N.current.memoizedState.isDehydrated){var M=hr(N.pendingLanes);if(M!==0){var H=N;for(H.pendingLanes|=2,H.entangledLanes|=2;M;){var Z=1<<31-zs(M);H.entanglements[1]|=Z,M&=~Z}yi(N),(Sn&6)===0&&(ty=ln()+500,$p(0))}}break;case 13:H=Aa(N,2),H!==null&&tr(H,N,2),ry(),Gw(N,2)}if(N=qw(b),N===null&&Dw(u,d,b,by,m),N===_)break;_=N}_!==null&&b.stopPropagation()}else Dw(u,d,b,null,m)}}function qw(u){return u=su(u),jw(u)}var by=null;function jw(u){if(by=null,u=ri(u),u!==null){var d=se(u);if(d===null)u=null;else{var m=d.tag;if(m===13){if(u=ee(d),u!==null)return u;u=null}else if(m===3){if(d.stateNode.current.memoizedState.isDehydrated)return d.tag===3?d.stateNode.containerInfo:null;u=null}else d!==u&&(u=null)}}return by=u,null}function ON(u){switch(u){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(cr()){case Pn:return 2;case Et:return 8;case _s:case ti:return 32;case ni:return 268435456;default:return 32}default:return 32}}var Kw=!1,gl=null,yl=null,bl=null,Ip=new Map,Ep=new Map,xl=[],RG="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function zN(u,d){switch(u){case"focusin":case"focusout":gl=null;break;case"dragenter":case"dragleave":yl=null;break;case"mouseover":case"mouseout":bl=null;break;case"pointerover":case"pointerout":Ip.delete(d.pointerId);break;case"gotpointercapture":case"lostpointercapture":Ep.delete(d.pointerId)}}function Ap(u,d,m,b,_,N){return u===null||u.nativeEvent!==N?(u={blockedOn:d,domEventName:m,eventSystemFlags:b,nativeEvent:N,targetContainers:[_]},d!==null&&(d=Vi(d),d!==null&&DN(d)),u):(u.eventSystemFlags|=b,d=u.targetContainers,_!==null&&d.indexOf(_)===-1&&d.push(_),u)}function DG(u,d,m,b,_){switch(d){case"focusin":return gl=Ap(gl,u,d,m,b,_),!0;case"dragenter":return yl=Ap(yl,u,d,m,b,_),!0;case"mouseover":return bl=Ap(bl,u,d,m,b,_),!0;case"pointerover":var N=_.pointerId;return Ip.set(N,Ap(Ip.get(N)||null,u,d,m,b,_)),!0;case"gotpointercapture":return N=_.pointerId,Ep.set(N,Ap(Ep.get(N)||null,u,d,m,b,_)),!0}return!1}function FN(u){var d=ri(u.target);if(d!==null){var m=se(d);if(m!==null){if(d=m.tag,d===13){if(d=ee(m),d!==null){u.blockedOn=d,tg(u.priority,function(){if(m.tag===13){var b=Vr(),_=Aa(m,b);_!==null&&tr(_,m,b),Gw(m,b)}});return}}else if(d===3&&m.stateNode.current.memoizedState.isDehydrated){u.blockedOn=m.tag===3?m.stateNode.containerInfo:null;return}}}u.blockedOn=null}function xy(u){if(u.blockedOn!==null)return!1;for(var d=u.targetContainers;0<d.length;){var m=qw(u.nativeEvent);if(m===null){m=u.nativeEvent;var b=new m.constructor(m.type,m);Ih=b,m.target.dispatchEvent(b),Ih=null}else return d=Vi(m),d!==null&&DN(d),u.blockedOn=m,!1;d.shift()}return!0}function LN(u,d,m){xy(u)&&m.delete(d)}function OG(){Kw=!1,gl!==null&&xy(gl)&&(gl=null),yl!==null&&xy(yl)&&(yl=null),bl!==null&&xy(bl)&&(bl=null),Ip.forEach(LN),Ep.forEach(LN)}function wy(u,d){u.blockedOn===d&&(u.blockedOn=null,Kw||(Kw=!0,t.unstable_scheduleCallback(t.unstable_NormalPriority,OG)))}var vy=null;function MN(u){vy!==u&&(vy=u,t.unstable_scheduleCallback(t.unstable_NormalPriority,function(){vy===u&&(vy=null);for(var d=0;d<u.length;d+=3){var m=u[d],b=u[d+1],_=u[d+2];if(typeof b!="function"){if(jw(b||m)===null)continue;break}var N=Vi(m);N!==null&&(u.splice(d,3),d-=3,L1(N,{pending:!0,data:_,method:m.method,action:b},b,_))}}))}function Rp(u){function d(Z){return wy(Z,u)}gl!==null&&wy(gl,u),yl!==null&&wy(yl,u),bl!==null&&wy(bl,u),Ip.forEach(d),Ep.forEach(d);for(var m=0;m<xl.length;m++){var b=xl[m];b.blockedOn===u&&(b.blockedOn=null)}for(;0<xl.length&&(m=xl[0],m.blockedOn===null);)FN(m),m.blockedOn===null&&xl.shift();if(m=(u.ownerDocument||u).$$reactFormReplay,m!=null)for(b=0;b<m.length;b+=3){var _=m[b],N=m[b+1],M=_[Cs]||null;if(typeof N=="function")M||MN(m);else if(M){var H=null;if(N&&N.hasAttribute("formAction")){if(_=N,M=N[Cs]||null)H=M.formAction;else if(jw(_)!==null)continue}else H=M.action;typeof H=="function"?m[b+1]=H:(m.splice(b,3),b-=3),MN(m)}}}function Xw(u){this._internalRoot=u}$y.prototype.render=Xw.prototype.render=function(u){var d=this._internalRoot;if(d===null)throw Error(s(409));var m=d.current,b=Vr();AN(m,b,u,d,null,null)},$y.prototype.unmount=Xw.prototype.unmount=function(){var u=this._internalRoot;if(u!==null){this._internalRoot=null;var d=u.containerInfo;u.tag===0&&pd(),AN(u.current,2,null,u,null,null),ry(),d[Pi]=null}};function $y(u){this._internalRoot=u}$y.prototype.unstable_scheduleHydration=function(u){if(u){var d=xh();u={blockedOn:null,target:u,priority:d};for(var m=0;m<xl.length&&d!==0&&d<xl[m].priority;m++);xl.splice(m,0,u),m===0&&FN(u)}};var BN=e.version;if(BN!=="19.0.0")throw Error(s(527,BN,"19.0.0"));pe.findDOMNode=function(u){var d=u._reactInternals;if(d===void 0)throw typeof u.render=="function"?Error(s(188)):(u=Object.keys(u).join(","),Error(s(268,u)));return u=G(d),u=u!==null?Y(u):null,u=u===null?null:u.stateNode,u};var zG={bundleType:0,version:"19.0.0",rendererPackageName:"react-dom",currentDispatcherRef:z,findFiberByHostInstance:ri,reconcilerVersion:"19.0.0"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Sy=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Sy.isDisabled&&Sy.supportsFiber)try{Rr=Sy.inject(zG),vn=Sy}catch{}}return Op.createRoot=function(u,d){if(!r(u))throw Error(s(299));var m=!1,b="",_=nk,N=sk,M=rk,H=null;return d!=null&&(d.unstable_strictMode===!0&&(m=!0),d.identifierPrefix!==void 0&&(b=d.identifierPrefix),d.onUncaughtError!==void 0&&(_=d.onUncaughtError),d.onCaughtError!==void 0&&(N=d.onCaughtError),d.onRecoverableError!==void 0&&(M=d.onRecoverableError),d.unstable_transitionCallbacks!==void 0&&(H=d.unstable_transitionCallbacks)),d=IN(u,1,!1,null,null,m,b,_,N,M,H,null),u[Pi]=d.current,Rw(u.nodeType===8?u.parentNode:u),new Xw(d)},Op.hydrateRoot=function(u,d,m){if(!r(u))throw Error(s(299));var b=!1,_="",N=nk,M=sk,H=rk,Z=null,he=null;return m!=null&&(m.unstable_strictMode===!0&&(b=!0),m.identifierPrefix!==void 0&&(_=m.identifierPrefix),m.onUncaughtError!==void 0&&(N=m.onUncaughtError),m.onCaughtError!==void 0&&(M=m.onCaughtError),m.onRecoverableError!==void 0&&(H=m.onRecoverableError),m.unstable_transitionCallbacks!==void 0&&(Z=m.unstable_transitionCallbacks),m.formState!==void 0&&(he=m.formState)),d=IN(u,1,!0,d,m??null,b,_,N,M,H,Z,he),d.context=EN(null),m=d.current,b=Vr(),_=ll(b),_.callback=null,ul(m,_,b),d.current.lanes=b,nu(d,b),yi(d),u[Pi]=d.current,Rw(u),new $y(d)},Op.version="19.0.0",Op}var YN;function XG(){if(YN)return Qw.exports;YN=1;function t(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)}catch(e){console.error(e)}}return t(),Qw.exports=KG(),Qw.exports}var YG=XG();const ZG=ID(YG);var zp={},ZN;function QG(){if(ZN)return zp;ZN=1,Object.defineProperty(zp,"__esModule",{value:!0}),zp.parse=i,zp.serialize=c;const t=/^[\u0021-\u003A\u003C\u003E-\u007E]+$/,e=/^[\u0021-\u003A\u003C-\u007E]*$/,n=/^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,s=/^[\u0020-\u003A\u003D-\u007E]*$/,r=Object.prototype.toString,a=(()=>{const f=function(){};return f.prototype=Object.create(null),f})();function i(f,g){const y=new a,x=f.length;if(x<2)return y;const w=(g==null?void 0:g.decode)||h;let v=0;do{const $=f.indexOf("=",v);if($===-1)break;const T=f.indexOf(";",v),C=T===-1?x:T;if($>C){v=f.lastIndexOf(";",$-1)+1;continue}const I=o(f,v,$),A=l(f,$,I),O=f.slice(I,A);if(y[O]===void 0){let B=o(f,$+1,C),z=l(f,C,B);const P=w(f.slice(B,z));y[O]=P}v=C+1}while(v<x);return y}function o(f,g,y){do{const x=f.charCodeAt(g);if(x!==32&&x!==9)return g}while(++g<y);return y}function l(f,g,y){for(;g>y;){const x=f.charCodeAt(--g);if(x!==32&&x!==9)return g+1}return y}function c(f,g,y){const x=(y==null?void 0:y.encode)||encodeURIComponent;if(!t.test(f))throw new TypeError(`argument name is invalid: ${f}`);const w=x(g);if(!e.test(w))throw new TypeError(`argument val is invalid: ${g}`);let v=f+"="+w;if(!y)return v;if(y.maxAge!==void 0){if(!Number.isInteger(y.maxAge))throw new TypeError(`option maxAge is invalid: ${y.maxAge}`);v+="; Max-Age="+y.maxAge}if(y.domain){if(!n.test(y.domain))throw new TypeError(`option domain is invalid: ${y.domain}`);v+="; Domain="+y.domain}if(y.path){if(!s.test(y.path))throw new TypeError(`option path is invalid: ${y.path}`);v+="; Path="+y.path}if(y.expires){if(!p(y.expires)||!Number.isFinite(y.expires.valueOf()))throw new TypeError(`option expires is invalid: ${y.expires}`);v+="; Expires="+y.expires.toUTCString()}if(y.httpOnly&&(v+="; HttpOnly"),y.secure&&(v+="; Secure"),y.partitioned&&(v+="; Partitioned"),y.priority)switch(typeof y.priority=="string"?y.priority.toLowerCase():void 0){case"low":v+="; Priority=Low";break;case"medium":v+="; Priority=Medium";break;case"high":v+="; Priority=High";break;default:throw new TypeError(`option priority is invalid: ${y.priority}`)}if(y.sameSite)switch(typeof y.sameSite=="string"?y.sameSite.toLowerCase():y.sameSite){case!0:case"strict":v+="; SameSite=Strict";break;case"lax":v+="; SameSite=Lax";break;case"none":v+="; SameSite=None";break;default:throw new TypeError(`option sameSite is invalid: ${y.sameSite}`)}return v}function h(f){if(f.indexOf("%")===-1)return f;try{return decodeURIComponent(f)}catch{return f}}function p(f){return r.call(f)==="[object Date]"}return zp}QG();/**
 * react-router v7.4.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */var QN="popstate";function JG(t={}){function e(s,r){let{pathname:a,search:i,hash:o}=s.location;return w$("",{pathname:a,search:i,hash:o},r.state&&r.state.usr||null,r.state&&r.state.key||"default")}function n(s,r){return typeof r=="string"?r:cf(r)}return tH(e,n,null,t)}function as(t,e){if(t===!1||t===null||typeof t>"u")throw new Error(e)}function Ii(t,e){if(!t){typeof console<"u"&&console.warn(e);try{throw new Error(e)}catch{}}}function eH(){return Math.random().toString(36).substring(2,10)}function JN(t,e){return{usr:t.state,key:t.key,idx:e}}function w$(t,e,n=null,s){return{pathname:typeof t=="string"?t:t.pathname,search:"",hash:"",...typeof e=="string"?kf(e):e,state:n,key:e&&e.key||s||eH()}}function cf({pathname:t="/",search:e="",hash:n=""}){return e&&e!=="?"&&(t+=e.charAt(0)==="?"?e:"?"+e),n&&n!=="#"&&(t+=n.charAt(0)==="#"?n:"#"+n),t}function kf(t){let e={};if(t){let n=t.indexOf("#");n>=0&&(e.hash=t.substring(n),t=t.substring(0,n));let s=t.indexOf("?");s>=0&&(e.search=t.substring(s),t=t.substring(0,s)),t&&(e.pathname=t)}return e}function tH(t,e,n,s={}){let{window:r=document.defaultView,v5Compat:a=!1}=s,i=r.history,o="POP",l=null,c=h();c==null&&(c=0,i.replaceState({...i.state,idx:c},""));function h(){return(i.state||{idx:null}).idx}function p(){o="POP";let w=h(),v=w==null?null:w-c;c=w,l&&l({action:o,location:x.location,delta:v})}function f(w,v){o="PUSH";let $=w$(x.location,w,v);c=h()+1;let T=JN($,c),C=x.createHref($);try{i.pushState(T,"",C)}catch(I){if(I instanceof DOMException&&I.name==="DataCloneError")throw I;r.location.assign(C)}a&&l&&l({action:o,location:x.location,delta:1})}function g(w,v){o="REPLACE";let $=w$(x.location,w,v);c=h();let T=JN($,c),C=x.createHref($);i.replaceState(T,"",C),a&&l&&l({action:o,location:x.location,delta:0})}function y(w){let v=r.location.origin!=="null"?r.location.origin:r.location.href,$=typeof w=="string"?w:cf(w);return $=$.replace(/ $/,"%20"),as(v,`No window.location.(origin|href) available to create URL for href: ${$}`),new URL($,v)}let x={get action(){return o},get location(){return t(r,i)},listen(w){if(l)throw new Error("A history only accepts one active listener");return r.addEventListener(QN,p),l=w,()=>{r.removeEventListener(QN,p),l=null}},createHref(w){return e(r,w)},createURL:y,encodeLocation(w){let v=y(w);return{pathname:v.pathname,search:v.search,hash:v.hash}},push:f,replace:g,go(w){return i.go(w)}};return x}function ED(t,e,n="/"){return nH(t,e,n,!1)}function nH(t,e,n,s){let r=typeof e=="string"?kf(e):e,a=_o(r.pathname||"/",n);if(a==null)return null;let i=AD(t);sH(i);let o=null;for(let l=0;o==null&&l<i.length;++l){let c=fH(a);o=hH(i[l],c,s)}return o}function AD(t,e=[],n=[],s=""){let r=(a,i,o)=>{let l={relativePath:o===void 0?a.path||"":o,caseSensitive:a.caseSensitive===!0,childrenIndex:i,route:a};l.relativePath.startsWith("/")&&(as(l.relativePath.startsWith(s),`Absolute route path "${l.relativePath}" nested under path "${s}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),l.relativePath=l.relativePath.slice(s.length));let c=vo([s,l.relativePath]),h=n.concat(l);a.children&&a.children.length>0&&(as(a.index!==!0,`Index routes must not have child routes. Please remove all child routes from route path "${c}".`),AD(a.children,e,h,c)),!(a.path==null&&!a.index)&&e.push({path:c,score:cH(c,a.index),routesMeta:h})};return t.forEach((a,i)=>{var o;if(a.path===""||!((o=a.path)!=null&&o.includes("?")))r(a,i);else for(let l of RD(a.path))r(a,i,l)}),e}function RD(t){let e=t.split("/");if(e.length===0)return[];let[n,...s]=e,r=n.endsWith("?"),a=n.replace(/\?$/,"");if(s.length===0)return r?[a,""]:[a];let i=RD(s.join("/")),o=[];return o.push(...i.map(l=>l===""?a:[a,l].join("/"))),r&&o.push(...i),o.map(l=>t.startsWith("/")&&l===""?"/":l)}function sH(t){t.sort((e,n)=>e.score!==n.score?n.score-e.score:dH(e.routesMeta.map(s=>s.childrenIndex),n.routesMeta.map(s=>s.childrenIndex)))}var rH=/^:[\w-]+$/,aH=3,iH=2,oH=1,lH=10,uH=-2,eI=t=>t==="*";function cH(t,e){let n=t.split("/"),s=n.length;return n.some(eI)&&(s+=uH),e&&(s+=iH),n.filter(r=>!eI(r)).reduce((r,a)=>r+(rH.test(a)?aH:a===""?oH:lH),s)}function dH(t,e){return t.length===e.length&&t.slice(0,-1).every((s,r)=>s===e[r])?t[t.length-1]-e[e.length-1]:0}function hH(t,e,n=!1){let{routesMeta:s}=t,r={},a="/",i=[];for(let o=0;o<s.length;++o){let l=s[o],c=o===s.length-1,h=a==="/"?e:e.slice(a.length)||"/",p=m0({path:l.relativePath,caseSensitive:l.caseSensitive,end:c},h),f=l.route;if(!p&&c&&n&&!s[s.length-1].route.index&&(p=m0({path:l.relativePath,caseSensitive:l.caseSensitive,end:!1},h)),!p)return null;Object.assign(r,p.params),i.push({params:r,pathname:vo([a,p.pathname]),pathnameBase:bH(vo([a,p.pathnameBase])),route:f}),p.pathnameBase!=="/"&&(a=vo([a,p.pathnameBase]))}return i}function m0(t,e){typeof t=="string"&&(t={path:t,caseSensitive:!1,end:!0});let[n,s]=pH(t.path,t.caseSensitive,t.end),r=e.match(n);if(!r)return null;let a=r[0],i=a.replace(/(.)\/+$/,"$1"),o=r.slice(1);return{params:s.reduce((c,{paramName:h,isOptional:p},f)=>{if(h==="*"){let y=o[f]||"";i=a.slice(0,a.length-y.length).replace(/(.)\/+$/,"$1")}const g=o[f];return p&&!g?c[h]=void 0:c[h]=(g||"").replace(/%2F/g,"/"),c},{}),pathname:a,pathnameBase:i,pattern:t}}function pH(t,e=!1,n=!0){Ii(t==="*"||!t.endsWith("*")||t.endsWith("/*"),`Route path "${t}" will be treated as if it were "${t.replace(/\*$/,"/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${t.replace(/\*$/,"/*")}".`);let s=[],r="^"+t.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(i,o,l)=>(s.push({paramName:o,isOptional:l!=null}),l?"/?([^\\/]+)?":"/([^\\/]+)"));return t.endsWith("*")?(s.push({paramName:"*"}),r+=t==="*"||t==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?r+="\\/*$":t!==""&&t!=="/"&&(r+="(?:(?=\\/|$))"),[new RegExp(r,e?void 0:"i"),s]}function fH(t){try{return t.split("/").map(e=>decodeURIComponent(e).replace(/\//g,"%2F")).join("/")}catch(e){return Ii(!1,`The URL path "${t}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${e}).`),t}}function _o(t,e){if(e==="/")return t;if(!t.toLowerCase().startsWith(e.toLowerCase()))return null;let n=e.endsWith("/")?e.length-1:e.length,s=t.charAt(n);return s&&s!=="/"?null:t.slice(n)||"/"}function mH(t,e="/"){let{pathname:n,search:s="",hash:r=""}=typeof t=="string"?kf(t):t;return{pathname:n?n.startsWith("/")?n:gH(n,e):e,search:xH(s),hash:wH(r)}}function gH(t,e){let n=e.replace(/\/+$/,"").split("/");return t.split("/").forEach(r=>{r===".."?n.length>1&&n.pop():r!=="."&&n.push(r)}),n.length>1?n.join("/"):"/"}function nv(t,e,n,s){return`Cannot include a '${t}' character in a manually specified \`to.${e}\` field [${JSON.stringify(s)}].  Please separate it out to the \`to.${n}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`}function yH(t){return t.filter((e,n)=>n===0||e.route.path&&e.route.path.length>0)}function DD(t){let e=yH(t);return e.map((n,s)=>s===e.length-1?n.pathname:n.pathnameBase)}function OD(t,e,n,s=!1){let r;typeof t=="string"?r=kf(t):(r={...t},as(!r.pathname||!r.pathname.includes("?"),nv("?","pathname","search",r)),as(!r.pathname||!r.pathname.includes("#"),nv("#","pathname","hash",r)),as(!r.search||!r.search.includes("#"),nv("#","search","hash",r)));let a=t===""||r.pathname==="",i=a?"/":r.pathname,o;if(i==null)o=n;else{let p=e.length-1;if(!s&&i.startsWith("..")){let f=i.split("/");for(;f[0]==="..";)f.shift(),p-=1;r.pathname=f.join("/")}o=p>=0?e[p]:"/"}let l=mH(r,o),c=i&&i!=="/"&&i.endsWith("/"),h=(a||i===".")&&n.endsWith("/");return!l.pathname.endsWith("/")&&(c||h)&&(l.pathname+="/"),l}var vo=t=>t.join("/").replace(/\/\/+/g,"/"),bH=t=>t.replace(/\/+$/,"").replace(/^\/*/,"/"),xH=t=>!t||t==="?"?"":t.startsWith("?")?t:"?"+t,wH=t=>!t||t==="#"?"":t.startsWith("#")?t:"#"+t;function vH(t){return t!=null&&typeof t.status=="number"&&typeof t.statusText=="string"&&typeof t.internal=="boolean"&&"data"in t}var zD=["POST","PUT","PATCH","DELETE"];new Set(zD);var $H=["GET",...zD];new Set($H);var Zd=Ce.createContext(null);Zd.displayName="DataRouter";var J0=Ce.createContext(null);J0.displayName="DataRouterState";var FD=Ce.createContext({isTransitioning:!1});FD.displayName="ViewTransition";var SH=Ce.createContext(new Map);SH.displayName="Fetchers";var _H=Ce.createContext(null);_H.displayName="Await";var Oi=Ce.createContext(null);Oi.displayName="Navigation";var eb=Ce.createContext(null);eb.displayName="Location";var Io=Ce.createContext({outlet:null,matches:[],isDataRoute:!1});Io.displayName="Route";var R2=Ce.createContext(null);R2.displayName="RouteError";function CH(t,{relative:e}={}){as(Nf(),"useHref() may be used only in the context of a <Router> component.");let{basename:n,navigator:s}=Ce.useContext(Oi),{hash:r,pathname:a,search:i}=If(t,{relative:e}),o=a;return n!=="/"&&(o=a==="/"?n:vo([n,a])),s.createHref({pathname:o,search:i,hash:r})}function Nf(){return Ce.useContext(eb)!=null}function xc(){return as(Nf(),"useLocation() may be used only in the context of a <Router> component."),Ce.useContext(eb).location}var LD="You should call navigate() in a React.useEffect(), not when your component is first rendered.";function MD(t){Ce.useContext(Oi).static||Ce.useLayoutEffect(t)}function TH(){let{isDataRoute:t}=Ce.useContext(Io);return t?BH():kH()}function kH(){as(Nf(),"useNavigate() may be used only in the context of a <Router> component.");let t=Ce.useContext(Zd),{basename:e,navigator:n}=Ce.useContext(Oi),{matches:s}=Ce.useContext(Io),{pathname:r}=xc(),a=JSON.stringify(DD(s)),i=Ce.useRef(!1);return MD(()=>{i.current=!0}),Ce.useCallback((l,c={})=>{if(Ii(i.current,LD),!i.current)return;if(typeof l=="number"){n.go(l);return}let h=OD(l,JSON.parse(a),r,c.relative==="path");t==null&&e!=="/"&&(h.pathname=h.pathname==="/"?e:vo([e,h.pathname])),(c.replace?n.replace:n.push)(h,c.state,c)},[e,n,a,r,t])}Ce.createContext(null);function If(t,{relative:e}={}){let{matches:n}=Ce.useContext(Io),{pathname:s}=xc(),r=JSON.stringify(DD(n));return Ce.useMemo(()=>OD(t,JSON.parse(r),s,e==="path"),[t,r,s,e])}function NH(t,e,n,s){as(Nf(),"useRoutes() may be used only in the context of a <Router> component.");let{navigator:r,static:a}=Ce.useContext(Oi),{matches:i}=Ce.useContext(Io),o=i[i.length-1],l=o?o.params:{},c=o?o.pathname:"/",h=o?o.pathnameBase:"/",p=o&&o.route;{let $=p&&p.path||"";BD(c,!p||$.endsWith("*")||$.endsWith("*?"),`You rendered descendant <Routes> (or called \`useRoutes()\`) at "${c}" (under <Route path="${$}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${$}"> to <Route path="${$==="/"?"*":`${$}/*`}">.`)}let f=xc(),g;g=f;let y=g.pathname||"/",x=y;if(h!=="/"){let $=h.replace(/^\//,"").split("/");x="/"+y.replace(/^\//,"").split("/").slice($.length).join("/")}let w=!a&&n&&n.matches&&n.matches.length>0?n.matches:ED(t,{pathname:x});return Ii(p||w!=null,`No routes matched location "${g.pathname}${g.search}${g.hash}" `),Ii(w==null||w[w.length-1].route.element!==void 0||w[w.length-1].route.Component!==void 0||w[w.length-1].route.lazy!==void 0,`Matched leaf route at location "${g.pathname}${g.search}${g.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`),DH(w&&w.map($=>Object.assign({},$,{params:Object.assign({},l,$.params),pathname:vo([h,r.encodeLocation?r.encodeLocation($.pathname).pathname:$.pathname]),pathnameBase:$.pathnameBase==="/"?h:vo([h,r.encodeLocation?r.encodeLocation($.pathnameBase).pathname:$.pathnameBase])})),i,n,s)}function IH(){let t=MH(),e=vH(t)?`${t.status} ${t.statusText}`:t instanceof Error?t.message:JSON.stringify(t),n=t instanceof Error?t.stack:null,s="rgba(200,200,200, 0.5)",r={padding:"0.5rem",backgroundColor:s},a={padding:"2px 4px",backgroundColor:s},i=null;return console.error("Error handled by React Router default ErrorBoundary:",t),i=Ce.createElement(Ce.Fragment,null,Ce.createElement("p",null," Hey developer "),Ce.createElement("p",null,"You can provide a way better UX than this when your app throws errors by providing your own ",Ce.createElement("code",{style:a},"ErrorBoundary")," or"," ",Ce.createElement("code",{style:a},"errorElement")," prop on your route.")),Ce.createElement(Ce.Fragment,null,Ce.createElement("h2",null,"Unexpected Application Error!"),Ce.createElement("h3",{style:{fontStyle:"italic"}},e),n?Ce.createElement("pre",{style:r},n):null,i)}var EH=Ce.createElement(IH,null),AH=class extends Ce.Component{constructor(t){super(t),this.state={location:t.location,revalidation:t.revalidation,error:t.error}}static getDerivedStateFromError(t){return{error:t}}static getDerivedStateFromProps(t,e){return e.location!==t.location||e.revalidation!=="idle"&&t.revalidation==="idle"?{error:t.error,location:t.location,revalidation:t.revalidation}:{error:t.error!==void 0?t.error:e.error,location:e.location,revalidation:t.revalidation||e.revalidation}}componentDidCatch(t,e){console.error("React Router caught the following error during render",t,e)}render(){return this.state.error!==void 0?Ce.createElement(Io.Provider,{value:this.props.routeContext},Ce.createElement(R2.Provider,{value:this.state.error,children:this.props.component})):this.props.children}};function RH({routeContext:t,match:e,children:n}){let s=Ce.useContext(Zd);return s&&s.static&&s.staticContext&&(e.route.errorElement||e.route.ErrorBoundary)&&(s.staticContext._deepestRenderedBoundaryId=e.route.id),Ce.createElement(Io.Provider,{value:t},n)}function DH(t,e=[],n=null,s=null){if(t==null){if(!n)return null;if(n.errors)t=n.matches;else if(e.length===0&&!n.initialized&&n.matches.length>0)t=n.matches;else return null}let r=t,a=n==null?void 0:n.errors;if(a!=null){let l=r.findIndex(c=>c.route.id&&(a==null?void 0:a[c.route.id])!==void 0);as(l>=0,`Could not find a matching route for errors on route IDs: ${Object.keys(a).join(",")}`),r=r.slice(0,Math.min(r.length,l+1))}let i=!1,o=-1;if(n)for(let l=0;l<r.length;l++){let c=r[l];if((c.route.HydrateFallback||c.route.hydrateFallbackElement)&&(o=l),c.route.id){let{loaderData:h,errors:p}=n,f=c.route.loader&&!h.hasOwnProperty(c.route.id)&&(!p||p[c.route.id]===void 0);if(c.route.lazy||f){i=!0,o>=0?r=r.slice(0,o+1):r=[r[0]];break}}}return r.reduceRight((l,c,h)=>{let p,f=!1,g=null,y=null;n&&(p=a&&c.route.id?a[c.route.id]:void 0,g=c.route.errorElement||EH,i&&(o<0&&h===0?(BD("route-fallback",!1,"No `HydrateFallback` element provided to render during initial hydration"),f=!0,y=null):o===h&&(f=!0,y=c.route.hydrateFallbackElement||null)));let x=e.concat(r.slice(0,h+1)),w=()=>{let v;return p?v=g:f?v=y:c.route.Component?v=Ce.createElement(c.route.Component,null):c.route.element?v=c.route.element:v=l,Ce.createElement(RH,{match:c,routeContext:{outlet:l,matches:x,isDataRoute:n!=null},children:v})};return n&&(c.route.ErrorBoundary||c.route.errorElement||h===0)?Ce.createElement(AH,{location:n.location,revalidation:n.revalidation,component:g,error:p,children:w(),routeContext:{outlet:null,matches:x,isDataRoute:!0}}):w()},null)}function D2(t){return`${t} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function OH(t){let e=Ce.useContext(Zd);return as(e,D2(t)),e}function zH(t){let e=Ce.useContext(J0);return as(e,D2(t)),e}function FH(t){let e=Ce.useContext(Io);return as(e,D2(t)),e}function O2(t){let e=FH(t),n=e.matches[e.matches.length-1];return as(n.route.id,`${t} can only be used on routes that contain a unique "id"`),n.route.id}function LH(){return O2("useRouteId")}function MH(){var s;let t=Ce.useContext(R2),e=zH("useRouteError"),n=O2("useRouteError");return t!==void 0?t:(s=e.errors)==null?void 0:s[n]}function BH(){let{router:t}=OH("useNavigate"),e=O2("useNavigate"),n=Ce.useRef(!1);return MD(()=>{n.current=!0}),Ce.useCallback(async(r,a={})=>{Ii(n.current,LD),n.current&&(typeof r=="number"?t.navigate(r):await t.navigate(r,{fromRouteId:e,...a}))},[t,e])}var tI={};function BD(t,e,n){!e&&!tI[t]&&(tI[t]=!0,Ii(!1,n))}Ce.memo(PH);function PH({routes:t,future:e,state:n}){return NH(t,void 0,n,e)}function VH({basename:t="/",children:e=null,location:n,navigationType:s="POP",navigator:r,static:a=!1}){as(!Nf(),"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");let i=t.replace(/^\/*/,"/"),o=Ce.useMemo(()=>({basename:i,navigator:r,static:a,future:{}}),[i,r,a]);typeof n=="string"&&(n=kf(n));let{pathname:l="/",search:c="",hash:h="",state:p=null,key:f="default"}=n,g=Ce.useMemo(()=>{let y=_o(l,i);return y==null?null:{location:{pathname:y,search:c,hash:h,state:p,key:f},navigationType:s}},[i,l,c,h,p,f,s]);return Ii(g!=null,`<Router basename="${i}"> is not able to match the URL "${l}${c}${h}" because it does not start with the basename, so the <Router> won't render anything.`),g==null?null:Ce.createElement(Oi.Provider,{value:o},Ce.createElement(eb.Provider,{children:e,value:g}))}var e0="get",t0="application/x-www-form-urlencoded";function tb(t){return t!=null&&typeof t.tagName=="string"}function UH(t){return tb(t)&&t.tagName.toLowerCase()==="button"}function WH(t){return tb(t)&&t.tagName.toLowerCase()==="form"}function GH(t){return tb(t)&&t.tagName.toLowerCase()==="input"}function HH(t){return!!(t.metaKey||t.altKey||t.ctrlKey||t.shiftKey)}function qH(t,e){return t.button===0&&(!e||e==="_self")&&!HH(t)}var _y=null;function jH(){if(_y===null)try{new FormData(document.createElement("form"),0),_y=!1}catch{_y=!0}return _y}var KH=new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);function sv(t){return t!=null&&!KH.has(t)?(Ii(!1,`"${t}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${t0}"`),null):t}function XH(t,e){let n,s,r,a,i;if(WH(t)){let o=t.getAttribute("action");s=o?_o(o,e):null,n=t.getAttribute("method")||e0,r=sv(t.getAttribute("enctype"))||t0,a=new FormData(t)}else if(UH(t)||GH(t)&&(t.type==="submit"||t.type==="image")){let o=t.form;if(o==null)throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');let l=t.getAttribute("formaction")||o.getAttribute("action");if(s=l?_o(l,e):null,n=t.getAttribute("formmethod")||o.getAttribute("method")||e0,r=sv(t.getAttribute("formenctype"))||sv(o.getAttribute("enctype"))||t0,a=new FormData(o,t),!jH()){let{name:c,type:h,value:p}=t;if(h==="image"){let f=c?`${c}.`:"";a.append(`${f}x`,"0"),a.append(`${f}y`,"0")}else c&&a.append(c,p)}}else{if(tb(t))throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');n=e0,s=null,r=t0,i=t}return a&&r==="text/plain"&&(i=a,a=void 0),{action:s,method:n.toLowerCase(),encType:r,formData:a,body:i}}function z2(t,e){if(t===!1||t===null||typeof t>"u")throw new Error(e)}async function YH(t,e){if(t.id in e)return e[t.id];try{let n=await import(t.module);return e[t.id]=n,n}catch(n){return console.error(`Error loading route module \`${t.module}\`, reloading page...`),console.error(n),window.__reactRouterContext&&window.__reactRouterContext.isSpaMode,window.location.reload(),new Promise(()=>{})}}function ZH(t){return t==null?!1:t.href==null?t.rel==="preload"&&typeof t.imageSrcSet=="string"&&typeof t.imageSizes=="string":typeof t.rel=="string"&&typeof t.href=="string"}async function QH(t,e,n){let s=await Promise.all(t.map(async r=>{let a=e.routes[r.route.id];if(a){let i=await YH(a,n);return i.links?i.links():[]}return[]}));return n6(s.flat(1).filter(ZH).filter(r=>r.rel==="stylesheet"||r.rel==="preload").map(r=>r.rel==="stylesheet"?{...r,rel:"prefetch",as:"style"}:{...r,rel:"prefetch"}))}function nI(t,e,n,s,r,a){let i=(l,c)=>n[c]?l.route.id!==n[c].route.id:!0,o=(l,c)=>{var h;return n[c].pathname!==l.pathname||((h=n[c].route.path)==null?void 0:h.endsWith("*"))&&n[c].params["*"]!==l.params["*"]};return a==="assets"?e.filter((l,c)=>i(l,c)||o(l,c)):a==="data"?e.filter((l,c)=>{var p;let h=s.routes[l.route.id];if(!h||!h.hasLoader)return!1;if(i(l,c)||o(l,c))return!0;if(l.route.shouldRevalidate){let f=l.route.shouldRevalidate({currentUrl:new URL(r.pathname+r.search+r.hash,window.origin),currentParams:((p=n[0])==null?void 0:p.params)||{},nextUrl:new URL(t,window.origin),nextParams:l.params,defaultShouldRevalidate:!0});if(typeof f=="boolean")return f}return!0}):[]}function JH(t,e,{includeHydrateFallback:n}={}){return e6(t.map(s=>{let r=e.routes[s.route.id];if(!r)return[];let a=[r.module];return r.clientActionModule&&(a=a.concat(r.clientActionModule)),r.clientLoaderModule&&(a=a.concat(r.clientLoaderModule)),n&&r.hydrateFallbackModule&&(a=a.concat(r.hydrateFallbackModule)),r.imports&&(a=a.concat(r.imports)),a}).flat(1))}function e6(t){return[...new Set(t)]}function t6(t){let e={},n=Object.keys(t).sort();for(let s of n)e[s]=t[s];return e}function n6(t,e){let n=new Set;return new Set(e),t.reduce((s,r)=>{let a=JSON.stringify(t6(r));return n.has(a)||(n.add(a),s.push({key:a,link:r})),s},[])}function s6(t,e){let n=typeof t=="string"?new URL(t,typeof window>"u"?"server://singlefetch/":window.location.origin):t;return n.pathname==="/"?n.pathname="_root.data":e&&_o(n.pathname,e)==="/"?n.pathname=`${e.replace(/\/$/,"")}/_root.data`:n.pathname=`${n.pathname.replace(/\/$/,"")}.data`,n}function PD(){let t=Ce.useContext(Zd);return z2(t,"You must render this element inside a <DataRouterContext.Provider> element"),t}function r6(){let t=Ce.useContext(J0);return z2(t,"You must render this element inside a <DataRouterStateContext.Provider> element"),t}var F2=Ce.createContext(void 0);F2.displayName="FrameworkContext";function VD(){let t=Ce.useContext(F2);return z2(t,"You must render this element inside a <HydratedRouter> element"),t}function a6(t,e){let n=Ce.useContext(F2),[s,r]=Ce.useState(!1),[a,i]=Ce.useState(!1),{onFocus:o,onBlur:l,onMouseEnter:c,onMouseLeave:h,onTouchStart:p}=e,f=Ce.useRef(null);Ce.useEffect(()=>{if(t==="render"&&i(!0),t==="viewport"){let x=v=>{v.forEach($=>{i($.isIntersecting)})},w=new IntersectionObserver(x,{threshold:.5});return f.current&&w.observe(f.current),()=>{w.disconnect()}}},[t]),Ce.useEffect(()=>{if(s){let x=setTimeout(()=>{i(!0)},100);return()=>{clearTimeout(x)}}},[s]);let g=()=>{r(!0)},y=()=>{r(!1),i(!1)};return n?t!=="intent"?[a,f,{}]:[a,f,{onFocus:Fp(o,g),onBlur:Fp(l,y),onMouseEnter:Fp(c,g),onMouseLeave:Fp(h,y),onTouchStart:Fp(p,g)}]:[!1,f,{}]}function Fp(t,e){return n=>{t&&t(n),n.defaultPrevented||e(n)}}function i6({page:t,...e}){let{router:n}=PD(),s=Ce.useMemo(()=>ED(n.routes,t,n.basename),[n.routes,t,n.basename]);return s?Ce.createElement(l6,{page:t,matches:s,...e}):null}function o6(t){let{manifest:e,routeModules:n}=VD(),[s,r]=Ce.useState([]);return Ce.useEffect(()=>{let a=!1;return QH(t,e,n).then(i=>{a||r(i)}),()=>{a=!0}},[t,e,n]),s}function l6({page:t,matches:e,...n}){let s=xc(),{manifest:r,routeModules:a}=VD(),{basename:i}=PD(),{loaderData:o,matches:l}=r6(),c=Ce.useMemo(()=>nI(t,e,l,r,s,"data"),[t,e,l,r,s]),h=Ce.useMemo(()=>nI(t,e,l,r,s,"assets"),[t,e,l,r,s]),p=Ce.useMemo(()=>{if(t===s.pathname+s.search+s.hash)return[];let y=new Set,x=!1;if(e.forEach(v=>{var T;let $=r.routes[v.route.id];!$||!$.hasLoader||(!c.some(C=>C.route.id===v.route.id)&&v.route.id in o&&((T=a[v.route.id])!=null&&T.shouldRevalidate)||$.hasClientLoader?x=!0:y.add(v.route.id))}),y.size===0)return[];let w=s6(t,i);return x&&y.size>0&&w.searchParams.set("_routes",e.filter(v=>y.has(v.route.id)).map(v=>v.route.id).join(",")),[w.pathname+w.search]},[i,o,s,r,c,e,t,a]),f=Ce.useMemo(()=>JH(h,r),[h,r]),g=o6(h);return Ce.createElement(Ce.Fragment,null,p.map(y=>Ce.createElement("link",{key:y,rel:"prefetch",as:"fetch",href:y,...n})),f.map(y=>Ce.createElement("link",{key:y,rel:"modulepreload",href:y,...n})),g.map(({key:y,link:x})=>Ce.createElement("link",{key:y,...x})))}function u6(...t){return e=>{t.forEach(n=>{typeof n=="function"?n(e):n!=null&&(n.current=e)})}}var UD=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u";try{UD&&(window.__reactRouterVersion="7.4.1")}catch{}function c6({basename:t,children:e,window:n}){let s=Ce.useRef();s.current==null&&(s.current=JG({window:n,v5Compat:!0}));let r=s.current,[a,i]=Ce.useState({action:r.action,location:r.location}),o=Ce.useCallback(l=>{Ce.startTransition(()=>i(l))},[i]);return Ce.useLayoutEffect(()=>r.listen(o),[r,o]),Ce.createElement(VH,{basename:t,children:e,location:a.location,navigationType:a.action,navigator:r})}var WD=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,GD=Ce.forwardRef(function({onClick:e,discover:n="render",prefetch:s="none",relative:r,reloadDocument:a,replace:i,state:o,target:l,to:c,preventScrollReset:h,viewTransition:p,...f},g){let{basename:y}=Ce.useContext(Oi),x=typeof c=="string"&&WD.test(c),w,v=!1;if(typeof c=="string"&&x&&(w=c,UD))try{let z=new URL(window.location.href),P=c.startsWith("//")?new URL(z.protocol+c):new URL(c),F=_o(P.pathname,y);P.origin===z.origin&&F!=null?c=F+P.search+P.hash:v=!0}catch{Ii(!1,`<Link to="${c}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)}let $=CH(c,{relative:r}),[T,C,I]=a6(s,f),A=f6(c,{replace:i,state:o,target:l,preventScrollReset:h,relative:r,viewTransition:p});function O(z){e&&e(z),z.defaultPrevented||A(z)}let B=Ce.createElement("a",{...f,...I,href:w||$,onClick:v||a?e:O,ref:u6(g,C),target:l,"data-discover":!x&&n==="render"?"true":void 0});return T&&!x?Ce.createElement(Ce.Fragment,null,B,Ce.createElement(i6,{page:$})):B});GD.displayName="Link";var d6=Ce.forwardRef(function({"aria-current":e="page",caseSensitive:n=!1,className:s="",end:r=!1,style:a,to:i,viewTransition:o,children:l,...c},h){let p=If(i,{relative:c.relative}),f=xc(),g=Ce.useContext(J0),{navigator:y,basename:x}=Ce.useContext(Oi),w=g!=null&&x6(p)&&o===!0,v=y.encodeLocation?y.encodeLocation(p).pathname:p.pathname,$=f.pathname,T=g&&g.navigation&&g.navigation.location?g.navigation.location.pathname:null;n||($=$.toLowerCase(),T=T?T.toLowerCase():null,v=v.toLowerCase()),T&&x&&(T=_o(T,x)||T);const C=v!=="/"&&v.endsWith("/")?v.length-1:v.length;let I=$===v||!r&&$.startsWith(v)&&$.charAt(C)==="/",A=T!=null&&(T===v||!r&&T.startsWith(v)&&T.charAt(v.length)==="/"),O={isActive:I,isPending:A,isTransitioning:w},B=I?e:void 0,z;typeof s=="function"?z=s(O):z=[s,I?"active":null,A?"pending":null,w?"transitioning":null].filter(Boolean).join(" ");let P=typeof a=="function"?a(O):a;return Ce.createElement(GD,{...c,"aria-current":B,className:z,ref:h,style:P,to:i,viewTransition:o},typeof l=="function"?l(O):l)});d6.displayName="NavLink";var h6=Ce.forwardRef(({discover:t="render",fetcherKey:e,navigate:n,reloadDocument:s,replace:r,state:a,method:i=e0,action:o,onSubmit:l,relative:c,preventScrollReset:h,viewTransition:p,...f},g)=>{let y=y6(),x=b6(o,{relative:c}),w=i.toLowerCase()==="get"?"get":"post",v=typeof o=="string"&&WD.test(o),$=T=>{if(l&&l(T),T.defaultPrevented)return;T.preventDefault();let C=T.nativeEvent.submitter,I=(C==null?void 0:C.getAttribute("formmethod"))||i;y(C||T.currentTarget,{fetcherKey:e,method:I,navigate:n,replace:r,state:a,relative:c,preventScrollReset:h,viewTransition:p})};return Ce.createElement("form",{ref:g,method:w,action:x,onSubmit:s?l:$,...f,"data-discover":!v&&t==="render"?"true":void 0})});h6.displayName="Form";function p6(t){return`${t} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function HD(t){let e=Ce.useContext(Zd);return as(e,p6(t)),e}function f6(t,{target:e,replace:n,state:s,preventScrollReset:r,relative:a,viewTransition:i}={}){let o=TH(),l=xc(),c=If(t,{relative:a});return Ce.useCallback(h=>{if(qH(h,e)){h.preventDefault();let p=n!==void 0?n:cf(l)===cf(c);o(t,{replace:p,state:s,preventScrollReset:r,relative:a,viewTransition:i})}},[l,o,c,n,s,e,t,r,a,i])}var m6=0,g6=()=>`__${String(++m6)}__`;function y6(){let{router:t}=HD("useSubmit"),{basename:e}=Ce.useContext(Oi),n=LH();return Ce.useCallback(async(s,r={})=>{let{action:a,method:i,encType:o,formData:l,body:c}=XH(s,e);if(r.navigate===!1){let h=r.fetcherKey||g6();await t.fetch(h,n,r.action||a,{preventScrollReset:r.preventScrollReset,formData:l,body:c,formMethod:r.method||i,formEncType:r.encType||o,flushSync:r.flushSync})}else await t.navigate(r.action||a,{preventScrollReset:r.preventScrollReset,formData:l,body:c,formMethod:r.method||i,formEncType:r.encType||o,replace:r.replace,state:r.state,fromRouteId:n,flushSync:r.flushSync,viewTransition:r.viewTransition})},[t,e,n])}function b6(t,{relative:e}={}){let{basename:n}=Ce.useContext(Oi),s=Ce.useContext(Io);as(s,"useFormAction must be used inside a RouteContext");let[r]=s.matches.slice(-1),a={...If(t||".",{relative:e})},i=xc();if(t==null){a.search=i.search;let o=new URLSearchParams(a.search),l=o.getAll("index");if(l.some(h=>h==="")){o.delete("index"),l.filter(p=>p).forEach(p=>o.append("index",p));let h=o.toString();a.search=h?`?${h}`:""}}return(!t||t===".")&&r.route.index&&(a.search=a.search?a.search.replace(/^\?/,"?index&"):"?index"),n!=="/"&&(a.pathname=a.pathname==="/"?n:vo([n,a.pathname])),cf(a)}function x6(t,e={}){let n=Ce.useContext(FD);as(n!=null,"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");let{basename:s}=HD("useViewTransitionState"),r=If(t,{relative:e.relative});if(!n.isTransitioning)return!1;let a=_o(n.currentLocation.pathname,s)||n.currentLocation.pathname,i=_o(n.nextLocation.pathname,s)||n.nextLocation.pathname;return m0(r.pathname,i)!=null||m0(r.pathname,a)!=null}new TextEncoder;function sI(){return Kt.jsxs("div",{children:[Kt.jsx("h2",{children:"Welcome to the AI Demo"}),Kt.jsx("p",{children:"Select a model page from the navigation above."})]})}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w6=1e-7,v6=1e-4;class qD{constructor(e,n){this.backend=e,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,n){this.dataIdsCount++,this.data.set(e,n)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class L2{refCount(e){return br("refCount")}incRef(e){return br("incRef")}timerAvailable(){return!0}time(e){return br("time")}read(e){return br("read")}readSync(e){return br("readSync")}readToGPU(e,n){return br("readToGPU")}numDataIds(){return br("numDataIds")}disposeData(e,n){return br("disposeData")}write(e,n,s){return br("write")}move(e,n,s,r,a){return br("move")}createTensorFromGPUData(e,n,s){return br("createTensorFromGPUData")}memory(){return br("memory")}floatPrecision(){return br("floatPrecision")}epsilon(){return this.floatPrecision()===32?w6:v6}dispose(){return br("dispose")}}function br(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $6(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,Sd(t,e,n)}function tc(t,e,n){return Math.max(t,Math.min(e,n))}function M2(t){return t%2===0?t:t+1}function Sd(t,e,n){const s=t[e];t[e]=t[n],t[n]=s}function S6(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function V(t,e){if(!t)throw new Error(typeof e=="string"?e:e())}function Er(t,e,n=""){V(Rt(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function Qd(t){V(t!=null,()=>"The input to the tensor constructor must be a non-null value.")}function $e(t){if(t.length===0)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function _6(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==null&&e[n]!==null&&t[n]!==e[n])return!1;return!0}function Rt(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function Ld(t){return t%1===0}function v$(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function Ed(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function rI(t,e=r=>0,n,s){return new Promise((r,a)=>{let i=0;const o=()=>{if(t()){r();return}i++;const l=e(i);if(n!=null&&i>=n){a();return}s!=null?s(o,l):setTimeout(o,l)};o()})}function jD(t,e){let n=1,s=-1;for(let a=0;a<t.length;++a)if(t[a]>=0)n*=t[a];else if(t[a]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${a}`);s=a}else if(t[a]<0)throw Error(`Shapes can not be < 0. Found ${t[a]} at dim ${a}`);if(s===-1){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(n===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const r=t.slice();return r[s]=e/n,r}function St(t,e){const n=e.length;return t=t==null?e.map((s,r)=>r):[].concat(t),V(t.every(s=>s>=-n&&s<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),V(t.every(s=>Ld(s)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(s=>s<0?n+s:s)}function Wl(t,e){const n=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,a=e==null||r?null:St(e,t).sort();let i=0;for(let o=0;o<t.length;++o){if(a!=null){if(a[i]===o&&t[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${t[o]}' is not 1`);(a[i]==null||a[i]>o)&&t[o]===1&&(n.push(t[o]),s.push(o)),a[i]<=o&&i++}t[o]!==1&&(n.push(t[o]),s.push(o))}return{newShape:n,keptDims:s}}function ys(t,e){return An(t,e)}function An(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else if(t==="string")n=new Array(e);else throw new Error(`Unknown data type ${t}`);return n}function C6(t,e){for(let n=0;n<t.length;n++){const s=t[n];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function T6(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function KD(t,e){return!(e==="complex64"||e==="float32"&&t!=="complex64"||e==="int32"&&t!=="float32"&&t!=="complex64"||e==="bool"&&t==="bool")}function g0(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function k6(t){if(t==null)return 0;let e=0;return t.forEach(n=>e+=n.length),e}function Ef(t){return typeof t=="string"||t instanceof String}function N6(t){return typeof t=="boolean"}function $$(t){return typeof t=="number"}function Jd(t){return Array.isArray(t)?Jd(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":$$(t)?"float32":Ef(t)?"string":N6(t)?"bool":"float32"}function S$(t){return!!(t&&t.constructor&&t.call&&t.apply)}function _$(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function nt(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let s=e-3;s>=0;--s)n[s]=n[s+1]*t[s+1];return n}function XD(t,e,n,s=!1){const r=new Array;if(e.length===1){const a=e[0]*(s?2:1);for(let i=0;i<a;i++)r[i]=n[t+i]}else{const a=e[0],i=e.slice(1),o=i.reduce((l,c)=>l*c)*(s?2:1);for(let l=0;l<a;l++)r[l]=XD(t+l*o,i,n,s)}return r}function xa(t,e,n=!1){if(t.length===0)return e[0];const s=t.reduce((r,a)=>r*a)*(n?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return XD(0,t,e,n)}function I6(t,e){if(Array.isArray(t))return t;if(e==="float32")return t instanceof Float32Array?t:new Float32Array(t);if(e==="int32")return t instanceof Int32Array?t:new Int32Array(t);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(t));throw new Error(`Unknown dtype ${e}`)}function B2(t,e){const n=Rs(t,e);for(let s=0;s<n.length;s++)n[s]=1;return n}function Rs(t,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function YD(t,e){const n=t.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return xa(t,new Float32Array(n));if(e==="int32")return xa(t,new Int32Array(n));if(e==="bool")return xa(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function Yr(t){t.forEach(e=>{V(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function _i(t,e,n){if(e===0)return 0;if(e===1)return t[0];let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=n[r]*t[r];return s}function eh(t,e,n){if(e===0)return[];if(e===1)return[t];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(t/n[r]),t-=s[r]*n[r];return s[s.length-1]=t,s}function nc(t){return t&&t.then&&typeof t.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aI="tfjsflags";class E6{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=A6,this.populateURLFlags()}setPlatform(e,n){this.platform!=null&&(ye().getBool("IS_TEST")||ye().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=n}registerFlag(e,n,s){if(this.flagRegistry[e]={evaluationFn:n,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];ye().getBool("IS_TEST")||ye().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const n=this.evaluateFlag(e);if(nc(n))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=n,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,n){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=n,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(n)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);aI in e&&e[aI].split(",").forEach(s=>{const[r,a]=s.split(":");this.urlFlags[r]=D6(r,a)})}}function A6(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...s)=>(R6(e,s[0],s[1]),s.join("="))),e}function R6(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function D6(t,e){const n=e.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:e}function ye(){return ZD}let ZD=null;function O6(t){ZD=t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rv;function QD(){if(rv==null){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else if(typeof self<"u")t=self;else throw new Error("Could not find a global object");rv=t}return rv}function z6(){const t=QD();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function P2(t,e){const n=z6();if(n.has(t))return n.get(t);{const s=e();return n.set(t,s),n.get(t)}}const nb="Abs",Af="Acos",Rf="Acosh",th="Add",sb="AddN",V2="All",U2="Any",rb="ArgMax",ab="ArgMin",Df="Asin",Of="Asinh",zf="Atan",Ff="Atanh",Lf="Atan2",ib="AvgPool",W2="AvgPoolGrad",ob="AvgPool3D",G2="AvgPool3DGrad",lb="BatchMatMul",ub="BatchToSpaceND",H2="Bincount",cb="BitwiseAnd",F6="BroadcastTo",q2="BroadcastArgs",Mf="Cast",Bf="Ceil",Pf="ClipByValue",j2="Complex",db="ComplexAbs",hb="Concat",pb="Conv2D",K2="Conv2DBackpropFilter",fb="Conv2DBackpropInput",mb="Conv3D",X2="Conv3DBackpropFilterV2",Y2="Conv3DBackpropInputV2",Vf="Cos",Uf="Cosh",Z2="Cumprod",gb="Cumsum",Q2="CropAndResize",J2="DenseBincount",eS="DepthToSpace",yb="DepthwiseConv2dNative",tS="DepthwiseConv2dNativeBackpropFilter",nS="DepthwiseConv2dNativeBackpropInput",sS="Diag",bb="Dilation2D",C$="Dilation2DBackpropInput",T$="Dilation2DBackpropFilter",L6="Draw",Wf="RealDiv",rS="Einsum",Gf="Elu",aS="EluGrad",Hf="Erf",xb="Equal",qf="Exp",wb="ExpandDims",jf="Expm1",iS="FFT",oS="Fill",lS="FlipLeftRight",Kf="Floor",Xf="FloorDiv",vb="FusedBatchNorm",$b="GatherV2",uS="GatherNd",Sb="Greater",Yf="GreaterEqual",Zf="Identity",cS="IFFT",dS="Imag",Qf="IsFinite",Jf="IsInf",em="IsNan",_b="LeakyRelu",Cb="Less",Tb="LessEqual",hS="LinSpace",tm="Log",nm="Log1p",kb="LogicalAnd",Nb="LogicalNot",Ib="LogicalOr",M6="LogSoftmax",Eb="LRN",pS="LRNGrad",Ab="Max",sm="Maximum",Rb="MaxPool",fS="MaxPoolGrad",Db="MaxPool3D",mS="MaxPool3DGrad",gS="MaxPoolWithArgmax",Ob="Mean",zb="Min",rm="Minimum",Fb="MirrorPad",am="Mod",yS="Multinomial",im="Multiply",Lb="Neg",Mb="NotEqual",bS="NonMaxSuppressionV3",xS="NonMaxSuppressionV4",wS="NonMaxSuppressionV5",Bb="OnesLike",Pb="OneHot",Vb="Pack",Ub="PadV2",om="Pow",Wb="Prelu",Gb="Prod",vS="RaggedGather",$S="RaggedRange",SS="RaggedTensorToTensor",_S="Range",CS="Real",lm="Reciprocal",um="Relu",Hb="Reshape",qb="ResizeNearestNeighbor",TS="ResizeNearestNeighborGrad",jb="ResizeBilinear",kS="ResizeBilinearGrad",cm="Relu6",Kb="Reverse",dm="Round",hm="Rsqrt",NS="ScatterNd",IS="TensorScatterUpdate",ES="SearchSorted",Xb="Select",pm="Selu",Yb="Slice",fm="Sin",mm="Sinh",gm="Sign",ym="Sigmoid",bm="Softplus",xm="Sqrt",Zb="Sum",Qb="SpaceToBatchND",Jb="SplitV",ex="Softmax",AS="SparseFillEmptyRows",RS="SparseReshape",DS="SparseSegmentMean",OS="SparseSegmentSum",zS="SparseToDense",wm="SquaredDifference",FS="Square",tx="StaticRegexReplace",LS="StridedSlice",MS="StringNGrams",BS="StringSplit",PS="StringToHashBucketFast",vm="Sub",$m="Tan",Sm="Tanh",_m="Tile",VS="TopK",US="Transform",Ad="Transpose",WS="Unique",nx="Unpack",sx="UnsortedSegmentSum",rx="ZerosLike",Cm="Step",B6="FromPixels",GS="RotateWithOffset",y0="_FusedMatMul",b0="FusedConv2D",x0="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gr(...t){ye().getBool("IS_TEST")||ye().getBool("PROD")||console.warn(...t)}function P6(...t){ye().getBool("IS_TEST")||ye().getBool("PROD")||console.log(...t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w0=P2("kernelRegistry",()=>new Map),k$=P2("gradRegistry",()=>new Map);function iI(t,e){const n=eO(t,e);return w0.get(n)}function oI(t){return k$.get(t)}function lI(t){const e=w0.entries(),n=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[a,i]=r,[o]=a.split("_");o===t&&n.push(i)}return n}function JD(t){const{kernelName:e,backendName:n}=t,s=eO(e,n);w0.has(s)&&Gr(`The kernel '${e}' for backend '${n}' is already registered`),w0.set(s,t)}function V6(t){const{kernelName:e}=t;k$.has(e)&&ye().getBool("DEBUG")&&Gr(`Overriding the gradient for '${e}'`),k$.set(e,t)}function eO(t,e){return`${e}_${t}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tO(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}var av,uI;function U6(){if(uI)return av;uI=1,av=e;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(P,F,K){this.low=P|0,this.high=F|0,this.unsigned=!!K}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function n(P){return(P&&P.__isLong__)===!0}e.isLong=n;var s={},r={};function a(P,F){var K,X,te;return F?(P>>>=0,(te=0<=P&&P<256)&&(X=r[P],X)?X:(K=o(P,(P|0)<0?-1:0,!0),te&&(r[P]=K),K)):(P|=0,(te=-128<=P&&P<128)&&(X=s[P],X)?X:(K=o(P,P<0?-1:0,!1),te&&(s[P]=K),K))}e.fromInt=a;function i(P,F){if(isNaN(P))return F?$:v;if(F){if(P<0)return $;if(P>=y)return O}else{if(P<=-9223372036854776e3)return B;if(P+1>=x)return A}return P<0?i(-P,F).neg():o(P%g|0,P/g|0,F)}e.fromNumber=i;function o(P,F,K){return new e(P,F,K)}e.fromBits=o;var l=Math.pow;function c(P,F,K){if(P.length===0)throw Error("empty string");if(P==="NaN"||P==="Infinity"||P==="+Infinity"||P==="-Infinity")return v;if(typeof F=="number"?(K=F,F=!1):F=!!F,K=K||10,K<2||36<K)throw RangeError("radix");var X;if((X=P.indexOf("-"))>0)throw Error("interior hyphen");if(X===0)return c(P.substring(1),F,K).neg();for(var te=i(l(K,8)),Q=v,q=0;q<P.length;q+=8){var oe=Math.min(8,P.length-q),se=parseInt(P.substring(q,q+oe),K);if(oe<8){var ee=i(l(K,oe));Q=Q.mul(ee).add(i(se))}else Q=Q.mul(te),Q=Q.add(i(se))}return Q.unsigned=F,Q}e.fromString=c;function h(P,F){return typeof P=="number"?i(P,F):typeof P=="string"?c(P,F):o(P.low,P.high,typeof F=="boolean"?F:P.unsigned)}e.fromValue=h;var p=65536,f=1<<24,g=p*p,y=g*g,x=y/2,w=a(f),v=a(0);e.ZERO=v;var $=a(0,!0);e.UZERO=$;var T=a(1);e.ONE=T;var C=a(1,!0);e.UONE=C;var I=a(-1);e.NEG_ONE=I;var A=o(-1,2147483647,!1);e.MAX_VALUE=A;var O=o(-1,-1,!0);e.MAX_UNSIGNED_VALUE=O;var B=o(0,-2147483648,!1);e.MIN_VALUE=B;var z=e.prototype;return z.toInt=function(){return this.unsigned?this.low>>>0:this.low},z.toNumber=function(){return this.unsigned?(this.high>>>0)*g+(this.low>>>0):this.high*g+(this.low>>>0)},z.toString=function(F){if(F=F||10,F<2||36<F)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(B)){var K=i(F),X=this.div(K),te=X.mul(K).sub(this);return X.toString(F)+te.toInt().toString(F)}else return"-"+this.neg().toString(F);for(var Q=i(l(F,6),this.unsigned),q=this,oe="";;){var se=q.div(Q),ee=q.sub(se.mul(Q)).toInt()>>>0,U=ee.toString(F);if(q=se,q.isZero())return U+oe;for(;U.length<6;)U="0"+U;oe=""+U+oe}},z.getHighBits=function(){return this.high},z.getHighBitsUnsigned=function(){return this.high>>>0},z.getLowBits=function(){return this.low},z.getLowBitsUnsigned=function(){return this.low>>>0},z.getNumBitsAbs=function(){if(this.isNegative())return this.eq(B)?64:this.neg().getNumBitsAbs();for(var F=this.high!=0?this.high:this.low,K=31;K>0&&(F&1<<K)==0;K--);return this.high!=0?K+33:K+1},z.isZero=function(){return this.high===0&&this.low===0},z.eqz=z.isZero,z.isNegative=function(){return!this.unsigned&&this.high<0},z.isPositive=function(){return this.unsigned||this.high>=0},z.isOdd=function(){return(this.low&1)===1},z.isEven=function(){return(this.low&1)===0},z.equals=function(F){return n(F)||(F=h(F)),this.unsigned!==F.unsigned&&this.high>>>31===1&&F.high>>>31===1?!1:this.high===F.high&&this.low===F.low},z.eq=z.equals,z.notEquals=function(F){return!this.eq(F)},z.neq=z.notEquals,z.ne=z.notEquals,z.lessThan=function(F){return this.comp(F)<0},z.lt=z.lessThan,z.lessThanOrEqual=function(F){return this.comp(F)<=0},z.lte=z.lessThanOrEqual,z.le=z.lessThanOrEqual,z.greaterThan=function(F){return this.comp(F)>0},z.gt=z.greaterThan,z.greaterThanOrEqual=function(F){return this.comp(F)>=0},z.gte=z.greaterThanOrEqual,z.ge=z.greaterThanOrEqual,z.compare=function(F){if(n(F)||(F=h(F)),this.eq(F))return 0;var K=this.isNegative(),X=F.isNegative();return K&&!X?-1:!K&&X?1:this.unsigned?F.high>>>0>this.high>>>0||F.high===this.high&&F.low>>>0>this.low>>>0?-1:1:this.sub(F).isNegative()?-1:1},z.comp=z.compare,z.negate=function(){return!this.unsigned&&this.eq(B)?B:this.not().add(T)},z.neg=z.negate,z.add=function(F){n(F)||(F=h(F));var K=this.high>>>16,X=this.high&65535,te=this.low>>>16,Q=this.low&65535,q=F.high>>>16,oe=F.high&65535,se=F.low>>>16,ee=F.low&65535,U=0,G=0,Y=0,ce=0;return ce+=Q+ee,Y+=ce>>>16,ce&=65535,Y+=te+se,G+=Y>>>16,Y&=65535,G+=X+oe,U+=G>>>16,G&=65535,U+=K+q,U&=65535,o(Y<<16|ce,U<<16|G,this.unsigned)},z.subtract=function(F){return n(F)||(F=h(F)),this.add(F.neg())},z.sub=z.subtract,z.multiply=function(F){if(this.isZero())return v;if(n(F)||(F=h(F)),t){var K=t.mul(this.low,this.high,F.low,F.high);return o(K,t.get_high(),this.unsigned)}if(F.isZero())return v;if(this.eq(B))return F.isOdd()?B:v;if(F.eq(B))return this.isOdd()?B:v;if(this.isNegative())return F.isNegative()?this.neg().mul(F.neg()):this.neg().mul(F).neg();if(F.isNegative())return this.mul(F.neg()).neg();if(this.lt(w)&&F.lt(w))return i(this.toNumber()*F.toNumber(),this.unsigned);var X=this.high>>>16,te=this.high&65535,Q=this.low>>>16,q=this.low&65535,oe=F.high>>>16,se=F.high&65535,ee=F.low>>>16,U=F.low&65535,G=0,Y=0,ce=0,pe=0;return pe+=q*U,ce+=pe>>>16,pe&=65535,ce+=Q*U,Y+=ce>>>16,ce&=65535,ce+=q*ee,Y+=ce>>>16,ce&=65535,Y+=te*U,G+=Y>>>16,Y&=65535,Y+=Q*ee,G+=Y>>>16,Y&=65535,Y+=q*se,G+=Y>>>16,Y&=65535,G+=X*U+te*ee+Q*se+q*oe,G&=65535,o(ce<<16|pe,G<<16|Y,this.unsigned)},z.mul=z.multiply,z.divide=function(F){if(n(F)||(F=h(F)),F.isZero())throw Error("division by zero");if(t){if(!this.unsigned&&this.high===-2147483648&&F.low===-1&&F.high===-1)return this;var K=(this.unsigned?t.div_u:t.div_s)(this.low,this.high,F.low,F.high);return o(K,t.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?$:v;var X,te,Q;if(this.unsigned){if(F.unsigned||(F=F.toUnsigned()),F.gt(this))return $;if(F.gt(this.shru(1)))return C;Q=$}else{if(this.eq(B)){if(F.eq(T)||F.eq(I))return B;if(F.eq(B))return T;var q=this.shr(1);return X=q.div(F).shl(1),X.eq(v)?F.isNegative()?T:I:(te=this.sub(F.mul(X)),Q=X.add(te.div(F)),Q)}else if(F.eq(B))return this.unsigned?$:v;if(this.isNegative())return F.isNegative()?this.neg().div(F.neg()):this.neg().div(F).neg();if(F.isNegative())return this.div(F.neg()).neg();Q=v}for(te=this;te.gte(F);){X=Math.max(1,Math.floor(te.toNumber()/F.toNumber()));for(var oe=Math.ceil(Math.log(X)/Math.LN2),se=oe<=48?1:l(2,oe-48),ee=i(X),U=ee.mul(F);U.isNegative()||U.gt(te);)X-=se,ee=i(X,this.unsigned),U=ee.mul(F);ee.isZero()&&(ee=T),Q=Q.add(ee),te=te.sub(U)}return Q},z.div=z.divide,z.modulo=function(F){if(n(F)||(F=h(F)),t){var K=(this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,F.low,F.high);return o(K,t.get_high(),this.unsigned)}return this.sub(this.div(F).mul(F))},z.mod=z.modulo,z.rem=z.modulo,z.not=function(){return o(~this.low,~this.high,this.unsigned)},z.and=function(F){return n(F)||(F=h(F)),o(this.low&F.low,this.high&F.high,this.unsigned)},z.or=function(F){return n(F)||(F=h(F)),o(this.low|F.low,this.high|F.high,this.unsigned)},z.xor=function(F){return n(F)||(F=h(F)),o(this.low^F.low,this.high^F.high,this.unsigned)},z.shiftLeft=function(F){return n(F)&&(F=F.toInt()),(F&=63)===0?this:F<32?o(this.low<<F,this.high<<F|this.low>>>32-F,this.unsigned):o(0,this.low<<F-32,this.unsigned)},z.shl=z.shiftLeft,z.shiftRight=function(F){return n(F)&&(F=F.toInt()),(F&=63)===0?this:F<32?o(this.low>>>F|this.high<<32-F,this.high>>F,this.unsigned):o(this.high>>F-32,this.high>=0?0:-1,this.unsigned)},z.shr=z.shiftRight,z.shiftRightUnsigned=function(F){if(n(F)&&(F=F.toInt()),F&=63,F===0)return this;var K=this.high;if(F<32){var X=this.low;return o(X>>>F|K<<32-F,K>>>F,this.unsigned)}else return F===32?o(K,0,this.unsigned):o(K>>>F-32,0,this.unsigned)},z.shru=z.shiftRightUnsigned,z.shr_u=z.shiftRightUnsigned,z.toSigned=function(){return this.unsigned?o(this.low,this.high,!1):this},z.toUnsigned=function(){return this.unsigned?this:o(this.low,this.high,!0)},z.toBytes=function(F){return F?this.toBytesLE():this.toBytesBE()},z.toBytesLE=function(){var F=this.high,K=this.low;return[K&255,K>>>8&255,K>>>16&255,K>>>24,F&255,F>>>8&255,F>>>16&255,F>>>24]},z.toBytesBE=function(){var F=this.high,K=this.low;return[F>>>24,F>>>16&255,F>>>8&255,F&255,K>>>24,K>>>16&255,K>>>8&255,K&255]},e.fromBytes=function(F,K,X){return X?e.fromBytesLE(F,K):e.fromBytesBE(F,K)},e.fromBytesLE=function(F,K){return new e(F[0]|F[1]<<8|F[2]<<16|F[3]<<24,F[4]|F[5]<<8|F[6]<<16|F[7]<<24,K)},e.fromBytesBE=function(F,K){return new e(F[4]<<24|F[5]<<16|F[6]<<8|F[7],F[0]<<24|F[1]<<16|F[2]<<8|F[3],K)},av}var nO=U6();const sO=ID(nO),W6=BG({__proto__:null,default:sO},[nO]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gu=sO||W6;function ax(t){return Gu.fromString(t,!0,16)}const rO=ax("c3a5c85c97cb3127"),Wu=ax("b492b66fbe98f273"),Us=ax("9ae16a3b2f90404f");function N$(t){return t.xor(t.shru(47))}function aO(t,e,n){const s=t.slice(e,e+n);return Gu.fromBytes(Array.from(s),!0,!0)}function an(t,e){return aO(t,e,8)}function cI(t,e){return aO(t,e,4)}function ns(t,e){return e===0?t:t.shru(e).or(t.shl(64-e))}function Nl(t,e,n=ax("9ddfea08eb382d69")){let s=t.xor(e).mul(n);s=s.xor(s.shru(47));let r=e.xor(s).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function G6(t,e,n,s,r,a){r=r.add(t),a=ns(a.add(r).add(s),21);const i=r;return r=r.add(e),r=r.add(n),a=a.add(ns(r,44)),[r.add(s),a.add(i)]}function Cy(t,e,n,s){return G6(an(t,e),an(t,e+8),an(t,e+16),an(t,e+24),n,s)}function H6(t,e=t.length){if(e>=8){const n=Us.add(e*2),s=an(t,0).add(Us),r=an(t,e-8),a=ns(r,37).mul(n).add(s),i=ns(s,25).add(r).mul(n);return Nl(a,i,n)}if(e>=4){const n=Us.add(e*2),s=cI(t,0);return Nl(s.shl(3).add(e),cI(t,e-4),n)}if(e>0){const n=t[0],s=t[e>>1],r=t[e-1],a=n+(s<<8),i=e+(r<<2);return N$(Us.mul(a).xor(rO.mul(i))).mul(Us)}return Us}function q6(t,e=t.length){const n=Us.add(e*2),s=an(t,0).mul(Wu),r=an(t,8),a=an(t,e-8).mul(n),i=an(t,e-16).mul(Us);return Nl(ns(s.add(r),43).add(ns(a,30)).add(i),s.add(ns(r.add(Us),18)).add(a),n)}function j6(t,e=t.length){const n=Us.add(e*2),s=an(t,0).mul(Us),r=an(t,8),a=an(t,e-8).mul(n),i=an(t,e-16).mul(Us),o=ns(s.add(r),43).add(ns(a,30)).add(i),l=Nl(o,s.add(ns(r.add(Us),18)).add(a),n),c=an(t,16).mul(n),h=an(t,24),p=o.add(an(t,e-32)).mul(n),f=l.add(an(t,e-24)).mul(n);return Nl(ns(c.add(h),43).add(ns(p,30)).add(f),c.add(ns(h.add(s),18)).add(p),n)}function K6(t,e=t.length){const n=Gu.fromNumber(81,!0);if(e<=32)return e<=16?H6(t,e):q6(t,e);if(e<=64)return j6(t,e);let s=n,r=n.mul(Wu).add(113),a=N$(r.mul(Us).add(113)).mul(Us),i=[Gu.UZERO,Gu.UZERO],o=[Gu.UZERO,Gu.UZERO];s=s.mul(Us).add(an(t,0));let l=0;const c=(e-1>>6)*64,h=c+(e-1&63)-63;do s=ns(s.add(r).add(i[0]).add(an(t,l+8)),37).mul(Wu),r=ns(r.add(i[1]).add(an(t,l+48)),42).mul(Wu),s=s.xor(o[1]),r=r.add(i[0]).add(an(t,l+40)),a=ns(a.add(o[0]),33).mul(Wu),i=Cy(t,l,i[1].mul(Wu),s.add(o[0])),o=Cy(t,l+32,a.add(o[1]),r.add(an(t,l+16))),[a,s]=[s,a],l+=64;while(l!==c);const p=Wu.add(a.and(255).shl(1));return l=h,o[0]=o[0].add(e-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),s=ns(s.add(r).add(i[0]).add(an(t,l+8)),37).mul(p),r=ns(r.add(i[1]).add(an(t,l+48)),42).mul(p),s=s.xor(o[1].mul(9)),r=r.add(i[0].mul(9).add(an(t,l+40))),a=ns(a.add(o[0]),33).mul(p),i=Cy(t,l,i[1].mul(p),s.add(o[0])),o=Cy(t,l+32,a.add(o[1]),r.add(an(t,l+16))),[a,s]=[s,a],Nl(Nl(i[0],o[0],p).add(N$(r).mul(rO)).add(a),Nl(i[1],o[1],p).add(s),p)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gl(t,e){return e==="string"?Il(t):wc([t],e)}function X6(t,e){return t instanceof Float32Array&&e==="float32"||t instanceof Int32Array&&e==="int32"||t instanceof Uint8Array&&e==="bool"}function wc(t,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=sc(t)),ye().getBool("DEBUG")&&C6(t,e),X6(t,e))return t;if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool"){const n=new Uint8Array(t.length);for(let s=0;s<n.length;++s)Math.round(t[s])!==0&&(n[s]=1);return n}else throw new Error(`Unknown data type ${e}`)}function sr(){return ye().platform.now()}function Il(t,e="utf-8"){return e=e||"utf-8",ye().platform.encode(t,e)}function Rl(t,e="utf-8"){return e=e||"utf-8",ye().platform.decode(t,e)}function va(t){return ye().platform.isTypedArray!=null?ye().platform.isTypedArray(t):tO(t)}function sc(t,e=[],n=!1){if(e==null&&(e=[]),typeof t=="boolean"||typeof t=="number"||typeof t=="string"||nc(t)||t==null||va(t)&&n)e.push(t);else if(Array.isArray(t)||va(t))for(let s=0;s<t.length;++s)sc(t[s],e,n);else{let s=-1;for(const r of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)sc(t[r],e,n)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Y6{constructor(e,n){this.backendTimer=e,this.logger=n,n==null&&(this.logger=new Q6)}profileKernel(e,n,s){let r;const a=()=>{r=s()};let i;const o=sr();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(a);else{a();for(const c of r)c.dataSync();i=Promise.resolve({kernelMs:sr()-o})}if(ye().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<r.length;c++){const h=r[c];h.data().then(p=>{Z6(p,h.dtype,e)})}return{kernelName:e,outputs:r,inputs:n,timeMs:i.then(c=>c.kernelMs),extraInfo:i.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:n,outputs:s,timeMs:r,inputs:a,extraInfo:i}=e;s.forEach(o=>{Promise.all([o.data(),r,i]).then(l=>{this.logger.logKernelProfile(n,o,l[0],l[1],a,l[2])})})}}function Z6(t,e,n){if(e!=="float32")return!1;for(let s=0;s<t.length;s++){const r=t[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class Q6{logKernelProfile(e,n,s,r,a,i){const o=typeof r=="number"?Ed(`${r}ms`,9):r.error,l=Ed(e,25),c=n.rank,h=n.size,p=Ed(n.shape.toString(),14);let f="";for(const g in a){const y=a[g];if(y!=null){const x=y.shape||n.shape,w=x.length;f+=`${g}: ${w}D ${w>0?x:""} `}}console.log(`%c${l}	%c${o}	%c${c}D ${p}	%c${h}	%c${f}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J6(t,e,n){const s={},r={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<t.length;l++){const c=t[l],h=c.inputs;for(const p in h){const f=h[p];let g=!1;for(let y=0;y<e.length;y++)if(s[f.id]){c.outputs.forEach(x=>s[x.id]=!0),g=!0,r[c.id]=!0;break}if(g)break}}const a={};a[n.id]=!0;const i={};for(let l=t.length-1;l>=0;l--){const c=t[l],h=c.inputs;for(let p=0;p<c.outputs.length;p++)if(a[c.outputs[p].id]){for(const f in h)a[h[f].id]=!0,i[c.id]=!0;break}}const o=[];for(let l=0;l<t.length;l++){const c=t[l];if(r[c.id]&&i[c.id]){const h={};for(const f in c.inputs){const g=c.inputs[f];s[g.id]&&(h[f]=g)}const p=Object.assign({},c);p.inputs=h,p.outputs=c.outputs,o.push(p)}}return o}function eq(t,e,n,s){for(let r=e.length-1;r>=0;r--){const a=e[r],i=[];if(a.outputs.forEach(l=>{const c=t[l.id];c!=null?i.push(c):i.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const l in a.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);const c=n(()=>o[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const h=a.inputs[l];if(!Rt(c.shape,h.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${h.shape}'`);if(t[h.id]==null)t[h.id]=c;else{const p=t[h.id];t[h.id]=s(p,c),p.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dI=20,Lp=3,iv=7;function tq(t,e,n,s){const r=nt(e),a=nq(t,e,n,r),i=e.length,o=n0(t,e,n,r,a),l=["Tensor"];return s&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(o.map(c=>"    "+c).join(`
`)),l.join(`
`)}function nq(t,e,n,s){const r=$e(e),a=s[s.length-1],i=new Array(a).fill(0),o=e.length,l=n==="complex64"?Zp(t):t;if(o>1)for(let c=0;c<r/a;c++){const h=c*a;for(let p=0;p<a;p++)i[p]=Math.max(i[p],Yp(l[h+p],0,n).length)}return i}function Yp(t,e,n){let s;return Array.isArray(t)?s=`${parseFloat(t[0].toFixed(iv))} + ${parseFloat(t[1].toFixed(iv))}j`:Ef(t)?s=`'${t}'`:n==="bool"?s=iO(t):s=parseFloat(t.toFixed(iv)).toString(),Ed(s,e)}function iO(t){return t===0?"false":"true"}function n0(t,e,n,s,r,a=!0){const i=n==="complex64"?2:1,o=e[0],l=e.length;if(l===0){if(n==="complex64"){const x=Zp(t);return[Yp(x[0],0,n)]}return n==="bool"?[iO(t[0])]:[t[0].toString()]}if(l===1){if(o>dI){const w=Lp*i;let v=Array.from(t.slice(0,w)),$=Array.from(t.slice((o-Lp)*i,o*i));return n==="complex64"&&(v=Zp(v),$=Zp($)),["["+v.map((T,C)=>Yp(T,r[C],n)).join(", ")+", ..., "+$.map((T,C)=>Yp(T,r[o-Lp+C],n)).join(", ")+"]"]}return["["+(n==="complex64"?Zp(t):Array.from(t)).map((w,v)=>Yp(w,r[v],n)).join(", ")+"]"]}const c=e.slice(1),h=s.slice(1),p=s[0]*i,f=[];if(o>dI){for(let x=0;x<Lp;x++){const w=x*p,v=w+p;f.push(...n0(t.slice(w,v),c,n,h,r,!1))}f.push("...");for(let x=o-Lp;x<o;x++){const w=x*p,v=w+p;f.push(...n0(t.slice(w,v),c,n,h,r,x===o-1))}}else for(let x=0;x<o;x++){const w=x*p,v=w+p;f.push(...n0(t.slice(w,v),c,n,h,r,x===o-1))}const g=l===2?",":"";f[0]="["+(o>0?f[0]+g:"");for(let x=1;x<f.length-1;x++)f[x]=" "+f[x]+g;let y=`,
`;for(let x=2;x<l;x++)y+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(a?"":y),f}function Zp(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kn{constructor(e,n,s){if(this.dtype=n,this.shape=e.slice(),this.size=$e(e),s!=null){const r=s.length;V(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||An(n,this.size),this.strides=nt(e)}set(e,...n){n.length===0&&(n=[0]),V(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const s=this.locToIndex(n);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let n=0;for(const r of e){if(r<0||r>=this.shape[n]){const a=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(a)}n++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let n=e[e.length-1];for(let s=0;s<e.length-1;++s)n+=this.strides[s]*e[s];return n}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const n=new Array(this.shape.length);for(let s=0;s<n.length-1;++s)n[s]=Math.floor(e/this.strides[s]),e-=n[s]*this.strides[s];return n[n.length-1]=e,n}get rank(){return this.shape.length}toTensor(){return Wa().makeTensor(this.values,this.shape,this.dtype)}}let Wa=null,_d=null;function sq(t){Wa=t}function rq(t){_d=t}class yn{constructor(e,n,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=n||"float32",this.size=$e(e),this.strides=nt(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return _d.buffer(this.shape,this.dtype,e)}bufferSync(){return _d.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return xa(this.shape,e,this.dtype==="complex64")}arraySync(){return xa(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Wa().read(this.dataId);if(this.dtype==="string"){const n=await e;try{return n.map(s=>Rl(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Wa().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Wa().readSync(this.dataId);if(this.dtype==="string")try{return e.map(n=>Rl(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Wa().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Wa().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return _d.print(this,e)}clone(){return this.throwIfDisposed(),_d.clone(this)}toString(e=!1){const n=this.dataSync();return tq(n,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),_d.cast(this,e)}variable(e=!0,n,s){return this.throwIfDisposed(),Wa().makeVariable(this,e,n,s)}}Object.defineProperty(yn,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function _e(){return P2("Tensor",()=>yn)}_e();class v0 extends yn{constructor(e,n,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=n,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Rt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Wa().disposeTensor(this),this.dataId=e.dataId,Wa().incRef(this,null)}dispose(){Wa().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(v0,Symbol.hasInstance,{value:t=>t instanceof yn&&t.assign!=null&&t.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var hI;(function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"})(hI||(hI={}));var I$;(function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"})(I$||(I$={}));var E$;(function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"})(E$||(E$={}));var A$;(function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"})(A$||(A$={}));var R$;(function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"})(R$||(R$={}));const aq={float32:A$,int32:I$,bool:E$,complex64:R$};function _r(t,e){if(t==="string"||e==="string"){if(t==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return aq[t][e]}function HS(t){return _r(t,"int32")}function oO(t){return t!=null&&typeof t=="object"&&"texture"in t&&t.texture instanceof WebGLTexture}function lO(t){return typeof GPUBuffer<"u"&&t!=null&&typeof t=="object"&&"buffer"in t&&t.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cn(t,e){if(t.dtype===e.dtype)return[t,e];const n=_r(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function iq(t,e){V(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function uO(t){const e=[];return cO(t,e,new Set),e}function cO(t,e,n){if(t==null)return;if(t instanceof yn){e.push(t);return}if(!oq(t))return;const s=t;for(const r in s){const a=s[r];n.has(a)||(n.add(a),cO(a,e,n))}}function oq(t){return Array.isArray(t)||typeof t=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ov(t){return t.kernelName!=null}class pI{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Md{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new pI}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const s=e[n];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:n}=this.initializeBackend(e);if(n)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,n,s=1){return e in this.registryFactory?(Gr(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:n,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:n,asyncInit:s}=this.initializeBackend(e);if(!(s?await n:n))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Y6(this.backendInstance),!0}setupRegisteredKernels(){lI(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){lI(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const n=this.registryFactory[e];if(n==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=n.factory();if(s&&!(s instanceof L2)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,a=s.then(i=>r<this.pendingBackendInitId?!1:(this.registry[e]=i,this.pendingBackendInit=null,!0)).catch(i=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Gr(`Initialization of backend ${e} failed`),Gr(i.stack||i.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return Gr(`Initialization of backend ${e} failed`),Gr(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,n)=>this.registryFactory[n].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const s=e[n],{success:r,asyncInit:a}=this.initializeBackend(s);if(a||r)return{name:s,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,n){const s=this.state.tensorInfo.get(n),r=s.backend,a=this.readSync(n),i=r.refCount(n);r.disposeData(n,!0),s.backend=e,e.move(n,a,s.shape,s.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,n){let s=null;if(n==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");n=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=n(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,n,s){e();try{const r=s();return n(),r}catch(r){throw n(),r}}nextTensorId(){return Md.nextTensorId++}nextVariableId(){return Md.nextVariableId++}clone(e){const n=ie.runKernel(Zf,{x:e}),s={x:e},r=i=>({x:()=>{const o="float32",l={x:i},c={dtype:o};return ie.runKernel(Mf,l,c)}}),a=[];return this.addTapeNode(this.state.activeScope.name,s,[n],r,a,{}),n}runKernel(e,n,s){if(this.backendName==null&&this.backend,!(iI(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:n,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,n,s){const r=this.backend.numDataIds();let a=0;s.forEach(l=>{a+=l.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-n-a-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let n,s=[];const r=this.isTapeOn(),a=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l;const c=ov(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(ov(e)){const{kernelName:y,inputs:x,attrs:w}=e;this.backendName==null&&this.backend;const v=iI(y,this.backendName);V(v!=null,()=>`Cannot find registered kernel '${y}' for backend '${this.backendName}'`),o=()=>{const $=this.backend.numDataIds();l=v.kernelFunc({inputs:x,attrs:w,backend:this.backend});const T=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(y,$,T);const C=T.map(I=>I.rank!=null?I:this.makeTensorFromTensorInfo(I));if(r){const I=this.getTensorsForGradient(y,x,C);s=this.saveTensorsForBackwardMode(I)}return C}}else{const{forwardFunc:y}=e,x=w=>{r&&(s=w.map(v=>this.keep(this.clone(v))))};o=()=>{const w=this.backend.numDataIds();l=this.tidy(()=>y(this.backend,x));const v=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,w,v),v}}const{inputs:h,attrs:p}=e,f=ov(e)?null:e.backwardsFunc;let g;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=o():(g=this.profiler.profileKernel(c,h,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(g),n=g.outputs)}),r&&this.addTapeNode(c,h,n,f,s,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map(y=>h[y]!=null?h[y].shape:null),outputShapes:n.map(y=>y.shape),kernelTimeMs:g.timeMs,extraInfo:g.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,n,s){const r=oI(e);if(r!=null){const a=r.inputsToSave||[],i=r.outputsToSave||[];let o;r.saveAllInputs?(V(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(c=>n[c])):o=a.map(c=>n[c]);const l=s.filter((c,h)=>i[h]);return o.concat(l)}return[]}makeTensor(e,n,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let a=e;s==="string"&&Ef(e[0])&&(a=e.map(l=>Il(l)));const i=r.write(a,n,s),o=new yn(n,s,i,this.nextTensorId());if(this.trackTensor(o,r),s==="string"){const l=this.state.tensorInfo.get(i),c=k6(a);this.state.numBytes+=c-l.bytes,l.bytes=c}return o}makeTensorFromDataId(e,n,s,r){s=s||"float32";const a={dataId:e,shape:n,dtype:s};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,n){const{dataId:s,shape:r,dtype:a}=e,i=new yn(r,a,s,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(e,n=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const a=new v0(e,n,s,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,n){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*g0(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:n||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof v0||this.track(e)}incRef(e,n){this.trackTensor(e,n),this.backend.incRef(e.dataId)}removeDataId(e,n){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===n&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const n=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*g0(e.dtype);this.state.numBytes-=s}n.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,n.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const n=this.state.registeredVariables[e];this.disposeVariable(n)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const n=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,n,s,r,a,i){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:n,outputs:s,saved:a},l=oI(e);l!=null&&(r=l.gradFunc),r!=null&&(o.gradient=c=>(c=c.map((h,p)=>{if(h==null){const f=s[p],g=Rs(f.size,f.dtype);return this.makeTensor(g,f.shape,f.dtype)}return h}),r(c.length>1?c:c[0],a,i))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(n.name=e),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(e){const n=uO(e),s=new Set(n.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const i=this.state.activeScope.track[a];!i.kept&&!s.has(i.id)&&i.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(a=>{!a.kept&&a.scopeId===r.id&&this.track(a)})}gradients(e,n,s,r=!1){if(V(n.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));V(a instanceof yn,()=>"The result y returned by f() must be a tensor.");const i=J6(this.state.activeTape,n,a);if(!r&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[a.id]=s??lq(a.shape),eq(o,i,c=>this.tidy(c),uq);const l=n.map(c=>o[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const h of c.saved)h.dispose()}),this.state.activeTape=null),{value:a,grads:l}})}customGrad(e){return V(S$(e),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{V(n.every(o=>o instanceof yn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};n.forEach((o,l)=>{r[l]=o});const a=(o,l)=>(s=e(...n,l),V(s.value instanceof yn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),V(S$(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),i=(o,l)=>{const c=s.gradFunc(o,l),h=Array.isArray(c)?c:[c];V(h.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),V(h.every(f=>f instanceof yn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const p={};return h.forEach((f,g)=>{p[g]=()=>f}),p};return this.runKernelFunc({forwardFunc:a,backwardsFunc:i,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,n){return this.state.tensorInfo.get(e).backend.readToGPU(e,n)}async time(e){const n=sr(),s=await this.backend.time(e);return s.wallMs=sr()-n,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new pI;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Md.nextTensorId=0;Md.nextVariableId=0;function lq(t){const e=B2($e(t),"float32");return ie.makeTensor(e,t,"float32")}function dO(){const t=QD();if(t._tfengine==null){const e=new E6(t);t._tfengine=new Md(e)}return O6(t._tfengine.ENV),sq(()=>t._tfengine),t._tfengine}const ie=dO();function uq(t,e){const n={a:t,b:e};return ie.runKernel(th,n)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cq(){return typeof navigator<"u"&&navigator!=null}function hO(t){if(t||cq()){if(t||(t=navigator),t.product==="ReactNative")return!0;const e=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");if(!e){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function pO(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const or=ye();or.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});or.registerFlag("IS_BROWSER",()=>pO());or.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");or.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));or.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));or.registerFlag("PROD",()=>!1);or.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>or.getBool("DEBUG"));or.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);or.registerFlag("IS_TEST",()=>!1);or.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>or.getBool("DEBUG"));or.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);or.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);or.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hl(t,e){let n=t;if(va(t))return e==="string"?[]:[t.length];if(oO(t)){const r=t.channels||"RGBA";return[t.height,t.width*r.length]}else if(lO(t))return[t.buffer.size/(e==null?4:g0(e))];if(!Array.isArray(t))return[];const s=[];for(;Array.isArray(n)||va(n)&&e!=="string";)s.push(n.length),n=n[0];return Array.isArray(t)&&ye().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&fO(t,s,[]),s}function fO(t,e,n){if(n=n||[],!Array.isArray(t)&&!va(t)){V(e.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}V(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),V(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const s=e.slice(1);for(let r=0;r<t.length;++r)fO(t[r],s,n.concat(r))}function fI(t,e,n,s){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==e||t==="numeric"&&e==="string")throw new Error(`Argument '${n}' passed to '${s}' must be ${t} tensor, but got ${e} tensor`)}}function W(t,e,n,s="numeric"){if(t instanceof _e())return fI(s,t.dtype,e,n),t;let r=Jd(t);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),fI(s,r,e,n),t==null||!va(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){const l=t==null?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}const a=Hl(t,r);!va(t)&&!Array.isArray(t)&&(t=[t]);const o=r!=="string"?wc(t,r):sc(t,[],!0);return ie.makeTensor(o,a,r)}function $0(t,e,n,s="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((a,i)=>W(a,`${e}[${i}]`,n,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mO="__op";function ne(t){const e=Object.keys(t);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const s=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+mO;const r=(...a)=>{ie.startScope(n);try{const i=s(...a);return nc(i)&&console.error("Cannot return a Promise inside of tidy."),ie.endScope(i),i}catch(i){throw ie.endScope(null),i}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dq(t,e){const n=W(t,"real","complex"),s=W(e,"imag","complex");Er(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:n,imag:s};return ie.runKernel(j2,r)}const Dl=ne({complex_:dq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ql(t,e,n,s){if(s==null)s=Jd(t);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(lO(t)||oO(t)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return ie.backend.createTensorFromGPUData(t,e||n,s)}if(!va(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Yr(e);const r=$e(e),a=$e(n);V(r===a,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${a}`);for(let i=0;i<n.length;++i){const o=n[i],l=i===n.length-1?o!==$e(e.slice(i)):!0;V(n[i]===e[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return!va(t)&&!Array.isArray(t)&&(t=[t]),e=e||n,t=s!=="string"?wc(t,s):sc(t,[],!0),ie.makeTensor(t,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ha(t,e,n){const s=Hl(t,n);return ql(t,e,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rc={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Qa{static join(e){return new Qa(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>va(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let n=0;for(let s=0;s<e.length;s++){const r=e[s];s!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=n+r.byteLength;this.shards.push({buffer:r,start:n,end:a}),n=a}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,n=isNaN(Number(n))?0:n,e=Math.max(0,e),n=Math.min(this.byteLength,n),n<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const r=n-e,a=new ArrayBuffer(r),i=new Uint8Array(a);let o=0;for(let l=s;l<this.shards.length;l++){const c=this.shards[l],p=e+o-c.start,f=o,y=Math.min(n,c.end)-c.start,x=new Uint8Array(c.buffer,p,y-p);if(i.set(x,f),o+=x.length,n<c.end)break}return a}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function n(r){return e<r.start?-1:e>=r.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=hq(this.shards,n);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function hq(t,e){let n=0,s=t.length;for(;n<=s;){const r=Math.floor((s-n)/2)+n,a=e(t[r]);if(a===0)return r;a<0?s=r:n=r+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ua(){return ie}function mI(){return ie.memory()}function me(t,e){return ie.tidy(t,e)}function $t(t){uO(t).forEach(n=>n.dispose())}function ss(t){return ie.keep(t)}function pq(){return ie.ready()}function fq(){return ie.backendName}function gO(t,e,n=1){return ie.registerBackend(t,e,n)}function yO(){return ie.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ol=4;async function D$(t,e){const n=[],s=[],r=Array.isArray(t)?t.map(i=>i.name):Object.keys(t);for(let i=0;i<r.length;++i){const o=r[i],l=Array.isArray(t)?t[i].tensor:t[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);const c={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const h=new Promise(async p=>{const f=await l.bytes(),g=f.reduce((w,v)=>w+v.length,0)+Ol*f.length,y=new Uint8Array(g);let x=0;for(let w=0;w<f.length;w++){const v=f[w],$=new Uint8Array(new Uint32Array([v.length]).buffer);y.set($,x),x+=Ol,y.set(v,x),x+=v.length}p(y)});s.push(h)}else s.push(l.data());e!=null&&(c.group=e),n.push(c)}const a=await Promise.all(s);return{data:yq(a),specs:n}}function bO(t,e){const n=new Qa(t),s={};let r=0;for(const a of e){const i=mq(a,(o,l)=>n.slice(r+o,r+l));s[a.name]=xO(a,n.slice(r,r+i)),r+=i}return s}function mq(t,e){const n=$e(t.shape);let s;if("quantization"in t){const r=t.quantization;s=rc[r.dtype]}else if(t.dtype==="string"){let r=0;for(let a=0;a<n;a++)r+=Ol+new Uint32Array(e(r,r+Ol))[0];return r}else s=rc[t.dtype];return n*s}async function gq(t,e){const n=$e(t.shape);let s;if("quantization"in t){const r=t.quantization;s=rc[r.dtype]}else if(t.dtype==="string"){let r=0;for(let a=0;a<n;a++)r+=Ol+new Uint32Array(await e(r,r+Ol))[0];return r}else s=rc[t.dtype];return n*s}function xO(t,e){const n=t.name,s=t.dtype,r=t.shape,a=$e(r);let i,o=0;if("quantization"in t){const l=t.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${t.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${t.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${t.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const c=rc[l.dtype],h=l.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(s==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(h.length);for(let p=0;p<h.length;p++){const f=h[p];i[p]=f*l.scale+l.min}}else if(l.dtype==="float16")i=Sq()(h);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(s==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(h.length);for(let p=0;p<h.length;p++){const f=h[p];i[p]=Math.round(f*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${s}`);o+=a*c}else if(s==="string"){const l=$e(t.shape);i=[];for(let c=0;c<l;c++){const h=new Uint32Array(e.slice(o,o+Ol))[0];o+=Ol;const p=new Uint8Array(e.slice(o,o+h));i.push(p),o+=h}}else{const l=rc[s];if(s==="float32")i=new Float32Array(e);else if(s==="int32")i=new Int32Array(e);else if(s==="bool")i=new Uint8Array(e);else if(s==="complex64"){i=new Float32Array(e);const c=new Float32Array(i.length/2),h=new Float32Array(i.length/2);for(let y=0;y<c.length;y++)c[y]=i[y*2],h[y]=i[y*2+1];const p=Ha(c,r,"float32"),f=Ha(h,r,"float32"),g=Dl(p,f);return p.dispose(),f.dispose(),g}else throw new Error(`Unsupported dtype in weight '${n}': ${s}`);o+=a*l}return Ha(i,r,s)}async function gI(t,e,n){let s=new Uint8Array(e);for(;s.byteLength<n;){const{done:r,value:a}=await t.read();if(r&&a==null){const o=n-s.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}const i=new Uint8Array(s.length+a.byteLength);i.set(s,0),i.set(new Uint8Array(a),s.length),s=i}return s.buffer}async function wO(t,e){const n={},s=t.getReader();let r=new ArrayBuffer(0);for(const a of e){const i=await gq(a,async(c,h)=>(r=await gI(s,r,h),r.slice(c,h)));r=await gI(s,r,i);const o=r.slice(0,i);r=r.slice(i);const l=xO(a,o);if(n[a.name]=l,fq()==="webgpu"){const c=yO();"uploadToGPU"in c&&$e(l.shape)>=ye().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&c.uploadToGPU(l.dataId)}}return n}function yq(t){if(t===null)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(a=>{if(e+=a.byteLength,n.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const s=new Uint8Array(e);let r=0;return n.forEach(a=>{s.set(new Uint8Array(a.buffer),r),r+=a.byteLength}),s.buffer}const qS=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function yI(t){return qS?Buffer.byteLength(t,"utf8"):new Blob([t]).size}function bq(t){if(qS)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let s=0,r=e.length;s<r;s++)n+=String.fromCharCode(e[s]);return btoa(n)}function xq(t){if(qS){const s=Buffer.from(t,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let s=0;s<e.length;++s)n.set([e.charCodeAt(s)],s);return n.buffer}function vO(t){return Qa.join(t)}function bI(t){const e="/";for(t=t.trim();t.endsWith(e);)t=t.slice(0,t.length-1);const n=t.split(e);return n[n.length-1]}function $O(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(n.initializerSignature=t.initializerSignature),t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),n}function SO(t,e,n){const s={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!=null&&(s.trainingConfig=t.trainingConfig),t.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=n}return t.signature!=null&&(s.signature=t.signature),t.userDefinedMetadata!=null&&(s.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(s.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(s.initializerSignature=t.initializerSignature),s}async function jS(t,e){let n,s;return t.weightsManifest!=null&&([n,s]=await e(t.weightsManifest)),SO(t,n,s)}function Tm(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:yI(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:yI(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:new Qa(t.weightData).byteLength}}function O$(t){const e=[];for(const n of t)e.push(...n.weights);return e}function wq(){const t=n=>{let s=n<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}function vq(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}function $q(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}function Sq(){const t=wq(),e=vq(),n=$q();return s=>{const r=new ArrayBuffer(4*s.length),a=new Uint32Array(r);for(let i=0;i<s.length;i++){const o=s[i],l=t[n[o>>10]+(o&1023)]+e[o>>10];a[i]=l}return new Float32Array(r)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return gn.instance==null&&(gn.instance=new gn),gn.instance}static registerSaveRouter(e){gn.getInstance().saveRouters.push(e)}static registerLoadRouter(e){gn.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return gn.getHandlers(e,"save")}static getLoadHandlers(e,n){return gn.getHandlers(e,"load",n)}static getHandlers(e,n,s){const r=[];return(n==="load"?gn.getInstance().loadRouters:gn.getInstance().saveRouters).forEach(i=>{const o=i(e,s);o!==null&&r.push(o)}),r}}const _q=t=>gn.registerSaveRouter(t),Cq=t=>gn.registerLoadRouter(t),_O=t=>gn.getSaveHandlers(t),Tq=(t,e)=>gn.getLoadHandlers(t,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z$="tensorflowjs",F$=1,Zu="models_store",Cl="model_info_store";function CO(){if(!ye().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function L$(t){const e=t.result;e.createObjectStore(Zu,{keyPath:"modelPath"}),e.createObjectStore(Cl,{keyPath:"modelPath"})}class ac{constructor(e){if(this.indexedDB=CO(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,n){return new Promise((s,r)=>{const a=this.indexedDB.open(z$,F$);a.onupgradeneeded=()=>L$(a),a.onsuccess=()=>{const i=a.result;if(n==null){const o=i.transaction(Zu,"readonly"),c=o.objectStore(Zu).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return i.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=h=>(i.close(),r(c.error)),o.oncomplete=()=>i.close()}else{n.weightData=Qa.join(n.weightData);const o=Tm(n),l=i.transaction(Cl,"readwrite");let c=l.objectStore(Cl),h;try{h=c.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(f){return r(f)}let p;h.onsuccess=()=>{p=i.transaction(Zu,"readwrite");const f=p.objectStore(Zu);let g;try{g=f.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:o})}catch(y){return r(y)}g.onsuccess=()=>s({modelArtifactsInfo:o}),g.onerror=y=>{c=l.objectStore(Cl);const x=c.delete(this.modelPath);x.onsuccess=()=>(i.close(),r(g.error)),x.onerror=w=>(i.close(),r(g.error))}},h.onerror=f=>(i.close(),r(h.error)),l.oncomplete=()=>{p==null?i.close():p.oncomplete=()=>i.close()}}},a.onerror=i=>r(a.error)})}}ac.URL_SCHEME="indexeddb://";const TO=t=>ye().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(ac.URL_SCHEME)?kq(t.slice(ac.URL_SCHEME.length)):null;gn.registerSaveRouter(TO);gn.registerLoadRouter(TO);function kq(t){return new ac(t)}function Nq(t){return t.startsWith(ac.URL_SCHEME)?t.slice(ac.URL_SCHEME.length):t}class Iq{constructor(){this.indexedDB=CO()}async listModels(){return new Promise((e,n)=>{const s=this.indexedDB.open(z$,F$);s.onupgradeneeded=()=>L$(s),s.onsuccess=()=>{const r=s.result,a=r.transaction(Cl,"readonly"),o=a.objectStore(Cl).getAll();o.onsuccess=()=>{const l={};for(const c of o.result)l[c.modelPath]=c.modelArtifactsInfo;e(l)},o.onerror=l=>(r.close(),n(o.error)),a.oncomplete=()=>r.close()},s.onerror=r=>n(s.error)})}async removeModel(e){return e=Nq(e),new Promise((n,s)=>{const r=this.indexedDB.open(z$,F$);r.onupgradeneeded=()=>L$(r),r.onsuccess=()=>{const a=r.result,i=a.transaction(Cl,"readwrite"),o=i.objectStore(Cl),l=o.get(e);let c;l.onsuccess=()=>{if(l.result==null)return a.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const h=o.delete(e),p=()=>{c=a.transaction(Zu,"readwrite");const g=c.objectStore(Zu).delete(e);g.onsuccess=()=>n(l.result.modelArtifactsInfo),g.onerror=y=>s(l.error)};h.onsuccess=p,h.onerror=f=>(p(),a.close(),s(l.error))}},l.onerror=h=>(a.close(),s(l.error)),i.oncomplete=()=>{c==null?a.close():c.oncomplete=()=>a.close()}},r.onerror=a=>s(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wo="/",Cd="tensorflowjs_models",kO="info",Eq="model_topology",Aq="weight_specs",Rq="weight_data",Dq="model_metadata";function NO(t){return{info:[Cd,t,kO].join(wo),topology:[Cd,t,Eq].join(wo),weightSpecs:[Cd,t,Aq].join(wo),weightData:[Cd,t,Rq].join(wo),modelMetadata:[Cd,t,Dq].join(wo)}}function IO(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function Oq(t){const e=t.split(wo);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(wo)}function zq(t){return t.startsWith(ic.URL_SCHEME)?t.slice(ic.URL_SCHEME.length):t}class ic{constructor(e){if(!ye().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=NO(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=Tm(e),a=Qa.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,bq(a));const i={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:r}}catch{throw IO(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const o=JSON.parse(a);n.format=o.format,n.generatedBy=o.generatedBy,n.convertedBy=o.convertedBy,o.signature!=null&&(n.signature=o.signature),o.userDefinedMetadata!=null&&(n.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(n.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(n.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(n.trainingConfig=o.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=xq(i),n}}ic.URL_SCHEME="localstorage://";const EO=t=>ye().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(ic.URL_SCHEME)?Fq(t.slice(ic.URL_SCHEME.length)):null;gn.registerSaveRouter(EO);gn.registerLoadRouter(EO);function Fq(t){return new ic(t)}class Lq{constructor(){V(ye().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),V(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},n=Cd+wo,s=wo+kO;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(n)&&a.endsWith(s)){const i=Oq(a);e[i]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=zq(e);const n=NO(e);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(n.info));return IO(n),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rd="://";class Vs{constructor(){this.managers={}}static getInstance(){return Vs.instance==null&&(Vs.instance=new Vs),Vs.instance}static registerManager(e,n){V(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Rd)&&(e=e.slice(0,e.indexOf(Rd))),V(e.length>0,()=>"scheme must not be an empty string.");const s=Vs.getInstance();V(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=n}static getManager(e){const n=Vs.getInstance().managers[e];if(n==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return n}static getSchemes(){return Object.keys(Vs.getInstance().managers)}}function s0(t){if(t.indexOf(Rd)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Vs.getSchemes().join(",")}`);return{scheme:t.split(Rd)[0],path:t.split(Rd)[1]}}async function AO(t,e,n=!1){V(t!==e,()=>`Old path and new path are the same: '${t}'`);const s=gn.getLoadHandlers(t);V(s.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),V(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${t}.`);const r=s[0],a=gn.getSaveHandlers(e);V(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),V(a.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const i=a[0],o=s0(t).scheme,l=s0(t).path,c=o===s0(t).scheme,h=await r.load();n&&c&&await Vs.getManager(o).removeModel(l);const p=await i.save(h);return n&&!c&&await Vs.getManager(o).removeModel(l),p.modelArtifactsInfo}async function Mq(){const t=Vs.getSchemes(),e={};for(const n of t){const s=await Vs.getManager(n).listModels();for(const r in s){const a=n+Rd+r;e[a]=s[r]}}return e}async function Bq(t){const e=s0(t);return Vs.getManager(e.scheme).removeModel(e.path)}async function Pq(t,e){return AO(t,e,!1)}async function Vq(t,e){return AO(t,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uq{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,n){return fetch(e,n)}now(){return performance.now()}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,n){return new TextDecoder(n).decode(e)}setTimeoutCustom(e,n){if(typeof window>"u"||!ye().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,n);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return tO(e)}}if(ye().get("IS_BROWSER")){ye().setPlatform("browser",new Uq);try{Vs.registerManager(ic.URL_SCHEME,new Lq)}catch{}try{Vs.registerManager(ac.URL_SCHEME,new Iq)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wq={importFetch:()=>require("node-fetch")};let lv;class Gq{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return ye().global.fetch!=null?ye().global.fetch(e,n):(lv==null&&(lv=Wq.importFetch()),lv(e,n))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(e)}decode(e,n){return e.length===0?"":new this.util.TextDecoder(n).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}ye().get("IS_NODE")&&!ye().get("IS_BROWSER")&&ye().setPlatform("node",new Gq);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xt(t,e="float32",n){return e=e||"float32",Yr(t),new Kn(t,e,n)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hq(t,e){const n=W(t,"x","cast");if(!T6(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&n.dtype!=="string"||e!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:n},r={dtype:e};return ie.runKernel(Mf,s,r)}const Ge=ne({cast_:Hq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qq(t){const n={x:W(t,"x","clone","string_or_numeric")};return ie.runKernel(Zf,n)}const $o=ne({clone_:qq});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RO(t,e=!1){console.log(t.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */dO();const jq={buffer:xt,cast:Ge,clone:$o,print:RO};rq(jq);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kq(t,e){let n=W(t,"a","add"),s=W(e,"b","add");[n,s]=Cn(n,s);const r={a:n,b:s};return ie.runKernel(th,r)}const Ae=ne({add_:Kq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xq(t,e){let n=W(t,"a","floorDiv"),s=W(e,"b","floorDiv");[n,s]=Cn(n,s);const r={a:n,b:s};return ie.runKernel(Xf,r)}const KS=ne({floorDiv_:Xq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yq(t,e){let n=W(t,"a","div"),s=W(e,"b","div");if([n,s]=Cn(n,s),n.dtype==="int32"&&s.dtype==="int32")return KS(n,s);const r={a:n,b:s},a={};return ie.runKernel(Wf,r,a)}const et=ne({div_:Yq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zq(t,e){let n=W(t,"a","mul"),s=W(e,"b","mul");[n,s]=Cn(n,s);const r={a:n,b:s};return ie.runKernel(im,r)}const ae=ne({mul_:Zq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qq(t){const e=W(t,"x","abs");if(e.dtype==="complex64"){const n={x:e};return ie.runKernel(db,n)}else{const n={x:e};return ie.runKernel(nb,n)}}const Gn=ne({abs_:Qq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jq(t){const n={x:W(t,"x","acos")};return ie.runKernel(Af,n)}const DO=ne({acos_:Jq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ej(t){const n={x:W(t,"x","acosh")};return ie.runKernel(Rf,n)}const OO=ne({acosh_:ej});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tj(t){V(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),V(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((r,a)=>W(r,`tensors${a}`,"addN")),n=e[0];e.forEach(r=>{if(r.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!Rt(r.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return ie.runKernel(sb,s)}const nj=ne({addN_:tj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sj(t,e=null,n=!1){const r={x:W(t,"x","all","bool")},a={axis:e,keepDims:n};return ie.runKernel(V2,r,a)}const XS=ne({all_:sj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rj(t,e=null,n=!1){const r={x:W(t,"x","any","bool")},a={axis:e,keepDims:n};return ie.runKernel(U2,r,a)}const S0=ne({any_:rj});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aj(t,e=0){const s={x:W(t,"x","argMax")},r={axis:e};return ie.runKernel(rb,s,r)}const Bd=ne({argMax_:aj});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ij(t,e=0){const s={x:W(t,"x","argMin")},r={axis:e};return ie.runKernel(ab,s,r)}const zO=ne({argMin_:ij});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oj(t){const n={x:W(t,"x","asin")};return ie.runKernel(Df,n)}const FO=ne({asin_:oj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lj(t){const n={x:W(t,"x","asinh")};return ie.runKernel(Of,n)}const LO=ne({asinh_:lj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uj(t){const n={x:W(t,"x","atan")};return ie.runKernel(zf,n)}const MO=ne({atan_:uj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cj(t,e){let n=W(t,"a","atan2"),s=W(e,"b","atan2");[n,s]=Cn(n,s);const r={a:n,b:s};return ie.runKernel(Lf,r)}const BO=ne({atan2_:cj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dj(t){const n={x:W(t,"x","atanh")};return ie.runKernel(Ff,n)}const PO=ne({atanh_:dj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function km(t,e,n,s,r="NHWC",a){const i=t[3],o=[...e,i],l=Ao(r);return os(t,o,n,a,s,null,null,l)}function _a(t,e,n,s,r,a,i="channelsLast"){const[o,l]=df(e);let c;if(i==="channelsLast")c=[o,l,t[3],t[3]];else if(i==="channelsFirst")c=[o,l,t[1],t[1]];else throw new Error(`Unknown dataFormat ${i}`);return os(t,c,n,s,r,a,!1,i)}function Eo(t,e,n,s,r,a,i="NDHWC"){const[o,l,c]=M$(e);let h,p;if(i==="NDHWC")p="channelsLast",h=[o,l,c,t[4],t[4]];else if(i==="NCDHW")p="channelsFirst",h=[o,l,c,t[1],t[1]];else throw new Error(`Unknown dataFormat ${i}`);return jl(t,h,n,s,r,!1,p,a)}function os(t,e,n,s,r,a,i=!1,o="channelsLast"){let[l,c,h,p]=[-1,-1,-1,-1];if(o==="channelsLast")[l,c,h,p]=t;else if(o==="channelsFirst")[l,p,c,h]=t;else throw new Error(`Unknown dataFormat ${o}`);const[f,g,,y]=e,[x,w]=df(n),[v,$]=df(s),T=Dd(f,v),C=Dd(g,$),{padInfo:I,outHeight:A,outWidth:O}=fj(r,c,h,x,w,T,C,a,o),B=i?y*p:y;let z;return o==="channelsFirst"?z=[l,B,A,O]:o==="channelsLast"&&(z=[l,A,O,B]),{batchSize:l,dataFormat:o,inHeight:c,inWidth:h,inChannels:p,outHeight:A,outWidth:O,outChannels:B,padInfo:I,strideHeight:x,strideWidth:w,filterHeight:f,filterWidth:g,effectiveFilterHeight:T,effectiveFilterWidth:C,dilationHeight:v,dilationWidth:$,inShape:t,outShape:z,filterShape:e}}function jl(t,e,n,s,r,a=!1,i="channelsLast",o){let[l,c,h,p,f]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,c,h,p,f]=t;else if(i==="channelsFirst")[l,f,c,h,p]=t;else throw new Error(`Unknown dataFormat ${i}`);const[g,y,x,,w]=e,[v,$,T]=M$(n),[C,I,A]=M$(s),O=Dd(g,C),B=Dd(y,I),z=Dd(x,A),{padInfo:P,outDepth:F,outHeight:K,outWidth:X}=mj(r,c,h,p,v,$,T,O,B,z,o),te=a?w*f:w;let Q;return i==="channelsFirst"?Q=[l,te,F,K,X]:i==="channelsLast"&&(Q=[l,F,K,X,te]),{batchSize:l,dataFormat:i,inDepth:c,inHeight:h,inWidth:p,inChannels:f,outDepth:F,outHeight:K,outWidth:X,outChannels:te,padInfo:P,strideDepth:v,strideHeight:$,strideWidth:T,filterDepth:g,filterHeight:y,filterWidth:x,effectiveFilterDepth:O,effectiveFilterHeight:B,effectiveFilterWidth:z,dilationDepth:C,dilationHeight:I,dilationWidth:A,inShape:t,outShape:Q,filterShape:e}}function hj(t,e,n,s,r){s==null&&(s=YS(t,e,n));const a=t[0],i=t[1],o=hf((a-e+2*s)/n+1,r),l=hf((i-e+2*s)/n+1,r);return[o,l]}function pj(t,e,n,s,r,a){r==null&&(r=YS(t,e[0],s[0]));const i=[0,0,0,n];for(let o=0;o<3;o++)t[o]+2*r>=e[o]&&(i[o]=hf((t[o]-e[o]+2*r)/s[o]+1,a));return i}function YS(t,e,n,s=1){const r=Dd(e,s);return Math.floor((t[0]*(n-1)-n+r)/2)}function df(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function M$(t){return typeof t=="number"?[t,t,t]:t}function Dd(t,e){return e<=1?t:t+(t-1)*(e-1)}function fj(t,e,n,s,r,a,i,o,l){let c,h,p;if(typeof t=="number"){c={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};const g=hj([e,n],a,s,t,o);h=g[0],p=g[1]}else if(t==="same"){h=Math.ceil(e/s),p=Math.ceil(n/r);const f=Math.max(0,(h-1)*s+a-e),g=Math.max(0,(p-1)*r+i-n),y=Math.floor(f/2),x=f-y,w=Math.floor(g/2),v=g-w;c={top:y,bottom:x,left:w,right:v,type:"SAME"}}else if(t==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((e-a+1)/s),p=Math.ceil((n-i+1)/r);else if(typeof t=="object"){const f=l==="channelsLast"?t[1][0]:t[2][0],g=l==="channelsLast"?t[1][1]:t[2][1],y=l==="channelsLast"?t[2][0]:t[3][0],x=l==="channelsLast"?t[2][1]:t[3][1];c={top:f,bottom:g,left:y,right:x,type:f===0&&g===0&&y===0&&x===0?"VALID":"EXPLICIT"},h=hf((e-a+f+g)/s+1,o),p=hf((n-i+y+x)/r+1,o)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:c,outHeight:h,outWidth:p}}function mj(t,e,n,s,r,a,i,o,l,c,h){let p,f,g,y;if(t==="valid"&&(t=0),typeof t=="number"){p={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};const w=pj([e,n,s,1],[o,l,c],1,[r,a,i],t,h);f=w[0],g=w[1],y=w[2]}else if(t==="same"){f=Math.ceil(e/r),g=Math.ceil(n/a),y=Math.ceil(s/i);const x=(f-1)*r+o-e,w=(g-1)*a+l-n,v=(y-1)*i+c-s,$=Math.floor(x/2),T=x-$,C=Math.floor(w/2),I=w-C,A=Math.floor(v/2),O=v-A;p={top:C,bottom:I,left:A,right:O,front:$,back:T,type:"SAME"}}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:p,outDepth:f,outHeight:g,outWidth:y}}function hf(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function zl(t){const[e,n,s]=df(t);return e===1&&n===1&&s===1}function xs(t,e){return zl(t)||zl(e)}function oc(t){return df(t).every(e=>e>0)}function Ao(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function js(t,e,n){if(n!=null){if(typeof e=="string")throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if(typeof e=="number")V(Ld(e),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{V(Ld(r),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${r}.`)})});else throw Error(`Error in ${t}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gj(t,e){const s={x:W(t,"x","reshape","string_or_numeric")},r={shape:e};return ie.runKernel(Hb,s,r)}const le=ne({reshape_:gj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yj(t,e,n,s,r){const a=W(t,"x","avgPool","float32"),i=1;V(xs(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=a,l=!1;a.rank===3&&(l=!0,o=le(a,[1,a.shape[0],a.shape[1],a.shape[2]])),V(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),js("avgPool",s,r);const c={x:o},h={filterSize:e,strides:n,pad:s,dimRoundingMode:r};let p=ie.runKernel(ib,c,h);return p=Ge(p,a.dtype),l?le(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const ix=ne({avgPool_:yj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bj(t,e,n,s,r,a="NDHWC"){const i=W(t,"x","avgPool3d","float32");let o=i,l=!1;i.rank===4&&(l=!0,o=le(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),V(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),V(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),V(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),js("avgPool3d",s,r);const c={x:o},h={filterSize:e,strides:n,pad:s,dimRoundingMode:r,dataFormat:a};let p=ie.runKernel(ob,c,h);return p=Ge(p,o.dtype),l?le(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const VO=ne({avgPool3d_:bj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xj(t,e=0){V(t.length>=1,()=>"Pass at least one tensor to concat");const n=$0(t,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),n.length===1)return $o(n[0]);const s=n,r={axis:e};return ie.runKernel(hb,s,r)}const Bn=ne({concat_:xj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wj(t,e,n=!1,s=!1){let r=W(t,"a","matMul"),a=W(e,"b","matMul");[r,a]=Cn(r,a);const i={a:r,b:a},o={transposeA:n,transposeB:s};return ie.runKernel(lb,i,o)}const Tt=ne({matMul_:wj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vj(t){const n={x:W(t,"x","sigmoid","float32")};return ie.runKernel(ym,n)}const Ci=ne({sigmoid_:vj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $j(t,e,n){const s=W(t,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},a={begin:e,size:n};return ie.runKernel(Yb,r,a)}const Ot=ne({slice_:$j});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sj(t){const n={x:W(t,"x","tanh","float32")};return ie.runKernel(Sm,n)}const lc=ne({tanh_:Sj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _j(t,e,n,s,r,a){const i=W(t,"forgetBias","basicLSTMCell"),o=W(e,"lstmKernel","basicLSTMCell"),l=W(n,"lstmBias","basicLSTMCell"),c=W(s,"data","basicLSTMCell"),h=W(r,"c","basicLSTMCell"),p=W(a,"h","basicLSTMCell"),f=Bn([c,p],1),g=Tt(f,o),y=Ae(g,l),x=y.shape[0],w=y.shape[1]/4,v=[x,w],$=Ot(y,[0,0],v),T=Ot(y,[0,w],v),C=Ot(y,[0,w*2],v),I=Ot(y,[0,w*3],v),A=Ae(ae(Ci($),lc(T)),ae(h,Ci(Ae(i,C)))),O=ae(lc(A),Ci(I));return[A,O]}const Cj=ne({basicLSTMCell_:_j});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tj(t,e,n){const s=W(t,"x","batchToSpaceND"),r=e.reduce((o,l)=>o*l);V(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),V(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),V(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const a={x:s},i={blockShape:e,crops:n};return ie.runKernel(ub,a,i)}const ox=ne({batchToSpaceND_:Tj});function kj(t){let e;return t.rank===0||t.rank===1?e=le(t,[1,1,1,t.size]):t.rank===2?e=le(t,[1,1,t.shape[0],t.shape[1]]):t.rank===3?e=le(t,[1,t.shape[0],t.shape[1],t.shape[2]]):e=t,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nj(t,e,n,s,r,a){a==null&&(a=.001);const i=W(t,"x","batchNorm"),o=W(e,"mean","batchNorm"),l=W(n,"variance","batchNorm");let c;r!=null&&(c=W(r,"scale","batchNorm"));let h;s!=null&&(h=W(s,"offset","batchNorm")),V(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),V(h==null||o.rank===h.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),V(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const f={x:kj(i),scale:c,offset:h,mean:o,variance:l},g={varianceEpsilon:a},y=ie.runKernel(vb,f,g);return le(y,i.shape)}const Nm=ne({batchNorm_:Nj});function Ij(t,e,n,s,r,a){const i=W(t,"x","batchNorm"),o=W(e,"mean","batchNorm"),l=W(n,"variance","batchNorm");let c;r!=null&&(c=W(r,"scale","batchNorm"));let h;return s!=null&&(h=W(s,"offset","batchNorm")),V(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),V(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),V(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&V(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),h!=null&&V(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${h.rank}.`),Nm(i,o,l,h,c,a)}const UO=ne({batchNorm2d_:Ij});function Ej(t,e,n,s,r,a){const i=W(t,"x","batchNorm"),o=W(e,"mean","batchNorm"),l=W(n,"variance","batchNorm");let c;r!=null&&(c=W(r,"scale","batchNorm"));let h;return s!=null&&(h=W(s,"offset","batchNorm")),V(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),V(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),V(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&V(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),h!=null&&V(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${h.rank}.`),Nm(i,o,l,h,c,a)}const WO=ne({batchNorm3d_:Ej});function Aj(t,e,n,s,r,a){const i=W(t,"x","batchNorm"),o=W(e,"mean","batchNorm"),l=W(n,"variance","batchNorm");let c;r!=null&&(c=W(r,"scale","batchNorm"));let h;return s!=null&&(h=W(s,"offset","batchNorm")),V(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),V(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),V(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&V(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),h!=null&&V(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${h.rank}.`),Nm(i,o,l,h,c,a)}const GO=ne({batchNorm4d_:Aj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rj(t,e,n){const s=W(t,"x","bincount"),r=W(e,"weights","bincount");V(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),V(n>=0,()=>`size must be non-negative, but got ${n}.`),V(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const a={x:s,weights:r},i={size:n};return ie.runKernel(H2,a,i)}const HO=ne({bincount_:Rj});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dj(t,e){const n=W(t,"x","bitwiseAnd"),s=W(e,"y","bitwiseAnd");if(!Rt(n.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${s.shape}`);if(n.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${s.dtype}`);const r={a:n,b:s};return ie.runKernel(cb,r)}const Oj=ne({bitwiseAnd_:Dj});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zj(t,e){const n=W(t,"s0","broadcastArgs","int32"),s=W(e,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:n,s1:s};return ie.runKernel(q2,r)}const Fj=ne({broadcastArgs_:zj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lj(t,e){let n=W(t,"broadcastTo","x");const s=n.shape;if(Yr(e),e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const c=n.shape.slice();for(;c.length<e.length;)c.unshift(1);n=le(n,c)}const r=n.shape,a=Array.from(e);for(let c=e.length-1;c>=0;c--)if(r[c]===e[c])a[c]=1;else if(n.shape[c]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(a.map((c,h)=>c>1?h:-1).filter(c=>c>=0).length===0)return $o(n);const o={x:n},l={reps:a};return ie.runKernel(_m,o,l)}const Od=ne({broadcastTo_:Lj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mj(t){const n={x:W(t,"x","ceil","float32")};return ie.runKernel(Bf,n)}const qO=ne({ceil_:Mj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nh(t,e,n){Yr(t),n=n||Jd(e);const s={shape:t,value:e,dtype:n};return ie.runKernel(oS,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bj(t,e,n){const s=W(t,"x","clipByValue");if(V(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),e===n)return nh(s.shape,e,s.dtype);const r={x:s},a={clipValueMin:e,clipValueMax:n};return ie.runKernel(Pf,r,a)}const Cr=ne({clipByValue_:Bj});function Pj(t){return Bn(t,0)}const jO=ne({concat1d_:Pj});function Vj(t,e){return Bn(t,e)}const KO=ne({concat2d_:Vj});function Uj(t,e){return Bn(t,e)}const XO=ne({concat3d_:Uj});function Wj(t,e){return Bn(t,e)}const YO=ne({concat4d_:Wj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gj(t,e,n,s,r="NHWC",a=[1,1],i){const o=W(t,"x","conv2d","float32"),l=W(e,"filter","conv2d","float32");let c=o,h=!1;o.rank===3&&(h=!0,c=le(o,[1,o.shape[0],o.shape[1],o.shape[2]])),V(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),V(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),js("conv2d",s,i);const p=r==="NHWC"?c.shape[3]:c.shape[1];V(p===l.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${l.shape[2]}.`),V(xs(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),V(oc(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),V(oc(n),()=>"Error in conv2D: Strides should be larger than 0.");const f={x:c,filter:l},g={strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:i},y=ie.runKernel(pb,f,g);return h?le(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const Fl=ne({conv2d_:Gj});function Hj(t,e,n,s,r="NWC",a=1,i){const o=W(t,"x","conv1d"),l=W(e,"filter","conv1d");let c=o,h=!1;o.rank===2&&(h=!0,c=le(o,[1,o.shape[0],o.shape[1]])),V(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),V(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),js("conv1d",s,i),V(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),V(xs(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),V(oc(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),V(oc(n),()=>"Error in conv1D: Stride should be larger than 0."),V(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const p=le(l,[1,l.shape[0],l.shape[1],l.shape[2]]),f=le(c,[c.shape[0],1,c.shape[1],c.shape[2]]),w=Fl(f,p,[1,n],s,"NHWC",[1,a],i);return h?le(w,[w.shape[2],w.shape[3]]):le(w,[w.shape[0],w.shape[2],w.shape[3]])}const ZS=ne({conv1d_:Hj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qj(t,e,n,s,r,a="NHWC",i){V(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let o=t,l=e,c=!1;e.rank===3&&(c=!0,l=le(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,t[0],t[1],t[2]]),V(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),V(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),V(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const h=a==="NHWC"?o[3]:o[1],p=a==="NHWC"?l.shape[3]:l.shape[1];V(h===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${h}) must match input depth for filter ${n.shape[2]}.`),V(p===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${n.shape[3]}.`),js("conv2dDerInput",r,i);const f={dy:l,filter:n},g={strides:s,pad:r,dataFormat:a,dimRoundingMode:i,inputShape:o},y=ie.runKernel(fb,f,g);return c?le(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const QS=ne({conv2DBackpropInput_:qj});function jj(t,e,n,s,r,a){const i=W(t,"x","conv2dTranspose"),o=W(e,"filter","conv2dTranspose");return QS(n,i,o,s,r,"NHWC",a)}const JS=ne({conv2dTranspose_:jj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kj(t,e,n,s,r="NDHWC",a=[1,1,1]){const i=W(t,"x","conv3d"),o=W(e,"filter","conv3d");let l=i,c=!1;i.rank===4&&(c=!0,l=le(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),V(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),V(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),V(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),V(xs(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),V(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),V(oc(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),V(oc(n),()=>"Error in conv3D: Strides should be larger than 0.");const h={x:l,filter:o},p={strides:n,pad:s,dataFormat:r,dilations:a},f=ie.runKernel(mb,h,p);return c?le(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const ZO=ne({conv3d_:Kj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xj(t,e,n,s,r){V(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let a=t,i=e,o=!1;e.rank===4&&(o=!0,i=le(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),a=[1,t[0],t[1],t[2],t[3]]);const l=a[4],c=i.shape[4];V(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),V(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),V(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),V(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),V(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);const h={dy:i,filter:n},p={pad:r,strides:s,inputShape:a},f=ie.runKernel(Y2,h,p);return o?le(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const QO=ne({conv3DBackpropInput_:Xj});function Yj(t,e,n,s,r){const a=W(t,"x","conv3dTranspose"),i=W(e,"filter","conv3dTranspose");return QO(n,a,i,s,r)}const JO=ne({conv3dTranspose_:Yj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zj(t){const n={x:W(t,"x","cos","float32")};return ie.runKernel(Vf,n)}const lx=ne({cos_:Zj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qj(t){const n={x:W(t,"x","cosh","float32")};return ie.runKernel(Uf,n)}const e_=ne({cosh_:Qj});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jj(t,e=0,n=!1,s=!1){const a={x:W(t,"x","cumprod")},i={axis:e,exclusive:n,reverse:s};return ie.runKernel(Z2,a,i)}const _0=ne({cumprod_:Jj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e5(t,e=0,n=!1,s=!1){const a={x:W(t,"x","cumsum")},i={axis:e,exclusive:n,reverse:s};return ie.runKernel(gb,a,i)}const t_=ne({cumsum_:e5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t5(t,e,n,s=!1){const r=W(t,"x","denseBincount"),a=W(e,"weights","denseBincount");V(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),V(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),V(n>=0,()=>`size must be non-negative, but got ${n}.`),V(a.size===r.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${a.shape}.`);const i={x:r,weights:a},o={size:n,binaryOutput:s};return ie.runKernel(J2,i,o)}const B$=ne({denseBincount_:t5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n5(t,e,n="NHWC"){const s=W(t,"x","depthToSpace","float32"),r=n==="NHWC"?s.shape[1]:s.shape[2],a=n==="NHWC"?s.shape[2]:s.shape[3],i=n==="NHWC"?s.shape[3]:s.shape[1];V(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),V(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),V(a*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${e} for depthToSpace with input shape
        ${s.shape}`),V(i%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${i} for depthToSpace with input shape ${s.shape}`);const o={x:s},l={blockSize:e,dataFormat:n};return ie.runKernel(eS,o,l)}const ez=ne({depthToSpace_:n5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s5(t,e,n,s,r="NHWC",a=[1,1],i){const o=W(t,"x","depthwiseConv2d","float32"),l=W(e,"filter","depthwiseConv2d","float32");let c=o,h=!1;o.rank===3&&(h=!0,c=le(o,[1,o.shape[0],o.shape[1],o.shape[2]])),V(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),V(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const p=r==="NHWC"?c.shape[3]:c.shape[1];V(p===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${l.shape[2]}.`),js("depthwiseConv2d",s,i);const f={x:c,filter:l},g={strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:i},y=ie.runKernel(yb,f,g);return h?le(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const Im=ne({depthwiseConv2d_:s5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r5(t){const n={x:W(t,"x","diag")};return ie.runKernel(sS,n)}const a5=ne({diag_:r5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i5(t,e,n,s,r=[1,1],a="NHWC"){const i=W(t,"x","dilation2d"),o=W(e,"filter","dilation2d");V(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),V(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),V(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let l=i,c=!1;i.rank===3&&(l=le(i,[1,i.shape[0],i.shape[1],i.shape[2]]),c=!0),V(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);const h={x:l,filter:o},p={strides:n,pad:s,dilations:r},f=ie.runKernel(bb,h,p);return c?le(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const tz=ne({dilation2d_:i5});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pd(t,e){const n=t.length,s=[];for(let r=0;r<n;r++){const a=n-1-r,i=t[a]||1;(e[e.length-1-r]||1)>1&&i===1&&s.unshift(a)}return s}function Zn(t,e){const n=[];for(let s=0;s<e.length;s++){const r=t[t.length-s-1],a=e.length-s-1,i=e[a];(r==null||r===1&&i>1)&&n.unshift(a)}return n}function ft(t,e){const n=Math.max(t.length,e.length),s=new Array(n);for(let r=0;r<n;r++){let a=t[t.length-r-1];a==null&&(a=1);let i=e[e.length-r-1];if(i==null&&(i=1),a===1)s[n-r-1]=i;else if(i===1)s[n-r-1]=a;else if(a!==i){const o=`Operands could not be broadcast together with shapes ${t} and ${e}.`;throw Error(o)}else s[n-r-1]=a}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o5(t,e){let n=W(t,"a","equal","string_or_numeric"),s=W(e,"b","equal","string_or_numeric");[n,s]=Cn(n,s),ft(n.shape,s.shape);const r={a:n,b:s};return ie.runKernel(xb,r)}const Ka=ne({equal_:o5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l5(t,e,n){const s=W(e,"a","where"),r=W(n,"b","where"),a=W(t,"condition","where","bool"),i=ft(ft(a.shape,s.shape),r.shape),o=Od(a,i),l=Od(s,i),c=Od(r,i),h={condition:o,t:l,e:c};return ie.runKernel(Xb,h)}const As=ne({where_:l5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u5(t){const n={x:W(t,"x","zerosLike")};return ie.runKernel(rx,n)}const Lt=ne({zerosLike_:u5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c5(t,e){let n=W(t,"a","div"),s=W(e,"b","div");[n,s]=Cn(n,s);const r=et(n,s),a=Lt(r),i=Ka(s,a);return As(i,a,r)}const nz=ne({divNoNan_:c5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d5(t,e){const n=W(t,"t1","dot"),s=W(e,"t2","dot");V((n.rank===1||n.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);const r=n.rank===1?n.size:n.shape[1],a=s.rank===1?s.size:s.shape[0];if(V(r===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${a}.`),n.rank===1&&s.rank===1){const i=le(n,[1,-1]),o=le(s,[-1,1]),l=Tt(i,o);return le(l,[])}else if(n.rank===1&&s.rank===2){const i=le(n,[1,-1]),o=le(s,[s.shape[0],s.shape[1]]),l=Tt(i,o);return le(l,[l.size])}else if(n.rank===2&&s.rank===1){const i=le(s,[-1,1]),o=Tt(n,i);return le(o,[o.size])}else{const i=le(s,[s.shape[0],s.shape[1]]);return Tt(n,i)}}const sz=ne({dot_:d5});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h5(t,...e){const n=e.map((r,a)=>W(r,`tensors${a}`,"einsum")),s={equation:t};return ie.runKernel(rS,n,s)}const Td=ne({einsum_:h5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p5(t){const n={x:W(t,"x","elu","float32")};return ie.runKernel(Gf,n)}const Em=ne({elu_:p5});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f5(t,e){const n=W(t,"x","ensureShape","string_or_numeric");if(!_6(n.shape,e))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${e}`);return t}const m5=ne({ensureShape_:f5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g5(t){let e=W(t,"x","erf");V(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Ge(e,"float32"));const n={x:e};return ie.runKernel(Hf,n)}const n_=ne({erf_:g5});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s_(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function rz(t,e,n){const s=t.length+e.length,r=[];let a=0,i=0;for(let o=0;o<s;o++)n.indexOf(o)===-1?r.push(t[a++]):r.push(e[i++]);return r}function ls(t,e){const n=[],s=t.length;for(let a=0;a<s;a++)e.indexOf(a)===-1&&n.push(t[a]);const r=e.map(a=>t[a]);return[n,r]}function Rn(t,e){const n=e.map(s=>1);return rz(t,n,e)}function ws(t,e,n){V(s_(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function wn(t,e){if(s_(t,e))return null;const n=[];for(let s=0;s<e;++s)t.indexOf(s)===-1&&n.push(s);return t.forEach(s=>n.push(s)),n}function Kl(t){return t.map((e,n)=>[n,e]).sort((e,n)=>e[1]-n[1]).map(e=>e[0])}function Dn(t,e){const n=[];for(let s=e-t;s<e;++s)n.push(s);return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y5(t,e=null,n=!1){const r={x:W(t,"x","max")},a={reductionIndices:e,keepDims:n};return ie.runKernel(Ab,r,a)}const wa=ne({max_:y5});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b5(t,e=null,n=!1){const r={x:W(t,"x","min")},a={axis:e,keepDims:n};return ie.runKernel(zb,r,a)}const pf=ne({min_:b5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x5(t,e){let n=W(t,"base","pow"),s=W(e,"exp","pow");[n,s]=Cn(n,s);const r={a:n,b:s};return ie.runKernel(om,r)}const Co=ne({pow_:x5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function st(t,e){if((va(t)&&e!=="string"||Array.isArray(t))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&va(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ql(t,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w5(t){const n={x:W(t,"x","sqrt","float32")};return ie.runKernel(xm,n)}const bs=ne({sqrt_:w5});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v5(t){const e=W(t,"x","square"),n={};return ie.runKernel("Square",{x:e},n)}const nn=ne({square_:v5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $5(t,e=null,n=!1){let s=W(t,"x","sum");s.dtype==="bool"&&(s=Ge(s,"int32"));const r={x:s},a={axis:e,keepDims:n};return ie.runKernel(Zb,r,a)}const Xe=ne({sum_:$5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S5(t,e="euclidean",n=null,s=!1){t=W(t,"x","norm");const r=az(t,e,n);let a=r.shape;if(s){const i=St(n,t.shape);a=Rn(r.shape,i)}return le(r,a)}function az(t,e,n=null){if(t.rank===0)return Gn(t);if(t.rank!==1&&n===null)return az(le(t,[-1]),e,n);if(t.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(e===1)return Xe(Gn(t),n);if(e===1/0)return wa(Gn(t),n);if(e===-1/0)return pf(Gn(t),n);if(e==="euclidean"||e===2)return bs(Xe(Co(Gn(t),st(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&n.length===2){if(e===1)return wa(Xe(Gn(t),n[0]),n[1]-1);if(e===1/0)return wa(Xe(Gn(t),n[1]),n[0]);if(e===-1/0)return pf(Xe(Gn(t),n[1]),n[0]);if(e==="fro"||e==="euclidean")return bs(Xe(nn(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Am=ne({norm_:S5});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _5(t,e=null,n=!1){return Am(t,"euclidean",e,n)}const iz=ne({euclideanNorm_:_5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C5(t){const n={x:W(t,"x","exp")};return ie.runKernel(qf,n)}const Tr=ne({exp_:C5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T5(t,e=0){const n=W(t,"x","expandDims","string_or_numeric");V(e<=n.rank,()=>"Axis must be <= rank of the tensor");const s={input:n},r={dim:e};return ie.runKernel(wb,s,r)}const Ws=ne({expandDims_:T5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k5(t){const n={x:W(t,"x","expm1")};return ie.runKernel(jf,n)}const oz=ne({expm1_:k5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N5(t,e){const n=W(t,"x","tile","string_or_numeric");V(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);const s={x:n},r={reps:e};return ie.runKernel(_m,s,r)}const ga=ne({tile_:N5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I5(t,e,n,s="float32"){e==null&&(e=t);const r=xt([t,e],s),a=t<=e?t:e;for(let o=0;o<a;++o)r.set(1,o,o);const i=le(r.toTensor(),[t,e]);if(n==null)return i;if(n.length===1)return ga(Ws(i,0),[n[0],1,1]);if(n.length===2)return ga(Ws(Ws(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return ga(Ws(Ws(Ws(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const r_=ne({eye_:I5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E5(t){const n={x:W(t,"x","floor","float32")};return ie.runKernel(Kf,n)}const Rm=ne({floor_:E5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A5(t,e,n=0,s=0){const r=W(t,"x","gather"),a=W(e,"indices","gather","int32"),i={x:r,indices:a},o={axis:n,batchDims:s};return ie.runKernel($b,i,o)}const Dm=ne({gather_:A5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R5(t,e){let n=W(t,"a","greater","string_or_numeric"),s=W(e,"b","greater","string_or_numeric");[n,s]=Cn(n,s),ft(n.shape,s.shape);const r={a:n,b:s};return ie.runKernel(Sb,r)}const Ar=ne({greater_:R5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D5(t,e){let n=W(t,"a","greaterEqual","string_or_numeric"),s=W(e,"b","greaterEqual","string_or_numeric");[n,s]=Cn(n,s),ft(n.shape,s.shape);const r={a:n,b:s};return ie.runKernel(Yf,r)}const Xl=ne({greaterEqual_:D5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O5(t){const n={input:W(t,"input","imag")};return ie.runKernel(dS,n)}const ux=ne({imag_:O5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z5(t){const n={x:W(t,"x","isFinite")};return ie.runKernel(Qf,n)}const lz=ne({isFinite_:z5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F5(t){const n={x:W(t,"x","isInf")};return ie.runKernel(Jf,n)}const uz=ne({isInf_:F5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L5(t){const n={x:W(t,"x","isNaN")};return ie.runKernel(em,n)}const cz=ne({isNaN_:L5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M5(t,e=.2){const s={x:W(t,"x","leakyRelu")},r={alpha:e};return ie.runKernel(_b,s,r)}const cx=ne({leakyRelu_:M5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B5(t,e){let n=W(t,"a","less","string_or_numeric"),s=W(e,"b","less","string_or_numeric");[n,s]=Cn(n,s),ft(n.shape,s.shape);const r={a:n,b:s};return ie.runKernel(Cb,r)}const ff=ne({less_:B5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P5(t,e){let n=W(t,"a","lessEqual","string_or_numeric"),s=W(e,"b","lessEqual","string_or_numeric");[n,s]=Cn(n,s),ft(n.shape,s.shape);const r={a:n,b:s};return ie.runKernel(Tb,r)}const vc=ne({lessEqual_:P5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V5(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const s={start:t,stop:e,num:n};return ie.runKernel(hS,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U5(t,e=5,n=1,s=1,r=.5){const a=W(t,"x","localResponseNormalization");V(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),V(Ld(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let i=a,o=!1;a.rank===3&&(o=!0,i=le(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const l={x:i},c={depthRadius:e,bias:n,alpha:s,beta:r},h=ie.runKernel(Eb,l,c);return o?le(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const dz=ne({localResponseNormalization_:U5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W5(t){const n={x:W(t,"x","log","float32")};return ie.runKernel(tm,n)}const Kr=ne({log_:W5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G5(t){const n={x:W(t,"x","log1p")};return ie.runKernel(nm,n)}const dx=ne({log1p_:G5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H5(t,e){V(S$(t),()=>"The f passed in variableGrads(f) must be a function"),V(e==null||Array.isArray(e)&&e.every(c=>c instanceof v0),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=e!=null;if(!n){e=[];for(const c in ie.registeredVariables)e.push(ie.registeredVariables[c])}const s=n?e.filter(c=>!c.trainable):null,r=e.length;e=e.filter(c=>c.trainable),V(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const a=!0,{value:i,grads:o}=ie.gradients(t,e,null,a);V(o.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),V(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const l={};return e.forEach((c,h)=>{o[h]!=null&&(l[c.name]=o[h])}),s!=null&&s.forEach(c=>l[c.name]=null),{value:i,grads:l}}function To(t){return ie.customGrad(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q5(t){const n={x:W(t,"x","neg")};return ie.runKernel(Lb,n)}const dn=ne({neg_:q5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j5(t){const n={x:W(t,"x","softplus")};return ie.runKernel(bm,n)}const sh=ne({softplus_:j5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K5(t){const e=W(t,"x","logSigmoid");return To(s=>({value:dn(sh(dn(s))),gradFunc:i=>ae(i,Ci(dn(s)))}))(e)}const hz=ne({logSigmoid_:K5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X5(t,e){let n=W(t,"a","sub"),s=W(e,"b","sub");[n,s]=Cn(n,s);const r={a:n,b:s};return ie.runKernel(vm,r)}const qe=ne({sub_:X5});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y5(t,e=-1){const n=W(t,"logits","logSoftmax");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return To((r,a)=>{const o=wa(r,e,!0),l=qe(r,o),c=qe(Ge(l,"float32"),Kr(Xe(Tr(l),e,!0)));return a([c]),{value:c,gradFunc:(p,f)=>{const[g]=f,y=!0,x=Tr(g);return qe(p,ae(Xe(p,e,y),x))}}})(n)}const a_=ne({logSoftmax_:Y5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z5(t,e=null,n=!1){const s=W(t,"x","logSumExp"),r=St(e,s.shape),a=wa(s,r,!0),i=qe(s,a),o=Tr(i),l=Xe(o,r),c=Kr(l),h=Ae(le(a,c.shape),c);if(n){const p=Rn(h.shape,r);return le(h,p)}return h}const hx=ne({logSumExp_:Z5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q5(t,e){const n=W(t,"a","logicalAnd","bool"),s=W(e,"b","logicalAnd","bool");ft(n.shape,s.shape);const r={a:n,b:s};return ie.runKernel(kb,r)}const Ei=ne({logicalAnd_:Q5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J5(t){const n={x:W(t,"x","logicalNot","bool")};return ie.runKernel(Nb,n)}const px=ne({logicalNot_:J5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e8(t,e){const n=W(t,"a","logicalOr","bool"),s=W(e,"b","logicalOr","bool");ft(n.shape,s.shape);const r={a:n,b:s};return ie.runKernel(Ib,r)}const i_=ne({logicalOr_:e8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t8(t,e){const n=W(t,"a","logicalXor","bool"),s=W(e,"b","logicalXor","bool");return ft(n.shape,s.shape),Ei(i_(t,e),px(Ei(t,e)))}const pz=ne({logicalXor_:t8});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ty=2147483648;function n8(t,e,n="left"){const s=W(t,"sortedSequence","searchSorted"),r=W(e,"values","searchSorted"),a=s.shape[s.shape.length-1],i=r.shape[r.shape.length-1],o=le(s,[-1,a]),l=le(r,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if($e(l.shape)>=Ty)throw new Error(`values tensor size must less than ${Ty}`);if(o.shape[1]>=Ty)throw new Error(`trailing dim_size must less than ${Ty} for int32 output type, was ${o.shape[1]}`);const c={sortedSequence:o,values:l},h={side:n};return ie.runKernel(ES,c,h)}const o_=ne({searchSorted_:n8});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s8(t,e){return o_(t,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r8(t,e,n,s,r){const a=W(t,"x","maxPool"),i=1;let o=a,l=!1;a.rank===3&&(l=!0,o=le(a,[1,a.shape[0],a.shape[1],a.shape[2]])),V(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),V(xs(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),js("maxPool",s,r);const c={x:o},h={filterSize:e,strides:n,pad:s,dimRoundingMode:r},p=ie.runKernel(Rb,c,h);return l?le(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const fx=ne({maxPool_:r8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a8(t,e=[1,1,1],n,s,r,a="NDHWC"){const i=W(t,"x","maxPool3d");let o=i,l=!1;i.rank===4&&(l=!0,o=le(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),V(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),V(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),js("maxPool3d",s,r);const c={x:o},h={filterSize:e,strides:n,pad:s,dimRoundingMode:r,dataFormat:a},p=ie.runKernel(Db,c,h);return l?le(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const fz=ne({maxPool3d_:a8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i8(t,e,n,s,r=!1){const i={x:W(t,"x","maxPoolWithArgmax")},o={filterSize:e,strides:n,pad:s,includeBatchInIndex:r},l=ie.runKernel(gS,i,o);return{result:l[0],indexes:l[1]}}const o8=ne({maxPoolWithArgmax_:i8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l8(t,e){let n=W(t,"a","maximum"),s=W(e,"b","maximum");[n,s]=Cn(n,s),n.dtype==="bool"&&(n=Ge(n,"int32"),s=Ge(s,"int32")),ft(n.shape,s.shape);const r={a:n,b:s};return ie.runKernel(sm,r)}const Ro=ne({maximum_:l8});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u8(t,e=null,n=!1){const r={x:W(t,"x","mean")},a={axis:e,keepDims:n};return ie.runKernel(Ob,r,a)}const _n=ne({mean_:u8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hn(t,e="float32"){if(Yr(t),e==="complex64"){const s=Hn(t,"float32"),r=Hn(t,"float32");return Dl(s,r)}const n=Rs($e(t),e);return ie.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ir(t,e="float32"){if(Yr(t),e==="complex64"){const s=ir(t,"float32"),r=Hn(t,"float32");return Dl(s,r)}const n=B2($e(t),e);return ie.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c8(t,e,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(t===void 0)return[];let s=W(t,"x","meshgrid",t instanceof yn?t.dtype:"float32");if(e===void 0)return[s];let r=W(e,"y","meshgrid",e instanceof yn?e.dtype:"float32");const a=$e(s.shape),i=$e(r.shape);return n==="xy"?(s=le(s,[1,-1]),r=le(r,[-1,1]),[Tt(ir([i,1],s.dtype),s),Tt(r,ir([1,a],r.dtype))]):(s=le(s,[-1,1]),r=le(r,[1,-1]),[Tt(s,ir([1,i],s.dtype)),Tt(ir([a,1],r.dtype),r)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d8(t,e){let n=W(t,"a","minimum"),s=W(e,"b","minimum");[n,s]=Cn(n,s),n.dtype==="bool"&&(n=Ge(n,"int32"),s=Ge(s,"int32")),ft(n.shape,s.shape);const r={a:n,b:s};return ie.runKernel(rm,r)}const uc=ne({minimum_:d8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h8(t,e,n){V(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const s=W(t,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");V(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=n==="reflect"?1:0;for(let o=0;o<s.rank;o++)V(e[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),V(e[o][0]>=0&&e[o][0]<=s.shape[o]-r&&e[o][1]>=0&&e[o][1]<=s.shape[o]-r,()=>`Padding in dimension ${o} cannot be greater than or equal to ${s.shape[o]-r} or less than 0 for input of shape ${s.shape}`);const a={paddings:e,mode:n},i={x:s};return ie.runKernel(Fb,i,a)}const mz=ne({mirrorPad_:h8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p8(t,e){let n=W(t,"a","mod"),s=W(e,"b","mod");[n,s]=Cn(n,s);const r={a:n,b:s};return ie.runKernel(am,r)}const gz=ne({mod_:p8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f8(t,e=null,n=!1){t=W(t,"x","moments");const s=St(e,t.shape),r=_n(t,s,n);let a=r.shape;n||(a=Rn(r.shape,s));const i=nn(qe(Ge(t,"float32"),le(r,a))),o=_n(i,s,n);return{mean:r,variance:o}}const mx=ne({moments_:f8});function m8(t,e,n,s){const r=W(e,"data","multiRNNCell"),a=$0(n,"c","multiRNNCell"),i=$0(s,"h","multiRNNCell");let o=r;const l=[];for(let p=0;p<t.length;p++){const f=t[p](o,a[p],i[p]);l.push(f[0]),l.push(f[1]),o=f[1]}const c=[],h=[];for(let p=0;p<l.length;p+=2)c.push(l[p]),h.push(l[p+1]);return[c,h]}const g8=ne({multiRNNCell_:m8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y8(t,e,n,s=!1){const r=W(t,"logits","multinomial"),a=r.size,i=r.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const l={logits:i===1?le(r,[1,-1]):r},c={numSamples:e,seed:n,normalized:s},h=ie.runKernel(yS,l,c);return i===1?le(h,[h.size]):h}const b8=ne({multinomial_:y8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x8(t,e){let n=W(t,"a","notEqual","string_or_numeric"),s=W(e,"b","notEqual","string_or_numeric");[n,s]=Cn(n,s),ft(n.shape,s.shape);const r={a:n,b:s};return ie.runKernel(Mb,r)}const Vd=ne({notEqual_:x8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w8(t,e,n=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const i={indices:W(t,"indices","oneHot","int32")},o={dtype:r,depth:e,onValue:n,offValue:s};return ie.runKernel(Pb,i,o)}const l_=ne({oneHot_:w8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v8(t){const n={x:W(t,"x","onesLike")};return ie.runKernel(Bb,n)}const Xr=ne({onesLike_:v8});function $8(t,e){const n=W(t,"v1","outerProduct"),s=W(e,"v2","outerProduct");V(n.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${s.rank}.`);const r=le(n,[-1,1]),a=le(s,[1,-1]);return Tt(r,a)}const S8=ne({outerProduct_:$8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _8(t,e,n=0){const s=W(t,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:n},a={x:s};return ie.runKernel(Ub,a,r)}const Yl=ne({pad_:_8});function C8(t,e,n=0){return V(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Yl(t,[e],n)}const T8=ne({pad1d_:C8});function k8(t,e,n=0){return V(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Yl(t,e,n)}const N8=ne({pad2d_:k8});function I8(t,e,n=0){return V(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Yl(t,e,n)}const E8=ne({pad3d_:I8});function A8(t,e,n=0){return V(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Yl(t,e,n)}const R8=ne({pad4d_:A8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D8(t,e,n){const s=W(t,"x","spaceToBatchND");V(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),V(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),V(s.shape.reduce((i,o,l)=>l>0&&l<=e.length?i&&(o+n[l-1][0]+n[l-1][1])%e[l-1]===0:i,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},a={blockShape:e,paddings:n};return ie.runKernel(Qb,r,a)}const gx=ne({spaceToBatchND_:D8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O8(t,e,n,s,r,a,i){r==null&&(r=[1,1]),a==null&&(a=1),s===0&&(s="valid");const o=W(t,"x","maxPool");let l=o,c=!1;o.rank===3&&(c=!0,l=le(o,[1,o.shape[0],o.shape[1],o.shape[2]])),V(xs(a,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${r}'`);const h=_a(l.shape,e,a,r,s),p=[h.dilationHeight,h.dilationWidth];let f;s==="same"?f=F8([h.filterHeight,h.filterWidth],p):f=[[0,0],[0,0]];const g=p[0]===1&&p[1]===1,[y,x]=z8([h.inHeight,h.inWidth],p,f),w=g?s:"valid",v=g?l:gx(l,p,y),T=(n==="avg"?()=>ix(v,e,a,w,i):()=>fx(v,e,a,w,i))(),C=g?T:ox(T,p,x);return c?le(C,[C.shape[1],C.shape[2],C.shape[3]]):C}function z8(t,e,n){const s=n.map(h=>h[0]),r=n.map(h=>h[1]),a=t.concat(s,r),i=e.map((h,p)=>(h-a[p]%h)%h),o=r.map((h,p)=>h+i[p]),l=e.map((h,p)=>[s[p],o[p]]),c=e.map((h,p)=>[0,i[p]]);return[l,c]}function F8(t,e){const s=t.map((i,o)=>i+(i-1)*(e[o]-1)).map(i=>i-1),r=s.map(i=>Math.floor(i/2)),a=s.map((i,o)=>i-r[o]);return s.map((i,o)=>[r[o],a[o]])}const yz=ne({pool_:O8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L8(t,e){const n=W(t,"x","prelu"),s=W(e,"alpha","prelu"),r={x:n,alpha:s};return ie.runKernel(Wb,r)}const yx=ne({prelu_:L8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M8(t,e=null,n=!1){let s=W(t,"x","prod");s.dtype==="bool"&&(s=Ge(s,"int32"));const r={x:s},a={axis:e,keepDims:n};return ie.runKernel(Gb,r,a)}const bz=ne({prod_:M8});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B8(t,e,n,s){const r=t.map((h,p)=>W(h,`tensors${p}`,"raggedGather","int32")),a=W(e,"paramsDenseValues","raggedGather"),i=W(n,"indices","raggedGather","int32"),o={paramsNestedSplits:r,paramsDenseValues:a,indices:i},l={outputRaggedRank:s},c=ie.runKernel(vS,o,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const P8=ne({raggedGather_:B8});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V8(t,e,n){const s=W(t,"starts","raggedRange"),r=W(e,"limits","raggedRange",s.dtype),a=W(n,"deltas","raggedRange",s.dtype),i={starts:s,limits:r,deltas:a},o=ie.runKernel($S,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}const U8=ne({raggedRange_:V8});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W8(t,e,n,s,r){const a=W(t,"shape","raggedTensorToTensor","int32"),i=W(e,"values","raggedTensorToTensor"),o=W(n,"defaultValue","raggedTensorToTensor",i.dtype),l=s.map((p,f)=>W(p,`tensors${f}`,"raggedTensorToTensor","int32")),c={shape:a,values:i,defaultValue:o,rowPartitionTensors:l},h={rowPartitionTypes:r};return ie.runKernel(SS,c,h)}const G8=ne({raggedTensorToTensor_:W8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H8(t,e,n){Yr(t);const s=$e(t);let r=null;if(n==null||n==="float32")r=new Float32Array(s);else if(n==="int32")r=new Int32Array(s);else if(n==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${n}`);for(let a=0;a<s;a++)r[a]=e();return ie.makeTensor(r,t,n)}const q8=ne({rand_:H8});var r0={exports:{}},j8=r0.exports,xI;function K8(){return xI||(xI=1,function(t){(function(e,n,s){function r(l){var c=this,h=o();c.next=function(){var p=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=p-(c.c=p|0)},c.c=1,c.s0=h(" "),c.s1=h(" "),c.s2=h(" "),c.s0-=h(l),c.s0<0&&(c.s0+=1),c.s1-=h(l),c.s1<0&&(c.s1+=1),c.s2-=h(l),c.s2<0&&(c.s2+=1),h=null}function a(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function i(l,c){var h=new r(l),p=c&&c.state,f=h.next;return f.int32=function(){return h.next()*4294967296|0},f.double=function(){return f()+(f()*2097152|0)*11102230246251565e-32},f.quick=f,p&&(typeof p=="object"&&a(p,h),f.state=function(){return a(h,{})}),f}function o(){var l=4022871197,c=function(h){h=String(h);for(var p=0;p<h.length;p++){l+=h.charCodeAt(p);var f=.02519603282416938*l;l=f>>>0,f-=l,f*=l,l=f>>>0,f-=l,l+=f*4294967296}return(l>>>0)*23283064365386963e-26};return c}n&&n.exports?n.exports=i:this.alea=i})(j8,t)}(r0)),r0.exports}var a0={exports:{}},X8=a0.exports,wI;function Y8(){return wI||(wI=1,function(t){(function(e,n,s){function r(o){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var p=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^p^p>>>8},o===(o|0)?l.x=o:c+=o;for(var h=0;h<c.length+64;h++)l.x^=c.charCodeAt(h)|0,l.next()}function a(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l}function i(o,l){var c=new r(o),h=l&&l.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var f=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(f+g)/(1<<21);while(y===0);return y},p.int32=c.next,p.quick=p,h&&(typeof h=="object"&&a(h,c),p.state=function(){return a(c,{})}),p}n&&n.exports?n.exports=i:this.xor128=i})(X8,t)}(a0)),a0.exports}var i0={exports:{}},Z8=i0.exports,vI;function Q8(){return vI||(vI=1,function(t){(function(e,n,s){function r(o){var l=this,c="";l.next=function(){var p=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(p^p<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,o===(o|0)?l.x=o:c+=o;for(var h=0;h<c.length+64;h++)l.x^=c.charCodeAt(h)|0,h==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function a(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l.v=o.v,l.d=o.d,l}function i(o,l){var c=new r(o),h=l&&l.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var f=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(f+g)/(1<<21);while(y===0);return y},p.int32=c.next,p.quick=p,h&&(typeof h=="object"&&a(h,c),p.state=function(){return a(c,{})}),p}n&&n.exports?n.exports=i:this.xorwow=i})(Z8,t)}(i0)),i0.exports}var o0={exports:{}},J8=o0.exports,$I;function eK(){return $I||($I=1,function(t){(function(e,n,s){function r(o){var l=this;l.next=function(){var h=l.x,p=l.i,f,g;return f=h[p],f^=f>>>7,g=f^f<<24,f=h[p+1&7],g^=f^f>>>10,f=h[p+3&7],g^=f^f>>>3,f=h[p+4&7],g^=f^f<<7,f=h[p+7&7],f=f^f<<13,g^=f^f<<9,h[p]=g,l.i=p+1&7,g};function c(h,p){var f,g=[];if(p===(p|0))g[0]=p;else for(p=""+p,f=0;f<p.length;++f)g[f&7]=g[f&7]<<15^p.charCodeAt(f)+g[f+1&7]<<13;for(;g.length<8;)g.push(0);for(f=0;f<8&&g[f]===0;++f);for(f==8?g[7]=-1:g[f],h.x=g,h.i=0,f=256;f>0;--f)h.next()}c(l,o)}function a(o,l){return l.x=o.x.slice(),l.i=o.i,l}function i(o,l){o==null&&(o=+new Date);var c=new r(o),h=l&&l.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var f=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(f+g)/(1<<21);while(y===0);return y},p.int32=c.next,p.quick=p,h&&(h.x&&a(h,c),p.state=function(){return a(c,{})}),p}n&&n.exports?n.exports=i:this.xorshift7=i})(J8,t)}(o0)),o0.exports}var l0={exports:{}},tK=l0.exports,SI;function nK(){return SI||(SI=1,function(t){(function(e,n,s){function r(o){var l=this;l.next=function(){var h=l.w,p=l.X,f=l.i,g,y;return l.w=h=h+1640531527|0,y=p[f+34&127],g=p[f=f+1&127],y^=y<<13,g^=g<<17,y^=y>>>15,g^=g>>>12,y=p[f]=y^g,l.i=f,y+(h^h>>>16)|0};function c(h,p){var f,g,y,x,w,v=[],$=128;for(p===(p|0)?(g=p,p=null):(p=p+"\0",g=0,$=Math.max($,p.length)),y=0,x=-32;x<$;++x)p&&(g^=p.charCodeAt((x+32)%p.length)),x===0&&(w=g),g^=g<<10,g^=g>>>15,g^=g<<4,g^=g>>>13,x>=0&&(w=w+1640531527|0,f=v[x&127]^=g+w,y=f==0?y+1:0);for(y>=128&&(v[(p&&p.length||0)&127]=-1),y=127,x=4*128;x>0;--x)g=v[y+34&127],f=v[y=y+1&127],g^=g<<13,f^=f<<17,g^=g>>>15,f^=f>>>12,v[y]=g^f;h.w=w,h.X=v,h.i=y}c(l,o)}function a(o,l){return l.i=o.i,l.w=o.w,l.X=o.X.slice(),l}function i(o,l){o==null&&(o=+new Date);var c=new r(o),h=l&&l.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var f=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(f+g)/(1<<21);while(y===0);return y},p.int32=c.next,p.quick=p,h&&(h.X&&a(h,c),p.state=function(){return a(c,{})}),p}n&&n.exports?n.exports=i:this.xor4096=i})(tK,t)}(l0)),l0.exports}var u0={exports:{}},sK=u0.exports,_I;function rK(){return _I||(_I=1,function(t){(function(e,n,s){function r(o){var l=this,c="";l.next=function(){var p=l.b,f=l.c,g=l.d,y=l.a;return p=p<<25^p>>>7^f,f=f-g|0,g=g<<24^g>>>8^y,y=y-p|0,l.b=p=p<<20^p>>>12^f,l.c=f=f-g|0,l.d=g<<16^f>>>16^y,l.a=y-p|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,o===Math.floor(o)?(l.a=o/4294967296|0,l.b=o|0):c+=o;for(var h=0;h<c.length+20;h++)l.b^=c.charCodeAt(h)|0,l.next()}function a(o,l){return l.a=o.a,l.b=o.b,l.c=o.c,l.d=o.d,l}function i(o,l){var c=new r(o),h=l&&l.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var f=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(f+g)/(1<<21);while(y===0);return y},p.int32=c.next,p.quick=p,h&&(typeof h=="object"&&a(h,c),p.state=function(){return a(c,{})}),p}n&&n.exports?n.exports=i:this.tychei=i})(sK,t)}(u0)),u0.exports}var c0={exports:{}};const aK={},iK=Object.freeze(Object.defineProperty({__proto__:null,default:aK},Symbol.toStringTag,{value:"Module"})),oK=PG(iK);var lK=c0.exports,CI;function uK(){return CI||(CI=1,function(t){(function(e,n,s){var r=256,a=6,i=52,o="random",l=s.pow(r,a),c=s.pow(2,i),h=c*2,p=r-1,f;function g(C,I,A){var O=[];I=I==!0?{entropy:!0}:I||{};var B=v(w(I.entropy?[C,T(n)]:C??$(),3),O),z=new y(O),P=function(){for(var F=z.g(a),K=l,X=0;F<c;)F=(F+X)*r,K*=r,X=z.g(1);for(;F>=h;)F/=2,K/=2,X>>>=1;return(F+X)/K};return P.int32=function(){return z.g(4)|0},P.quick=function(){return z.g(4)/4294967296},P.double=P,v(T(z.S),n),(I.pass||A||function(F,K,X,te){return te&&(te.S&&x(te,z),F.state=function(){return x(z,{})}),X?(s[o]=F,K):F})(P,B,"global"in I?I.global:this==s,I.state)}function y(C){var I,A=C.length,O=this,B=0,z=O.i=O.j=0,P=O.S=[];for(A||(C=[A++]);B<r;)P[B]=B++;for(B=0;B<r;B++)P[B]=P[z=p&z+C[B%A]+(I=P[B])],P[z]=I;(O.g=function(F){for(var K,X=0,te=O.i,Q=O.j,q=O.S;F--;)K=q[te=p&te+1],X=X*r+q[p&(q[te]=q[Q=p&Q+K])+(q[Q]=K)];return O.i=te,O.j=Q,X})(r)}function x(C,I){return I.i=C.i,I.j=C.j,I.S=C.S.slice(),I}function w(C,I){var A=[],O=typeof C,B;if(I&&O=="object")for(B in C)try{A.push(w(C[B],I-1))}catch{}return A.length?A:O=="string"?C:C+"\0"}function v(C,I){for(var A=C+"",O,B=0;B<A.length;)I[p&B]=p&(O^=I[p&B]*19)+A.charCodeAt(B++);return T(I)}function $(){try{var C;return f&&(C=f.randomBytes)?C=C(r):(C=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(C)),T(C)}catch{var I=e.navigator,A=I&&I.plugins;return[+new Date,e,A,e.screen,T(n)]}}function T(C){return String.fromCharCode.apply(0,C)}if(v(s.random(),n),t.exports){t.exports=g;try{f=oK}catch{}}else s["seed"+o]=g})(typeof self<"u"?self:lK,[],Math)}(c0)),c0.exports}var uv,TI;function cK(){if(TI)return uv;TI=1;var t=K8(),e=Y8(),n=Q8(),s=eK(),r=nK(),a=rK(),i=uK();return i.alea=t,i.xor128=e,i.xorwow=n,i.xorshift7=s,i.xor4096=r,i.tychei=a,uv=i,uv}var bx=cK();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class u_{constructor(e,n,s,r,a){this.mean=e,this.stdDev=n,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const i=a||Math.random();this.random=bx.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,n,s=!1;for(;!s;){let r,a,i;do r=2*this.random()-1,a=2*this.random()-1,i=r*r+a*a;while(i>=1||i===0);const o=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*r*o,n=this.mean+this.stdDev*a*o,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class dK{constructor(e,n,s,r){this.alpha=e,this.beta=1/n,this.dtype=s;const a=r||Math.random();this.randu=bx.alea(a.toString()),this.randn=new u_(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,n,s,r,a,i;for(;;){do r=this.randn.nextValue(),i=1+this.c*r;while(i<=0);if(i*=i*i,e=r*r,n=1-.331*e*e,s=.5*e+this.d*(1-i+Math.log(i)),a=this.randu(),a<n||Math.log(a)<s)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class hK{constructor(e=0,n=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=n-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);this.random=bx.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pK(t,e,n=1,s="float32",r){if(Yr(t),n==null&&(n=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const a=new dK(e,n,s,r),i=xt(t,s);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const fK=ne({randomGamma_:pK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mK(t,e=0,n=1,s,r){if(Yr(t),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const a=new u_(e,n,s,!1,r),i=xt(t,s);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const c_=ne({randomNormal_:mK});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gK(t,e,n){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return c_(t,0,1,e,n)}const yK=ne({randomStandardNormal_:gK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bK(t,e=0,n=1,s="float32",r){Yr(t);const a=xt(t,s),i=new hK(e,n,null,r);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const $c=ne({randomUniform_:bK});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xK(t,e,n,s){return $c(t,e,n,"int32",s)}const wK=ne({randomUniformInt_:xK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ud(t,e,n=1,s="float32"){if(n===0)throw new Error("Cannot have a step of zero");const r={start:t,stop:e,step:n,dtype:s};return ie.runKernel(_S,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vK(t){const n={input:W(t,"input","real")};return ie.runKernel(CS,n)}const mf=ne({real_:vK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $K(t){const n={x:W(t,"x","reciprocal")};return ie.runKernel(lm,n)}const xz=ne({reciprocal_:$K});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SK(t){const n={x:W(t,"x","relu")};return ie.runKernel(um,n)}const zi=ne({relu_:SK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _K(t){const n={x:W(t,"x","relu6")};return ie.runKernel(cm,n)}const d_=ne({relu6_:_K});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CK(t,e){const s={x:W(t,"x","reverse")},r={dims:e};return ie.runKernel(Kb,s,r)}const $a=ne({reverse_:CK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TK(t){const e=W(t,"x","reverse");return V(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),$a(e,0)}const kK=ne({reverse1d_:TK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NK(t,e){const n=W(t,"x","reverse");return V(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),$a(n,e)}const IK=ne({reverse2d_:NK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EK(t,e){const n=W(t,"x","reverse");return V(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),$a(n,e)}const AK=ne({reverse3d_:EK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RK(t,e){const n=W(t,"x","reverse");return V(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),$a(n,e)}const DK=ne({reverse4d_:RK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OK(t){const n={x:W(t,"x","round")};return ie.runKernel(dm,n)}const h_=ne({round_:OK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zK(t){const n={x:W(t,"x","rsqrt","float32")};return ie.runKernel(hm,n)}const p_=ne({rsqrt_:zK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FK(t){const n={x:W(t,"x","selu")};return ie.runKernel(pm,n)}const f_=ne({selu_:FK});function LK(t,e,n,s,r,a=[1,1],i="NHWC"){const o=W(t,"x","separableConv2d"),l=W(e,"depthwiseFilter","separableConv2d"),c=W(n,"pointwiseFilter","separableConv2d");let h=o,p=!1;if(o.rank===3&&(p=!0,h=le(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");V(h.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${h.rank}.`),V(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),V(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),V(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),V(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const f=l.shape[2],g=l.shape[3];V(c.shape[2]===f*g,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${f*g}, but got ${c.shape[2]}.`);const y=Im(h,l,s,r,i,a),w=Fl(y,c,1,"valid",i);return p?le(w,[w.shape[1],w.shape[2],w.shape[3]]):w}const m_=ne({separableConv2d_:LK});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function MK(t,e){const n=W(t,"x","setdiff1d"),s=W(e,"y","setdiff1d");V(n.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${s.dtype}).`),V(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),V(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await n.data(),a=await s.data(),i=new Set(a);let o=0;for(let h=0;h<r.length;h++)i.has(r[h])||o++;const l=new Kn([o],n.dtype),c=new Kn([o],"int32");for(let h=0,p=0;h<r.length;h++)i.has(r[h])||(l.values[p]=r[h],c.values[p]=h,p++);return[l.toTensor(),c.toTensor()]}const BK=MK;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PK(t){const n={x:W(t,"x","sign")};return ie.runKernel(gm,n)}const wz=ne({sign_:PK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VK(t){const n={x:W(t,"x","sin","float32")};return ie.runKernel(fm,n)}const g_=ne({sin_:VK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UK(t){const n={x:W(t,"x","sinh")};return ie.runKernel(mm,n)}const y_=ne({sinh_:UK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WK(t,e,n){const s=W(t,"x","slice1d");return V(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),Ot(s,[e],[n])}const xx=ne({slice1d_:WK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GK(t,e,n){const s=W(t,"x","slice2d");return V(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),Ot(s,e,n)}const b_=ne({slice2d_:GK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HK(t,e,n){const s=W(t,"x","slice3d");return V(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),Ot(s,e,n)}const wx=ne({slice3d_:HK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qK(t,e,n){const s=W(t,"x","slice4d");return V(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),Ot(s,e,n)}const gf=ne({slice4d_:qK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jK(t,e=-1){const n=W(t,"logits","softmax","float32");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const s={logits:n},r={dim:e};return ie.runKernel(ex,s,r)}const vx=ne({softmax_:jK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KK(t){V(t.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);const e={input:t};return ie.runKernel(iS,e)}const $x=ne({fft_:KK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XK(t){V(t.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);const e={input:t};return ie.runKernel(cS,e)}const yf=ne({ifft_:XK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YK(t){const e=t.shape[t.shape.length-1],n=t.size/e;let s;if(e<=2){const r=le(t,[n,e]);s=yf(r)}else{const r=[n,2*(e-1)],a=le(mf(t),[n,e]),i=le(ux(t),[n,e]),o=$a(Ot(a,[0,1],[n,e-2]),1),l=ae($a(Ot(i,[0,1],[n,e-2]),1),st(-1)),c=Bn([a,o],1),h=Bn([i,l],1),p=le(Dl(c,h),[r[0],r[1]]);s=yf(p)}if(s=mf(s),t.rank===3&&t.shape[0]!==0){const r=s,a=t.shape[0];s=le(s,[a,s.shape[0]/a,s.shape[1]]),r.dispose()}return s}const x_=ne({irfft_:YK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZK(t,e,n=0){const r={x:W(t,"x","split")},a={numOrSizeSplits:e,axis:n};return ie.runKernel(Jb,r,a)}const Sr=ne({split_:ZK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QK(t,e){V(t.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const s=t.size/n;let r;if(e!=null&&e<n){const y=t.shape.map(w=>0),x=t.shape.map(w=>w);x[t.shape.length-1]=e,r=Ot(t,y,x),n=e}else if(e!=null&&e>n){const y=t.shape.map(x=>x);y[t.shape.length-1]=e-n,r=Bn([t,Hn(y)],t.shape.length-1),n=e}else r=t;const a=Lt(r),i=le(Dl(r,a),[s,n]),o=$x(i),l=Math.floor(n/2)+1,c=mf(o),h=ux(o),p=Sr(c,[l,n-l],c.shape.length-1),f=Sr(h,[l,n-l],h.shape.length-1),g=r.shape.slice();return g[r.shape.length-1]=l,le(Dl(p[0],f[0]),g)}const Sx=ne({rfft_:QK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JK(t,e){let n=W(t,"a","squaredDifference"),s=W(e,"b","squaredDifference");[n,s]=Cn(n,s),ft(n.shape,s.shape);const r={a:n,b:s},a={};return ie.runKernel(wm,r,a)}const w_=ne({squaredDifference_:JK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eX(t,e){const n=W(t,"x","squeeze","string_or_numeric");return le(n,Wl(n.shape,e).newShape)}const Sc=ne({squeeze_:eX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tX(t,e=0){const n=$0(t,"tensors","stack","string_or_numeric");V(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&V(e<=n[0].rank,()=>"Axis must be <= rank of the tensor");const s=n,r={axis:e};return ie.runKernel(Vb,s,r)}const kr=ne({stack_:tX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nX(t,e=0){const s={x:W(t,"x","step")},r={alpha:e};return ie.runKernel(Cm,s,r)}const rh=ne({step_:nX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sX(t,e,n,s,r=0,a=0,i=0,o=0,l=0){const h={x:W(t,"x","stridedSlice","string_or_numeric")},p={begin:e,end:n,strides:s,beginMask:r,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return ie.runKernel(LS,h,p)}const vz=ne({stridedSlice_:sX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rX(t){const n={x:W(t,"x","tan","float32")};return ie.runKernel($m,n)}const $z=ne({tan_:rX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hs(t,e){Qd(t);const n=Hl(t,e);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ql(t,null,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function of(t,e,n){if(Qd(t),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Hl(t,n);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ql(t,e,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aX(t,e,n){if(Qd(t),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=Hl(t,n);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return ql(t,e,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iX(t,e,n){if(Qd(t),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=Hl(t,n);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return ql(t,e,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oX(t,e,n){if(Qd(t),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=Hl(t,n);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return ql(t,e,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lX(t,e,n){if(Qd(t),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=Hl(t,n);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,ql(t,e,s,n)}function Sz(t,e,n){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${s}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(a+` update.rank < ${r}. `);if(t.length<s+(n.rank-r))throw new Error(a+` Output shape length < ${s+(n.rank-r)}`);if(n.rank!==r+t.length-s)throw new Error(a+` update.rank != ${r+t.length-s}`);for(let i=0;i<r;++i)if(n.shape[i]!==e.shape[i])throw new Error(a+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${e.shape[i]}).`);for(let i=0;i<n.rank-r;++i)if(n.shape[i+r]!==t[i+s])throw new Error(a+` updates.shape[${i+r}] (${n.shape[i+r]}) != shape[${i+r}] (${t[i+r]})`)}function v_(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}Sz(n,e,t)}function _c(t,e,n){const s=e.shape.length,r=s>1?e.shape[s-1]:1,a=n.length;let i=1;for(let p=r;p<a;++p)i*=n[p];const o=r<1?1:r,l=$e(e.shape)/o,c=[...nt(n.slice(0,r)),1],h=$e(n);return{sliceRank:r,numUpdates:l,sliceSize:i,strides:c,outputSize:h}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uX(t,e,n){const s=W(t,"tensor","tensorScatterupdate"),r=W(e,"indices","tensorScatterupdate","int32"),a=W(n,"updates","tensorScatterupdate");if(v_(a,r,s.shape),s.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${a.dtype}.`);const i={tensor:s,indices:r,updates:a},o={};return ie.runKernel(IS,i,o)}const cX=ne({tensorScatterUpdate_:uX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dX(t,e=1,n=!0){const s=W(t,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const a={x:s},i={k:e,sorted:n},[o,l]=ie.runKernel(VS,a,i);return{values:o,indices:l}}const _z=ne({topk_:dX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hX(t,e=0,n=1,s,r){if(Yr(t),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new u_(e,n,s,!0,r),i=xt(t,s);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const $_=ne({truncatedNormal_:hX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pX(t,e=0){const n=W(t,"x","unique","string_or_numeric");V(n.rank>0,()=>"The input tensor must be at least 1D");const s={x:n},r={axis:e},[a,i]=ie.runKernel(WS,s,r);return{values:a,indices:i}}const Cz=ne({unique_:pX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fX(t,e,n){const s=W(t,"x","unsortedSegmentSum"),r=W(e,"segmentIds","unsortedSegmentSum","int32");V(Ld(n),()=>"numSegments must be of dtype int");const a={x:s,segmentIds:r},i={numSegments:n};return ie.runKernel(sx,a,i)}const S_=ne({unsortedSegmentSum_:fX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mX(t,e=0){const n=W(t,"x","unstack","string_or_numeric");V(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);const s={value:n},r={axis:e};return ie.runKernel(nx,s,r)}const Sa=ne({unstack_:mX});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gX(t,e){return o_(t,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tz(t,e=!0,n,s){return ie.makeVariable(t,e,n,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function __(t,e){const n=[];for(let a=0;a<e.length;a++)e[a]&&n.push(a);const s=xt(t,"int32"),r=xt([n.length,t.length],"int32");for(let a=0;a<n.length;a++){const i=s.indexToLoc(n[a]),o=a*t.length;r.values.set(i,o)}return r.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function yX(t){const e=W(t,"condition","whereAsync","bool"),n=await e.data(),s=__(e.shape,n);return t!==e&&e.dispose(),s}const kz=yX;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function bX(t,e,n){const s=W(t,"tensor","boolMask"),r=W(e,"mask","boolMask","bool"),a=n??0,i=r.rank,o=s.shape;V(i>0,()=>"mask cannot be scalar"),Er(o.slice(a,a+i),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let x=a;x<a+i;x++)l*=o[x];const c=o.slice(0,a).concat([l],o.slice(a+i)),h=le(s,c),p=le(r,[-1]),f=await kz(p),g=Sc(f,[1]),y=Dm(h,g,a);return t!==s&&s.dispose(),e!==r&&r.dispose(),g.dispose(),h.dispose(),p.dispose(),f.dispose(),y}const xX=bX;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wX(t,e,n){const s=W(t,"x","transpose");if(e==null&&(e=s.shape.map((i,o)=>o).reverse()),V(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(i=>{V(i>=0&&i<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},a={perm:e};return s.dtype==="complex64"?me(()=>{let i=mf(s),o=ux(s);return i=ie.runKernel(Ad,{x:i},a),o=ie.runKernel(Ad,{x:o},a),n&&(o=dn(o)),Dl(i,o)}):ie.runKernel(Ad,r,a)}const Ft=ne({transpose_:wX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vX(t,e,n,s,r=!0){const a=W(t,"v","movingAverage"),i=W(e,"x","movingAverage"),o=W(n,"decay","movingAverage");iq(a,i),V(Rt(a.shape,i.shape),()=>"Shape mismatch in v and x");const l=st(1),c=qe(l,o);let h=ae(qe(i,a),c);if(r){V(s!=null,()=>"When using zeroDebias: true, step is required.");const p=W(s,"step","movingAverage");h=et(h,qe(l,Co(o,p)))}return Ae(a,h)}const $X=ne({movingAverage_:vX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SX(t,e,n){Yr(n);const s=W(t,"indices","scatterND","int32"),r=W(e,"updates","scatterND");v_(r,s,n);const a={indices:s,updates:r},i={shape:n};return ie.runKernel(NS,a,i)}const _X=ne({scatterND_:SX});function CX(t,e,n,s){if(t.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const r=t.rank>0?t.shape[0]:1,a=t.rank>1?t.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const i=e.size;if(!(e.rank===0||e.rank===1&&i===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TX(t,e,n,s=0){Yr(n);const r=W(t,"sparseIndices","sparseToDense","int32"),a=W(e,"sparseValues","sparseToDense","string_or_numeric"),i=W(s,"defaultValue","sparseToDense",a.dtype);CX(r,a,n,i);const o={sparseIndices:r,sparseValues:a,defaultValue:i},l={outputShape:n};return ie.runKernel(zS,o,l)}const kX=ne({sparseToDense_:TX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NX(t,e){const n=W(e,"indices","gatherND","int32"),r={params:W(t,"x","gatherND","string_or_numeric"),indices:n};return ie.runKernel(uS,r)}const IX=ne({gatherND_:NX});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EX(t,e){if(e==null)return t.shape.slice();if(Rt(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let s=0;s<t.shape.length;s++)e[s]==null&&t.shape[s]!=null?n.push(t.shape[s]):n.push(e[s]);return n}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AX(t,e,n,s){const r=W(t,"x","dropout");if(V(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),V(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return t instanceof yn?r.clone():r;const a=EX(r,n),i=1-e,o=et(Rm(Ae($c(a,0,1,"float32",s),i)),i);return ae(r,o)}const Nz=ne({dropout_:AX});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iz(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function C_(t,e,n){const s=1-t%2,r=new Float32Array(t);for(let a=0;a<t;++a){const i=2*Math.PI*a/(t+s-1);r[a]=e-n*Math.cos(i)}return Hs(r,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function RX(t,e,n=1){const s=W(t,"predictions","inTopK"),r=W(e,"targets","inTopK");V(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),V(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),Er(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=s.shape[s.shape.length-1];V(n>0&&n<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`);const i=await s.data(),o=await r.data(),[l,c]=[i.length/a,a],h=ys("bool",l);for(let p=0;p<l;p++){const f=p*c,g=i.subarray(f,f+c),y=[];for(let x=0;x<g.length;x++)y.push({value:g[x],index:x});y.sort((x,w)=>w.value-x.value),h[p]=0;for(let x=0;x<n;x++)if(y[x].index===o[p]){h[p]=1;break}}return t!==s&&s.dispose(),e!==r&&r.dispose(),Ha(h,r.shape,"bool")}const DX=RX;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OX(t,e,n,s,r,a="NHWC",i){let o=t;t.rank===3&&(o=le(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=le(e,[1,e.shape[0],e.shape[1],e.shape[2]])),V(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),V(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),V(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const c=a==="NHWC"?o.shape[3]:o.shape[1],h=a==="NHWC"?l.shape[3]:l.shape[1];V(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`),V(h===n[3],()=>`Error in conv2dDerFilter: depth of dy (${h}) must match output depth for filter (${n[3]}).`),js("conv2dDerFilter",r,i);const p={x:o,dy:l},f={strides:s,pad:r,dataFormat:a,dimRoundingMode:i,filterShape:n};return ie.runKernel(K2,p,f)}const T_=ne({conv2DBackpropFilter_:OX});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _x(t,e,n){if(n==null||n==="linear")return t;if(n==="relu")return ae(t,rh(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Cx(t,e){let n=e;const s=Zn(t.shape,e.shape);return s.length>0&&(n=Xe(n,s)),le(n,t.shape)}function Tx(t,e,n,s){if(e==="linear")return t;if(e==="relu")return zi(t);if(e==="elu")return Em(t);if(e==="relu6")return d_(t);if(e==="prelu")return yx(t,n);if(e==="leakyrelu")return cx(t,s);if(e==="sigmoid")return Ci(t);throw new Error(`Unknown fused activation ${e}.`)}const kx=(t,e)=>!(t>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zX({x:t,filter:e,strides:n,pad:s,dataFormat:r="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:h}){if(l=l||"linear",kx(ie.state.gradientDepth,l)===!1){V(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let A=Fl(t,e,n,s,r,a,i);return o!=null&&(A=Ae(A,o)),Tx(A,l,c,h)}const p=W(t,"x","conv2d","float32"),f=W(e,"filter","conv2d","float32");let g=p,y=!1;p.rank===3&&(y=!0,g=le(p,[1,p.shape[0],p.shape[1],p.shape[2]])),V(g.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${g.rank}.`),V(f.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),js("fused conv2d",s,i);const x=r==="NHWC"?g.shape[3]:g.shape[1];V(f.shape[2]===x,()=>`Error in conv2d: depth of input (${x}) must match input depth for filter ${f.shape[2]}.`),V(xs(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const w=os(g.shape,f.shape,n,a,s,i);let v;o!=null&&(v=W(o,"bias","fused conv2d"),[v]=Cn(v,p),r==="NHWC"?ft(w.outShape,v.shape):(V(v.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${v.shape.length}.`),V(v.shape.length===0||v.shape[0]===w.outChannels||v.shape[0]===1,()=>`Error in fused conv2d: bias shape (${v.shape}) is not compatible with the number of output channels (${w.outChannels})`)));let $;if(c!=null){const A=c.shape;if(V(A.length<=1||A.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${A.length}.`),A.length===1)V(A[0]===1||A[0]===w.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${A}) is not compatible with the number of output channels (${w.outChannels}).`);else if(A.length===3)try{ft(A,w.outShape)}catch{const B=`Error in fused conv2d: PReLU activation weights (${A}) is not compatible with the output shape of the conv2d (${w.outShape}).`;throw Error(B)}$=W(c,"prelu weights","fused conv2d")}const T=(A,O)=>{V(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[B,z,P,F]=O,K=_x(A,P,l);V(zl(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const X=QS(z.shape,K,B,n,s),te=T_(z,K,B.shape,n,s),Q=[X,te];if(F!=null){const q=Cx(F,K);Q.push(q)}return Q},C={x:g,filter:f,bias:v,preluActivationWeights:$},I={strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:h};return o==null?To((O,B,z)=>{let P=ie.runKernel(b0,C,I);return z([B,O,P]),y&&(P=le(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:T}})(g,f):To((O,B,z,P)=>{let F=ie.runKernel(b0,C,I);return P([B,O,F,z]),y&&(F=le(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:T}})(g,f,v)}const Ez=ne({fusedConv2d_:zX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FX(t,e,n,s,r,a=[1,1],i){let o=t;t.rank===3&&(o=le(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=le(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:o,dy:l},h={strides:s,pad:r,dimRoundingMode:i,dilations:a,filterShape:n};return ie.runKernel(tS,c,h)}const Az=ne({depthwiseConv2dNativeBackpropFilter_:FX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LX(t,e,n,s,r,a=[1,1],i){let o=e,l=!1;e.rank===3&&(l=!0,o=le(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:o,filter:n},h={strides:s,pad:r,dimRoundingMode:i,dilations:a,inputShape:t},p=ie.runKernel(nS,c,h);return l?le(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Rz=ne({depthwiseConv2dNativeBackpropInput_:LX});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MX({x:t,filter:e,strides:n,pad:s,dataFormat:r="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:h}){if(kx(ie.state.gradientDepth,l)===!1){let I=Im(t,e,n,s,r,a,i);return o!=null&&(I=Ae(I,o)),Tx(I,l,c,h)}const p=W(t,"x","depthwiseConv2d","float32"),f=W(e,"filter","depthwiseConv2d","float32");let g=p,y=!1;p.rank===3&&(y=!0,g=le(p,[1,p.shape[0],p.shape[1],p.shape[2]])),V(g.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${g.rank}.`),V(f.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),V(g.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${g.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),a==null&&(a=[1,1]),V(xs(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),js("fused depthwiseConv2d",s,i);const x=os(g.shape,f.shape,n,a,s,i,!0);let w;o!=null&&(w=W(o,"bias","fused conv2d"),[w]=Cn(w,p),ft(x.outShape,w.shape));let v;c!=null&&(v=W(c,"prelu weights","fused depthwiseConv2d"));const $=(I,A)=>{V(zl(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[O,B,z,P]=A,F=_x(I,z,l),K=Rz(B.shape,F,O,n,s,a,i),X=Az(B,F,O.shape,n,s,a,i);if(P!=null){const te=Cx(w,F);return[K,X,te]}return[K,X]},T={x:g,filter:f,bias:w,preluActivationWeights:v},C={strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:h};return o==null?To((A,O,B)=>{let z=ie.runKernel(x0,T,C);return B([O,A,z]),y&&(z=le(z,[z.shape[1],z.shape[2],z.shape[3]])),{value:z,gradFunc:$}})(g,f):To((A,O,B,z)=>{let P=ie.runKernel(x0,T,C);return z([O,A,P,B]),y&&(P=le(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:$}})(g,f,w)}const BX=ne({fusedDepthwiseConv2d_:MX});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PX({a:t,b:e,transposeA:n=!1,transposeB:s=!1,bias:r,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(kx(ie.state.gradientDepth,a)===!1){let F=Tt(t,e,n,s);return r!=null&&(F=Ae(F,r)),Tx(F,a,i,o)}let l=W(t,"a","fused matMul"),c=W(e,"b","fused matMul");[l,c]=Cn(l,c);const h=n?l.shape[l.rank-2]:l.shape[l.rank-1],p=s?c.shape[c.rank-1]:c.shape[c.rank-2],f=n?l.shape[l.rank-1]:l.shape[l.rank-2],g=s?c.shape[c.rank-2]:c.shape[c.rank-1],y=l.shape.slice(0,-2),x=c.shape.slice(0,-2),w=$e(y),v=$e(x);V(h===p,()=>`Error in fused matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${n} and transposeB=${s} must match.`);const T=ft(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([f,g]),C=n?le(l,[w,h,f]):le(l,[w,f,h]),I=s?le(c,[v,g,p]):le(c,[v,p,g]);let A;r!=null&&(A=W(r,"bias","fused matMul"),[A]=Cn(A,l),ft(T,A.shape));let O;i!=null&&(O=W(i,"prelu weights","fused matMul"));const B=(F,K)=>{const[X,te,Q,q]=K,oe=_x(le(F,Q.shape),Q,a);let se,ee;if(!n&&!s?(se=Tt(oe,te,!1,!0),ee=Tt(X,oe,!0,!1)):!n&&s?(se=Tt(oe,te,!1,!1),ee=Tt(oe,X,!0,!1)):n&&!s?(se=Tt(te,oe,!1,!0),ee=Tt(X,oe,!1,!1)):(se=Tt(te,oe,!0,!0),ee=Tt(oe,X,!0,!0)),r!=null){const U=Cx(q,oe);return[se,ee,U]}else return[se,ee]},z={a:C,b:I,bias:A,preluActivationWeights:O},P={transposeA:n,transposeB:s,activation:a,leakyreluAlpha:o};return r==null?To((K,X,te)=>{const Q=ie.runKernel(y0,z,P);return te([K,X,Q]),{value:le(Q,T),gradFunc:B}})(C,I):To((K,X,te,Q)=>{const q=ie.runKernel(y0,z,P);return Q([K,X,q,te]),{value:le(q,T),gradFunc:B}})(C,I,A)}const P$=ne({fusedMatMul_:PX});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VX=Object.freeze(Object.defineProperty({__proto__:null,conv2d:Ez,depthwiseConv2d:BX,matMul:P$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UX(t){return C_(t,.54,.46)}const WX=ne({hammingWindow_:UX});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GX(t){return C_(t,.5,.5)}const Dz=ne({hannWindow_:GX});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HX(t,e,n,s=!1,r=0){let a=0;const i=[];for(;a+e<=t.size;)i.push(Ot(t,a,e)),a+=n;if(s)for(;a<t.size;){const o=a+e-t.size,l=Bn([Ot(t,a,e-o),nh([o],r)]);i.push(l),a+=n}return i.length===0?of([],[0,e]):le(Bn(i),[i.length,e])}const Oz=ne({frame_:HX});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qX(t,e,n,s,r=Dz){s==null&&(s=Iz(e));const a=Oz(t,e,n),i=ae(a,r(e));return Sx(i,s)}const jX=ne({stft_:qX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KX(t,e,n,s,r="bilinear",a=0){const i=W(t,"image","cropAndResize"),o=W(e,"boxes","cropAndResize","float32"),l=W(n,"boxInd","cropAndResize","int32"),c=o.shape[0];V(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),V(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${o.shape}.`),V(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${o.shape}.`),V(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),V(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),V(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const h={image:i,boxes:o,boxInd:l},p={method:r,extrapolationValue:a,cropSize:s};return ie.runKernel(Q2,h,p)}const XX=ne({cropAndResize_:KX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YX(t){const e=W(t,"image","flipLeftRight","float32");V(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const n={image:e};return ie.runKernel(lS,n,{})}const ZX=ne({flipLeftRight_:YX});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QX(t){const e=W(t,"image","grayscaleToRGB"),n=e.rank-1,s=e.shape[n];V(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),V(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,n),r[n]=3,ga(e,r)}const JX=ne({grayscaleToRGB_:QX});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e7(t){const e=W(t,"image","RGBToGrayscale"),n=e.rank-1,s=e.shape[n];V(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),V(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=e.dtype,a=Ge(e,"float32"),i=Hs([.2989,.587,.114]);let o;switch(e.rank){case 2:o=Td("ij,j->i",a,i);break;case 3:o=Td("ijk,k->ij",a,i);break;case 4:o=Td("ijkl,l->ijk",a,i);break;case 5:o=Td("ijklm,m->ijkl",a,i);break;case 6:o=Td("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return o=Ws(o,-1),Ge(o,r)}const t7=ne({rgbToGrayscale_:e7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n7(t,e,n=0,s=.5){const r=W(t,"image","rotateWithOffset","float32");V(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const a={image:r},i={radians:e,fillValue:n,center:s};return ie.runKernel(GS,a,i)}const s7=ne({rotateWithOffset_:n7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ah(t,e,n,s,r,a){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),a==null&&(a=0);const i=t.shape[0];return n=Math.min(n,i),V(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),V(t.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),V(t.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),V(e.rank===1,()=>"scores must be a 1D tensor"),V(e.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${e.shape[0]}`),V(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r7(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY){const a=W(t,"boxes","nonMaxSuppression","float32"),i=W(e,"scores","nonMaxSuppression","float32"),o=ah(a,i,n,s,r);n=o.maxOutputSize,s=o.iouThreshold,r=o.scoreThreshold;const l={maxOutputSize:n,iouThreshold:s,scoreThreshold:r};return ie.runKernel(bS,{boxes:a,scores:i},l)}const a7=ne({nonMaxSuppression_:r7});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i7(t,e,n){const s=o7(t,e,n),r=s<0?-(s+1):s;t.splice(r,0,e)}function o7(t,e,n){return u7(t,e,n||l7)}function l7(t,e){return t>e?1:t<e?-1:0}function u7(t,e,n){let s=0,r=t.length,a=0,i=!1;for(;s<r;){a=s+(r-s>>>1);const o=n(e,t[a]);o>0?s=a+1:(r=a,i=!o)}return i?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k_(t,e,n,s,r){return E_(t,e,n,s,r,0)}function N_(t,e,n,s,r,a){return E_(t,e,n,s,r,0,!1,a,!0)}function I_(t,e,n,s,r,a){return E_(t,e,n,s,r,a,!0)}function E_(t,e,n,s,r,a,i=!1,o=!1,l=!1){const c=[];for(let w=0;w<e.length;w++)e[w]>r&&c.push({score:e[w],boxIndex:w,suppressBeginIndex:0});c.sort(kI);const h=a>0?-.5/a:0,p=[],f=[];for(;p.length<n&&c.length>0;){const w=c.pop(),{score:v,boxIndex:$,suppressBeginIndex:T}=w;if(v<r)break;let C=!1;for(let I=p.length-1;I>=T;--I){const A=c7(t,$,p[I]);if(A>=s){C=!0;break}if(w.score=w.score*d7(s,h,A),w.score<=r)break}w.suppressBeginIndex=p.length,C||(w.score===v?(p.push($),f.push(w.score)):w.score>r&&i7(c,w,kI))}const g=p.length,y=n-g;o&&y>0&&(p.push(...new Array(y).fill(0)),f.push(...new Array(y).fill(0)));const x={selectedIndices:p};return i&&(x.selectedScores=f),l&&(x.validOutputs=g),x}function c7(t,e,n){const s=t.subarray(e*4,e*4+4),r=t.subarray(n*4,n*4+4),a=Math.min(s[0],s[2]),i=Math.min(s[1],s[3]),o=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),c=Math.min(r[0],r[2]),h=Math.min(r[1],r[3]),p=Math.max(r[0],r[2]),f=Math.max(r[1],r[3]),g=(o-a)*(l-i),y=(p-c)*(f-h);if(g<=0||y<=0)return 0;const x=Math.max(a,c),w=Math.max(i,h),v=Math.min(o,p),$=Math.min(l,f),T=Math.max(v-x,0)*Math.max($-w,0);return T/(g+y-T)}function d7(t,e,n){const s=Math.exp(e*n*n);return n<=t?s:0}function kI(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function h7(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY){const a=W(t,"boxes","nonMaxSuppressionAsync"),i=W(e,"scores","nonMaxSuppressionAsync"),o=ah(a,i,n,s,r);n=o.maxOutputSize,s=o.iouThreshold,r=o.scoreThreshold;const l=await Promise.all([a.data(),i.data()]),c=l[0],h=l[1],{selectedIndices:p}=k_(c,h,n,s,r);return a!==t&&a.dispose(),i!==e&&i.dispose(),Hs(p,"int32")}const p7=h7;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f7(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,a=0){const i=W(t,"boxes","nonMaxSuppression"),o=W(e,"scores","nonMaxSuppression"),l=ah(i,o,n,s,r,a);n=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,a=l.softNmsSigma;const c={boxes:i,scores:o},h={maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:a},p=ie.runKernel(wS,c,h);return{selectedIndices:p[0],selectedScores:p[1]}}const m7=ne({nonMaxSuppressionWithScore_:f7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function g7(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,a=0){const i=W(t,"boxes","nonMaxSuppressionAsync"),o=W(e,"scores","nonMaxSuppressionAsync"),l=ah(i,o,n,s,r,a);n=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,a=l.softNmsSigma;const c=await Promise.all([i.data(),o.data()]),h=c[0],p=c[1],{selectedIndices:f,selectedScores:g}=I_(h,p,n,s,r,a);return i!==t&&i.dispose(),o!==e&&o.dispose(),{selectedIndices:Hs(f,"int32"),selectedScores:Hs(g)}}const y7=g7;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b7(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,a=!1){const i=W(t,"boxes","nonMaxSuppression"),o=W(e,"scores","nonMaxSuppression"),l=ah(i,o,n,s,r,null),c=l.maxOutputSize,h=l.iouThreshold,p=l.scoreThreshold,f={boxes:i,scores:o},g={maxOutputSize:c,iouThreshold:h,scoreThreshold:p,padToMaxOutputSize:a},y=ie.runKernel(xS,f,g);return{selectedIndices:y[0],validOutputs:y[1]}}const x7=ne({nonMaxSuppressionPadded_:b7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function w7(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,a=!1){const i=W(t,"boxes","nonMaxSuppressionAsync"),o=W(e,"scores","nonMaxSuppressionAsync"),l=ah(i,o,n,s,r,null),c=l.maxOutputSize,h=l.iouThreshold,p=l.scoreThreshold,[f,g]=await Promise.all([i.data(),o.data()]),{selectedIndices:y,validOutputs:x}=N_(f,g,c,h,p,a);return i!==t&&i.dispose(),o!==e&&o.dispose(),{selectedIndices:Hs(y,"int32"),validOutputs:st(x,"int32")}}const v7=w7;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $7(t,e,n=!1,s=!1){const r=W(t,"images","resizeBilinear");V(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),V(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),V(s===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=r,i=!1;r.rank===3&&(i=!0,a=le(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const o={images:a},l={alignCorners:n,halfPixelCenters:s,size:e},c=ie.runKernel(jb,o,l);return i?le(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const zz=ne({resizeBilinear_:$7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S7(t,e,n=!1,s=!1){const r=W(t,"images","resizeNearestNeighbor");V(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),V(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),V(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),V(s===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=r,i=!1;r.rank===3&&(i=!0,a=le(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const o={images:a},l={alignCorners:n,halfPixelCenters:s,size:e},c=ie.runKernel(qb,o,l);return i?le(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Fz=ne({resizeNearestNeighbor_:S7});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _7(t,e="binary",n=!1,s=.5){const r=W(t,"image","threshold"),a=.2989,i=.587,o=.114,l=r.shape[0]*r.shape[1];let c=ae(Hs([s]),255),h,p,f,g;if(V(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),V(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),V(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),V(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[h,p,f]=Sr(r,[1,1,1],-1);const w=ae(h,a),v=ae(p,i),$=ae(f,o);g=Ae(Ae(w,v),$)}else g=t;if(e==="otsu"){const w=HO(Ge(h_(g),"int32"),Ha([]),256);c=C7(w,l)}const y=n?vc(g,c):Ar(g,c);return Ge(ae(y,255),"int32")}function C7(t,e){let n=Hs([-1]),s=Hs([0]),r=Hs([0]),a,i,o,l,c,h;for(let p=0;p<t.size-1;p++){a=Ot(t,0,p+1),i=Ot(t,p+1),c=et(Xe(a),e),h=et(Xe(i),e);const f=Xe(ae(a,Ud(0,a.size)));o=et(f,Xe(a));const g=nh(i.shape,a.size),y=Ae(Ud(0,i.size),g),x=ae(i,y);l=et(Xe(x),Xe(i));const w=qe(o,l),v=qe(o,l),$=ae(c,h);r=ae(ae($,w),v);const T=Ar(r,s);s=As(T,r,s),n=As(T,Hs([p]),n)}return n}const T7=ne({threshold_:_7});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k7(t,e,n="nearest",s="constant",r=0,a){const i=W(t,"image","transform","float32"),o=W(e,"transforms","transform","float32");V(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),V(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),V(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const l={image:i,transforms:o},c={interpolation:n,fillMode:s,fillValue:r,outputShape:a};return ie.runKernel(US,l,c)}const N7=ne({transform_:k7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I7(t,e,n){const s=W(t,"a","bandPart");V(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[a,i]=s.shape.slice(-2);let o,l;typeof e=="number"?(V(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),V(e<=a,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${a}).`),o=W(e<0?a:e,"numLower","bandPart")):(V(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=As(ff(e,0),a,uc(e,a))),typeof n=="number"?(V(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),V(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=W(n<0?i:n,"numUpper","bandPart")):(V(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=As(ff(n,0),i,uc(n,i)));const c=le(Ud(0,a,1,"int32"),[-1,1]),h=Ud(0,i,1,"int32"),p=qe(c,h),f=Ei(vc(p,o),Xl(p,dn(l))),g=Hn([a,i],s.dtype);return le(kr(Sa(le(s,[-1,a,i])).map(y=>As(f,y,g))),r)}const E7=ne({bandPart_:I7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A7(t){let e;if(Array.isArray(t)){e=!1,V(t!=null&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=t[0].shape[0];for(let a=1;a<t.length;++a)V(t[a].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[a].shape[0]} vs. ${r})`)}else e=!0,t=Sr(t,t.shape[0],0).map(r=>Sc(r,[0]));V(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],s=t;for(let r=0;r<t.length;++r)n.push(ie.tidy(()=>{let a=s[r];if(r>0)for(let i=0;i<r;++i){const o=ae(Xe(ae(n[i],a)),n[i]);a=qe(a,o)}return et(a,Am(a,"euclidean"))}));return e?kr(n,0):n}const R7=ne({gramSchmidt_:A7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D7(t,e=!1){if(V(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),t.rank===2)return NI(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((l,c)=>l*c),s=Sa(le(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),r=[],a=[];s.forEach(l=>{const[c,h]=NI(l,e);r.push(c),a.push(h)});const i=le(kr(r,0),t.shape),o=le(kr(a,0),t.shape);return[i,o]}}function NI(t,e=!1){return ie.tidy(()=>{V(t.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],s=t.shape[1];let r=r_(n),a=$o(t);const i=of([[1]],[1,1]);let o=$o(i);const l=n>=s?s:n;for(let c=0;c<l;++c){const h=a,p=o,f=r;[o,a,r]=ie.tidy(()=>{const g=Ot(a,[c,c],[n-c,1]),y=Am(g),x=Ot(a,[c,c],[1,1]),w=As(Ar(x,0),of([[-1]]),of([[1]])),v=qe(x,ae(w,y)),$=et(g,v);$.shape[0]===1?o=$o(i):o=Bn([i,Ot($,[1,0],[$.shape[0]-1,$.shape[1]])],0);const T=dn(et(Tt(w,v),y)),C=Ot(a,[c,0],[n-c,s]),I=ae(T,o),A=Ft(o);if(c===0)a=qe(C,Tt(I,Tt(A,C)));else{const z=qe(C,Tt(I,Tt(A,C)));a=Bn([Ot(a,[0,0],[c,s]),z],0)}const O=Ft(I),B=Ot(r,[0,c],[n,r.shape[1]-c]);if(c===0)r=qe(B,Tt(Tt(B,o),O));else{const z=qe(B,Tt(Tt(B,o),O));r=Bn([Ot(r,[0,0],[n,c]),z],1)}return[o,a,r]}),$t([h,p,f])}return!e&&n>s&&(r=Ot(r,[0,0],[n,s]),a=Ot(a,[0,0],[s,s])),[r,a]})}const O7=ne({qr_:D7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ar;(function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(ar||(ar={}));function z7(t,e,n=ar.SUM_BY_NONZERO_WEIGHTS){const s=W(t,"losses","computeWeightedLoss");let r=null;e!=null&&(r=W(e,"weights","computeWeightedLoss"));const a=r==null?s:ae(s,r);if(n===ar.NONE)return a;if(n===ar.SUM)return Xe(a);if(n===ar.MEAN){if(r==null)return _n(a);{const i=s.size/r.size,o=et(Xe(a),Xe(r));return i>1?et(o,st(i)):o}}if(n===ar.SUM_BY_NONZERO_WEIGHTS){if(r==null)return et(Xe(a),st(s.size));{const i=ae(r,ir(s.shape)),o=Ge(Xe(Vd(i,st(0))),"float32");return et(Xe(a),o)}}throw Error(`Unknown reduction: ${n}`)}const Do=ne({computeWeightedLoss_:z7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F7(t,e,n,s=ar.SUM_BY_NONZERO_WEIGHTS){const r=W(t,"labels","absoluteDifference"),a=W(e,"predictions","absoluteDifference");let i=null;n!=null&&(i=W(n,"weights","absoluteDifference")),Er(r.shape,a.shape,"Error in absoluteDifference: ");const o=Gn(qe(r,a));return Do(o,i,s)}const L7=ne({absoluteDifference_:F7});function M7(t,e,n,s,r=ar.SUM_BY_NONZERO_WEIGHTS){const a=W(t,"labels","cosineDistance"),i=W(e,"predictions","cosineDistance");let o=null;s!=null&&(o=W(s,"weights","cosineDistance")),Er(a.shape,i.shape,"Error in cosineDistance: ");const l=st(1),c=qe(l,Xe(ae(a,i),n,!0));return Do(c,o,r)}const B7=ne({cosineDistance_:M7});function P7(t,e,n,s=ar.SUM_BY_NONZERO_WEIGHTS){let r=W(t,"labels","hingeLoss");const a=W(e,"predictions","hingeLoss");let i=null;n!=null&&(i=W(n,"weights","hingeLoss")),Er(r.shape,a.shape,"Error in hingeLoss: ");const o=st(1);r=qe(ae(st(2),r),o);const l=zi(qe(o,ae(r,a)));return Do(l,i,s)}const V7=ne({hingeLoss_:P7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U7(t,e,n,s=1,r=ar.SUM_BY_NONZERO_WEIGHTS){const a=W(t,"labels","huberLoss"),i=W(e,"predictions","huberLoss");let o=null;n!=null&&(o=W(n,"weights","huberLoss")),Er(a.shape,i.shape,"Error in huberLoss: ");const l=st(s),c=Gn(qe(i,a)),h=uc(c,l),p=qe(c,h),f=Ae(ae(st(.5),nn(h)),ae(l,p));return Do(f,o,r)}const W7=ne({huberLoss_:U7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G7(t,e,n,s=1e-7,r=ar.SUM_BY_NONZERO_WEIGHTS){const a=W(t,"labels","logLoss"),i=W(e,"predictions","logLoss");let o=null;n!=null&&(o=W(n,"weights","logLoss")),Er(a.shape,i.shape,"Error in logLoss: ");const l=st(1),c=st(s),h=dn(ae(a,Kr(Ae(i,c)))),p=ae(qe(l,a),Kr(Ae(qe(l,i),c))),f=qe(h,p);return Do(f,o,r)}const H7=ne({logLoss_:G7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q7(t,e,n,s=ar.SUM_BY_NONZERO_WEIGHTS){const r=W(t,"labels","meanSquaredError"),a=W(e,"predictions","meanSquaredError");let i=null;n!=null&&(i=W(n,"weights","meanSquaredError")),Er(r.shape,a.shape,"Error in meanSquaredError: ");const o=w_(r,a);return Do(o,i,s)}const j7=ne({meanSquaredError_:q7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K7(t,e){const n=W(t,"labels","sigmoidCrossEntropyWithLogits"),s=W(e,"logits","sigmoidCrossEntropyWithLogits");Er(n.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=zi(s),a=ae(s,n),i=dx(Tr(dn(Gn(s))));return Ae(qe(r,a),i)}function X7(t,e,n,s=0,r=ar.SUM_BY_NONZERO_WEIGHTS){let a=W(t,"multiClassLabels","sigmoidCrossEntropy");const i=W(e,"logits","sigmoidCrossEntropy");let o=null;if(n!=null&&(o=W(n,"weights","sigmoidCrossEntropy")),Er(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),s>0){const c=st(s),h=st(1),p=st(.5);a=Ae(ae(a,qe(h,c)),ae(p,c))}const l=K7(a,i);return Do(l,o,r)}const Y7=ne({sigmoidCrossEntropy_:X7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z7(t,e,n=-1){if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return To((r,a,i)=>{const l=hx(a,[n],!0),c=qe(Ge(a,"float32"),l);i([r,c]);const h=dn(ae(c,r));return{value:Xe(h,[n]),gradFunc:(g,y)=>{const[x,w]=y,v=Rn(g.shape,[n]);return[ae(le(g,v),qe(Ge(x,"float32"),Tr(w))),ae(le(g,v),qe(Tr(w),Ge(x,"float32")))]}}})(t,e)}function Q7(t,e,n,s=0,r=ar.SUM_BY_NONZERO_WEIGHTS){let a=W(t,"onehotLabels","softmaxCrossEntropy");const i=W(e,"logits","softmaxCrossEntropy");let o=null;if(n!=null&&(o=W(n,"weights","softmaxCrossEntropy")),Er(a.shape,i.shape,"Error in softmaxCrossEntropy: "),s>0){const c=st(s),h=st(1),p=st(a.shape[1]);a=Ae(ae(a,qe(h,c)),et(c,p))}const l=Z7(a,i);return Do(l,o,r)}const J7=ne({softmaxCrossEntropy_:Q7});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e9(t,e,n,s){const r=W(t,"indices","sparseFillEmptyRows","int32"),a=W(e,"values","sparseFillEmptyRows"),i=W(n,"denseShape","sparseFillEmptyRows","int32"),o=W(s,"defaultValue","sparseFillEmptyRows",a.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:r,values:a,denseShape:i,defaultValue:o},c=ie.runKernel(AS,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const t9=ne({sparseFillEmptyRows_:e9});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n9(t,e,n){const s=W(t,"inputIndices","sparseReshape","int32"),r=W(e,"inputShape","sparseReshape","int32"),a=W(n,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const i={inputIndices:s,inputShape:r,newShape:a},o=ie.runKernel(RS,i);return{outputIndices:o[0],outputShape:o[1]}}const s9=ne({sparseReshape_:n9});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r9(t,e,n){const s=W(t,"data","sparseSegmentMean"),r=W(e,"indices","sparseSegmentMean","int32"),a=W(n,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);const i={data:s,indices:r,segmentIds:a};return ie.runKernel(DS,i)}const a9=ne({sparseSegmentMean_:r9});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i9(t,e,n){const s=W(t,"data","sparseSegmentSum"),r=W(e,"indices","sparseSegmentSum","int32"),a=W(n,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);const i={data:s,indices:r,segmentIds:a};return ie.runKernel(OS,i)}const o9=ne({sparseSegmentSum_:i9});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l9(t,e,n,s,r,a,i,o){const l=W(t,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=W(e,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const h={separator:n,nGramWidths:s,leftPad:r,rightPad:a,padWidth:i,preserveShortSequences:o},p={data:l,dataSplits:c},f=ie.runKernel(MS,p,h);return{nGrams:f[0],nGramsSplits:f[1]}}const u9=ne({stringNGrams_:l9});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c9(t,e,n=!0){const s=W(t,"input","stringSplit","string"),r=W(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const a={skipEmpty:n},i={input:s,delimiter:r},o=ie.runKernel(BS,i,a);return{indices:o[0],values:o[1],shape:o[2]}}const d9=ne({stringSplit_:c9});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h9(t,e){const n=W(t,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:n};return ie.runKernel(PS,r,s)}const p9=ne({stringToHashBucketFast_:h9});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f9(t,e,n,s=!0){const r=W(t,"input","staticRegexReplace","string"),a={pattern:e,rewrite:n,replaceGlobal:s};return ie.runKernel(tx,{x:r},a)}const m9=ne({staticRegexReplace_:f9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g9={fft:$x,ifft:yf,rfft:Sx,irfft:x_},y9={hammingWindow:WX,hannWindow:Dz,frame:Oz,stft:jX},$i={flipLeftRight:ZX,grayscaleToRGB:JX,resizeNearestNeighbor:Fz,resizeBilinear:zz,rgbToGrayscale:t7,rotateWithOffset:s7,cropAndResize:XX,nonMaxSuppression:a7,nonMaxSuppressionAsync:p7,nonMaxSuppressionWithScore:m7,nonMaxSuppressionWithScoreAsync:y7,nonMaxSuppressionPadded:x7,nonMaxSuppressionPaddedAsync:v7,threshold:T7,transform:N7},Lz={bandPart:E7,gramSchmidt:R7,qr:O7},b9={absoluteDifference:L7,computeWeightedLoss:Do,cosineDistance:B7,hingeLoss:V7,huberLoss:W7,logLoss:H7,meanSquaredError:j7,sigmoidCrossEntropy:Y7,softmaxCrossEntropy:J7},x9={sparseFillEmptyRows:t9,sparseReshape:s9,sparseSegmentMean:a9,sparseSegmentSum:o9},w9={stringNGrams:u9,stringSplit:d9,stringToHashBucketFast:p9,staticRegexReplace:m9};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v9=new Map,$9=new Map;class ih{getClassName(){return this.constructor.className}static fromConfig(e,n){return new e(n)}}class ma{constructor(){this.classNameMap={}}static getMap(){return ma.instance==null&&(ma.instance=new ma),ma.instance}static register(e){ma.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function De(t,e,n){V(t.className!=null,()=>"Class being registered does not have the static className property defined."),V(typeof t.className=="string",()=>"className is required to be a string, but got type "+typeof t.className),V(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof n>"u"&&(n=t.className);const s=n,r=e+">"+s;return ma.register(t),v9.set(r,t),$9.set(t,r),t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zl extends ih{minimize(e,n=!1,s){const{value:r,grads:a}=this.computeGradients(e,s);if(s!=null){const i=s.map(o=>({name:o.name,tensor:a[o.name]}));this.applyGradients(i)}else this.applyGradients(a);return $t(a),n?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,n){return H5(e,n)}dispose(){this.iterations_!=null&&$t(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:st(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Zl,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mz extends Zl{static get className(){return"Adadelta"}constructor(e,n,s=null){super(),this.learningRate=e,this.rho=n,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=ie.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const a=ie.registeredVariables[s],i=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:me(()=>Lt(a).variable(i))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:me(()=>Lt(a).variable(i))});const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const l=this.accumulatedGrads[r].variable,c=this.accumulatedUpdates[r].variable;me(()=>{const h=Ae(ae(l,this.rho),ae(nn(o),1-this.rho)),p=ae(et(bs(Ae(c,this.epsilon)),bs(Ae(l,this.epsilon))),o),f=Ae(ae(c,this.rho),ae(nn(p),1-this.rho));l.assign(h),c.assign(f);const g=Ae(ae(p,-this.learningRate),a);a.assign(g)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&($t(this.accumulatedGrads.map(e=>e.variable)),$t(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.rho,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bz extends Zl{static get className(){return"Adagrad"}constructor(e,n=.1){super(),this.learningRate=e,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const a=ie.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:me(()=>nh(a.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const o=this.accumulatedGrads[r].variable;me(()=>{const l=Ae(o,nn(i));o.assign(l);const c=Ae(ae(et(i,bs(Ae(l,ie.backend.epsilon()))),-this.learningRate),a);a.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&$t(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,n){return new e(n.learningRate,n.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pz extends Zl{static get className(){return"Adam"}constructor(e,n,s,r=null){super(),this.learningRate=e,this.beta1=n,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],me(()=>{this.accBeta1=st(n).variable(),this.accBeta2=st(s).variable()}),r==null&&(this.epsilon=ie.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);me(()=>{const s=qe(1,this.accBeta1),r=qe(1,this.accBeta2);n.forEach((a,i)=>{const o=ie.registeredVariables[a],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:me(()=>Lt(o).variable(l))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${a}/v`,variable:me(()=>Lt(o).variable(l))});const c=Array.isArray(e)?e[i].tensor:e[a];if(c==null)return;const h=this.accumulatedFirstMoment[i].variable,p=this.accumulatedSecondMoment[i].variable,f=Ae(ae(h,this.beta1),ae(c,1-this.beta1)),g=Ae(ae(p,this.beta2),ae(nn(c),1-this.beta2)),y=et(f,s),x=et(g,r);h.assign(f),p.assign(g);const w=Ae(ae(et(y,Ae(bs(x),this.epsilon)),-this.learningRate),o);o.assign(w)}),this.accBeta1.assign(ae(this.accBeta1,this.beta1)),this.accBeta2.assign(ae(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&$t(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&$t(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e),me(()=>{this.accBeta1.assign(Co(this.beta1,this.iterations_+1)),this.accBeta2.assign(Co(this.beta2,this.iterations_+1))});const n=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vz extends Zl{static get className(){return"Adamax"}constructor(e,n,s,r=null,a=0){super(),this.learningRate=e,this.beta1=n,this.beta2=s,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],me(()=>{this.iteration=st(0).variable(),this.accBeta1=st(n).variable()}),r==null&&(this.epsilon=ie.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);me(()=>{const s=qe(1,this.accBeta1),r=et(-this.learningRate,Ae(ae(this.iteration,this.decay),1));n.forEach((a,i)=>{const o=ie.registeredVariables[a],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:Lt(o).variable(l)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${a}/v`,variable:Lt(o).variable(l)});const c=Array.isArray(e)?e[i].tensor:e[a];if(c==null)return;const h=this.accumulatedFirstMoment[i].variable,p=this.accumulatedWeightedInfNorm[i].variable,f=Ae(ae(h,this.beta1),ae(c,1-this.beta1)),g=ae(p,this.beta2),y=Gn(c),x=Ro(g,y);h.assign(f),p.assign(x);const w=Ae(ae(et(r,s),et(f,Ae(x,this.epsilon))),o);o.assign(w)}),this.iteration.assign(Ae(this.iteration,1)),this.accBeta1.assign(ae(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&$t(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&$t(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class A_ extends Zl{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const i=ie.registeredVariables[s];me(()=>{const o=Ae(ae(this.c,a),i);i.assign(o)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=ss(st(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,n){return new e(n.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uz extends A_{static get className(){return"Momentum"}constructor(e,n,s=!1){super(e),this.learningRate=e,this.momentum=n,this.useNesterov=s,this.accumulations=[],this.m=st(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const a=ie.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:me(()=>Lt(a).variable(!1))});const i=this.accumulations[r].variable,o=Array.isArray(e)?e[r].tensor:e[s];o!=null&&me(()=>{let l;const c=Ae(ae(this.m,i),o);this.useNesterov?l=Ae(ae(this.c,Ae(o,ae(c,this.m))),a):l=Ae(ae(this.c,c),a),i.assign(c),a.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&$t(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,n){return new e(n.learningRate,n.momentum,n.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wz extends Zl{static get className(){return"RMSProp"}constructor(e,n=.9,s=0,r=null,a=!1){if(super(),this.learningRate=e,this.decay=n,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,r==null&&(this.epsilon=ie.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const a=ie.registeredVariables[s],i=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:me(()=>Lt(a).variable(i))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:me(()=>Lt(a).variable(i))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:me(()=>Lt(a).variable(i))});const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const l=this.accumulatedMeanSquares[r].variable,c=this.accumulatedMoments[r].variable;me(()=>{const h=Ae(ae(l,this.decay),ae(nn(o),1-this.decay));if(this.centered){const p=this.accumulatedMeanGrads[r].variable,f=Ae(ae(p,this.decay),ae(o,1-this.decay)),g=et(ae(o,this.learningRate),bs(qe(h,Ae(nn(f),this.epsilon)))),y=Ae(ae(c,this.momentum),g);l.assign(h),p.assign(f),c.assign(y);const x=qe(a,y);a.assign(x)}else{const p=Ae(ae(l,this.decay),ae(nn(o),1-this.decay)),f=Ae(ae(c,this.momentum),et(ae(o,this.learningRate),bs(Ae(p,this.epsilon))));l.assign(p),c.assign(f);const g=qe(a,f);a.assign(g)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&$t(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&$t(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&$t(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(n*2,n*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,n){return new e(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S9=[Mz,Bz,Pz,Vz,Uz,Wz,A_];function _9(){for(const t of S9)De(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C9="model",T9=".json",k9=".weights.bin";function II(t){return new Promise(e=>setTimeout(e)).then(t)}class cc{constructor(e){if(!ye().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(cc.URL_SCHEME)&&(e=e.slice(cc.URL_SCHEME.length)),(e==null||e.length===0)&&(e=C9),this.modelJsonFileName=e+T9,this.weightDataFileName=e+k9}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=Qa.join(e.weightData),s=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],a=$O(e,r),i=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await II(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=s,await II(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Tm(e)}}}}cc.URL_SCHEME="downloads://";class N9{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,n)=>{const s=new FileReader;s.onload=r=>{const a=JSON.parse(r.target.result),i=a.modelTopology;if(i==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:i});return}const l=jS(a,c=>this.loadWeights(c));e(l)},s.onerror=r=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const n=[],s=[];for(const i of e)n.push(...i.weights),s.push(...i.paths);const r=this.checkManifestAndWeightFiles(e),a=s.map(i=>this.loadWeightsFile(i,r[i]));return Promise.all(a).then(i=>[n,i])}loadWeightsFile(e,n){return new Promise((s,r)=>{const a=new FileReader;a.onload=i=>{const o=i.target.result;s(o)},a.onerror=i=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(e){const n=[],s=this.weightsFiles.map(a=>bI(a.name)),r={};for(const a of e)a.paths.forEach(i=>{const o=bI(i);if(n.indexOf(o)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(n.push(o),s.indexOf(o)===-1)throw new Error(`Weight file with basename '${o}' is not provided.`);r[i]=this.weightsFiles[s.indexOf(o)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const I9=t=>ye().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(cc.URL_SCHEME)?E9(t.slice(cc.URL_SCHEME.length)):null;gn.registerSaveRouter(I9);function E9(t="model"){return new cc(t)}function A9(t){return new N9(t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EI(t,e,n,s){i(t),n=n??0,s=s??1,o(n,s);let r=0;const a=l=>(l.then(c=>{const h=n+ ++r/t.length*(s-n);return e(h),c}),l);function i(l){V(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,c){V(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),V(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),V(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(t.map(a))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Gz(t,e){e==null&&(e={});const n=e.fetchFunc==null?ye().platform.fetch:e.fetchFunc,s=t.map(p=>n(p,e.requestInit,{isBinary:!0})),o=(e.onProgress==null?await Promise.all(s):await EI(s,e.onProgress,0,.5)).map(p=>p.arrayBuffer());return e.onProgress==null?await Promise.all(o):await EI(o,e.onProgress,.5,1)}function R9(t,e){var n;const s=e.fetchFunc==null?ye().platform.fetch:e.fetchFunc;let r=0,a;return(n=e.onProgress)===null||n===void 0||n.call(e,0),new ReadableStream({pull:async i=>{for(var o;r<t.length;){a||(a=(await s(t[r],e.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:c}=await a.read();if(l){r++,a=void 0,(o=e.onProgress)===null||o===void 0||o.call(e,r/t.length);continue}i.enqueue(c);return}i.close()}})}async function D9(t,e="",n,s){return Hz(i=>Gz(i,{requestInit:s}))(t,e,n)}function Hz(t){return async(e,n="",s)=>{const r=e.map(()=>!1),a={},i=s!=null?s.map(()=>!1):[],o=[];if(e.forEach((g,y)=>{let x=0;g.weights.forEach(w=>{const v="quantization"in w?w.quantization.dtype:w.dtype,$=rc[v]*$e(w.shape),T=()=>{r[y]=!0,a[y]==null&&(a[y]=[]),a[y].push({manifestEntry:w,groupOffset:x,sizeBytes:$})};s!=null?s.forEach((C,I)=>{C===w.name&&(T(),i[I]=!0)}):T(),o.push(w.name),x+=$})}),!i.every(g=>g)){const g=s.filter((y,x)=>!i[x]);throw new Error(`Could not find weights in manifest with names: ${g.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}const l=r.reduce((g,y,x)=>(y&&g.push(x),g),[]),c=[];l.forEach(g=>{e[g].paths.forEach(y=>{const x=n+(n.endsWith("/")?"":"/")+y;c.push(x)})});const h=await t(c),p={};let f=0;return l.forEach(g=>{const y=e[g].paths.length,x=new Qa(h.slice(f,f+y));a[g].forEach(v=>{const $=x.slice(v.groupOffset,v.groupOffset+v.sizeBytes),T=bO($,[v.manifestEntry]);for(const C in T)p[C]=T[C]}),f+=y}),p}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O9="application/octet-stream",z9="application/json";class R_{constructor(e,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(V(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=ye().platform.fetch,V(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&V(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{},this.loadOptions=n}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=$O(e,s);if(n.body.append("model.json",new Blob([JSON.stringify(r)],{type:z9}),"model.json"),e.weightData!=null){const i=Qa.join(e.weightData);n.body.append("model.weights.bin",new Blob([i],{type:O9}),"model.weights.bin")}const a=await this.fetch(this.path,n);if(a.ok)return{modelArtifactsInfo:Tm(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await e.json()}catch{let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}const s=n.modelTopology,r=n.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return n}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return jS(e,n=>this.loadWeights(n))}async loadStream(){const e=await this.loadModelJSON(),n=await this.getWeightUrls(e.weightsManifest),s=O$(e.weightsManifest),r=()=>R9(n,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(e){const n=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=F9(n),a=this.weightPathPrefix||s,i=[],o=[];for(const l of e)for(const c of l.paths)this.weightUrlConverter!=null?o.push(this.weightUrlConverter(c)):i.push(a+c+r);return this.weightUrlConverter&&i.push(...await Promise.all(o)),i}async loadWeights(e){const n=await this.getWeightUrls(e),s=O$(e),r=await Gz(n,this.loadOptions);return[s,r]}}R_.URL_SCHEME_REGEX=/^https?:\/\//;function F9(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),s=t.substring(0,e),r=n>e?t.substring(n):"";return[s+"/",r]}function V$(t){return t.match(R_.URL_SCHEME_REGEX)!=null}const qz=(t,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let n=!0;if(Array.isArray(t)?n=t.every(s=>V$(s)):n=V$(t),n)return D_(t,e)}return null};gn.registerSaveRouter(qz);gn.registerLoadRouter(qz);function D_(t,e){return new R_(t,e)}function L9(t,e){return D_(t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cv{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class jz{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class M9{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=n=>Promise.resolve(e.save(n)))}}function B9(t,e,n,s){const r=arguments;return new M9(Kz(...r))}function Kz(t,e,n,s){return arguments.length===1?t.modelTopology!=null||t.weightSpecs!=null?new cv(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new cv({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new cv({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:s}))}function P9(t){return new jz(t)}function V9(t){return new jz(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xz=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Qa,browserFiles:A9,browserHTTPRequest:L9,concatenateArrayBuffers:vO,copyModel:Pq,decodeWeights:bO,decodeWeightsStream:wO,encodeWeights:D$,fromMemory:B9,fromMemorySync:Kz,getLoadHandlers:Tq,getModelArtifactsForJSON:jS,getModelArtifactsForJSONSync:SO,getModelArtifactsInfoForJSON:Tm,getSaveHandlers:_O,getWeightSpecs:O$,http:D_,isHTTPScheme:V$,listModels:Mq,loadWeights:D9,moveModel:Vq,registerLoadRouter:Cq,registerSaveRouter:_q,removeModel:Bq,weightsLoaderFactory:Hz,withSaveHandler:P9,withSaveHandlerSync:V9},Symbol.toStringTag,{value:"Module"}));function O_(t,e){const n=t.shape.length,s=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${n}`);if($e(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const r=e.shape,a=r[r.length-1];let i=1;for(let p=0;p<r.length-1;++p)i*=r[p];const o=t.shape,l=r.slice();l.pop();let c=1;for(let p=a;p<n;++p)c*=o[p],l.push(o[p]);const h=[...nt(t.shape).map(p=>p/c),1].slice(0,a);return[l,i,c,h]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U$=-2,U9=-1;function z_(t,e,n){const s=t.shape.length;V(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),V(s===n.length,()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)V(e[r]+n[r]<=t.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+n[r]}) would overflow input.shape[${r}] (${t.shape[r]})`)}function W9(t){const e=[];let n=0;for(;t>0;)t&1&&e.push(n),t/=2,n++;return e}function F_(t,e,n){const s=[];for(let r=0;r<t.length;r++)s[r]=Math.ceil((e[r]-t[r])/n[r]);return s}function Yz(t,e,n,s){const r=[...t];for(let a=r.length;a<s.length;a++)r.push(1);for(let a=0;a<n;a++)a===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function Zz(t,e,n){return n<=t?n:n-(e-1)}function Qz(t,e){const n=[];for(let s=0;s<t;s++)n.push(e+s);return n}function G9(t,e,n,s,r,a,i,o,l){const c=t.length;let h=new Array(c),p=new Array(c),f=new Array(c);if(e.length&&n>0){const g=e[0],y=n+1;h=Jz(i,g,y,s,t),p=eF(o,g,y,r,t),f=Yz(a,g,y,t)}else for(let g=0;g<c;g++)h[g]=nF(i,s,a,t,g,l),p[g]=sF(o,r,a,t,g,l),f[g]=tF(a,g,l);return{begin:h,end:p,strides:f}}function Jz(t,e,n,s,r){const a=[...r],i=Qz(n,e);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=0;else{const l=Zz(e,n,o);let c=s[l];t&1<<l&&(c=0),a[o]=c}return a}function eF(t,e,n,s,r){const a=[...r],i=Qz(n,e);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=Number.MAX_SAFE_INTEGER;else{const l=Zz(e,n,o);let c=s[l];t&1<<l&&(c=Number.MAX_SAFE_INTEGER),a[o]=c}for(let o=0;o<a.length;o++){const l=r[o];a[o]<0&&(a[o]+=l),a[o]=tc(0,a[o],r[o])}return a}function tF(t,e,n){let s=t[e];return(n&1<<e||s==null)&&(s=1),s}function nF(t,e,n,s,r,a){let i=e[r];const o=n[r]||1;(t&1<<r||a&1<<r||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);const l=s[r];return i<0&&(i+=l),i=tc(0,i,l-1),i}function sF(t,e,n,s,r,a){let i=e[r];const o=n[r]||1;(t&1<<r||a&1<<r||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);const l=s[r];return i<0&&(i+=l),o>0?i=tc(0,i,l):i=tc(-1,i,l-1),i}function L_(t,e,n){let s=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){s=r;break}for(let r=s+1;r<n.length;r++)if(e[r]>0||n[r]!==t[r])return!1;return!0}function M_(t,e){let n=t.length>0?t[t.length-1]:1;for(let s=0;s<t.length-1;s++)n+=t[s]*e[s];return n}function Nx(t,e,n){let s;const r=t.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(i=>{V(i!==-1,()=>"slice() does not support negative begin indexing.")});let a;return n==null?a=new Array(r).fill(-1):typeof n=="number"?a=[n,...new Array(r-1).fill(-1)]:n.length<r?a=n.concat(new Array(r-n.length).fill(-1)):a=n,a=a.map((i,o)=>i>=0?i:(V(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),t.shape[o]-s[o])),[s,a]}function B_(t,e,n,s,r,a,i,o,l){let c;if(s==null?(c=new Array(e.length),c.fill(1)):c=s,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let h=!1;const p={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:c.slice(),beginMask:r,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let T=0;T<p.dims;T++)h&&(1<<T&o)!==0&&p.numAddAxisAfterEllipsis++,1<<T&i&&(h=!0);h||(p.ellipsisMask|=1<<p.dims,p.dims++);const f={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};H9(p,f);let g=!0,y=!0,x=!0;const w=[],v=[];for(let T=0;T<t.length;++T){if(f.strides[T]===0)throw Error(`strides[${T}] must be non-zero`);const C=!!(f.shrinkAxisMask&1<<T),I=t[T];if(I===-1){w.push(C?1:-1);continue}const A=[f.beginMask&1<<T,f.endMask&1<<T],O=[f.strides[T]>0?0:-1,f.strides[T]>0?I:I-1];if(C&&f.strides[T]<=0)throw Error("only stride 1 allowed on non-range indexing.");x=x&&f.strides[T]===1;const B=!!(f.beginMask&1<<T&&f.endMask&1<<T);if(f.beginValid&&f.endValid){if(C){const K=f.begin[T]<0?I+f.begin[T]:f.begin[T];if(f.begin[T]=K,f.end[T]=f.begin[T]+1,K<0||K>=I)throw Error(`slice index ${f.begin[T]} of dimension ${T} out of bounds.`)}else f.begin[T]=AI(f.begin[T],0,f.strides[T],I,A,O),f.end[T]=AI(f.end[T],1,f.strides[T],I,A,O);const F=f.strides[T]===1&&f.begin[T]===0&&f.end[T]===I;g=g&&F,y=y&&(T===0&&f.strides[T]===1||F)}else g=g&&f.strides[T]===1&&B,y=y&&(T===0&&f.strides[T]===1||B);let z,P=!1;if(f.beginValid&&f.endValid?(z=f.end[T]-f.begin[T],P=!0):C?(z=1,P=!0):B&&I>=0&&(f.strides[T]<0?z=-I:z=I,P=!0),P){let F;z===0||z<0!=f.strides[T]<0?F=0:F=Math.trunc(z/f.strides[T])+(z%f.strides[T]!==0?1:0),w.push(F)}else w.push(-1)}for(let T=0;T<f.finalShapeGatherIndices.length;++T){const C=f.finalShapeGatherIndices[T];C>=0?v.push(w[C]):C===U$&&v.push(1)}return{finalShapeSparse:v.filter((T,C)=>f.finalShapeGatherIndices[C]!==U$),finalShape:v,isIdentity:g,sliceDim0:y,isSimpleSlice:x,begin:f.begin,end:f.end,strides:f.strides}}function H9(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=t.begin!=null,e.endValid=t.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<t.dims;s++)if(1<<s&t.ellipsisMask){const r=Math.min(e.dims-(t.dims-s)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<r;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=s}else if(1<<s&t.newAxisMask)e.finalShapeGatherIndices.push(U$),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);t.begin!=null&&(e.begin[n]=t.begin[s]),t.end!=null&&(e.end[n]=t.end[s]),e.strides[n]=t.strides[s],t.beginMask&1<<s&&(e.beginMask|=1<<n),t.endMask&1<<s&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(U9),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[n]=s,n++}}function AI(t,e,n,s,r,a){if(r[e])return n>0?a[e]:a[e+1&1];{const i=t<0?s+t:t;return i<a[0]?a[0]:i>a[1]?a[1]:i}}const q9=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:z_,computeFlatOffset:M_,computeOutShape:F_,getNormalizedAxes:G9,isSliceContinous:L_,maskToAxes:W9,parseSliceParams:Nx,sliceInfo:B_,startForAxis:nF,startIndicesWithElidedDims:Jz,stopForAxis:sF,stopIndicesWithElidedDims:eF,stridesForAxis:tF,stridesWithElidedDims:Yz},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class j9{static sgd(e){return new A_(e)}static momentum(e,n,s=!1){return new Uz(e,n,s)}static rmsprop(e,n=.9,s=0,r=null,a=!1){return new Wz(e,n,s,r,a)}static adam(e=.001,n=.9,s=.999,r=null){return new Pz(e,n,s,r)}static adadelta(e=.001,n=.95,s=null){return new Mz(e,n,s)}static adamax(e=.002,n=.9,s=.999,r=null,a=0){return new Vz(e,n,s,r,a)}static adagrad(e,n=.1){return new Bz(e,n)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xd=j9;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K9=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t();function rF(){return new Promise(t=>K9(()=>t()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P_(t,e){const n=t[0].length;t.forEach((r,a)=>{V(r.length===n,()=>`Error in concat${n}D: rank of tensors[${a}] must be the same as the rank of the rest (${n})`)}),V(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const s=t[0];t.forEach((r,a)=>{for(let i=0;i<n;i++)V(i===e||r[i]===s[i],()=>`Error in concat${n}D: Shape of tensors[${a}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${a}.`)})}function Ti(t,e){const n=t[0].slice();for(let s=1;s<t.length;s++)n[e]+=t[s][e];return n}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ga;(function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"})(Ga||(Ga={}));function aF(t,e,n){let s=new Array;if(n==null&&e==null)return s;if(e==null)for(;s.length<t+n.length;)s.push(-1);else s=e.slice();if(n==null)return s;if(t+n.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${t+n.length}, but shape.rank = ${s.length}`);for(let r=1;r<n.length;++r){const a=n[r],i=s[s.length-n.length+r],o=s[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+t}] = ${a} but shape[${r+t}] = ${o}`)}else s[i]=a}return s}function iF(t){const e={FIRST_DIM_SIZE:Ga.FIRST_DIM_SIZE,VALUE_ROWIDS:Ga.VALUE_ROWIDS,ROW_LENGTHS:Ga.ROW_LENGTHS,ROW_SPLITS:Ga.ROW_SPLITS,ROW_LIMITS:Ga.ROW_LIMITS,ROW_STARTS:Ga.ROW_STARTS},n=[];for(const s of t)if(s in e)n.push(e[s]);else break;return n}function oF(t){return t.length===0?0:t[0]===Ga.FIRST_DIM_SIZE?t.length-1:t.length}function lF(t,e){if(t==null||e==null)return;const n=t.length,s=e.length;if(n>=s)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(n,s-1);++r){const a=t[r],i=e[r+1];if(a>=0&&i>=0&&a!==1&&a!==i)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-t.length}] = ${a} but ragged tensor input.flatValues.shape[${r-t.length}] = ${i}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V_=30;function Ix(t){return t<=V_?t:_$(t,Math.floor(Math.sqrt(t)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U_(t,e,n){const s=n*(typeof t=="number"?t:t[0]),r=e*(typeof t=="number"?t:t[1]);return[s,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Om(t,e,n,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(t[0]/n),r=r.concat(t.slice(1));else{r=r.concat(t[0]);const a=e.length;for(let i=0;i<a;++i)r=r.concat([t[i+1]/e[i],e[i]]);r=r.concat(t.slice(a+1))}return r}function zm(t,e,n=!0){const s=[];if(n){s.push(e);for(let r=e+1;r<t;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],a=[];for(let i=1;i<t;++i)i>=e*2+1||i%2===1?a.push(i):r.push(i);s.push(...r),s.push(0),s.push(...a)}return s}function Fm(t,e,n,s=!0){const r=[];s?r.push(t[0]/n):r.push(t[0]*n);for(let a=1;a<t.length;++a)a<=e.length?s?r.push(e[a-1]*t[a]):r.push(t[a]/e[a-1]):r.push(t[a]);return r}function W_(t,e){const n=[0];for(let s=0;s<e;++s)n.push(t[s][0]);return n}function G_(t,e,n){const s=t.slice(0,1);for(let r=0;r<n;++r)s.push(t[r+1]-e[r][0]-e[r][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ex=1.7580993408473768,Ax=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H_=.3275911,q_=.254829592,j_=-.284496736,K_=1.421413741,X_=-1.453152027,Y_=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ko(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(t.length*2);for(let s=0;s<n.length;s+=2)n[s]=t[s/2],n[s+1]=e[s/2];return n}function uF(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let s=0;s<t.length;s+=2)e[s/2]=t[s],n[s/2]=t[s+1];return{real:e,imag:n}}function cF(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],s[Math.floor(r/4)]=t[r+1];return{real:n,imag:s}}function dF(t){const e=Math.floor(t.length/4),n=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],s[Math.floor(r/4)]=t[r+1];return{real:n,imag:s}}function Z_(t,e){const n=t[e*2],s=t[e*2+1];return{real:n,imag:s}}function hF(t,e,n,s){t[s*2]=e,t[s*2+1]=n}function pF(t,e){const n=new Float32Array(t/2),s=new Float32Array(t/2);for(let r=0;r<Math.ceil(t/2);r++){const a=(e?2:-2)*Math.PI*(r/t);n[r]=Math.cos(a),s[r]=Math.sin(a)}return{real:n,imag:s}}function fF(t,e,n){const s=(n?2:-2)*Math.PI*(t/e),r=Math.cos(s),a=Math.sin(s);return{real:r,imag:a}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dv="->",X9=/->/g,RI=",",DI="...";function Q_(t,e){t=t.replace(/\s/g,"");const n=(t.length-t.replace(X9,"").length)/dv.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${dv}").`);const[s,r]=t.split(dv);V(s.indexOf(DI)===-1,()=>`The ellipsis notation ("${DI}") is not supported yet.`);const a=s.split(RI),i=a.length;if(e!==i)throw new Error(`Expected ${i} input tensors, received ${e}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let f=0;f<r.length;++f){const g=r[f];if(!a.some(y=>y.indexOf(g)!==-1))throw new Error(`Output subscripts contain the label ${g} not present in the input subscripts.`);o.indexOf(g)===-1&&o.push(g)}for(let f=0;f<s.length;++f){const g=s[f];o.indexOf(g)===-1&&g!==RI&&o.push(g)}const l=new Array(a.length);for(let f=0;f<i;++f){if(new Set(a[f].split("")).size!==a[f].length)throw new Error(`Found duplicate axes in input component ${a[f]}. Support for duplicate axes in input is not implemented yet.`);l[f]=[];for(let g=0;g<a[f].length;++g)l[f].push(o.indexOf(a[f][g]))}const c=o.length,h=r.length,p=[];for(let f=h;f<c;++f)p.push(f);return{allDims:o,summedDims:p,idDims:l}}function J_(t,e){let n=new Array(t);n.fill(-1);for(let r=0;r<e.length;++r)n[e[r]]=r;const s=[];for(let r=0;r<t;++r)n[r]===-1&&s.push(r);return n=n.filter(r=>r!==-1),{permutationIndices:n,expandDims:s}}function eC(t,e,n){const s=new Array(t);for(let r=0;r<n.length;++r){const a=n[r].shape;for(let i=0;i<e[r].length;++i)s[e[r][i]]===void 0?s[e[r][i]]=a[i]:V(s[e[r][i]]===a[i],()=>`Expected dimension ${s[e[r][i]]} at axis ${i} of input shaped ${JSON.stringify(a)}, but got dimension ${a[i]}`)}}function tC(t,e){const n=t,s=[];let r=0;t.length===0&&n.push(-1),r=t.length+1;for(let i=0;i<r;++i)s.push([]);const a=[];for(let i=0;i<n.length;++i){const o=n[i],l=Y9(e,o);for(const c of l)a.indexOf(c)===-1&&(s[i].push(c),a.push(c))}return{path:n,steps:s}}function nC(t){return t.every((e,n)=>e===n)}function Y9(t,e){const n=[];for(let s=0;s<t.length;++s)(t[s].length===0||t[s].indexOf(e)!==-1||e===-1)&&n.push(s);return n}function sC(t,e,n=0){let s=[];if(typeof e=="number")V(t.shape[n]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(t.shape[n]/e);else{const r=e.reduce((i,o)=>(o===-1&&(i+=1),i),0);V(r<=1,()=>"There should be only one negative value in split array.");const a=e.indexOf(-1);if(a!==-1){const i=e.reduce((o,l)=>l>0?o+l:o);e[a]=t.shape[n]-i}V(t.shape[n]===e.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mF(t){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`}function gF(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function yF(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bF(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function xF(t,e){return`size ${t} must be non-negative, not ${e}`}function wF(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function vF(t,e){const n=$e(t),s=$e(e);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${t} outputShape= ${e}`}function $F(t,e){const n=$e(t),s=$e(e);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${s}. inputShape=${t} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W$(){return"segment ids must be >= 0"}function SF(){return"segment ids are not increasing"}function _F(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function CF(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TF(t,e){let n=!1,s;for(t<=V_?(s=t,n=!0):s=_$(t,Math.floor(Math.sqrt(t)));!n;)s>e||s===t?n=!0:s=_$(t,s+1);return s}function kF(t,e,n){const s=[],r=t.length;for(let a=0;a<r;a++)a!==e?s.push(t[a]):s.push(n);return s}function rC(t,e,n,s){const r=e.shape.length,a=t.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>a)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${a}).`);if(n<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`);for(let p=0;p<s;++p)if(t.shape[p]!==e.shape[p])throw new Error(`x.shape[${p}]: ${t.shape[p]} should be equal to indices.shape[${p}]: ${e.shape[p]}.`);const i=t.shape[n],o=[];let l=1,c=1,h=1;for(let p=0;p<s;++p)o.push(t.shape[p]),l*=t.shape[p];for(let p=s;p<n;p++)o.push(t.shape[p]),c*=t.shape[p];for(let p=s;p<r;p++)o.push(e.shape[p]);for(let p=n+1;p<a;p++)o.push(t.shape[p]),h*=t.shape[p];return{batchSize:l,sliceSize:h,outerSize:c,dimSize:i,outputShape:o}}const Z9=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:rC,computeOutShape:kF,segOpComputeOptimalWindowSize:TF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function No(t){try{return t.map(e=>Rl(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function NF(t){return t.map(e=>Il(e))}const Q9=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:q_,ERF_A2:j_,ERF_A3:K_,ERF_A4:X_,ERF_A5:Y_,ERF_P:H_,PARALLELIZE_THRESHOLD:V_,get RowPartitionType(){return Ga},SELU_SCALE:Ax,SELU_SCALEALPHA:Ex,applyActivation:Tx,assertAndGetBroadcastShape:ft,assertAxesAreInnerMostDims:ws,assertParamsConsistent:P_,assignToTypedArray:hF,axesAreInnerMostDims:s_,calculateShapes:_c,checkEinsumDimSizes:eC,checkPadOnDimRoundingMode:js,combineLocations:rz,combineRaggedTensorToTensorShapes:aF,complexWithEvenIndex:cF,complexWithOddIndex:dF,computeConv2DInfo:os,computeConv3DInfo:jl,computeDefaultPad:YS,computeDilation2DInfo:km,computeOptimalWindowSize:Ix,computeOutAndReduceShapes:ls,computeOutShape:Ti,computePool2DInfo:_a,computePool3DInfo:Eo,convertConv2DDataFormat:Ao,decodeEinsumEquation:Q_,eitherStridesOrDilationsAreOne:xs,expandShapeToKeepDim:Rn,exponent:fF,exponents:pF,fromStringArrayToUint8:NF,fromUint8ToStringArray:No,getAxesPermutation:wn,getBroadcastDims:Pd,getComplexWithIndex:Z_,getEinsumComputePath:tC,getEinsumPermutation:J_,getFusedBiasGradient:Cx,getFusedDyActivation:_x,getImageCenter:U_,getInnerMostAxes:Dn,getPermuted:zm,getRaggedRank:oF,getReductionAxes:Zn,getReshaped:Om,getReshapedPermuted:Fm,getRowPartitionTypesHelper:iF,getSliceBeginCoords:W_,getSliceSize:G_,getSparseFillEmptyRowsIndicesDenseShapeMismatch:mF,getSparseFillEmptyRowsNegativeIndexErrorMessage:gF,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:yF,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:wF,getSparseReshapeInputOutputMismatchErrorMessage:$F,getSparseReshapeInputOutputMultipleErrorMessage:vF,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:bF,getSparseReshapeNegativeOutputDimErrorMessage:xF,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:CF,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:W$,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:SF,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:_F,getUndoAxesPermutation:Kl,isIdentityPermutation:nC,log:P6,mergeRealAndImagArrays:ko,prepareAndValidate:O_,prepareSplitSize:sC,segment_util:Z9,shouldFuse:kx,slice_util:q9,splitRealAndImagArrays:uF,stridesOrDilationsArePositive:oc,tupleValuesAreOne:zl,upcastType:_r,validateDefaultValueShape:lF,validateInput:v_,validateUpdateShape:Sz,warn:Gr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_9();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IF={kernelName:nb,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ae(t,rh(Ge(n,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J9={kernelName:Af,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const s=nn(Ge(n,"float32")),r=bs(qe(st(1),s));return dn(et(t,r))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eY={kernelName:Rf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const s=bs(qe(nn(Ge(n,"float32")),1));return et(t,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tY={kernelName:th,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=ft(n.shape,s.shape);return{a:()=>{let o=t;const l=Zn(n.shape,r);return l.length>0&&(o=Xe(o,l)),le(o,n.shape)},b:()=>{let o=t;const l=Zn(s.shape,r);return l.length>0&&(o=Xe(o,l)),le(o,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nY={kernelName:sb,saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach((s,r)=>{n[r]=()=>t.clone()}),n}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sY={kernelName:rb,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Lt(n)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rY={kernelName:ab,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Lt(n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aY={kernelName:Df,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>et(t,bs(qe(st(1),nn(Ge(n,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iY={kernelName:Of,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const s=bs(Ae(st(1),nn(Ge(n,"float32"))));return et(t,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oY={kernelName:Lf,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=ft(n.shape,s.shape);return{a:()=>{const o=Ae(nn(n),nn(s));let l=ae(t,et(s,o));const c=Zn(n.shape,r);return c.length>0&&(l=Xe(l,c)),le(l,n.shape)},b:()=>{const o=Ae(nn(n),nn(s));let l=dn(ae(t,et(n,o)));const c=Zn(s.shape,r);return c.length>0&&(l=Xe(l,c)),le(l,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lY={kernelName:zf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>et(t,Ae(nn(Ge(n,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uY={kernelName:Ff,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>et(t,qe(st(1),nn(Ge(n,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cY(t,e,n,s,r,a){const i=W(t,"dy","avgPool3dGrad"),o=W(e,"input","avgPool3dGrad");let l=i,c=o,h=!1;o.rank===4&&(h=!0,l=le(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),c=le(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),V(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),V(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),js("avgPool3dGrad",r,a);const p={dy:l,input:c},f={filterSize:n,strides:s,pad:r,dimRoundingMode:a},g=ie.runKernel(G2,p,f);return h?le(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const dY=ne({avgPool3dGrad_:cY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hY={kernelName:ob,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{filterSize:r,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>dY(t,s,r,a,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pY(t,e,n,s,r){const a=W(t,"dy","avgPoolGrad"),i=W(e,"input","avgPoolGrad");V(i.rank===a.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`);let o=i,l=a,c=!1;i.rank===3&&(c=!0,o=le(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=le(a,[1,a.shape[0],a.shape[1],a.shape[2]])),V(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),V(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const h={dy:l,input:o},p={filterSize:n,strides:s,pad:r},f=ie.runKernel(W2,h,p);return c?le(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const fY=ne({avgPoolGrad_:pY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mY={kernelName:ib,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{filterSize:r,strides:a,pad:i}=n;return{x:()=>fY(t,s,r,a,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gY={kernelName:lb,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[s,r]=e,{transposeA:a,transposeB:i}=n;return!a&&!i?{a:()=>Tt(t,r,!1,!0),b:()=>Tt(s,t,!0,!1)}:!a&&i?{a:()=>Tt(t,r,!1,!1),b:()=>Tt(t,s,!0,!1)}:a&&!i?{a:()=>Tt(r,t,!1,!0),b:()=>Tt(s,t,!1,!1)}:{a:()=>Tt(r,t,!0,!0),b:()=>Tt(t,s,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yY={kernelName:ub,gradFunc:(t,e,n)=>{const{blockShape:s,crops:r}=n;return{x:()=>gx(t,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bY={kernelName:F6,gradFunc:(t,e,n)=>{const s=n,r=s.inputShape,a=s.shape,i=Array.from(a);for(let l=r.length-1;l>=0;l--)if(r[l]===a[l])i[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${a}].`);const o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>Xe(t,o,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xY={kernelName:Mf,gradFunc:t=>({x:()=>t.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wY={kernelName:Bf,gradFunc:t=>({x:()=>Lt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vY={kernelName:Pf,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{clipValueMin:r,clipValueMax:a}=n;return{x:()=>As(Ei(Xl(s,r),vc(s,a)),t,Lt(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Y={kernelName:db,inputsToSave:["x"],gradFunc:IF.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SY={kernelName:hb,saveAllInputs:!0,gradFunc:(t,e,n)=>{const s=e.map(l=>l.shape),{axis:r}=n,a=St(r,e[0].shape)[0],i=s.map(l=>l[a]);return Sr(t,i,a).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Y={kernelName:pb,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,{dilations:a,strides:i,pad:o,dataFormat:l}=n;return V(zl(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>QS(s.shape,t,r,i,o,l),filter:()=>T_(s,t,r.shape,i,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CY={kernelName:fb,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,{strides:a,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>Fl(t,r,a,i,o,1,l),filter:()=>T_(t,s,r.shape,a,i,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TY(t,e,n,s,r){let a=t;t.rank===4&&(a=le(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let i=e;i.rank===4&&(i=le(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),V(a.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),V(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),V(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),V(a.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`),V(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);const o={x:a,dy:i},l={strides:s,pad:r,filterShape:n};return ie.runKernel(X2,o,l)}const kY=ne({conv3DBackpropFilter_:TY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NY={kernelName:mb,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:s,strides:r,pad:a}=n;V(zl(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[i,o]=e;return{x:()=>QO(i.shape,t,o,r,a),filter:()=>kY(i,t,o.shape,r,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IY={kernelName:Vf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ae(dn(g_(Ge(n,"float32"))),t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EY={kernelName:Uf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ae(y_(Ge(n,"float32")),t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AY={kernelName:gb,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r,exclusive:a,reverse:i}=n;return{x:()=>{const o=wn([r],s.rank);let l=t_(t,r,a,!i);return o!=null&&(l=Ft(l,o)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RY={kernelName:yb,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:s,strides:r,pad:a,dimRoundingMode:i}=n,o=s??[1,1];V(zl(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[l,c]=e;return V(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),V(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),V(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),V(xs(r,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`),js("depthwiseConv2d",a,i),{x:()=>Rz(l.shape,t,c,r,a,o,i),filter:()=>Az(l,t,c.shape,r,a,o,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DY={kernelName:bb,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,a={x:s,filter:r,dy:t},i={x:s,filter:r,dy:t};return{x:()=>ie.runKernel(C$,a,n),filter:()=>ie.runKernel(T$,i,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OY={kernelName:Gf,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,s={dy:t,y:n};return{x:()=>ie.runKernel(aS,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zY={kernelName:Hf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,s=ae(Tr(dn(nn(n))),2/Math.sqrt(Math.PI));return{x:()=>ae(t,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FY={kernelName:qf,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ae(t,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LY={kernelName:wb,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>le(t,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MY={kernelName:jf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ae(t,Tr(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BY={kernelName:Kf,gradFunc:t=>({x:()=>Lt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PY={kernelName:Xf,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=ft(n.shape,s.shape);return{a:()=>{const o=et(t,Ge(s,"float32")),l=Zn(n.shape,r);return l.length>0?le(Xe(o,l),n.shape):o},b:()=>{let o=ae(t,Ge(n,"float32"));const l=Zn(s.shape,r);l.length>0&&(o=le(Xe(o,l),s.shape));const c=nn(s);return dn(et(o,Ge(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VY={kernelName:vb,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:s}=n,[r,a,i,o]=e,l=o??st(1),c=Zn(a.shape,r.shape),h=[];if(a.rank===1){for(let C=0;C<r.shape.length-1;++C)h.push(r.shape[C]);h.push(1)}const p=qe(r,a),f=ae(t,l),g=p_(Ae(i,st(s))),y=ae(ae(ae(g,g),g),st(-.5));return{x:()=>a.rank===1?le(ae(ae(t,ga(le(g,[1,1,1,a.shape[0]]),h)),l),r.shape):le(ae(ae(t,g),l),r.shape),mean:()=>{let C=ae(ae(g,st(-1)),f);return a.rank===1&&(C=Xe(C,c)),le(C,a.shape)},variance:()=>{let C=ae(ae(y,p),f);return a.rank===1&&(C=Xe(C,c)),le(C,a.shape)},scale:()=>{const C=ae(p,g);let I=ae(t,C);return a.rank===1&&(I=Xe(I,c)),le(I,a.shape)},offset:()=>{let C=t;return a.rank===1&&(C=Xe(C,c)),le(C,a.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UY={kernelName:$b,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[s,r]=e,{axis:a,batchDims:i}=n,o=St(a,s.shape)[0],l=(c,h,p)=>()=>{const f=c.shape,g=h.size,y=f.slice(0,o),x=y.length,w=f.slice(a,f.length).slice(1),v=w.length,$=OI(0,x),T=OI(x+1,x+1+v),C=zI([y,[g],w]),I=le(p,C),A=le(h,[g]),O=zI([[x],$,T]),B=Ft(I,O);let z=S_(B,A,c.shape[o]);const P=Kl(O);return z=Ft(z,P),z};if(i===1){const c=s.shape[0],h=s.split(c,0);return{x:()=>kr(h.map((g,y)=>l(g,r.slice(y,1),t.slice(y,1))())).reshape(s.shape),indices:()=>r}}else return{x:l(s,r,t),indices:()=>r}}};function OI(t,e){const n=[];for(let s=t;s<e;++s)n.push(s);return n}function zI(t){const e=[];for(let n=0;n<t.length;++n)for(let s=0;s<t[n].length;++s)e.push(t[n][s]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WY={kernelName:Yf,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>Lt(n),b:()=>Lt(s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GY={kernelName:Zf,gradFunc:t=>({x:()=>Ge(t,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HY={kernelName:Qf,gradFunc:t=>({x:()=>Lt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qY={kernelName:Jf,gradFunc:t=>({x:()=>Lt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jY={kernelName:em,gradFunc:t=>({x:()=>Lt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KY={kernelName:_b,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{alpha:r}=n,a=Ar(s,0);return{x:()=>As(a,t,ae(t,r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XY={kernelName:nm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>et(t,Ae(n,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YY={kernelName:tm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>et(t,Ge(n,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZY={kernelName:M6,inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n;return{logits:()=>{const i=Tr(s);return qe(t,ae(Xe(t,r,!0),i))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QY(t,e,n,s=5,r=1,a=1,i=.5){const o={x:t,y:e,dy:n},l={depthRadius:s,bias:r,alpha:a,beta:i};return ie.runKernel(pS,o,l)}const JY=ne({localResponseNormalizationBackprop_:QY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eZ={kernelName:Eb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{depthRadius:a,bias:i,alpha:o,beta:l}=n;return{x:()=>JY(s,r,t,a,i,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EF(t,e,n,s){return e.rank<n.rank&&(e=le(e,Rn(e.shape,s))),t.rank<n.rank&&(t=le(t,Rn(t.shape,s))),{x:()=>ae(t,Ge(Ka(n,e),t.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FI={kernelName:Ab,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const s=n,{reductionIndices:r}=s,a=e[0],i=e[1],o=St(r,a.shape),l=EF(t,i,a,o);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tZ={kernelName:sm,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>ae(t,Ge(Xl(n,s),"float32")),b:()=>ae(t,Ge(ff(n,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nZ(t,e,n,s,r,a,i){const o=W(t,"dy","maxPool3dGrad"),l=W(e,"input","maxPool3dGrad"),c=W(n,"output","maxPool3dGrad");let h=o,p=l,f=c,g=!1;l.rank===4&&(g=!0,h=le(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),p=le(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),f=le(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),V(h.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${h.rank}.`),V(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),V(f.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${f.rank}.`),js("maxPool3dGrad",a,i);const y={dy:h,input:p,output:f},x={filterSize:s,strides:r,pad:a,dimRoundingMode:i},w=ie.runKernel(mS,y,x);return g?le(w,[w.shape[1],w.shape[2],w.shape[3],w.shape[4]]):w}const sZ=ne({maxPool3dGrad_:nZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rZ={kernelName:Db,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>sZ(t,s,r,a,i,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aZ(t,e,n,s,r,a,i){const o=W(t,"dy","maxPoolGrad"),l=W(e,"input","maxPoolGrad"),c=W(n,"output","maxPoolGrad");V(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),V(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),V(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),js("maxPoolGrad",a,i);const h={dy:o,input:l,output:c},p={filterSize:s,strides:r,pad:a,dimRoundingMode:i};return ie.runKernel(fS,h,p)}const iZ=ne({maxPoolGrad_:aZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oZ={kernelName:Rb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{filterSize:a,strides:i,pad:o}=n;return{x:()=>iZ(t,s,r,a,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lZ={kernelName:Ob,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n,a=St(r,s.shape),o=ls(s.shape,a)[1],l=$e(o);return{x:()=>{const h=s.shape.slice();a.forEach(g=>{h[g]=1});const p=le(t,h);return et(ae(p,ir(s.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uZ={kernelName:zb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const s=n,{axis:r}=s,[a,i]=e,o=St(r,a.shape),l=EF(t,i,a,o);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cZ={kernelName:rm,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>ae(t,Ge(vc(n,s),"float32")),b:()=>ae(t,Ge(Ar(n,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dZ={kernelName:Fb,inputsToSave:["x"],gradFunc:(t,e,n)=>{const s=e[0],{paddings:r}=n,a=r.map(i=>i[0]);return{x:()=>Ot(t,a,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hZ={kernelName:am,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=ft(n.shape,s.shape);return{a:()=>{const o=Zn(n.shape,r);return o.length>0?le(Xe(t,o),n.shape):t},b:()=>{const o=ae(t,dn(Rm(et(n,s)))),l=Zn(s.shape,r);return l.length>0?le(Xe(o,l),s.shape):o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pZ={kernelName:im,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=ft(n.shape,s.shape);return{a:()=>{const o=ae(t,Ge(s,"float32")),l=Zn(n.shape,r);return l.length>0?le(Xe(o,l),n.shape):o},b:()=>{const o=ae(t,Ge(n,"float32")),l=Zn(s.shape,r);return l.length>0?le(Xe(o,l),s.shape):o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fZ={kernelName:Lb,gradFunc:t=>({x:()=>dn(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mZ={kernelName:Pb,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>Hn(n.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gZ={kernelName:Bb,gradFunc:t=>({x:()=>Lt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yZ={kernelName:Vb,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:s}=n;return Sa(t,s).map(a=>()=>a)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LI={kernelName:Ub,inputsToSave:["x"],gradFunc:(t,e,n)=>{const s=e[0],{paddings:r}=n,a=r.map(i=>i[0]);return{x:()=>Ot(t,a,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bZ={kernelName:om,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,s,r]=e,a=n,i=s,o=ft(a.shape,i.shape);return{a:()=>{const h=Ge(i,"float32");let p=ae(t,ae(h,Co(a,qe(h,st(1)))));const f=Zn(a.shape,o);return f.length>0&&(p=Xe(p,f)),le(p,a.shape)},b:()=>{const h=Ar(a,0),p=As(h,Kr(a),Lt(a));let f=ae(t,ae(r,p));const g=Zn(i.shape,o);return g.length>0&&(f=Xe(f,g)),le(f,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xZ={kernelName:Wb,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,s]=e,r=Ar(n,0);return{x:()=>As(r,t,ae(t,s)),alpha:()=>{let a=As(r,Lt(t),ae(t,n));const i=Zn(s.shape,t.shape);return i.length>0&&(a=Xe(a,i)),le(a,s.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wZ(t,e,n){const s=t.shape.slice();s[n]=1;const r=le(e,s),a=_0(t,n,!0,!1),i=_0(t,n,!0,!0),o=ae(a,i);return ae(r,o)}function vZ(t,e,n){const s=t.shape.length,r=s-n.length,a=wn(n,s);let i=t;a!=null&&(i=Ft(t,a));const o=i.shape.slice(),c=o.splice(s-n.length,n.length).reduce((f,g)=>f*g,1);o.push(c);const h=i.reshape(o);let p=wZ(h,e,r);if(p=p.reshape(i.shape),a!=null){const f=Kl(a);p=Ft(p,f)}return p}const $Z={kernelName:Gb,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n;let a=[];return r==null?a=s.shape.map((i,o)=>o):typeof r=="number"?a=[r]:a=r,{x:()=>vZ(s,t,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SZ={kernelName:Wf,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=ft(n.shape,s.shape);return{a:()=>{const o=et(t,Ge(s,"float32")),l=Zn(n.shape,r);return l.length>0?le(Xe(o,l),n.shape):o},b:()=>{let o=ae(t,Ge(n,"float32"));const l=Zn(s.shape,r);l.length>0&&(o=le(Xe(o,l),s.shape));const c=nn(s);return dn(et(o,Ge(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Z={kernelName:lm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>et(t,dn(nn(n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CZ={kernelName:cm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,s=ae(vc(n,6),rh(n));return{x:()=>ae(t,Ge(s,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TZ={kernelName:um,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ae(t,Ge(rh(n),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kZ={kernelName:Hb,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>le(t,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NZ={kernelName:jb,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[s]=e,r={dy:t,images:s};return{images:()=>ie.runKernel(kS,r,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IZ={kernelName:qb,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[s]=e,r={dy:t,images:s};return{images:()=>ie.runKernel(TS,r,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EZ={kernelName:Kb,gradFunc:(t,e,n)=>{const{dims:s}=n,r=St(s,t.shape);return{x:()=>$a(t,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AZ={kernelName:dm,gradFunc:t=>({x:()=>Lt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RZ={kernelName:hm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>dn(et(t,ae(Co(n,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DZ={kernelName:Xb,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>Ge(Lt(n),"float32"),t:()=>ae(t,Ge(n,t.dtype)),e:()=>ae(t,Ge(px(n),t.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OZ={kernelName:pm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const s=Ar(n,st(0)),r=st(Ex),a=st(Ax),i=ae(t,a),o=ae(ae(t,r),Tr(Ge(n,"float32")));return As(s,i,o)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zZ={kernelName:ym,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ae(t,ae(n,qe(st(1),n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FZ={kernelName:gm,gradFunc:t=>({x:()=>Lt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LZ={kernelName:fm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ae(lx(Ge(n,"float32")),t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MZ={kernelName:mm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ae(e_(Ge(n,"float32")),t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BZ={kernelName:Yb,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{begin:r,size:a}=n,i=s.shape,[o,l]=Nx(s,r,a),c=[];for(let h=0;h<t.rank;h++)c.push([o[h],i[h]-o[h]-l[h]]);return{x:()=>Yl(t,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PZ={kernelName:ex,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s]=e,{dim:r}=n,a=!0,i=ae(t,s);return{logits:()=>qe(i,ae(Xe(i,[r],a),s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VZ={kernelName:bm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ae(t,Ci(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MI={kernelName:Qb,gradFunc:(t,e,n)=>{const{blockShape:s,paddings:r}=n;return{x:()=>ox(t,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BI={kernelName:Jb,gradFunc:(t,e,n)=>{const{axis:s}=n;return{x:()=>Bn(t,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UZ={kernelName:xm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>et(t,ae(bs(Ge(n,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WZ={kernelName:FS,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ae(t,ae(Ge(n,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GZ={kernelName:wm,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=st(2);return{a:()=>ae(t,ae(r,qe(n,s))),b:()=>ae(t,ae(r,qe(s,n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HZ={kernelName:Cm,gradFunc:t=>({x:()=>Lt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qZ={kernelName:vm,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=ft(n.shape,s.shape);return{a:()=>{let o=t;const l=Zn(n.shape,r);return l.length>0&&(o=Xe(o,l)),le(o,n.shape)},b:()=>{let o=t;const l=Zn(s.shape,r);return l.length>0&&(o=Xe(o,l)),le(dn(o),s.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jZ={kernelName:Zb,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,r=s.shape.slice(),{axis:a}=n;St(a,s.shape).forEach(c=>{r[c]=1});const o=le(t,r),l=ae(o,ir(s.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KZ={kernelName:$m,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>et(t,nn(lx(n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XZ={kernelName:Sm,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ae(qe(st(1),nn(n)),t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YZ={kernelName:_m,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{reps:r}=n;return{x:()=>{let i=Lt(s);if(s.rank===1)for(let o=0;o<r[0];++o)i=Ae(i,Ot(t,[o*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let o=0;o<r[0];++o)for(let l=0;l<r[1];++l)i=Ae(i,Ot(t,[o*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let o=0;o<r[0];++o)for(let l=0;l<r[1];++l)for(let c=0;c<r[2];++c)i=Ae(i,Ot(t,[o*s.shape[0],l*s.shape[1],c*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let o=0;o<r[0];++o)for(let l=0;l<r[1];++l)for(let c=0;c<r[2];++c)for(let h=0;h<r[3];++h)i=Ae(i,Ot(t,[o*s.shape[0],l*s.shape[1],c*s.shape[2],h*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return i}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZZ={kernelName:Ad,gradFunc:(t,e,n)=>{const s=n,{perm:r}=s,a=Kl(r);return{x:()=>Ft(t,a)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QZ={kernelName:nx,gradFunc:(t,e,n)=>{const s=n,{axis:r}=s;return{value:()=>kr(t,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JZ={kernelName:sx,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>eQ(t,n)}}};function eQ(t,e){const n=Ro(e,Lt(e)),s=Dm(t,n);let r=Xl(e,st(0,"int32"));const a=s.rank-r.rank;for(let o=0;o<a;++o)r=Ws(r,o+1);r=Ei(r,ir(s.shape,"bool"));const i=Lt(s);return As(r,s,i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tQ={kernelName:rx,gradFunc:t=>({x:()=>Lt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nQ=[IF,J9,eY,tY,nY,sY,rY,aY,iY,oY,lY,uY,hY,mY,gY,yY,bY,xY,wY,vY,$Y,SY,CY,_Y,NY,IY,EY,AY,RY,DY,SZ,OY,zY,FY,LY,MY,PY,BY,VY,UY,WY,GY,HY,qY,jY,KY,XY,YY,ZY,eZ,FI,FI,tZ,rZ,oZ,lZ,uZ,cZ,dZ,hZ,pZ,fZ,mZ,gZ,yZ,LI,LI,bZ,xZ,$Z,_Z,CZ,TZ,kZ,NZ,IZ,EZ,AZ,RZ,DZ,OZ,zZ,FZ,LZ,MZ,BZ,PZ,VZ,MI,MI,BI,BI,UZ,GZ,WZ,HZ,qZ,jZ,KZ,XZ,YZ,ZZ,QZ,JZ,tQ];for(const t of nQ)V6(t);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.abs=function(){return this.throwIfDisposed(),Gn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.acos=function(){return this.throwIfDisposed(),DO(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.acosh=function(){return this.throwIfDisposed(),OO(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.add=function(t){return this.throwIfDisposed(),Ae(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.all=function(t,e){return this.throwIfDisposed(),XS(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.any=function(t,e){return this.throwIfDisposed(),S0(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.argMax=function(t){return this.throwIfDisposed(),Bd(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.argMin=function(t){return this.throwIfDisposed(),zO(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.asScalar=function(){return this.throwIfDisposed(),V(this.size===1,()=>"The array must have only 1 element."),le(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.asType=function(t){return this.throwIfDisposed(),Ge(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.as1D=function(){return this.throwIfDisposed(),le(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.as2D=function(t,e){return this.throwIfDisposed(),le(this,[t,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.as3D=function(t,e,n){return this.throwIfDisposed(),le(this,[t,e,n])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.as4D=function(t,e,n,s){return this.throwIfDisposed(),le(this,[t,e,n,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.as5D=function(t,e,n,s,r){return this.throwIfDisposed(),le(this,[t,e,n,s,r])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.asin=function(){return this.throwIfDisposed(),FO(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.asinh=function(){return this.throwIfDisposed(),LO(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.atan=function(){return this.throwIfDisposed(),MO(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.atan2=function(t){return this.throwIfDisposed(),BO(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.atanh=function(){return this.throwIfDisposed(),PO(this)};_e().prototype.avgPool=function(t,e,n,s){return this.throwIfDisposed(),ix(this,t,e,n,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),ox(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.batchNorm=function(t,e,n,s,r){return this.throwIfDisposed(),Nm(this,t,e,n,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.broadcastTo=function(t){return this.throwIfDisposed(),Od(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.cast=function(t){return this.throwIfDisposed(),Ge(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.ceil=function(){return this.throwIfDisposed(),qO(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.clipByValue=function(t,e){return this.throwIfDisposed(),Cr(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof yn&&(t=[t]),Bn([this,...t],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.conv1d=function(t,e,n,s,r,a){return this.throwIfDisposed(),ZS(this,t,e,n,s,r,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.conv2dTranspose=function(t,e,n,s,r){return this.throwIfDisposed(),JS(this,t,e,n,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.conv2d=function(t,e,n,s,r,a){return this.throwIfDisposed(),Fl(this,t,e,n,s,r,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.cos=function(){return this.throwIfDisposed(),lx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.cosh=function(){return this.throwIfDisposed(),e_(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.cumprod=function(t,e,n){return this.throwIfDisposed(),_0(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),t_(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),ez(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.depthwiseConv2d=function(t,e,n,s,r,a){return this.throwIfDisposed(),Im(this,t,e,n,s,r,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.dilation2d=function(t,e,n,s,r){return this.throwIfDisposed(),tz(this,t,e,n,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.divNoNan=function(t){return this.throwIfDisposed(),nz(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.div=function(t){return this.throwIfDisposed(),et(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.dot=function(t){return this.throwIfDisposed(),sz(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.elu=function(){return this.throwIfDisposed(),Em(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.equal=function(t){return this.throwIfDisposed(),Ka(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.erf=function(){return this.throwIfDisposed(),n_(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.euclideanNorm=function(t,e){return this.throwIfDisposed(),iz(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.exp=function(){return this.throwIfDisposed(),Tr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.expandDims=function(t){return this.throwIfDisposed(),Ws(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.expm1=function(){return this.throwIfDisposed(),oz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.fft=function(){return this.throwIfDisposed(),$x(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.flatten=function(){return this.throwIfDisposed(),le(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.floor=function(){return this.throwIfDisposed(),Rm(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.floorDiv=function(t){return this.throwIfDisposed(),KS(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.gather=function(t,e,n){return this.throwIfDisposed(),Dm(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.greaterEqual=function(t){return this.throwIfDisposed(),Xl(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.greater=function(t){return this.throwIfDisposed(),Ar(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.ifft=function(){return this.throwIfDisposed(),yf(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.irfft=function(){return this.throwIfDisposed(),x_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.isFinite=function(){return this.throwIfDisposed(),lz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.isInf=function(){return this.throwIfDisposed(),uz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.isNaN=function(){return this.throwIfDisposed(),cz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.leakyRelu=function(t){return this.throwIfDisposed(),cx(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.lessEqual=function(t){return this.throwIfDisposed(),vc(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.less=function(t){return this.throwIfDisposed(),ff(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.localResponseNormalization=function(t,e,n,s){return this.throwIfDisposed(),dz(this,t,e,n,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.logSigmoid=function(){return this.throwIfDisposed(),hz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.logSoftmax=function(t){return this.throwIfDisposed(),a_(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.logSumExp=function(t,e){return this.throwIfDisposed(),hx(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.log=function(){return this.throwIfDisposed(),Kr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.log1p=function(){return this.throwIfDisposed(),dx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.logicalAnd=function(t){return this.throwIfDisposed(),Ei(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.logicalNot=function(){return this.throwIfDisposed(),px(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.logicalOr=function(t){return this.throwIfDisposed(),i_(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.logicalXor=function(t){return this.throwIfDisposed(),pz(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.matMul=function(t,e,n){return this.throwIfDisposed(),Tt(this,t,e,n)};_e().prototype.maxPool=function(t,e,n,s){return this.throwIfDisposed(),fx(this,t,e,n,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.max=function(t,e){return this.throwIfDisposed(),wa(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.maximum=function(t){return this.throwIfDisposed(),Ro(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.mean=function(t,e){return this.throwIfDisposed(),_n(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.min=function(t,e){return this.throwIfDisposed(),pf(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.minimum=function(t){return this.throwIfDisposed(),uc(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.mirrorPad=function(t,e){return this.throwIfDisposed(),mz(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.mod=function(t){return this.throwIfDisposed(),gz(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.mul=function(t){return this.throwIfDisposed(),ae(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.neg=function(){return this.throwIfDisposed(),dn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.norm=function(t,e,n){return this.throwIfDisposed(),Am(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.notEqual=function(t){return this.throwIfDisposed(),Vd(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),l_(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.onesLike=function(){return this.throwIfDisposed(),Xr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.pad=function(t,e){return this.throwIfDisposed(),Yl(this,t,e)};_e().prototype.pool=function(t,e,n,s,r,a){return this.throwIfDisposed(),yz(this,t,e,n,s,r,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.pow=function(t){return this.throwIfDisposed(),Co(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.prelu=function(t){return this.throwIfDisposed(),yx(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.prod=function(t,e){return this.throwIfDisposed(),bz(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.reciprocal=function(){return this.throwIfDisposed(),xz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.relu=function(){return this.throwIfDisposed(),zi(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.relu6=function(){return this.throwIfDisposed(),d_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.reshapeAs=function(t){return this.throwIfDisposed(),le(this,t.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.reshape=function(t){return this.throwIfDisposed(),le(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.resizeBilinear=function(t,e,n){return this.throwIfDisposed(),zz(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.resizeNearestNeighbor=function(t,e,n){return this.throwIfDisposed(),Fz(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.reverse=function(t){return this.throwIfDisposed(),$a(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.rfft=function(){return this.throwIfDisposed(),Sx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.round=function(){return this.throwIfDisposed(),h_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.rsqrt=function(){return this.throwIfDisposed(),p_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.selu=function(){return this.throwIfDisposed(),f_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.separableConv2d=function(t,e,n,s,r,a){return this.throwIfDisposed(),m_(this,t,e,n,s,r,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.sigmoid=function(){return this.throwIfDisposed(),Ci(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.sign=function(){return this.throwIfDisposed(),wz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.sin=function(){return this.throwIfDisposed(),g_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.sinh=function(){return this.throwIfDisposed(),y_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.slice=function(t,e){return this.throwIfDisposed(),Ot(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.softmax=function(t){return this.throwIfDisposed(),vx(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.softplus=function(){return this.throwIfDisposed(),sh(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),gx(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.split=function(t,e){return this.throwIfDisposed(),Sr(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.sqrt=function(){return this.throwIfDisposed(),bs(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.square=function(){return this.throwIfDisposed(),nn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.squaredDifference=function(t){return this.throwIfDisposed(),w_(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.squeeze=function(t){return this.throwIfDisposed(),Sc(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof yn?[this,t]:[this,...t];return kr(n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.step=function(t){return this.throwIfDisposed(),rh(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.stridedSlice=function(t,e,n,s,r,a,i,o){return this.throwIfDisposed(),vz(this,t,e,n,s,r,a,i,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.sub=function(t){return this.throwIfDisposed(),qe(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.sum=function(t,e){return this.throwIfDisposed(),Xe(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.tan=function(){return this.throwIfDisposed(),$z(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.tanh=function(){return this.throwIfDisposed(),lc(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.tile=function(t){return this.throwIfDisposed(),ga(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.toBool=function(){return this.throwIfDisposed(),Ge(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.toFloat=function(){return this.throwIfDisposed(),Ge(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.toInt=function(){return this.throwIfDisposed(),Ge(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.topk=function(t,e){return this.throwIfDisposed(),_z(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.transpose=function(t){return this.throwIfDisposed(),Ft(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.unique=function(t){return this.throwIfDisposed(),Cz(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),S_(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.unstack=function(t){return this.throwIfDisposed(),Sa(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.where=function(t,e){return this.throwIfDisposed(),As(t,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_e().prototype.zerosLike=function(){return this.throwIfDisposed(),Lt(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class xi extends Error{constructor(e){super(e),Object.setPrototypeOf(this,xi.prototype)}}class ya extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ya.prototype)}}class ue extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ue.prototype)}}class bt extends Error{constructor(e){super(e),Object.setPrototypeOf(this,bt.prototype)}}class aC extends Error{constructor(e){super(e),Object.setPrototypeOf(this,aC.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class AF{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let n;return this.cache.has(e)&&(n=this.cache.get(e),this.cache.delete(e),this.cache.set(e,n)),n}put(e,n){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,n)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let n=0;n<this.maxEntries-e;n++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function dc(t,e){if(Array.isArray(t)){let n=[];for(let s=0;s<e;s++)n=n.concat(t);return n}else{const n=new Array(e);return n.fill(t),n}}function wi(t,e){if(!t)throw new aC(e)}function PI(t,e){let n=0;for(const s of t)s===e&&n++;return n}function rr(t){return t.length===1?t[0]:t}function Qt(t){return Array.isArray(t)?t:[t]}function yo(t){const n=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return n[0]!=="_"?n:"private"+n}function Hu(t){return t.length<=1||t.indexOf("_")===-1?t:t.replace(/[_]+(\w|$)/g,(e,n)=>n.toUpperCase())}let ca={};function iC(t){if(t==null)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function G$(t){if(!(t==null||typeof t!="object"))if(Array.isArray(t))t.forEach(e=>G$(e));else{const e=Object.keys(t);for(const n of e){const s=t[n];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?t[n]=s.value:G$(s))}}}function Lm(t,e={},n={},s="object",r=!1){if(typeof t=="string"){const a=t;let i;if(a in n)i=n[a];else if(a in ca)i=ca[a];else if(i=e[a],i==null)throw new ue(`Unknown ${s}: ${t}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{const a=t;if(a.className==null||a.config==null)throw new ue(`${s}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);const i=a.className;let o,l;if(i in n?[o,l]=n[i]:i in ca?[o,l]=ca.className:i in e&&([o,l]=e[i]),o==null)throw new ue(`Unknown ${s}: ${i}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const c={};for(const g of Object.keys(ca))c[g]=ca[g];for(const g of Object.keys(n))c[g]=n[g];const h=a.config;h.customObjects=c;const p=Object.assign({},ca);for(const g of Object.keys(n))ca[g]=n[g];G$(a.config);const f=l(o,a.config,n,r);return ca=Object.assign({},p),f}else{const c=Object.assign({},ca);for(const p of Object.keys(n))ca[p]=n[p];const h=new o(a.config);return ca=Object.assign({},c),h}}}function sQ(t,e){return t<e?-1:t>e?1:0}function ky(t,e){return-1*sQ(t,e)}function El(t){if(t==null)return t;const e=[];for(const n of t)e.indexOf(n)===-1&&e.push(n);return e}function rQ(t){if(t==null)throw new ue(`Invalid value in obj: ${JSON.stringify(t)}`);for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function Cc(t,e,n){if(n!=null&&t.indexOf(n)<0)throw new ue(`${n} is not a valid ${e}.  Valid values are ${t} or null/undefined.`)}function oC(t,e,n=0,s=1/0){return wi(n>=0),wi(s>=n),Array.isArray(t)&&t.length>=n&&t.length<=s&&t.every(r=>typeof r===e)}function rs(t,e){Array.isArray(t)?(V(t.length>0,()=>`${e} is unexpectedly an empty array.`),t.forEach((n,s)=>rs(n,`element ${s+1} of ${e}`))):V(Number.isInteger(t)&&t>0,()=>`Expected ${e} to be a positive integer, but got ${RF(t)}.`)}function RF(t){return t===null?"null":Array.isArray(t)?"["+t.map(e=>RF(e)).join(",")+"]":typeof t=="string"?`"${t}"`:`${t}`}function aQ(t,e,n){let s=n!=null?n():sr(),r;return(...i)=>{const o=n!=null?n():sr();return o-s<e||(s=o,r=t(...i)),r}}function DF(t){return t==="relu"?"relu":t==="linear"?"linear":t==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let iQ=0;function OF(){return iQ++}const Ny={};function Rx(t=""){return t in Ny||(Ny[t]=0),Ny[t]+=1,t+Ny[t].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const oQ=["channelsFirst","channelsLast"],lQ=["nearest","bilinear"],uQ=["valid","same","causal"],cQ=["max","avg"],dQ=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const wd=new Map;function On(t){Cc(oQ,"DataFormat",t)}function hQ(t){Cc(lQ,"InterpolationFormat",t)}function Zr(t){Cc(uQ,"PaddingMode",t)}function zF(t){Cc(cQ,"PoolMode",t)}const lf=[],VI="/";function Ju(t,e){lf.push(t);try{const n=e();return lf.pop(),n}catch(n){throw lf.pop(),n}}function pQ(){return lf.length===0?"":lf.join(VI)+VI}function FF(t){if(!MF(t))throw new Error("Not a valid tensor name: '"+t+"'");return pQ()+t}function LF(t){if(!MF(t))throw new Error("Not a valid tensor name: '"+t+"'");wd.has(t)||wd.set(t,0);const e=wd.get(t);if(wd.set(t,wd.get(t)+1),e>0){const n=`${t}_${e}`;return wd.set(n,1),n}else return t}const fQ=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function MF(t){return!!t.match(fQ)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function mQ(t){return t===parseInt(t.toString(),10)}function Al(t,e,n){e==null&&(e=0),n==null&&(n=t.length);let s=1;for(let r=e;r<n;++r)s*=t[r];return s}function Wd(t){if(t.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let n=0;n<t.length;n++){const s=t[n];s<e&&(e=s)}return e}function Ll(t){if(t.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let n=0;n<t.length;n++){const s=t[n];s>e&&(e=s)}return e}function Xa(t,e){if(e<t)throw new ue(`end (${e}) < begin (${t}) is forbidden.`);const n=[];for(let s=t;s<e;++s)n.push(s);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let hv;function qn(){return hv==null&&(hv=yO().epsilon()),hv}function Ya(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ki(t,e){return Ge(t,e)}function Mm(t,e=-1){const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),le(t,n)}function gQ(t,e){return me(()=>{if(t.shape.length!==2)throw new ue(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);const n=Mm(t,1);return H$(n,[1,e,1])})}function yQ(t){const e=[Al(t.shape)];return le(t,e)}function bQ(t){if(t.rank<=1)throw new ue(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const e=[t.shape[0],Al(t.shape,1)];return le(t,e)}function ec(t,e,n){return me(()=>{switch(t.rank){case 1:return xx(t,e,n);case 2:return b_(t,[e,0],[n,t.shape[1]]);case 3:return wx(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return gf(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return Ot(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return Ot(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new ue(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function pv(t,e,n){return me(()=>{switch(t.rank){case 1:return xx(t,e,n);case 2:return b_(t,[0,e],[t.shape[0],n]);case 3:return wx(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return gf(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new ue(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function Iy(t,e,n,s){return me(()=>{switch(t.rank){case 1:return xx(t,e,n);case 2:switch(s){case 1:return ec(t,e,n);case 2:return pv(t,e,n);default:throw new ue(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return ec(t,e,n);case 2:return wx(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return pv(t,e,n);default:throw new ue(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return ec(t,e,n);case 2:return gf(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return gf(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return pv(t,e,n);default:throw new ue(`The axis is not within the rank of the tensor ${s}`)}default:throw new ue(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function lC(t,e=-1){let n;return e<0&&(n=t[0].rank,n!==0?e=n:e=0),e===t[0].rank&&(e=-1),Bn(t,e)}function UI(t,e){switch(t.rank){case 1:return jO([t,e]);case 2:return KO([t,e],0);case 3:return XO([t,e],0);case 4:return YO([t,e],0);default:throw new ue(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function H$(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new ue(`The length of input n (${e.length}) does not match the number of dimensions in input x (${t.rank})`);return ga(t,e)}function Dx(t,e=0,n=1,s,r){return c_(t,e,n,s,r)}function Ni(t,e,n,s){if(t.rank<2||e.rank<2)throw new bt(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=t.shape.slice(-1)[0],a=e.shape.slice(-2)[0];if(r!==a)throw new bt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${e.shape}`)}if(t.rank===2&&e.rank===2)return P$({a:t,b:e,transposeA:!1,transposeB:!1,bias:s?q$(t.rank,s,Ya()):null,activation:n});{const r=t.shape.slice(),a=r.pop();t=le(t,[-1,a]);const i=e.shape.slice(),o=i.pop(),l=i.pop(),c=[...i,o],h=Array.from({length:e.rank},(y,x)=>x===0?e.rank-2:x<=e.rank-2?x-1:x);e=le(Ft(e,h),[l,-1]);const p=[...r,...c];return le(P$({a:t,b:e,transposeA:!1,transposeB:!1,bias:s?q$(t.rank,s,Ya()):null,activation:n}),p)}}function BF(t,e,n){return me(()=>(Array.isArray(e)?e=Hs(e,"int32"):e=Ge(e,"int32"),Dm(t,e,n)))}function Bm(t){return ae(t,t)}function q$(t,e,n){const s=e.shape;if(e.rank!==1&&e.rank!==t)throw new ue(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${t}`);if(t===5){if(n==="channelsFirst")return s.length===1?le(e,[1,s[0],1,1,1]):le(e,[1,s[3],s[0],s[1],s[2]]);if(n==="channelsLast")return s.length===1?le(e,[1,1,1,1,s[0]]):le(e,[1].concat(s))}else if(t===4){if(n==="channelsFirst")return s.length===1?le(e,[1,s[0],1,1]):le(e,[1,s[2],s[0],s[1]]);if(n==="channelsLast")return s.length===1?le(e,[1,1,1,s[0]]):le(e,[1].concat(s))}else if(t===3){if(n==="channelsFirst")return s.length===1?le(e,[1,s[0],1]):le(e,[1,s[1],s[0]]);if(n==="channelsLast")return s.length===1?le(e,[1,1,s[0]]):le(e,[1].concat(s))}else if(t<3)return e;throw new ue(`Unsupported input rank by biasAdd: ${e.rank}`)}function Ja(t,e,n){return me(()=>(n==null&&(n=Ya()),On(n),Ae(t,q$(t.rank,e,n))))}function xQ(t,e=1){if(e!==1)throw new bt(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return Em(t)}function wQ(t){return me(()=>et(t,Ae(Gn(t),1)))}function PF(t,e,n,s){return me(()=>Nz(t,e,n,s))}function vQ(t){return me(()=>{const e=Ae(.5,ae(.2,t));return Cr(e,0,1)})}function Pm(t,e,n=!1){return n?t():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const $Q=["fanIn","fanOut","fanAvg"],SQ=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function _Q(t){Cc($Q,"FanMode",t)}function CQ(t){Cc(SQ,"Distribution",t)}class Ca extends ih{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class VF extends Ca{apply(e,n){return Hn(e,n)}}VF.className="Zeros";De(VF);class uC extends Ca{apply(e,n){return ir(e,n)}}uC.className="Ones";De(uC);class UF extends Ca{constructor(e){if(super(),typeof e!="object")throw new ue(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new ue(`config must have value set but got ${e}`);this.value=e.value}apply(e,n){return me(()=>ae(st(this.value),ir(e,n)))}getConfig(){return{value:this.value}}}UF.className="Constant";De(UF);class WF extends Ca{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,n){return $c(e,this.minval,this.maxval,n,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}WF.className="RandomUniform";De(WF);class GF extends Ca{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new bt(`randomNormal does not support dType ${n}.`);return Dx(e,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}GF.className="RandomNormal";De(GF);class HF extends Ca{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new bt(`truncatedNormal does not support dType ${n}.`);return $_(e,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}HF.className="TruncatedNormal";De(HF);class qF extends Ca{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,n){return me(()=>{if(e.length!==2||e[0]!==e[1])throw new ue("Identity matrix initializer can only be used for 2D square matrices.");return ae(this.gain,r_(e[0]))})}getConfig(){return{gain:this.gain}}}qF.className="Identity";De(qF);function TQ(t,e="channelsLast"){let n,s;if(On(e),t.length===2)n=t[0],s=t[1];else if([3,4,5].indexOf(t.length)!==-1){if(e==="channelsFirst"){const r=Al(t,2);n=t[1]*r,s=t[0]*r}else if(e==="channelsLast"){const r=Al(t,0,t.length-2);n=t[t.length-2]*r,s=t[t.length-1]*r}}else{const r=Al(t);n=Math.sqrt(r),s=Math.sqrt(r)}return[n,s]}class Nr extends Ca{constructor(e){if(super(),e.scale<0)throw new ue(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,_Q(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,CQ(this.distribution),this.seed=e.seed}apply(e,n){const s=TQ(e),r=s[0],a=s[1];let i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,r):this.mode==="fanOut"?i/=Math.max(1,a):i/=Math.max(1,(r+a)/2),this.distribution==="normal"){const o=Math.sqrt(i);if(n=n||"float32",n!=="float32"&&n!=="int32")throw new bt(`${this.getClassName()} does not support dType ${n}.`);return $_(e,0,o,n,this.seed)}else{const o=Math.sqrt(3*i);return $c(e,-o,o,n,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Nr.className="VarianceScaling";De(Nr);class cC extends Nr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Nr.className}}cC.className="GlorotUniform";De(cC);class dC extends Nr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Nr.className}}dC.className="GlorotNormal";De(dC);class hC extends Nr{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Nr.className}}hC.className="HeNormal";De(hC);class pC extends Nr{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Nr.className}}pC.className="HeUniform";De(pC);class fC extends Nr{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Nr.className}}fC.className="LeCunNormal";De(fC);class mC extends Nr{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Nr.className}}mC.className="LeCunUniform";De(mC);class jF extends Ca{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,n){return me(()=>{if(e.length<2)throw new bt("Shape must be at least 2D.");if(n!=="int32"&&n!=="float32"&&n!==void 0)throw new TypeError(`Unsupported data type ${n}.`);n=n;const s=$e(e.slice(0,-1)),r=e[e.length-1],a=s*r;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);const i=[Math.max(r,s),Math.min(r,s)],o=Dx(i,0,1,n,this.seed),l=Lz.qr(o,!1);let c=l[0];const p=l[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return c=ae(c,p.sign()),s<r&&(c=c.transpose()),ae(st(this.gain),c.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}jF.className="Orthogonal";De(jF);const WI={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function GI(t,e={}){return Lm(t,ma.getMap().classNameMap,e,"initializer")}function xn(t){return iC(t)}function pn(t){if(typeof t=="string"){const e=t in WI?WI[t]:t;if(e==="GlorotNormal")return new dC;if(e==="GlorotUniform")return new cC;if(e==="HeNormal")return new hC;if(e==="HeUniform")return new pC;if(e==="LeCunNormal")return new fC;if(e==="LeCunUniform")return new mC;{const n={};return n.className=e,n.config={},GI(n)}}else return t instanceof Ca?t:GI(t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function j$(t){return Array.isArray(t)&&Array.isArray(t[0])}function C0(t){return t.length===0?[]:Array.isArray(t[0])?t:[t]}function dt(t){let e;if(Array.isArray(t)){if(t.length!==1)throw new ue(`Expected Tensor length to be 1; got ${t.length}`);e=t[0]}else e=t;return e}function Wt(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(t.length===1)return t=t,t[0];throw new ue(`Expected exactly 1 Shape; got ${t.length}`)}else return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function T0(t){let e=0;for(const n of t)n.shape.length===0?e+=1:e+=n.shape.reduce((s,r)=>s*r);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const HI="Variable";class kQ{constructor(e,n="float32",s=HI,r=!0,a=null){this.dtype=n??"float32",this.shape=e.shape,this.id=OF(),s=s??HI,this.originalName=FF(s),this.name=LF(this.originalName),this.trainable_=r,this.constraint=a,this.val=Tz(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),NQ(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function NQ(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}function K$(t){return t.map(e=>e.read())}function gC(t){t.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class jn{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Ai{constructor(e,n,s,r,a,i,o){this.dtype=e,this.shape=n,this.sourceLayer=s,this.inputs=r,this.callArgs=a,this.outputTensorIndex=o,this.id=OF(),i!=null&&(this.originalName=FF(i),this.name=LF(this.originalName)),this.rank=n.length}}let IQ=0;class Ox{constructor(e,n){this.callArgs=n,this.id=IQ++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s!=null&&s.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const n of this.inboundLayers)n!=null?e.push(n.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let EQ=0;class _t extends ih{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=EQ++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let n=e.name;if(!n){const s=this.getClassName();n=yo(s)+"_"+Rx(s)}if(this.name=n,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let a=null;e.batchSize!=null&&(a=e.batchSize),s=[a].concat(e.inputShape)}this.batchInputShape=s;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,n){return e.name+"_ib-"+n.toString()}getNodeAtIndex(e,n){if(this.inboundNodes.length===0)throw new ya(`The layer has never been called and thus has no defined ${n}.`);if(this.inboundNodes.length<=e)throw new ue(`Asked to get ${n} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return rr(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return rr(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new xi(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new xi(`Layer ${this.name} is not connected, no input to return.`);return rr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new xi(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new xi(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return rr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(n=>n.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const n=Qt(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=Qt(this.inputSpec);if(n.length!==s.length)throw new ue(`Layer ${this.name} expects ${s.length} inputs, but it received ${n.length} input tensors. Input received: ${e}`);for(let r=0;r<n.length;r++){const a=n[r],i=s[r];if(i==null)continue;const o=a.rank;if(i.ndim!=null&&o!==i.ndim)throw new ue(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${o}`);if(i.maxNDim!=null&&o>i.maxNDim)throw new ue(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${o}`);if(i.minNDim!=null&&o<i.minNDim)throw new ue(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${o}.`);if(i.dtype!=null&&a.dtype!==i.dtype)throw new ue(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${a.dtype}.`);if(i.axes){const l=a.shape;for(const c in i.axes){const h=Number(c),p=i.axes[c],f=h>=0?l[h]:l[l.length+h];if(p!=null&&[p,null].indexOf(f)===-1)throw new ue(`Input ${r} is incompatible with layer ${this.name}: expected axis ${h} of input shape to have value ${p} but got shape ${l}.`)}}if(i.shape!=null)for(let l=0;l<i.shape.length;++l){const c=i.shape[l],h=a.shape[l];if(c!=null&&h!=null&&c!==h)throw new ue(`Input ${r} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${a.shape}.`)}}}call(e,n){return e}invokeCallHook(e,n){this._callHook!=null&&this._callHook(e,n)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,n){n=n||{},this.assertNotDisposed();const s=Qt(e),r=DQ(e),a=OQ(e);if(r===a)throw new ue("Arguments to apply() must be all SymbolicTensors or all Tensors");return Ju(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const i=[];for(const o of Qt(e))i.push(o.shape);this.build(rr(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let i=this.call(e,n);this.supportsMasking&&this.setMaskMetadata(e,i);const o=Qt(i),l=[];for(let c of o)s.indexOf(c)!==-1&&(c=c.clone()),l.push(c);if(i=rr(l),this.activityRegularizer!=null)throw new bt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{const i=AQ(e),o=this.computeOutputShape(i);let l;const c=RQ(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?i[0]:i),o!=null&&o.length>0&&Array.isArray(o[0])?l=o.map((h,p)=>new Ai(c,h,this,Qt(e),n,this.name,p)):l=new Ai(c,o,this,Qt(e),n,this.name),this.addInboundNode(e,l,null,null,i,o,n),this._refCount++,this.activityRegularizer!=null)throw new bt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let n=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&e[r]!=null&&e[r]!==s&&(n=!0)}),n&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new xi(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const n of this.inboundNodes){const s=JSON.stringify(n.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const n=this.inboundNodes[0].outputShapes;return Array.isArray(n)&&Array.isArray(n[0])&&n.length===1?n[0]:n}else throw new xi(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new ya(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return T0(this.weights)}build(e){this.built=!0}getWeights(e=!1){return K$(e?this.trainableWeights:this.weights)}setWeights(e){me(()=>{const n=this.weights;if(n.length!==e.length)throw new ue(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${n.length} weights. Provided weights: ${e}...`);if(n.length===0)return;const s=[],r=K$(n);for(let a=0;a<r.length;++a){const i=r[a],o=n[a],l=e[a];if(!Rt(i.shape,l.shape))throw new ue(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);s.push([o,l])}gC(s)})}addWeight(e,n,s,r,a,i,o,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new ue(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=l!=null?l():pn("zeros"));const c=r.apply(n,s),h=new kQ(c,s,e,i,o);return c.dispose(),a!=null&&this.addLoss(()=>a.apply(h.read())),i==null&&(i=!0),i?this._trainableWeights.push(h):this._nonTrainableWeights.push(h),h}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Qt(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,n){if(!this.supportsMasking){if(n!=null)if(Array.isArray(n))n.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return n}setMaskMetadata(e,n,s){if(!this.supportsMasking)return;const r=this.computeMask(e,s),a=Qt(n),i=Qt(r);if(a.length!==i.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let o=0;o<a.length;o++)a[o].kerasMask=i[o]}addInboundNode(e,n,s,r,a,i,o=null){const l=Qt(e);n=Qt(n),s=Qt(s),r=Qt(r),a=C0(a),i=C0(i);const c=[],h=[],p=[];for(const f of l)c.push(f.sourceLayer),h.push(f.nodeIndex),p.push(f.tensorIndex);new Ox({outboundLayer:this,inboundLayers:c,nodeIndices:h,tensorIndices:p,inputTensors:l,outputTensors:n,inputMasks:s,outputMasks:r,inputShapes:a,outputShapes:i},o);for(let f=0;f<n.length;f++)n[f].sourceLayer=this,n[f].nodeIndex=this.inboundNodes.length-1,n[f].tensorIndex=f}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function AQ(t){t=Qt(t);const e=[];for(const n of t)e.push(n.shape);return rr(e)}function RQ(t){return"float32"}function KF(t,e,n){if((e==null||n!=null&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),e.inboundNodes.length===0)return[t];{const s=e.inboundNodes[n];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let a=0;a<s.inboundLayers.length;a++){const i=s.inputTensors[a],o=s.inboundLayers[a],l=s.nodeIndices[a],c=KF(i,o,l);for(const h of c)r.indexOf(h)===-1&&r.push(h)}return r}}}function DQ(t){let e=!0;for(const n of Qt(t))if(!(n instanceof Ai)){e=!1;break}return e}function OQ(t){let e=!0;for(const n of Qt(t))if(n instanceof Ai){e=!1;break}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Vm extends _t{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:Rx("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new ue("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let n=e.batchInputShape;if(n==null){if(e.inputShape==null)throw new ue("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");n=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new ue("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=n,this.dtype=s,this.inputSpec=[{shape:n}];const r=new Ai(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new Ox({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]})}apply(e,n){throw new ue(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}Vm.className="InputLayer";De(Vm);function zQ(t){if(t.batchShape==null&&t.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(t.batchShape!=null&&t.shape!=null)throw new ue("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;t.shape!=null&&e==null&&(e=[null].concat(t.shape));let n=t.dtype;return n==null&&(n="float32"),new Vm({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function FQ(t,e){if(t.dtype==null||t.dtype===e.dtype)return e;try{return Ge(e,t.dtype)}catch{throw new ue(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}class Tl{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Tl)for(const n in e.id2Value)this.id2Value[n]=e.id2Value[n],n in e.id2Mask&&(this.id2Mask[n]=e.id2Mask[n]);else{if(e==null)return;for(const n of e)this.add(n.key,n.value)}}add(e,n,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=FQ(e,n),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new ue(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Ai){if(this.id2Value[e.id]==null)throw new ue(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const n=this.name2Id[e];if(n==null)throw new ue(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[n]}}getMask(e){if(e instanceof Ai){if(this.id2Value[e.id]==null)throw new ue(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const n=this.name2Id[e];if(n==null)throw new ue(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&$t(this.id2Mask)}}const k0=new AF,N0=new AF;function LQ(t){k0!=null&&k0.setMaxEntries(t),N0!=null&&N0.setMaxEntries(t)}function Qp(t,e,n,s){const r=n==null?!1:n.training,a=Array.isArray(t),i=a?t:[t],o=i.map(y=>y.name),l=[],c=e.names();for(const y of o)c.indexOf(y)!==-1?l.push(e.getValue(y)):l.push(null);const h=o.join(",")+"|"+e.names().sort().join(",");let p=k0.get(h),f;if(p==null){const y=MQ(i,e);p=y.sorted,f=y.recipientCounts,k0.put(h,p),N0.put(h,f)}f={},r||Object.assign(f,N0.get(h));const g=new Tl(e);for(let y=0;y<p.length;++y){const x=p[y],w=x.sourceLayer;if(w instanceof Vm)continue;const v=[],$=[],T=[];let C=!1;for(const z of x.inputs){const P=g.getValue(z),F=g.getMask(z);v.push(P),$.push(F),F!=null&&(C=!0),r||(f[z.name]--,f[z.name]===0&&!e.hasKey(z)&&o.indexOf(z.name)===-1&&!P.isDisposed&&z.sourceLayer.stateful!==!0&&T.push(P))}C&&(n=n||{},n.mask=$[0]);const I=Qt(w.apply(v,n));let A=null;w.supportsMasking&&(A=w.computeMask(v,$));const O=PQ(x),B=Array.isArray(O)?O:[O];for(let z=0;z<B.length;++z){g.hasKey(B[z])||g.add(B[z],I[z],Array.isArray(A)?A[0]:A);const P=o.indexOf(B[z].name);P!==-1&&(l[P]=I[z])}r||$t(T)}return g.disposeMasks(),a?l:l[0]}function MQ(t,e){V(t!=null&&t.length>0,()=>"Expected at least one fetch, got none");let n=[],s={};if(t.length===1){const r=qI(t[0],e);n=r.sorted,s=r.recipientMap}else{const r=new Set;for(const a of t){const{sorted:i,recipientMap:o}=qI(a,e);for(const l of i)r.has(l.name)||(n.push(l),r.add(l.name));for(const l in o)s[l]==null&&(s[l]=new Set),o[l].forEach(c=>s[l].add(c))}}return{sorted:n,recipientCounts:BQ(s)}}function BQ(t){const e={};for(const n in t)e[n]=t[n].size;return e}function qI(t,e){const n=new Set,s=[],r={};for(const o of e.names())n.add(o);const a=[],i=[];for(a.push(t);a.length>0;){const o=a[a.length-1];if(n.has(o.name)){a.pop();continue}const l=i[i.length-1]===a.length-1;if(o.inputs.length===0||l)a.pop(),s.push(o),n.add(o.name),l&&i.pop();else{i.push(a.length-1);for(const c of o.inputs)r[c.name]==null&&(r[c.name]=new Set),r[c.name].add(o.name),!n.has(c.name)&&a.push(c)}}return{sorted:s,recipientMap:r}}function PQ(t){let e;if(t.sourceLayer.inboundNodes.length===1)e=t.sourceLayer.output;else{let n=null;for(let s=0;s<t.sourceLayer.inboundNodes.length;++s)for(const r of t.sourceLayer.inboundNodes[s].outputTensors)if(r.id===t.id){n=s;break}e=t.sourceLayer.getOutputAt(n)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VQ=ye();VQ.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,LQ);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function yC(t,e){return me(()=>bs(Xe(ae(t,t),e,!0)))}class Um extends ih{getConfig(){return{}}}class XF extends Um{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return me(()=>{const n=yC(e,this.axis),s=Cr(n,0,this.maxValue);return ae(e,et(s,Ae(qn(),n)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}XF.className="MaxNorm";De(XF);class YF extends Um{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return me(()=>et(e,Ae(qn(),yC(e,this.axis))))}getConfig(){return{axis:this.axis}}}YF.className="UnitNorm";De(YF);class ZF extends Um{apply(e){return zi(e)}}ZF.className="NonNeg";De(ZF);class QF extends Um{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return me(()=>{const n=yC(e,this.axis),s=Ae(ae(this.rate,Cr(n,this.minValue,this.maxValue)),ae(1-this.rate,n));return ae(e,et(s,Ae(qn(),n)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}QF.className="MinMaxNorm";De(QF);const jI={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Xn(t){return iC(t)}function KI(t,e={}){return Lm(t,ma.getMap().classNameMap,e,"constraint")}function Yn(t){if(t==null)return null;if(typeof t=="string"){const n={className:t in jI?jI[t]:t,config:{}};return KI(n)}else return t instanceof Um?t:KI(t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function Lu(t){if(t==null)return;const e=[],n=[],s=[];for(const r in t){const a=t[r];if(typeof a!="number"){const i=a;e.push(i.data()),n.push(r),s.push(i)}}if(e.length>0){const r=await Promise.all(e);for(let a=0;a<r.length;++a)t[n[a]]=r[a][0];$t(s)}}function JF(t){if(t!=null)for(const e in t){const n=t[e];typeof n!="number"&&n.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var XI;(function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"})(XI||(XI={}));const UQ=125;class bf{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,n){}async onEpochEnd(e,n){}async onBatchBegin(e,n){}async onBatchEnd(e,n){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class WQ{constructor(e,n=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=n}append(e){this.callbacks.push(e)}setParams(e){for(const n of this.callbacks)n.setParams(e)}setModel(e){for(const n of this.callbacks)n.setModel(e)}async onEpochBegin(e,n){n==null&&(n={});for(const s of this.callbacks)await s.onEpochBegin(e,n)}async onEpochEnd(e,n){n==null&&(n={});for(const s of this.callbacks)await s.onEpochEnd(e,n)}async onBatchBegin(e,n){n==null&&(n={});for(const s of this.callbacks)await s.onBatchBegin(e,n)}async onBatchEnd(e,n){n==null&&(n={});for(const s of this.callbacks)await s.onBatchEnd(e,n)}async onTrainBegin(e){e==null&&(e={});for(const n of this.callbacks)await n.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const n of this.callbacks)await n.onTrainEnd(e)}}class GQ extends bf{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,n){n==null&&(n={});const s=n.size==null?0:n.size;this.seen+=s;for(const r in n){const a=n[r];if(typeof a=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+a*s;else{let i;r in this.totals?i=this.totals[r]:this.totals[r]=0;const o=me(()=>Ae(this.totals[r],ae(a,s)));this.totals[r]=o,i!=null&&i.dispose()}}}async onEpochEnd(e,n){if(n!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?n[s]=this.totals[s]/this.seen:me(()=>{const r=ae(et(1,this.seen),this.totals[s]);n[s]=r,this.totals[s].dispose(),ss(n[s])}))}}class HQ extends bf{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,n){n==null&&(n={}),this.epoch.push(e);for(const s in n)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(n[s])}async syncData(){const e=[],n=[],s=[];for(const a in this.history){const i=this.history[a];for(let o=0;o<i.length;++o)if(typeof i[o]!="number"){const l=i[o];e.push(l.data()),n.push(a),s.push(o)}}const r=await Promise.all(e);for(let a=0;a<r.length;++a)this.history[n[a]][s[a]].dispose(),this.history[n[a]][s[a]]=r[a][0]}}class qQ extends bf{constructor(e,n){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||rF,this.yieldEvery=n||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=UQ),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");$$(this.yieldEvery)&&(this.maybeWait=aQ(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,n,s){const r=[];this.yield!=null&&(await Lu(s),r.push(this.yield(e,n,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,n){this.currentEpoch=e,this.epochBegin!=null&&(await Lu(n),await this.epochBegin(e,n))}async onEpochEnd(e,n){const s=[];this.epochEnd!=null&&(await Lu(n),s.push(this.epochEnd(e,n))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,n){this.batchBegin!=null&&(await Lu(n),await this.batchBegin(e,n))}async onBatchEnd(e,n){const s=[];this.batchEnd!=null&&(await Lu(n),s.push(this.batchEnd(e,n))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):$$(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,n)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await Lu(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Lu(e),await this.trainEnd(e))}}function eL(t,e){return t==null&&(t={}),t instanceof bf?[t]:Array.isArray(t)&&t[0]instanceof bf?t:Qt(t).map(s=>new qQ(s,e))}class ha{constructor(){}static registerCallbackConstructor(e,n){V(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),ha.checkForDuplicate(n),ha.constructors[e]==null&&(ha.constructors[e]=[]),ha.constructors[e].push(n)}static checkForDuplicate(e){for(const n in ha.constructors)ha.constructors[+n].forEach(r=>{if(r===e)throw new ue("Duplicate callback constructor.")})}static clear(){ha.constructors={}}static createCallbacks(e){const n=[];for(const s in ha.constructors){const r=+s;e>=r&&n.push(...ha.constructors[r])}return n.map(s=>new s)}}ha.constructors={};function tL(t,e,n,s,r,a,i,o,l){const c=new HQ,h=[new GQ,...ha.createCallbacks(e)];t!=null&&h.push(...t),h.push(c);const p=new WQ(h);return p.setParams({epochs:n,initialEpoch:s,samples:r,steps:a,batchSize:i,verbose:e,doValidation:o,metrics:l}),{callbackList:p,history:c}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function So(t,e={},n=!1){return Lm(t,ma.getMap().classNameMap,e,"layer",n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function I0(t,e){return me(()=>{t.dtype!=="float32"&&(t=Ge(t,"float32"));const n=Xe(Bm(t),e,!0),s=nh(n.shape,qn()),r=bs(Ro(n,s));return et(t,r)})}function zx(t,e){return me(()=>_n(Bm(qe(e,t)),-1))}function bC(t,e){return me(()=>_n(Gn(qe(e,t)),-1))}function xC(t,e){return me(()=>{const n=qe(t,e),s=Cr(Gn(t),qn(),Number.MAX_VALUE),r=Gn(et(n,s));return ae(100,_n(r,-1))})}function jQ(t,e){return me(()=>{const n=Cr(e,qn(),Number.MAX_VALUE),s=Kr(Ae(1,n)),r=Cr(t,qn(),Number.MAX_VALUE),a=Kr(Ae(1,r));return _n(Bm(qe(s,a)),-1)})}function KQ(t,e){return me(()=>{const n=Ro(0,qe(1,ae(t,e)));return _n(Bm(n),-1)})}function XQ(t,e){return me(()=>{const n=Ro(0,qe(1,ae(t,e)));return _n(n,-1)})}function YQ(t,e){return me(()=>{const n=Xe(ae(t,e),-1),s=wa(ae(qe(1,t),e),-1);return Ro(0,Ae(1,qe(s,n)))})}function ZQ(t,e){return me(()=>{const n=Math.log(2),s=qe(e,t),r=qe(Ae(s,sh(ae(-2,s))),n);return _n(r,-1)})}function xf(t,e,n=!1){return me(()=>{if(n)e=vx(e);else{const s=Xe(e,e.shape.length-1,!0);e=et(e,s)}return e=Cr(e,qn(),1-qn()),dn(Xe(ae(Ge(t,"float32"),Kr(e)),e.shape.length-1))})}function E0(t,e,n=!1){return me(()=>{const s=Ge(Rm(yQ(t)),"int32");e=Cr(e,qn(),1-qn());const r=e.shape,a=le(l_(s,r[r.length-1]),r);return xf(a,e,n)})}function QQ(t,e){if(!Rt(t.shape,e.shape))throw new ue(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);return me(()=>{const n=zi(e),s=dn(Gn(e));return Ae(qe(n,ae(e,t)),dx(Tr(s)))})}function Fx(t,e){return me(()=>{let n;return n=Cr(e,qn(),1-qn()),n=Kr(et(n,qe(1,n))),_n(QQ(t,n),-1)})}function JQ(t,e){return me(()=>{const n=Cr(t,qn(),1),s=Cr(e,qn(),1);return Xe(ae(t,Kr(et(n,s))),-1)})}function eJ(t,e){return me(()=>{const n=Kr(Ae(qn(),e));return _n(qe(e,ae(t,n)),-1)})}function nL(t,e){return me(()=>{const n=I0(t,-1),s=I0(e,-1),r=ae(n,s);return dn(Xe(r,-1))})}const A0={meanSquaredError:zx,meanAbsoluteError:bC,meanAbsolutePercentageError:xC,meanSquaredLogarithmicError:jQ,squaredHinge:KQ,hinge:XQ,categoricalHinge:YQ,logcosh:ZQ,categoricalCrossentropy:xf,sparseCategoricalCrossentropy:E0,binaryCrossentropy:Fx,kullbackLeiblerDivergence:JQ,poisson:eJ,cosineProximity:nL};function fv(t){if(typeof t=="string"){if(t in A0)return A0[t];let e=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ue(e)}else return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function sL(t,e){return me(()=>{const n=ae(.5,Xr(e)),s=ki(Ar(e,n),t.dtype);return _n(Ka(t,s),-1)})}function rL(t,e){return me(()=>ki(Ka(Bd(t,-1),Bd(e,-1)),"float32"))}function tJ(t,e){return me(()=>Ge(Xe(Ei(Ka(t,1),Ka(e,1))),"float32"))}function nJ(t,e){return me(()=>Ge(Xe(Ei(Ka(t,0),Ka(e,1))),"float32"))}function sJ(t,e){return me(()=>{const n=tJ(t,e),s=nJ(t,e),r=Ae(n,s);return Ge(As(Ar(r,0),et(n,r),0),"float32")})}function rJ(t,e){return Fx(t,e)}function aJ(t,e){return t.rank===e.rank&&(t=Sc(t,[t.rank-1])),e=Bd(e,-1),e.dtype!==t.dtype&&(e=Ge(e,t.dtype)),Ge(Ka(t,e),"float32")}const iJ=zx,oJ=zx,lJ=bC,uJ=bC,cJ=xC,dJ=xC,aL=xf,hJ=nL,iL=E0,R0={binaryAccuracy:sL,categoricalAccuracy:rL,precision:sJ,categoricalCrossentropy:aL,sparseCategoricalCrossentropy:iL,mse:iJ,MSE:oJ,mae:lJ,MAE:uJ,mape:cJ,MAPE:dJ,cosine:hJ};function pJ(t){if(typeof t=="string"&&t in R0)return R0[t];if(typeof t!="string"&&t!=null)return t;throw new ue(`Unknown metric ${t}`)}function Ey(t){if(wi(t!==null,`Unknown LossOrMetricFn ${t}`),typeof t=="string")return t;{let e;for(const n of Object.keys(A0))if(A0[n]===t){e=n;break}if(e!==void 0)return e;for(const n of Object.keys(R0))if(R0[n]===t){e=n;break}return e!==void 0?e:t.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function fJ(t){const e={Adagrad:()=>xd.adagrad(.01),Adadelta:()=>xd.adadelta(1,.95,qn()),Adam:()=>xd.adam(.001,.9,.999,qn()),Adamax:()=>xd.adamax(.002,.9,.999,qn(),0),RMSProp:()=>xd.rmsprop(.001,.9,0,qn()),SGD:()=>xd.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new ue(`Unknown Optimizer ${t}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const YI=1*1024*1024;function ZI(t,e,n=!1){if(t==null||typeof t!="object"||Object.getPrototypeOf(t)!==Object.prototype||!X$(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const s=JSON.stringify(t);s.length>YI&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${YI}.`)}}function X$(t){if(t===null)return!0;if(typeof t=="object")if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e)if(typeof n!="string"||!X$(t[n]))return!1;return!0}else if(Array.isArray(t)){for(const e of t)if(!X$(e))return!1;return!0}else return!1;else{const e=typeof t;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function mJ(t,e,n,s=console.log){const r=yJ(t),a=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,n=n||[.32,.61,.89,1]):(e=e||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(h=>Math.floor(e*h)));let i;if(!r){a.push("Receives inputs"),i=[];for(const h in t.nodesByDepth)i.push(...t.nodesByDepth[h])}s("_".repeat(e)),D0(a,n,s),s("=".repeat(e));const o=t.layers;for(let h=0;h<o.length;++h)r?bJ(o[h],n,s):xJ(o[h],n,i,s),s((h===o.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=gJ(t),c=T0(t.nonTrainableWeights);s(`Total params: ${l+c}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${c}`),s("_".repeat(e))}function gJ(t){let e;return t.collectedTrainableWeights!=null?e=T0(t.collectedTrainableWeights):e=T0(t.trainableWeights),e}function yJ(t){let e=!0;const n=[],s=[];for(const r in t.nodesByDepth)n.push(t.nodesByDepth[r]);for(const r of n){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of t.layers){let a=!1;for(const i of r.inboundNodes)if(s.indexOf(i)!==-1)if(a){e=!1;break}else a=!0;if(!e)break}return e}function D0(t,e,n=console.log){let s="";for(let r=0;r<t.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=t[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);n(s)}function bJ(t,e,n){let s,r;try{r=t.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(t.outputShape)}catch{s="multiple"}const a=t.name,i=t.getClassName(),o=[`${a} (${i})`,r,s,t.countParams().toString()];D0(o,e,n)}function xJ(t,e,n,s){let r,a;try{a=t.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch{a="multiple"}try{r=JSON.stringify(t.outputShape)}catch{r="multiple"}const i=[];for(const p of t.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(p)===-1))for(let f=0;f<p.inboundLayers.length;++f){const g=p.inboundLayers[f].name,y=p.nodeIndices[f],x=p.tensorIndices[f];i.push(`${g}[${y}][${x}]`)}const o=t.name,l=t.getClassName(),c=i.length===0?"":i[0],h=[`${o} (${l})`,a,r,t.countParams().toString(),c];D0(h,e,s);for(let p=1;p<i.length;++p)D0(["","","","",i[p]],e,s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function oL(t,e,n){return(t==="inboundNodes"||t==="outputLayers"||t==="inputLayers")&&e===0&&typeof n=="string"}function Y$(t,e){if(t===null)return null;if(typeof t=="string")return Hu(t);if(typeof t=="number"||typeof t=="boolean")return t;if(t instanceof Array){const n=[],s=t.length;for(let r=0;r<s;++r){const a=t[r];oL(e,r,a)?n.push(a):n.push(Y$(a,e))}return n}else{const n={};for(const s of Object.keys(t)){const r=t[s];if(s==="name"&&typeof r=="string")n[s]=r;else{const a=Hu(s);n[a]=Y$(r,a)}}return n}}function Z$(t,e){if(t==null)return null;if(typeof t=="string")return yo(t);if(typeof t=="number"||typeof t=="boolean")return t;if(t instanceof Array){const n=[],s=t.length;for(let r=0;r<s;++r){const a=t[r];oL(e,r,a)?n.push(a):n.push(Z$(a,e))}return n}else{const n={};for(const s of Object.keys(t)){const r=t[s],a=yo(s);(s==="name"||s==="className")&&typeof r=="string"?n[a]=r:n[a]=Z$(r,s)}return n}}/** @license See the LICENSE file. */const lL="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const wJ=t=>{const e=Object.keys(t);if(e.length===0)return!1;const n=e[0].split("/");return!isNaN(parseInt(n[n.length-1],10))};class Va extends _t{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const $=this.getClassName().toLowerCase();this.name=Rx($)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],El(this.inputs).length!==this.inputs.length)throw new ue(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map($=>$.name)}`);El(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map($=>$.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const $ of this.outputs){const T=$.sourceLayer,C=$.nodeIndex,I=$.tensorIndex;this.outputLayers.push(T),this.outputLayersNodeIndices.push(C),this.outputLayersTensorIndices.push(I)}for(const $ of this.inputs){const T=$.sourceLayer,C=$.nodeIndex,I=$.tensorIndex;wi(C===0,"input layer has >1 nodes"),wi(I===0,"input layer has >1 tensors"),this.inputLayers.push(T),this.inputLayersNodeIndices.push(C),this.inputLayersTensorIndices.push(I)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let $=0;$<this.inputLayers.length;$++){const T=this.inputLayers[$];if(!(T instanceof Vm))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${$} (0-based) originates from layer type ${T.getClassName()}.`);this.inputNames.push(T.name),this.feedInputShapes.push(T.batchInputShape),this.feedInputNames.push(T.name)}for(const $ of this.outputLayers)this.outputNames.push($.name);this.internalInputShapes=this.inputs.map($=>$.shape),this.internalOutputShapes=this.outputs.map($=>$.shape);const n={},s={},r={},a={},i={},o=[],l=($,T,C,I,A,O)=>{(I==null||A==null||O==null)&&(I=$.sourceLayer,A=$.nodeIndex,O=$.tensorIndex);const B=I.inboundNodes[A];if(C.indexOf(B)!==-1)throw new ya(`The tensor ${$.name} at layer "${I.name}" is part of a cycle.`);if(T.indexOf(B)!==-1)return;this.containerNodes.add(Va.nodeKey(I,A)),I.id in i||(i[I.id]=Object.keys(i).length),C.indexOf(B)===-1&&C.push(B);const z=B.inboundLayers.length;for(let P=0;P<z;P++){const F=B.inputTensors[P],K=B.inboundLayers[P],X=B.nodeIndices[P],te=B.tensorIndices[P];l(F,T,C,K,X,te)}for(T.push(B);C.indexOf(B)>=0;)C.splice(C.indexOf(B),1);o.push(B)},c=[],h=[];for(const $ of this.outputs)l($,c,h);const p=o.slice().reverse();for(const $ of p){s[$.id]=$,$.id in n||(n[$.id]=0);let T=n[$.id];const C=r[$.outboundLayer.id]==null?0:r[$.outboundLayer.id];T=Math.max(T,C),r[$.outboundLayer.id]=T,a[$.outboundLayer.id]=$.outboundLayer,n[$.id]=T;for(let I=0;I<$.inboundLayers.length;I++){const A=$.inboundLayers[I],O=$.nodeIndices[I],B=A.inboundNodes[O],z=n[B.id]==null?0:n[B.id];n[B.id]=Math.max(T+1,z),s[B.id]=B}}const f={};for(const $ in n){const T=n[$];T in f||(f[T]=[]),f[T].push(s[$])}const g={};for(const $ in r){const T=r[$];T in g||(g[T]=[]),g[T].push(a[$])}let y=Object.keys(g).map($=>parseInt($,10)).sort(ky);this.layers=[];for(const $ of y){const T=g[$];T.sort((C,I)=>{const A=i[C.id],O=i[I.id];return A<O?-1:A>O?1:0});for(const C of T)C instanceof Va&&this.internalContainerRefs.push(C),this.layers.push(C)}this.layersByDepth=g,y=Object.keys(f).map($=>parseInt($,10)).sort(ky);const x=this.inputs.slice(),w=[];for(const $ of y)for(const T of f[$]){const C=T.outboundLayer;if(C!=null){for(const I of T.inputTensors)if(x.indexOf(I)===-1)throw new ya(`Graph disconnected: cannot obtain value for tensor ${I} at layer "${C.name}". The following previous layers were accessed without issue: ${w}`);for(const I of T.outputTensors)x.push(I);w.push(C.name)}}this.nodesByDepth=f;const v=this.layers.map($=>$.name);for(const $ of v){const T=v.filter(C=>C===$).length;if(T!==1)throw new ya(`The name "${$}" is used ${T} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(v))}this.outboundNodes=[],this.inboundNodes=[],new Ox({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map($=>null),outputMasks:this.outputs.map($=>null),inputShapes:this.inputs.map($=>$.shape),outputShapes:this.outputs.map($=>$.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const n of this.layers)e.numDisposedVariables+=n.dispose().numDisposedVariables;for(const n of this.internalContainerRefs)e.numDisposedVariables+=n.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(n=>{n._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new ue("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const n of this.layers)e=e.concat(n.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const n of this.layers)e.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const s of this.layers)n.push(...s.trainableWeights);return n.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,n=!0){const s={};let r=0;const a=wJ(e);a&&this.parseWeights(e);for(const o of this.layers)for(const[l,c]of o.weights.entries()){const h=a?`${c.name.split("/").slice(0,-1).join("/")+"/"}${l}`:c.originalName;if(s[h]!=null)throw new ue(`Duplicate weight name: ${h}`);s[h]=c,r++}const i=[];for(const o in e){let l=o;if(s[o]==null){const c=o.split("/");l=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(s[l]!=null)i.push([s[l],e[o]]);else if(n)throw new ue(`Provided weight data has no target variable: ${o}`);delete s[l]}if(n){const o=[];for(const l in s)o.push(l);if(o.length>0)throw new ue(`${o.length} of ${r} weights are not set: ${o}`)}gC(i)}parseWeights(e){for(const n in Object.keys(e)){const s=n.split("/"),r=["vars","layer_checkpoint_dependencies"],a=s.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!r.includes(i)).join("/");a!==n&&(e[a]=e[n],delete e[n])}}updatedConfig(){const e=this.getConfig(),n={};return n.className=this.getClassName(),n.config=e,n.kerasVersion=`tfjs-layers ${lL}`,n.backend="TensorFlow.js",n}toJSON(e,n=!0){const s=Z$(this.updatedConfig());return n?JSON.stringify(s):s}call(e,n){return me(()=>{e=Qt(e);const s=new Tl;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],e[r]);return Qp(this.outputs,s,n)})}computeMask(e,n){return me(()=>{e=Qt(e);let s;return n==null?s=dc(null,e.length):s=Qt(n),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const n=C0(e);if(n.length!==this.inputLayers.length)throw new ue(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let o=0;o<n.length;o++){const l=this.inputLayers[o],c=n[o],h=l.name+"_0_0";s[h]=c}const r=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(ky);if(r.length>1)for(const o of r){const l=this.nodesByDepth[o];for(const c of l){const h=c.outboundLayer;if(this.inputLayers.map(x=>x.id).indexOf(h.id)!==-1)continue;const p=[];for(let x=0;x<c.inboundLayers.length;x++){const w=c.inboundLayers[x],v=c.nodeIndices[x],$=c.tensorIndices[x],T=`${w.name}_${v}_${$}`,C=s[T];p.push(C)}const f=h.computeOutputShape(rr(p)),g=C0(f),y=h.inboundNodes.indexOf(c);for(let x=0;x<g.length;x++){const w=`${h.name}_${y}_${x}`;s[w]=g[x]}}}const a=[],i=[];for(let o=0;o<this.outputLayers.length;o++){const l=this.outputLayers[o],c=this.outputLayersNodeIndices[o],h=this.outputLayersTensorIndices[o],p=`${l.name}_${c}_${h}`;i.push(p)}for(let o=0;o<i.length;o++){const l=i[o];wi(l in s),a.push(s[l])}return rr(a)}runInternalGraph(e,n){n==null&&(n=dc(null,e.length));const s={};for(let l=0;l<this.inputs.length;++l){const c=this.inputs[l],h=e[l],p=n[l];s[c.id]=[h,p]}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(ky);for(const l of r){const c=this.nodesByDepth[l];for(const h of c){const p=h.outboundLayer,f=h.inputTensors,g=h.outputTensors,y=new Array;for(const x of f)x.id in s&&y.push(s[x.id]);if(y.length===f.length){let x={},w,v,$,T;if(h.callArgs!=null&&(x=h.callArgs),y.length===1){const[C,I]=y[0];x.mask==null&&(x.mask=I),$=Qt(p.call(C,x)),T=Qt(p.computeMask(C,I)),w=[C],v=[I]}else w=y.map(C=>C[0]),v=y.map(C=>C[1]),x.mask==null&&(x.mask=v),$=Qt(p.call(w,x)),T=Qt(p.computeMask(w,v));if(p.activityRegularizer)throw new bt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let C=0;C<g.length;++C){const I=g[C],A=$[C],O=T[C];s[I.id]=[A,O]}}}}const a=[],i=[],o=[];for(const l of this.outputs){wi(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[c,h]=s[l.id];o.push(c.shape),a.push(c),i.push(h)}return[a,i,o]}buildNodeConversionMap(e){const n={};let s;for(const r of this.layers){s=r instanceof Va?1:0;for(let a=0;a<r.inboundNodes.length;a++){const i=Va.nodeKey(r,a);this.containerNodes.has(i)&&(n[i]=s,s+=1)}}return n}getLayer(e,n){if(n!=null)return this.findLayer(n);if(e==null)throw new ue("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new ue(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new ue(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return me(()=>{const e=[];for(const n of this.layers)for(let s=0;s<n.inboundNodes.length;++s){const r=Va.nodeKey(n,s);this.containerNodes.has(r)&&e.push(...n.calculateLosses())}return e})}getConfig(){const e={name:this.name},n=this.buildNodeConversionMap(this.layers),s=[];for(const i of this.layers){const o=i.getClassName(),l=i.getConfig(),c=[];for(let p=0;p<i.inboundNodes.length;p++){const f=i.inboundNodes[p],g=Va.nodeKey(i,p);let y={};if(this.containerNodes.has(g)){if(f.callArgs)try{JSON.stringify(f.callArgs),y=f.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${f.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),y={}}if(f.inboundLayers.length>0){const x=[];for(let w=0;w<f.inboundLayers.length;w++){const v=f.inboundLayers[w],$=f.nodeIndices[w],T=f.tensorIndices[w],C=Va.nodeKey(v,$);let I=n[C];I==null&&(I=0),x.push([v.name,I,T,y])}c.push(x)}}}const h={};h.name=i.name,h.className=o,h.config=l,h.inboundNodes=c,s.push(h)}e.layers=s;const r=[];for(let i=0;i<this.inputLayers.length;i++){const o=this.inputLayers[i],l=this.inputLayersNodeIndices[i],c=Va.nodeKey(o,l);if(!this.containerNodes.has(c))continue;let h=n[c];h==null&&(h=0);const p=this.inputLayersTensorIndices[i];r.push([o.name,h,p])}e.inputLayers=r;const a=[];for(let i=0;i<this.outputLayers.length;i++){const o=this.outputLayers[i],l=this.outputLayersNodeIndices[i],c=Va.nodeKey(o,l);if(!this.containerNodes.has(c))continue;let h=n[c];h==null&&(h=0);const p=this.outputLayersTensorIndices[i];a.push([o.name,h,p])}return e.outputLayers=a,e}static fromConfig(e,n,s={},r=!1){const a={},i={};function o(w,v){w.name in i?i[w.name].push(v):i[w.name]=[v]}function l(w,v){const $=[];let T;for(const C of v){const I=C[0],A=C[1],O=C[2];if(T=C[3]==null?{}:C[3],!(I in a)){o(w,v);return}const B=a[I];if(B.inboundNodes.length<=A){o(w,v);return}const z=B.inboundNodes[A];$.push(z.outputTensors[O])}$.length>0&&w.apply(rr($),T)}function c(w){const v=w.name,$=So(w,n.customObjects!=null?n.customObjects:{});$.setFastWeightInitDuringBuild(r),a[v]=$,w.inboundNodes.forEach(C=>{if(!(C instanceof Array))throw new ue(`Corrupted configuration, expected array for nodeData: ${C}`);o($,C)})}const h=n.name,p=n.layers;for(const w of p)c(w);for(;!rQ(i);)for(const w of p){const v=a[w.name];if(v.name in i){const $=i[v.name];delete i[v.name];for(const T of $)l(v,T)}}const f=[],g=[],y=n.inputLayers;for(const w of y){const v=w[0],$=w[1],T=w[2];wi(v in a);const I=a[v].inboundNodes[$].outputTensors;f.push(I[T])}const x=n.outputLayers;for(const w of x){const v=w[0],$=w[1],T=w[2];wi(v in a);const I=a[v].inboundNodes[$].outputTensors;g.push(I[T])}return new e({inputs:f,outputs:g,name:h})}get stateful(){if(this._stateful)throw new ue("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){me(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function vJ(t,e,n){const s=e.length;if(t==null||Array.isArray(t)&&t.length===0)return e.map(r=>null);if(s===1)return Array.isArray(t)&&t.length===1?t:typeof t=="object"&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==s)throw new Error(`Provided ${n} is an array of ${t.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return t}else if(typeof t=="object"&&Object.keys(t).length>0&&typeof t[Object.keys(t)[0]]=="object"){const r=[];return e.forEach(a=>{a in t?r.push(t[a]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${n} must be either an array with ${s} elements or an object with ${e} keys. Provided ${n} not understood: ${JSON.stringify(t)}`)}function uL(t,e){return vJ(t,e,"classWeight")}async function cL(t,e,n,s){if(n!=null){const r=me(()=>{if(t.shape.length===1)return $o(t);if(t.shape.length===2){if(t.shape[1]>1)return Bd(t,1);if(t.shape[1]===1)return le(t,[t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),a=Array.from(await r.data());$t(r);const i=[];return a.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),Hs(i,"float32")}else return null}function $J(t,e){return ae(t,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const SJ=32;function dL(t,e){let n,s;const r=e;n=r.xs,s=r.ys,V(n!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const a=QI("input",t.inputNames,n),i=QI("output",t.outputNames,s),o=a[0].shape[0];V(a.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),V(i.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let l=0;l<a.length;l++)V(a[l].shape[0]===o,()=>`Batch size mismatch: input ${t.inputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${t.inputNames[0]}.`);for(let l=0;l<i.length;l++)V(i[l].shape[0]===o,()=>`Batch size mismatch: output ${t.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${t.inputNames[0]}.`);return{xs:a,ys:i}}function QI(t,e,n){if(n instanceof yn)return[n];if(Array.isArray(n))return V(n.length===e.length,()=>`Received an array of ${n.length} Tensors, but expected ${e.length} to match the ${t} keys ${e}.`),n;{const s=[];for(const r of e){if(n[r]==null)throw new ue(`The feature data generated by the dataset lacks the required ${t} key '${r}'.`);s.push(n[r])}return s}}function _J(t){if(t.length===3)throw new bt("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}async function CJ(t,e,n){const s=n.batchesPerEpoch!=null;if(V(t.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),V(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),V(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),V(!s||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),V(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const r=n.validationData!=null;let a,i;if(r)if(JI(n.validationData))V(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const w=_J(n.validationData);a=w.xs,i=w.ys}const o=t.makeTrainFunction(),l=t.getDedupedMetricsNames();let c;r?c=l.slice().concat(l.map(w=>"val_"+w)):c=l.slice();const h=eL(n.callbacks,n.yieldEvery),p=n.verbose==null?1:n.verbose,{callbackList:f,history:g}=tL(h,p,n.epochs,null,null,TJ(e,n),null,r,c);f.setModel(t),t.history=g,await f.onTrainBegin(),t.stopTraining_=!1;let y=n.initialEpoch==null?0:n.initialEpoch,x=await e.iterator();for(;y<n.epochs;){const w={};await f.onEpochBegin(y);let v=0,$=0;for(s||(x=await e.iterator());!s||v<n.batchesPerEpoch;){const T=await x.next();if(s&&T.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${v} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(T.value!=null){const{xs:C,ys:I}=dL(t,T.value),A={};A.batch=$,A.size=C[0].shape[0],await f.onBatchBegin($,A);const O=[];if(n.classWeight!=null){const P=uL(n.classWeight,t.outputNames);for(let F=0;F<P.length;++F)O.push(await cL(I[F],null,P[F]))}const B=C.concat(I).concat(O),z=o(B);$t(B);for(let P=0;P<l.length;++P){const F=l[P],K=z[P];A[F]=K,ss(K)}await f.onBatchEnd($,A),JF(A),$++,v++}if(s?v>=n.batchesPerEpoch:T.done){if(r){let C;JI(n.validationData)?C=Qt(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):C=Qt(t.evaluate(a,i,{batchSize:n.validationBatchSize==null?SJ:n.validationBatchSize,verbose:0}));for(let I=0;I<t.metricsNames.length;++I)w[`val_${t.metricsNames[I]}`]=C[I]}break}if(t.stopTraining_)break}if(await f.onEpochEnd(y,w),y++,t.stopTraining_)break}return await f.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}function TJ(t,e){let n=null;return e.batchesPerEpoch!=null?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size),n}function JI(t){return typeof t.iterator=="function"}function kJ(t){return typeof t.next=="function"}async function NJ(t,e,n){n=n||{};const s=n.batches!=null,r=t.testFunction;let a=[];if(n.verbose>0)throw new bt("Verbose mode is not implemented yet.");V(!s||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const i=kJ(e)?e:await e.iterator();let o=0,l=0;for(;!s||l<n.batches;){const c=await i.next();if(a=me(()=>{if(c.value){const{xs:h,ys:p}=dL(t,c.value),f=h.concat(p),g=me(()=>r(f));if($t(f),l===0)for(let x=0;x<g.length;++x)a.push(st(0));const y=f[0].shape[0];for(let x=0;x<g.length;++x){const w=g[x],v=a[x];a[x]=me(()=>Ae(a[x],ae(y,w))),l>0&&$t(v)}$t(g),o+=y,++l}return a}),c.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<a.length;++c){const h=a[c];a[c]=et(a[c],o),$t(h)}return rr(a)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function mv(t){V(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function Mp(t,e,n){return t==null?[null]:Array.isArray(t)?t.map(s=>ec(s,e,n-e)):ec(t,e,n-e)}function Q$(t,e){return me(()=>t==null?null:Array.isArray(t)?t.map(n=>Q$(n,e)):BF(t,e.dtype==="int32"?e:Ge(e,"int32")))}function gv(t,e){const n=[];let s=0,r=null;for(;s<t;)r=s+e,r>=t&&(r=t),n.push([s,r]),s=r;return n}function hL(t){const e=[];t instanceof yn&&(t=[t]);for(let n=0;n<t.length;++n){const s=t[n];if(s.rank===1)e.push(Mm(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function za(t,e){if(t==null)return;const n=[];if(e instanceof yn)n.push(e.id);else if(Array.isArray(e))e.forEach(r=>n.push(r.id));else if(e!=null)for(const r in e){const a=e[r];n.push(a.id)}const s=[];if(t instanceof yn)n.indexOf(t.id)===-1&&s.push(t);else if(Array.isArray(t))t.forEach(r=>{n.indexOf(r.id)===-1&&s.push(r)});else if(t!=null)for(const r in t){const a=t[r];n.indexOf(a.id)===-1&&s.push(a)}s.forEach(r=>{r.isDisposed||r.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function IJ(t){return t instanceof yn}function J$(t){return Array.isArray(t)}function eE(t){return!IJ(t)&&!J$(t)}function tE(t,e,n,s=!0,r=""){if(e==null||e.length===0){if(t!=null){let i=!1;if(J$(t)&&t.length>0)i=!0;else if(eE(t)){for(const o in t)if(t.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new ue(`Error when checking model ${r} expected no data, but got ${t}`)}return[]}if(t==null)return e.map(i=>null);let a;if(eE(t)){t=t,a=[];for(const i of e){if(t[i]==null)throw new ue(`No data provided for "${i}". Need data for each key in: ${e}`);a.push(t[i])}}else if(J$(t)){if(t=t,t.length!==e.length)throw new ue(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);a=t}else{if(t=t,e.length>1)throw new ue(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);a=[t]}if(a=hL(a),n!=null)for(let i=0;i<e.length;++i){if(n[i]==null)continue;const o=a[i];if(o.shape.length!==n[i].length)throw new ue(`Error when checking ${r}: expected ${e[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<n[i].length;++l){if(l===0&&!s)continue;const c=o.shape[l],h=n[i][l];if(h!=null&&h>=0&&c!==h)throw new ue(`${r} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${r} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return a}function EJ(t,e,n){const s=El(t.map(a=>a.shape[0]));s.sort();const r=El(e.map(a=>a.shape[0]));if(r.sort(),s.length>1)throw new ue(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(a=>a.shape))}`);if(r.length>1)throw new ue(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(a=>a.shape))}`);if(s.length>0&&r.length>0&&!Rt(s,r))throw new ue(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function AJ(t,e,n){const s=[zx,Fx,xf];for(let r=0;r<t.length;++r){const a=t[r],i=e[r],o=n[r];if(i!=null){if(i===xf&&a.shape[a.shape.length-1]===1)throw new ue(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(i)!==-1){const l=a.shape.slice(1),c=o.slice(1);for(let h=0;h<l.length;++h){const p=l[h],f=c[h];if(f!=null&&p!==f)throw new ue(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function nE(t,e,n,s=!0,r=""){let a;if(Array.isArray(t)){if(t.length!==e.length)throw new ue(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${t.length} Tensors(s).`);a=t}else{if(e.length>1)throw new ue(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);a=[t]}if(n!=null)for(let i=0;i<e.length;++i){if(n[i]==null)continue;const o=a[i];if(o.shape.length!==n[i].length)throw new ue(`Error when checking ${r}: expected ${e[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<n[i].length;++l){if(l===0&&!s)continue;const c=o.shape[l],h=n[i][l];if(h!=null&&h!==c)throw new ue(`Error when checking ${r}: expected ${e[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function RJ(t,e){if(t==null||Array.isArray(t)&&t.length===0)return e.map(s=>[]);let n;if(typeof t=="string"||typeof t=="function")n=[t];else if(Array.isArray(t)||typeof t=="object")n=t;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);if(Array.isArray(n))return e.map(s=>n);{const s=[];for(const r of e){let a=n.hasOwnProperty(r)?n[r]:[];Array.isArray(a)||(a=[a]),s.push(a)}return s}}const DJ="layers-model";class zd extends Va{constructor(e){super(e),this.isTraining=!1}summary(e,n,s=console.log){if(!this.built)throw new ue("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");mJ(this,e,n,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=fJ(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Zl))throw new ue("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let n=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const i in e.loss)if(this.outputNames.indexOf(i)===-1)throw new ue(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(const i of this.outputNames)e.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),n.push(fv(e.loss[i]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new ue(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);n=e.loss.map(o=>fv(o))}else{const i=fv(e.loss);this.outputs.forEach(o=>{n.push(i)})}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const o=this.internalOutputShapes[i],l=this.outputNames[i];this.feedOutputNames.push(l),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[i])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Ju("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(s.indexOf(i)!==-1)continue;const o=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([o,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});const r=RJ(e.metrics,this.outputNames),a=(i,o,l)=>{this.outputNames.length>1&&(o=this.outputNames[i]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([l,i])};Ju("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(s.indexOf(i)!==-1)continue;const o=r[i];(c=>{const h="";let p,f,g;for(const y of c){if(typeof y=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(y)!==-1){const w=this.internalOutputShapes[i];w[w.length-1]===1||this.lossFunctions[i]===Fx?["accuracy","acc"].indexOf(y)!==-1?f=sL:["crossentropy","ce"].indexOf(y)!==-1&&(f=rJ):this.lossFunctions[i]===E0?["accuracy","acc"].indexOf(y)!==-1?f=aJ:["crossentropy","ce"].indexOf(y)!==-1&&(f=iL):["accuracy","acc"].indexOf(y)!==-1?f=rL:["crossentropy","ce"].indexOf(y)!==-1&&(f=aL);let v;["accuracy","acc"].indexOf(y)!==-1?v="acc":["crossentropy","ce"].indexOf(y)!==-1&&(v="ce"),g=f,p=h+v}else g=pJ(y),p=h+Ey(y);let x;Ju(p,()=>{x=g}),a(i,p,x)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,n,s={}){const r=s.batchSize==null?32:s.batchSize;mv(r);const i=this.standardizeUserDataXY(e,n,!0,r);try{const o=i[0].concat(i[1]);this.makeTestFunction();const l=this.testFunction,c=this.testLoop(l,o,r,s.verbose,s.steps);return rr(c)}finally{za(i[0],e),za(i[1],n)}}async evaluateDataset(e,n){return this.makeTestFunction(),NJ(this,e,n)}checkNumSamples(e,n,s,r="steps"){let a;if(s!=null){if(a=null,n!=null)throw new ue(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${n}`)}else if(e!=null)Array.isArray(e)?a=e[0].shape[0]:a=e.shape[0];else throw new ue(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return a}execute(e,n){if(Array.isArray(n)&&n.length===0)throw new ue("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(n),r=s?n:[n],a=this.retrieveSymbolicTensors(r),i=new Tl;if(e instanceof yn&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new ue(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)i.add(this.inputs[l],e[l])}else for(const l of this.inputs){const c=e[l.name];if(c==null)throw new ue(`No value is provided for the model's input ${l.name}`);i.add(l,c)}const o=Qp(a,i);return s?o:o[0]}retrieveSymbolicTensors(e){const n=dc(null,e.length);let s=e.length;for(const r of this.layers){const a=Array.isArray(r.output)?r.output:[r.output],i=a.map(o=>o.name);for(let o=0;o<e.length;++o){const l=i.indexOf(e[o]);if(l!==-1&&(n[o]=a[l],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw n.forEach((a,i)=>{a==null&&r.push(e[i])}),new ue(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return n}predictLoop(e,n=32,s=!1){return me(()=>{const r=this.checkNumSamples(e);if(s)throw new bt("Verbose predictLoop() is not implemented yet.");const a=gv(r,n),i=this.outputs.map(o=>[]);for(let o=0;o<a.length;++o)me(()=>{const c=a[o][0],h=a[o][1],p=Mp(e,c,h),f=[];if(Array.isArray(p))for(let y=0;y<p.length;++y)f.push({key:this.inputs[y],value:p[y]});else f.push({key:this.inputs[0],value:p});const g=new Tl(f);return Qp(this.outputs,g)}).forEach((c,h)=>i[h].push(c));return rr(i.map(o=>Bn(o,0)))})}predict(e,n={}){const s=hL(e);nE(s,this.inputNames,this.feedInputShapes,!1);try{const r=n.batchSize==null?32:n.batchSize;return mv(r),this.predictLoop(s,r)}finally{za(s,e)}}predictOnBatch(e){nE(e,this.inputNames,this.feedInputShapes,!0);const n=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,n)}standardizeUserDataXY(e,n,s=!0,r){if(this.optimizer_==null)throw new ya("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let i=0;i<this.feedOutputShapes.length;++i){const o=this.feedOutputShapes[i];this.feedLossFns[i]===E0?a.push(o.slice(0,o.length-1).concat([1])):a.push(o)}if(e=tE(e,this.feedInputNames,this.feedInputShapes,!1,"input"),n=tE(n,this.feedOutputNames,a,!1,"target"),EJ(e,n),AJ(n,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new ue(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,n]}async standardizeUserData(e,n,s,r,a=!0,i){const[o,l]=this.standardizeUserDataXY(e,n,a,i);if(s!=null)throw new Error("sample weight is not supported yet.");let c=null;if(r!=null){const h=uL(r,this.outputNames);c=[];for(let p=0;p<h.length;++p)c.push(await cL(l[p],null,h[p]))}return[o,l,c]}testLoop(e,n,s,r=0,a){return me(()=>{const i=this.checkNumSamples(n,s,a,"steps"),o=[];if(r>0)throw new bt("Verbose mode is not implemented yet.");if(a!=null)throw new bt("steps mode in testLoop() is not implemented yet");{const l=gv(i,s),c=Hs(Xa(0,i));for(let h=0;h<l.length;++h){const p=l[h][0],f=l[h][1],g=ec(c,p,f-p),y=Q$(n,g),x=e(y);if(h===0)for(let w=0;w<x.length;++w)o.push(st(0));for(let w=0;w<x.length;++w){const v=x[w];o[w]=Ae(o[w],ae(f-p,v))}}for(let h=0;h<o.length;++h)o[h]=et(o[h],i)}return o})}getDedupedMetricsNames(){const e=this.metricsNames,n=[];for(let s=0;s<e.length;++s){const r=e[s];let a=r;if(PI(e,r)>1){const i=PI(e.slice(0,s),r);a+=`_${i}`}n.push(a)}return n}makeTrainFunction(){return e=>{const n=[],s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],o=()=>{const p=[];for(let x=0;x<this.inputs.length;++x)p.push({key:this.inputs[x],value:s[x]});const f=new Tl(p),g=Qp(this.outputs,f,{training:!0});let y;for(let x=0;x<this.lossFunctions.length;++x){const w=this.lossFunctions[x];let v=w(r[x],g[x]);a[x]!=null&&(v=$J(v,a[x]));const $=_n(v);n.push($),x===0?y=v:y=Ae(y,v)}for(let x=0;x<this.metricsTensors.length;++x){let w;if(this.outputs.length>1&&x<this.outputs.length)w=n[x];else{const v=this.metricsTensors[x][0],$=this.metricsTensors[x][1];w=_n(v(r[$],g[$]))}ss(w),i.push(w)}return y=_n(y),this.calculateLosses().forEach(x=>{y=Ae(y,x)}),y},l=this.collectedTrainableWeights.map(p=>p.read());return[this.optimizer_.minimize(o,!0,l)].concat(i)}}makeTestFunction(){this.testFunction=e=>me(()=>{const n=[];let s;const r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let c=0;c<this.inputs.length;++c)i.push({key:this.inputs[c],value:r[c]});const o=new Tl(i),l=Qp(this.outputs,o);for(let c=0;c<this.lossFunctions.length;++c){const h=this.lossFunctions[c],p=_n(h(a[c],l[c]));c===0?s=p:s=Ae(s,p),n.push(s)}for(let c=0;c<this.metricsTensors.length;++c){const h=this.metricsTensors[c][0],p=this.metricsTensors[c][1],f=_n(h(a[p],l[p]));n.push(f)}return n})}async fit(e,n,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,a,i,o,l,c,h,p,f;try{const g=s.batchSize==null?32:s.batchSize;mv(g);const x=await this.standardizeUserData(e,n,s.sampleWeight,s.classWeight,!1,g);r=x[0],a=x[1],f=x[2];let w=!1,v;if(s.validationData!=null&&s.validationData.length>0){if(w=!0,s.validationData.length===2)l=s.validationData[0],c=s.validationData[1];else throw s.validationData.length===3?new bt("validationData including sample weights is not supported yet."):new ue(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const P=await this.standardizeUserData(l,c,null,null,!0,g);h=P[0],p=P[1],v=h.concat(p)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){w=!0;const z=Math.floor(r[0].shape[0]*(1-s.validationSplit)),P=r[0].shape[0];h=Mp(r,z,P),i=r,r=Mp(r,0,z),p=Mp(a,z,P),o=a,a=Mp(a,0,z),v=h.concat(p)}else s.validationSteps!=null&&(w=!0);const $=r.concat(a).concat(f);this.checkTrainableWeightsConsistency();const T=this.makeTrainFunction(),C=this.getDedupedMetricsNames();let I,A;w?(this.makeTestFunction(),I=this.testFunction,A=C.slice().concat(C.map(z=>"val_"+z))):(I=null,v=[],A=C.slice());const O=eL(s.callbacks,s.yieldEvery);return await this.fitLoop(T,$,C,g,s.epochs,s.verbose,O,I,v,s.shuffle,A,s.initialEpoch,null,null)}finally{this.isTraining=!1,za(r,e),za(a,n),za(i,e),za(o,n),za(h,l),za(p,c),f!=null&&$t(f)}}async fitLoop(e,n,s,r,a,i,o,l,c,h,p,f,g,y){r==null&&(r=32),a==null&&(a=1),h==null&&(h=!0),f==null&&(f=0);let x=!1;if(l!=null&&c!=null&&(x=!0),y!=null&&(x=!0,g==null))throw new ue("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const w=this.checkNumSamples(n,r,g,"steps_per_epoch");let v;w!=null&&(v=Xa(0,w)),i==null&&(i=1);const{callbackList:$,history:T}=tL(o,i,a,f,w,g,r,x,p);$.setModel(this),this.history=T,await $.onTrainBegin(),this.stopTraining_=!1;for(let C=f;C<a;++C){await $.onEpochBegin(C);const I={};if(g!=null)throw new bt("stepsPerEpoch mode is not implemented yet.");{if(h==="batch")throw new bt("batch shuffling is not implemneted yet");h&&$6(v);const A=Hs(v),O=gv(w,r);for(let B=0;B<O.length;++B){const z={};if(await $.onBatchBegin(B,z),me(()=>{const P=O[B][0],F=O[B][1],K=ec(A,P,F-P);z.batch=B,z.size=F-P;const X=Q$(n,K),te=e(X);for(let Q=0;Q<s.length;++Q){const q=s[Q],oe=te[Q];z[q]=oe,ss(oe)}if(B===O.length-1&&x){const Q=this.testLoop(l,c,r);for(let q=0;q<s.length;++q){const oe=s[q],se=Q[q];ss(se),I["val_"+oe]=se}}}),await $.onBatchEnd(B,z),JF(z),this.stopTraining_)break}A.dispose()}if(await $.onEpochEnd(C,I),this.stopTraining_)break}return await $.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,n){return CJ(this,e,n)}async trainOnBatch(e,n){const s=await this.standardizeUserData(e,n),r=s[0],a=s[1],o=this.makeTrainFunction()(r.concat(a)),l=[];for(const c of o){const h=await c.data();l.push(h[0])}return $t(o),za(s[0],e),za(s[1],n),rr(l)}getNamedWeights(e){const n=[],s=e!=null&&e.trainableOnly,r=s?this.trainableWeights:this.weights,a=this.getWeights(s);for(let i=0;i<r.length;++i)s&&!r[i].trainable||n.push({name:r[i].originalName,tensor:a[i]});return n}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const n=mI().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=n-mI().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=yo(this.loss);else if(Array.isArray(this.loss)){for(const n of this.loss)if(typeof n!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(n=>yo(n))}else{const n=Object.keys(this.loss);e={};const s=this.loss;for(const r of n)if(typeof s[r]=="string")e[r]=yo(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[yo(Ey(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>yo(Ey(e)));{const e={};for(const n in this.metrics)e[n]=yo(Ey(this.metrics[n]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const n=Y$(e.optimizer_config),s=So(n);let r;if(typeof e.loss=="string")r=Hu(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(i=>Hu(i));else if(e.loss!=null){r={};for(const i in e.loss)r[i]=Hu(e.loss[i])}let a;if(Array.isArray(e.metrics))a=e.metrics.map(i=>Hu(i));else if(e.metrics!=null){a={};for(const i in e.metrics)a[i]=Hu(e.metrics[i])}this.compile({loss:r,metrics:a,optimizer:s})}async save(e,n){if(typeof e=="string"){const c=_O(e);if(c.length===0)throw new ue(`Cannot find any save handlers for URL '${e}'`);if(c.length>1)throw new ue(`Found more than one (${c.length}) save handlers for URL '${e}'`);e=c[0]}if(e.save==null)throw new ue("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await D$(this.getNamedWeights(n)),o={modelTopology:this.toJSON(null,!1),format:DJ,generatedBy:`TensorFlow.js tfjs-layers v${lL}`,convertedBy:null};if((n==null?!1:n.includeOptimizer)&&this.optimizer!=null){o.trainingConfig=this.getTrainingConfig();const c="optimizer",{data:h,specs:p}=await D$(await this.optimizer.getWeights(),c);s.specs.push(...p),s.data=vO([s.data,h])}return this.userDefinedMetadata!=null&&(ZI(this.userDefinedMetadata,this.name,!0),o.userDefinedMetadata=this.userDefinedMetadata),o.weightData=s.data,o.weightSpecs=s.specs,e.save(o)}setUserDefinedMetadata(e){ZI(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}zd.className="Model";De(zd);class pL extends zd{}pL.className="Functional";De(pL);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class wf extends zd{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:Rx("sequential_"),e.layers!=null)for(const n of e.layers)this.add(n)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new ue(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const n=e instanceof wf||e instanceof zd;let s;if(n){if(s=e,s.outputs.length!==1)throw new ue("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new ue("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new ue("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=zQ({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(n)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new ue(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new ue("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=KF(this.outputs[0])}this.inboundNodes=[],new Ox({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:dc(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,n){return this.model==null&&this.build(),this.model.call(e,n)}build(e){if(Wt(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new zd({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,n,s=console.log){this.built||this.build(),super.summary(e,n,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,n,s={}){if(!this.built)throw new ya("The model needs to be compiled before being used.");return this.model.evaluate(e,n,s)}async evaluateDataset(e,n){if(!this.built)throw new ya("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,n)}predict(e,n={}){return this.model==null&&this.build(),this.model.predict(e,n)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,n,s={}){if(!this.built)throw new ya("The model needs to be compiled before being used.");return this.model.fit(e,n,s)}async fitDataset(e,n){if(!this.built)throw new ya("The model needs to be compiled before being used.");return this.model.fitDataset(e,n)}async trainOnBatch(e,n){return this.model.trainOnBatch(e,n)}static fromConfig(e,n,s={},r=!1){let a,i={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new ue("Legacy serialization format not supported yet.");a=n}else V(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=n.layers,delete n.layers,i=n;const o=new e(i);if(!(o instanceof wf))throw new bt(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const l of a){const h=So(l,void 0,r);r&&h.setFastWeightInitDuringBuild(!0),o.add(h)}return o}set stopTraining(e){if(this.model==null)throw new ue("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new ue("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const n of this.layers){const s={};s.className=n.getClassName(),s.config=n.getConfig(),e.push(s)}return{name:this.name,layers:e}}}wf.className="Sequential";De(wf);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Ds=class extends ih{getConfig(){return{}}};class fL extends Ds{apply(e,n=1){return xQ(e,n)}}fL.className="elu";De(fL);class mL extends Ds{apply(e){return f_(e)}}mL.className="selu";De(mL);class gL extends Ds{apply(e){return zi(e)}}gL.className="relu";De(gL);class yL extends Ds{apply(e){return me(()=>uc(6,zi(e)))}}yL.className="relu6";De(yL);class bL extends Ds{apply(e){return e}}bL.className="linear";De(bL);class xL extends Ds{apply(e){return Ci(e)}}xL.className="sigmoid";De(xL);class wL extends Ds{apply(e){return vQ(e)}}wL.className="hardSigmoid";De(wL);class vL extends Ds{apply(e){return sh(e)}}vL.className="softplus";De(vL);class $L extends Ds{apply(e){return wQ(e)}}$L.className="softsign";De($L);class SL extends Ds{apply(e){return lc(e)}}SL.className="tanh";De(SL);let wC=class extends Ds{apply(e,n=-1){return vx(e,n)}};wC.className="softmax";De(wC);class _L extends Ds{apply(e,n=-1){return a_(e,n)}}_L.className="logSoftmax";De(_L);class CL extends Ds{apply(e){return me(()=>me(()=>{const n=Math.sqrt(2),s=ae(.5,Ae(1,n_(et(e,n))));return ae(e,s)}))}}CL.className="gelu";De(CL);class TL extends Ds{apply(e){return me(()=>ae(.5,ae(e,Ae(1,lc(ae(bs(et(2,Math.PI)),Ae(e,ae(.044715,Co(e,3)))))))))}}TL.className="gelu_new";De(TL);class kL extends Ds{apply(e){return me(()=>ae(e,lc(sh(e))))}}kL.className="mish";De(kL);class NL extends Ds{apply(e,n=1){return me(()=>ae(Ci(ae(e,n)),e))}}NL.className="swish";De(NL);function Ml(t){return t.getClassName()}function yv(t,e={}){return Lm(t,ma.getMap().classNameMap,e,"activation")}function Bl(t){if(t==null){const e={};return e.className="linear",e.config={},yv(e)}if(typeof t=="string"){const e={};return e.className=t,e.config={},yv(e)}else return t instanceof Ds?t:yv(t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function OJ(t){if(t!=null&&typeof t!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}class IL extends ih{}class EL extends IL{constructor(e){super(),OJ(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return me(()=>{let n=Hn([1]);return this.hasL1&&(n=Ae(n,Xe(ae(this.l1,Gn(e))))),this.hasL2&&(n=Ae(n,Xe(ae(this.l2,Bm(e))))),le(n,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,n){return new e({l1:n.l1,l2:n.l2})}}EL.className="L1L2";De(EL);const sE={l1l2:"L1L2"};function sn(t){return iC(t)}function rE(t,e={}){return Lm(t,ma.getMap().classNameMap,e,"regularizer")}function fn(t){if(t==null)return null;if(typeof t=="string"){const n={className:t in sE?sE[t]:t,config:{}};return rE(n)}else return t instanceof IL?t:rE(t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class AL extends _t{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,n){e=dt(e);let s=zi(e);return this.maxValue!=null&&(s=Cr(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},n=super.getConfig();return Object.assign(e,n),e}}AL.className="ReLU";De(AL);class RL extends _t{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,n){const s=dt(e);return cx(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},n=super.getConfig();return Object.assign(e,n),e}}RL.className="LeakyReLU";De(RL);class DL extends _t{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=pn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=fn(e.alphaRegularizer),this.alphaConstraint=Yn(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new ue(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Wt(e);const n=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)n[r-1]=1;this.alpha=this.addWeight("alpha",n,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)s[r]=e[r];this.inputSpec=[new jn({ndim:e.length,axes:s})],this.built=!0}call(e,n){return e=dt(e),yx(e,this.alpha.read())}getConfig(){const e={alphaInitializer:xn(this.alphaInitializer),alphaRegularizer:sn(this.alphaRegularizer),alphaConstraint:Xn(this.alphaConstraint),sharedAxes:this.sharedAxes},n=super.getConfig();return Object.assign(e,n),e}}DL.className="PReLU";De(DL);let OL=class extends _t{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new bt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,n){const s=dt(e);return Em(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},n=super.getConfig();return Object.assign(e,n),e}};OL.className="ELU";De(OL);class zL extends _t{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,n){const s=dt(e);return ae(s,Ge(Ar(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},n=super.getConfig();return Object.assign(e,n),e}}zL.className="ThresholdedReLU";De(zL);class FL extends _t{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new wC().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,n){return me(()=>{let s=dt(e);const r=n.mask;if(r!=null){const a=ae(qe(ir(s.shape),Ge(r,s.dtype)),st(-1e9));s=Ae(s,a)}return this.axis instanceof Array?this.axis.length>1?Tr(qe(s,hx(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},n=super.getConfig();return Object.assign(e,n),e}}FL.className="Softmax";De(FL);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Fd(t,e,n){if(typeof t=="number")return dc(t,e);if(t.length!==e)throw new ue(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);for(let s=0;s<e;++s){const r=t[s];if(!mQ(r))throw new ue(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number ${r}`)}return t}function qa(t,e,n,s,r=1){if(t==null)return t;const a=e+(e-1)*(r-1);let i;return n==="same"?i=t:i=t-a+1,Math.floor((i+s-1)/s)}function vi(t,e,n,s){if(t==null)return null;if(s==="valid")t=t*e+Ll([n-e,0]);else if(s==="same")t=t*e;else throw new ue(`Unsupport padding mode: ${s}.`);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function vC(t,e){return me(()=>(On(e),e==="channelsFirst"?Ft(t,[0,2,3,1]):t))}function LL(t,e){return me(()=>(On(e),e==="channelsFirst"?Ft(t,[0,2,3,4,1]):t))}function zJ(t,e,n,s=1,r="valid",a,i=1){return me(()=>{if(a==null&&(a=Ya()),On(a),t.shape.length!==3)throw new ue(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(e.shape.length!==3)throw new ue(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new ue(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(a==="channelsFirst"&&(t=Ft(t,[0,2,1])),r==="causal")throw new bt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=ZS(t,e,s,r==="same"?"same":"valid","NWC",i);return n!=null&&(o=Ja(o,n)),o})}function aE(t,e,n,s=[1,1],r="valid",a,i,o=null){return me(()=>{if(a==null&&(a=Ya()),On(a),t.rank!==3&&t.rank!==4)throw new ue(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(e.rank!==3&&e.rank!==4)throw new ue(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=vC(t,a);if(r==="causal")throw new bt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Ez({x:l,filter:e,strides:s,pad:r==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),a==="channelsFirst"&&(l=Ft(l,[0,3,1,2])),l})}function FJ(t,e,n,s=[1,1,1],r="valid",a,i){return me(()=>{if(a==null&&(a=Ya()),On(a),t.rank!==4&&t.rank!==5)throw new ue(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(e.rank!==4&&e.rank!==5)throw new ue(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let o=LL(t,a);if(r==="causal")throw new bt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=ZO(o,e,s,r==="same"?"same":"valid","NDHWC",i),n!=null&&(o=Ja(o,n)),a==="channelsFirst"&&(o=Ft(o,[0,4,1,2,3])),o})}class Lx extends _t{constructor(e,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Lx.verifyArgs(n),this.rank=e,rs(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new bt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Fd(n.kernelSize,e,"kernelSize"),this.strides=Fd(n.strides==null?1:n.strides,e,"strides"),this.padding=n.padding==null?"valid":n.padding,Zr(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,On(this.dataFormat),this.activation=Bl(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=pn(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Yn(n.biasConstraint),this.biasRegularizer=fn(n.biasRegularizer),this.activityRegularizer=fn(n.activityRegularizer),this.dilationRate=Fd(n.dilationRate==null?1:n.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new ue(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new ue(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new ue(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(wi("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!oC(e.kernelSize,"number",1,3))throw new ue(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Ml(this.activation),useBias:this.useBias,biasInitializer:xn(this.biasInitializer),biasRegularizer:sn(this.biasRegularizer),activityRegularizer:sn(this.activityRegularizer),biasConstraint:Xn(this.biasConstraint)},n=super.getConfig();return Object.assign(e,n),e}}class oh extends Lx{constructor(e,n){super(e,n),this.kernel=null,oh.verifyArgs(n),this.filters=n.filters,rs(this.filters,"filters"),this.kernelInitializer=pn(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Yn(n.kernelConstraint),this.kernelRegularizer=fn(n.kernelRegularizer)}build(e){e=Wt(e);const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new ue(`The channel dimension of the input should be defined. Found ${e[n]}`);const s=e[n],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:s}}],this.built=!0}call(e,n){return me(()=>{e=dt(e);let s;const r=this.bias==null?null:this.bias.read(),a=DF(this.activation.getClassName());if(a!=null&&this.rank===2)s=aE(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(this.rank===1)s=zJ(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=aE(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=FJ(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new bt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=Wt(e);const n=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<s.length;++a){const i=qa(s[a],this.kernelSize[a],this.padding,this.strides[a],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[a]);n.push(i)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(n),r.push(this.filters)):(r.push(this.filters),r=r.concat(n)),r}getConfig(){const e={filters:this.filters,kernelInitializer:xn(this.kernelInitializer),kernelRegularizer:sn(this.kernelRegularizer),kernelConstraint:Xn(this.kernelConstraint)},n=super.getConfig();return Object.assign(e,n),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new ue(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class Wm extends oh{constructor(e){super(2,e),Wm.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!oC(e.kernelSize,"number",1,2))throw new ue(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}Wm.className="Conv2D";De(Wm);class Gm extends oh{constructor(e){super(3,e),Gm.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new ue(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}Gm.className="Conv3D";De(Gm);class ML extends Wm{constructor(e){if(super(e),this.inputSpec=[new jn({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new ue(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Wt(e),e.length!==4)throw new ue("Input should have rank 4; Received input shape: "+JSON.stringify(e));const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new ue("The channel dimension of the inputs should be defined. Found `None`.");const s=e[n],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new jn({ndim:4,axes:{[n]:s}})],this.built=!0}call(e,n){return me(()=>{let s=dt(e);if(s.shape.length!==4)throw new ue(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,a=r[0];let i,o;this.dataFormat==="channelsFirst"?(i=2,o=3):(i=1,o=2);const l=r[i],c=r[o],h=this.kernelSize[0],p=this.kernelSize[1],f=this.strides[0],g=this.strides[1],y=vi(l,f,h,this.padding),x=vi(c,g,p,this.padding),w=[a,y,x,this.filters];this.dataFormat!=="channelsLast"&&(s=Ft(s,[0,2,3,1]));let v=JS(s,this.kernel.read(),w,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(v=Ft(v,[0,3,1,2])),this.bias!=null&&(v=Ja(v,this.bias.read(),this.dataFormat)),this.activation!=null&&(v=this.activation.apply(v)),v})}computeOutputShape(e){e=Wt(e);const n=e.slice();let s,r,a;this.dataFormat==="channelsFirst"?(s=1,r=2,a=3):(s=3,r=1,a=2);const i=this.kernelSize[0],o=this.kernelSize[1],l=this.strides[0],c=this.strides[1];return n[s]=this.filters,n[r]=vi(n[r],l,i,this.padding),n[a]=vi(n[a],c,o,this.padding),n}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}ML.className="Conv2DTranspose";De(ML);class BL extends Gm{constructor(e){if(super(e),this.inputSpec=[new jn({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new ue(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Wt(e),e.length!==5)throw new ue("Input should have rank 5; Received input shape: "+JSON.stringify(e));const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new ue("The channel dimension of the inputs should be defined. Found `None`.");const s=e[n],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new jn({ndim:5,axes:{[n]:s}})],this.built=!0}call(e,n){return me(()=>{let s=dt(e);if(s.shape.length!==5)throw new ue(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,a=r[0];let i,o,l;this.dataFormat==="channelsFirst"?(l=2,i=3,o=4):(l=1,i=2,o=3);const c=r[l],h=r[i],p=r[o],f=this.kernelSize[0],g=this.kernelSize[1],y=this.kernelSize[2],x=this.strides[0],w=this.strides[1],v=this.strides[2],$=vi(c,x,f,this.padding),T=vi(h,w,g,this.padding),C=vi(p,v,y,this.padding),I=[a,$,T,C,this.filters];this.dataFormat!=="channelsLast"&&(s=Ft(s,[0,2,3,4,1]));let A=JO(s,this.kernel.read(),I,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(A=Ft(A,[0,4,1,2,3])),this.bias!==null&&(A=Ja(A,this.bias.read(),this.dataFormat)),this.activation!==null&&(A=this.activation.apply(A)),A})}computeOutputShape(e){e=Wt(e);const n=e.slice();let s,r,a,i;this.dataFormat==="channelsFirst"?(s=1,r=2,a=3,i=4):(s=4,r=1,a=2,i=3);const o=this.kernelSize[0],l=this.kernelSize[1],c=this.kernelSize[2],h=this.strides[0],p=this.strides[1],f=this.strides[2];return n[s]=this.filters,n[r]=vi(n[r],h,o,this.padding),n[a]=vi(n[a],p,l,this.padding),n[i]=vi(n[i],f,c,this.padding),n}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}BL.className="Conv3DTranspose";De(BL);class PL extends oh{constructor(e,n){if(super(e,n),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,n.filters==null)throw new ue("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(n.kernelInitializer!=null||n.kernelRegularizer!=null||n.kernelConstraint!=null)throw new ue("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(n.padding!=null&&n.padding!=="same"&&n.padding!=="valid")throw new ue(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(n.padding)}`);this.depthMultiplier=n.depthMultiplier==null?1:n.depthMultiplier,this.depthwiseInitializer=pn(n.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=fn(n.depthwiseRegularizer),this.depthwiseConstraint=Yn(n.depthwiseConstraint),this.pointwiseInitializer=pn(n.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=fn(n.pointwiseRegularizer),this.pointwiseConstraint=Yn(n.pointwiseConstraint)}build(e){if(e=Wt(e),e.length<this.rank+2)throw new ue(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null||e[n]<0)throw new ue(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[n])}`);const s=e[n],r=this.kernelSize.concat([s,this.depthMultiplier]),a=[];for(let o=0;o<this.rank;++o)a.push(1);a.push(s*this.depthMultiplier,this.filters);const i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new jn({ndim:this.rank+2,axes:{[n]:s}})],this.built=!0}call(e,n){return me(()=>{e=dt(e);let s;if(this.rank===1)throw new bt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Ft(e,[0,2,3,1])),s=m_(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Ja(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=Ft(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=xn(this.depthwiseInitializer),e.pointwiseInitializer=xn(this.pointwiseInitializer),e.depthwiseRegularizer=sn(this.depthwiseRegularizer),e.pointwiseRegularizer=sn(this.pointwiseRegularizer),e.depthwiseConstraint=Xn(this.depthwiseConstraint),e.pointwiseConstraint=Xn(this.pointwiseConstraint),e}}PL.className="SeparableConv";class VL extends PL{constructor(e){super(2,e)}}VL.className="SeparableConv2D";De(VL);class Mx extends oh{constructor(e){super(1,e),Mx.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!oC(e.kernelSize,"number",1,1))throw new ue(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}Mx.className="Conv1D";De(Mx);class UL extends _t{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,n){return me(()=>{if(e=dt(e),this.dataFormat==="channelsLast"){const s=Iy(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Iy(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=Iy(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Iy(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}UL.className="Cropping2D";De(UL);class WL extends _t{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,On(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,hQ(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const n=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],n,s]}else{const n=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],n,s,e[3]]}}call(e,n){return me(()=>{let s=dt(e);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=Ft(s,[0,2,3,1]);const a=this.size[0]*r[2],i=this.size[1]*r[3],o=this.interpolation==="nearest"?$i.resizeNearestNeighbor(s,[a,i]):$i.resizeBilinear(s,[a,i]);return Ft(o,[0,3,1,2])}else{const a=this.size[0]*r[1],i=this.size[1]*r[2];return this.interpolation==="nearest"?$i.resizeNearestNeighbor(s,[a,i]):$i.resizeBilinear(s,[a,i])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},n=super.getConfig();return Object.assign(e,n),e}}WL.className="UpSampling2D";De(WL);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function LJ(t,e,n=[1,1],s="valid",r,a){return me(()=>{r==null&&(r=Ya()),On(r);let i=vC(t,r);if(t.rank!==4)throw new ue(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(e.rank!==4)throw new ue(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return i=Im(i,e,n,s==="same"?"same":"valid","NHWC",a),r==="channelsFirst"&&(i=Ft(i,[0,3,1,2])),i})}class GL extends Lx{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=pn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Yn(e.depthwiseConstraint),this.depthwiseRegularizer=fn(e.depthwiseRegularizer)}build(e){if(e=Wt(e),e.length<4)throw new ue(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const n=this.dataFormat==="channelsFirst"?1:3;if(e[n]==null||e[n]<0)throw new ue(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[n]}).`);const s=e[n],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return me(()=>{e=dt(e);let s=LJ(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Ja(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=Wt(e);const n=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=qa(n,this.kernelSize[0],this.padding,this.strides[0]),i=qa(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,a,i]:[e[0],a,i,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=xn(this.depthwiseInitializer),e.depthwiseRegularizer=sn(this.depthwiseRegularizer),e.depthwiseConstraint=Xn(this.depthwiseRegularizer),e}}GL.className="DepthwiseConv2D";De(GL);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function HL(t,e,n,s){if(Array.isArray(t)){if(e!=null||n!=null)throw new ue("When inputs is an array, neither initialState or constants should be provided");s!=null&&(n=t.slice(t.length-s,t.length),t=t.slice(0,t.length-s)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function r(a){return a==null||Array.isArray(a)?a:[a]}return e=r(e),n=r(n),{inputs:t,initialState:e,constants:n}}function qL(t,e,n,s=!1,r,a,i=!1,o=!1){return me(()=>{const l=e.shape.length;if(l<3)throw new ue(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(Xa(2,l));e=Ft(e,c),i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=Ge(Ge(r,"bool"),"float32"),r.rank===l-1&&(r=Ws(r,-1)),r=Ft(r,c)),s&&(e=$a(e,0),r!=null&&(r=$a(r,0)));const h=[];let p,f=n;const g=e.shape[0],y=Sa(e);let x;r!=null&&(x=Sa(r));for(let v=0;v<g;++v){const $=y[v],T=me(()=>t($,f));if(r==null)p=T[0],f=T[1];else{const C=me(()=>{const I=x[v],A=qe(Xr(I),I),O=Ae(ae(T[0],I),ae(f[0],A)),B=f.map((z,P)=>Ae(ae(T[1][P],I),ae(z,A)));return{output:O,newStates:B}});p=C.output,f=C.newStates}o&&h.push(p)}let w;return o&&(w=kr(h,1)),[p,w,f]})}class Ql extends _t{constructor(e){super(e);let n;if(e.cell==null)throw new ue("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?n=new _C({cells:e.cell}):n=e.cell,n.stateSize==null)throw new ue("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new jn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Xa(0,e).map(n=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){j$(e)&&(e=e[0]),e=e;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);const s=n[0];let r;if(this.returnSequences?r=[e[0],e[1],s]:r=[e[0],s],this.returnState){const a=[];for(const i of n)a.push([e[0],i]);return[r].concat(a)}else return r}computeMask(e,n){return me(()=>{Array.isArray(n)&&(n=n[0]);const s=this.returnSequences?n:null;if(this.returnState){const r=this.states.map(a=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let s=0;s<e;++s)n.push(null);return n}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new bt("Constants support is not implemented in RNN yet.");j$(e)&&(e=e[0]),e=e;const n=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new jn({shape:[n,null,...s]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!Rt(this.stateSpec.map(i=>i.shape[i.shape.length-1]),a))throw new ue(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(i=>new jn({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(e,n=!1){me(()=>{if(!this.stateful)throw new xi("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new ue("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Hn([s,r])):this.states_=[Hn([s,this.cell.stateSize])];else if(e==null)$t(this.states_),this.keptStates!=null&&($t(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Hn([s,r])):this.states_[0]=Hn([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ue(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);n===!0?this.keptStates.push(this.states_.slice()):$t(this.states_);for(let r=0;r<this.states_.length;++r){const a=e[r],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,o=[s,i];if(!Rt(a.shape,o))throw new ue(`State ${r} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${a.shape}`);this.states_[r]=a}}this.states_=this.states_.map(r=>ss(r.clone()))})}apply(e,n){let s=n==null?null:n.initialState,r=n==null?null:n.constants;n==null&&(n={});const a=HL(e,s,r,this.numConstants);e=a.inputs,s=a.initialState,r=a.constants;let i=[],o=[];if(s!=null){n.initialState=s,i=i.concat(s),this.stateSpec=[];for(const c of s)this.stateSpec.push(new jn({shape:c.shape}));o=o.concat(this.stateSpec)}if(r!=null&&(n.constants=r,i=i.concat(r),this.numConstants=r.length),i[0]instanceof Ai){const c=[e].concat(i),h=this.inputSpec.concat(o),p=this.inputSpec;this.inputSpec=h;const f=super.apply(c,n);return this.inputSpec=p,f}else return super.apply(e,n)}call(e,n){return me(()=>{const s=n==null?null:n.mask,r=n==null?null:n.training;let a=n==null?null:n.initialState;e=dt(e),a==null&&(this.stateful?a=this.states_:a=this.getInitialState(e));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==i)throw new ue(`RNN Layer has ${i} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:r},c=qL((y,x)=>{const w=this.cell.call([y].concat(x),o);return[w[0],w.slice(1)]},e,a,this.goBackwards,s,null,this.unroll,this.returnSequences),h=c[0],p=c[1],f=c[2];this.stateful&&this.resetStates(f,r);const g=this.returnSequences?p:h;return this.returnState?[g].concat(f):g})}getInitialState(e){return me(()=>{let n=Hn(e.shape);return n=Xe(n,[1,2]),n=Mm(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?H$(n,[1,s]):n):this.cell.stateSize>1?[H$(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===Ql.className&&(n.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),n)}static fromConfig(e,n,s={}){const r=n.cell,a=So(r,s);return new e(Object.assign(n,{cell:a}))}}Ql.className="RNN";De(Ql);class Bx extends _t{}class $C extends Bx{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,rs(this.units,"units"),this.activation=Bl(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=pn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=pn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=pn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=fn(e.kernelRegularizer),this.recurrentRegularizer=fn(e.recurrentRegularizer),this.biasRegularizer=fn(e.biasRegularizer),this.kernelConstraint=Yn(e.kernelConstraint),this.recurrentConstraint=Yn(e.recurrentConstraint),this.biasConstraint=Yn(e.biasConstraint),this.dropout=Wd([1,Ll([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Wd([1,Ll([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Wt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return me(()=>{if(e=e,e.length!==2)throw new ue(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const r=n.training==null?!1:n.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Pl({ones:()=>Xr(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Pl({ones:()=>Xr(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let a;const i=this.dropoutMask,o=this.recurrentDropoutMask;i!=null?a=Ni(ae(e,i),this.kernel.read()):a=Ni(e,this.kernel.read()),this.bias!=null&&(a=Ja(a,this.bias.read())),o!=null&&(s=ae(s,o));let l=Ae(a,Ni(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:Ml(this.activation),useBias:this.useBias,kernelInitializer:xn(this.kernelInitializer),recurrentInitializer:xn(this.recurrentInitializer),biasInitializer:xn(this.biasInitializer),kernelRegularizer:sn(this.kernelRegularizer),recurrentRegularizer:sn(this.recurrentRegularizer),biasRegularizer:sn(this.biasRegularizer),activityRegularizer:sn(this.activityRegularizer),kernelConstraint:Xn(this.kernelConstraint),recurrentConstraint:Xn(this.recurrentConstraint),biasConstraint:Xn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),n)}}$C.className="SimpleRNNCell";De($C);class jL extends Ql{constructor(e){e.cell=new $C(e),super(e)}call(e,n){return me(()=>{this.cell.dropoutMask!=null&&($t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&($t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=n==null?null:n.mask,r=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(e,{mask:s,training:r,initialState:a})})}static fromConfig(e,n){return new e(n)}}jL.className="SimpleRNN";De(jL);class SC extends Bx{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new ue("GRUCell does not support reset_after parameter set to true.");this.units=e.units,rs(this.units,"units"),this.activation=Bl(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Bl(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=pn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=pn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=pn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=fn(e.kernelRegularizer),this.recurrentRegularizer=fn(e.recurrentRegularizer),this.biasRegularizer=fn(e.biasRegularizer),this.kernelConstraint=Yn(e.kernelConstraint),this.recurrentConstraint=Yn(e.recurrentConstraint),this.biasConstraint=Yn(e.biasConstraint),this.dropout=Wd([1,Ll([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Wd([1,Ll([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Wt(e);const n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return me(()=>{if(e=e,e.length!==2)throw new ue(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=n.training==null?!1:n.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Pl({ones:()=>Xr(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Pl({ones:()=>Xr(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let o,l,c;0<this.dropout&&this.dropout<1&&(e=ae(e,a[0]));let h=Ni(e,this.kernel.read());this.useBias&&(h=Ja(h,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=ae(r,i[0]));const p=this.recurrentKernel.read(),[f,g]=Sr(p,[2*this.units,this.units],p.rank-1),y=Ni(r,f),[x,w,v]=Sr(h,3,h.rank-1),[$,T]=Sr(y,2,y.rank-1);o=this.recurrentActivation.apply(Ae(x,$)),l=this.recurrentActivation.apply(Ae(w,T));const C=Ni(ae(l,r),g);c=this.activation.apply(Ae(v,C));const I=Ae(ae(o,r),ae(Ae(1,dn(o)),c));return[I,I]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:Ml(this.activation),recurrentActivation:Ml(this.recurrentActivation),useBias:this.useBias,kernelInitializer:xn(this.kernelInitializer),recurrentInitializer:xn(this.recurrentInitializer),biasInitializer:xn(this.biasInitializer),kernelRegularizer:sn(this.kernelRegularizer),recurrentRegularizer:sn(this.recurrentRegularizer),biasRegularizer:sn(this.biasRegularizer),activityRegularizer:sn(this.activityRegularizer),kernelConstraint:Xn(this.kernelConstraint),recurrentConstraint:Xn(this.recurrentConstraint),biasConstraint:Xn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),n)}}SC.className="GRUCell";De(SC);class KL extends Ql{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new SC(e),super(e)}call(e,n){return me(()=>{this.cell.dropoutMask!=null&&($t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&($t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=n==null?null:n.mask,r=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(e,{mask:s,training:r,initialState:a})})}static fromConfig(e,n){return n.implmentation===0&&(n.implementation=1),new e(n)}}KL.className="GRU";De(KL);class Px extends Bx{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,rs(this.units,"units"),this.activation=Bl(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Bl(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=pn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=pn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=pn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=fn(e.kernelRegularizer),this.recurrentRegularizer=fn(e.recurrentRegularizer),this.biasRegularizer=fn(e.biasRegularizer),this.kernelConstraint=Yn(e.kernelConstraint),this.recurrentConstraint=Yn(e.recurrentConstraint),this.biasConstraint=Yn(e.biasConstraint),this.dropout=Wd([1,Ll([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Wd([1,Ll([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var n;e=Wt(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const a=this.biasInitializer,i=this.units;r=new(n=class extends Ca{apply(l,c){const h=a.apply([i]),p=new uC().apply([i]),f=a.apply([i*2]);return UI(UI(h,p),f)}},n.className="CustomInit",n)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,n){return me(()=>{const s=n.training==null?!1:n.training;if(e=e,e.length!==3)throw new ue(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Pl({ones:()=>Xr(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Pl({ones:()=>Xr(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let l,c,h,p;0<this.dropout&&this.dropout<1&&(e=ae(e,i[0]));let f=Ni(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=ae(r,o[0])),f=Ae(f,Ni(r,this.recurrentKernel.read())),this.useBias&&(f=Ja(f,this.bias.read()));const[g,y,x,w]=Sr(f,4,f.rank-1);l=this.recurrentActivation.apply(g),c=this.recurrentActivation.apply(y),h=Ae(ae(c,a),ae(l,this.activation.apply(x))),p=this.recurrentActivation.apply(w);const v=ae(p,this.activation.apply(h));return[v,v,h]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:Ml(this.activation),recurrentActivation:Ml(this.recurrentActivation),useBias:this.useBias,kernelInitializer:xn(this.kernelInitializer),recurrentInitializer:xn(this.recurrentInitializer),biasInitializer:xn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:sn(this.kernelRegularizer),recurrentRegularizer:sn(this.recurrentRegularizer),biasRegularizer:sn(this.biasRegularizer),activityRegularizer:sn(this.activityRegularizer),kernelConstraint:Xn(this.kernelConstraint),recurrentConstraint:Xn(this.recurrentConstraint),biasConstraint:Xn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),n)}}Px.className="LSTMCell";De(Px);class XL extends Ql{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Px(e),super(e)}call(e,n){return me(()=>{this.cell.dropoutMask!=null&&($t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&($t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=n==null?null:n.mask,r=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(e,{mask:s,training:r,initialState:a})})}static fromConfig(e,n){return n.implmentation===0&&(n.implementation=1),new e(n)}}XL.className="LSTM";De(XL);class _C extends Bx{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const n of this.cells.slice().reverse())Array.isArray(n.stateSize)?e.push(...n.stateSize):e.push(n.stateSize);return e}call(e,n){return me(()=>{e=e;let s=e.slice(1);const r=[];for(const o of this.cells.slice().reverse())Array.isArray(o.stateSize)?r.push(s.splice(0,o.stateSize.length)):r.push(s.splice(0,1));r.reverse();const a=[];let i;for(let o=0;o<this.cells.length;++o){const l=this.cells[o];s=r[o],o===0?i=[e[0]].concat(s):i=[i[0]].concat(s),i=l.call(i,n),a.push(i.slice(1))}s=[];for(const o of a.slice().reverse())s.push(...o);return[i[0]].concat(s)})}build(e){j$(e)&&(e=e[0]),e=e;let n;this.cells.forEach((s,r)=>{Ju(`RNNCell_${r}`,()=>{s.build(e),Array.isArray(s.stateSize)?n=s.stateSize[0]:n=s.stateSize,e=[e[0],n]})}),this.built=!0}getConfig(){const e=super.getConfig(),n=a=>({className:a.getClassName(),config:a.getConfig()}),r={cells:this.cells.map(n)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,n,s={}){const r=[];for(const a of n.cells)r.push(So(a,s));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const n of this.cells)e.push(...n.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const n of this.cells)e.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const s of this.cells)n.push(...s.trainableWeights);return n.concat(e)}return e}getWeights(){const e=[];for(const n of this.cells)e.push(...n.weights);return K$(e)}setWeights(e){const n=[];for(const s of this.cells){const r=s.weights.length,a=e.splice(r);for(let i=0;i<s.weights.length;++i)n.push([s.weights[i],a[i]])}gC(n)}}_C.className="StackedRNNCells";De(_C);function Pl(t){const{ones:e,rate:n,training:s=!1,count:r=1,dropoutFunc:a}=t,i=()=>a!=null?a(e(),n):PF(e(),n),o=()=>Pm(i,e,s);return!r||r<=1?ss(o().clone()):Array(r).fill(void 0).map(o).map(c=>ss(c.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var MJ=function(t,e){var n={};for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&e.indexOf(s)<0&&(n[s]=t[s]);if(t!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(t);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(t,s[r])&&(n[s[r]]=t[s[r]]);return n};class YL extends Ql{constructor(e){if(e.unroll)throw new bt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new bt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new jn({ndim:5})]}call(e,n){return me(()=>{if(this.cell.dropoutMask!=null&&($t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&($t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),n&&n.constants)throw new ue("ConvRNN2D cell does not support constants");const s=n==null?null:n.mask,r=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(e,{mask:s,training:r,initialState:a})})}computeOutputShape(e){let n=this.computeSingleOutputShape(e);return this.returnSequences||(n=[n[0],...n.slice(2)]),this.returnState&&(n=[n,...Array(2).fill([e[0],...n.slice(-3)])]),n}getInitialState(e){return me(()=>{const{stateSize:n}=this.cell,s=e.shape,r=this.computeSingleOutputShape(s),a=[r[0],...r.slice(2)],i=Hn(a);return Array.isArray(n)?Array(n.length).fill(i):[i]})}resetStates(e,n=!1){me(()=>{if(!this.stateful)throw new xi("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),a=[r[0],...r.slice(2)];if(s[0]==null)throw new ue("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Hn(a)):this.states_=[Hn(a)];else if(e==null)$t(this.states_),this.keptStates!=null&&($t(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Hn(a)):this.states_[0]=Hn(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ue(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);n?this.keptStates.push(this.states_.slice()):$t(this.states_);for(let o=0;o<this.states_.length;++o){const l=e[o],c=a;if(!Rt(l.shape,c))throw new ue(`State ${o} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${l.shape}`);this.states_[o]=l}}this.states_=this.states_.map(o=>ss(o.clone()))})}computeSingleOutputShape(e){const{dataFormat:n,filters:s,kernelSize:r,padding:a,strides:i,dilationRate:o}=this.cell,l=n==="channelsFirst",c=e[l?3:2],h=e[l?4:3],p=qa(c,r[0],a,i[0],o[0]),f=qa(h,r[1],a,i[1],o[1]);return[...e.slice(0,2),...l?[s,p,f]:[p,f,s]]}}YL.className="ConvRNN2D";class CC extends Px{constructor(e){const{filters:n,kernelSize:s,strides:r,padding:a,dataFormat:i,dilationRate:o}=e;super(Object.assign(Object.assign({},e),{units:n})),this.filters=n,rs(this.filters,"filters"),this.kernelSize=Fd(s,2,"kernelSize"),this.kernelSize.forEach(l=>rs(l,"kernelSize")),this.strides=Fd(r||1,2,"strides"),this.strides.forEach(l=>rs(l,"strides")),this.padding=a||"valid",Zr(this.padding),this.dataFormat=i||"channelsLast",On(this.dataFormat),this.dilationRate=Fd(o||1,2,"dilationRate"),this.dilationRate.forEach(l=>rs(l,"dilationRate"))}build(e){var n;e=Wt(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new ue(`The channel dimension of the input should be defined. Found ${e[s]}`);const r=e[s],a=4,i=this.kernelSize.concat([r,this.filters*a]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,this.filters*a]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const c=this.biasInitializer,h=this.filters;l=new(n=class extends Ca{apply(f,g){const y=c.apply([h]),x=ir([h]),w=c.apply([h*2]);return lC([y,x,w])}},n.className="CustomInit",n)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*a],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,n){return me(()=>{if(e.length!==3)throw new ue(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=n.training||!1,r=e[0],a=e[1],i=e[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Pl({ones:()=>Xr(r),rate:this.dropout,training:s,count:o,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,c=(U,G,Y)=>!G||!G[Y]?U:ae(G[Y],U);let h=c(r,l,0),p=c(r,l,1),f=c(r,l,2),g=c(r,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Pl({ones:()=>Xr(a),rate:this.recurrentDropout,training:s,count:o,dropoutFunc:this.dropoutFunc}));const y=this.recurrentDropoutMask;let x=c(a,y,0),w=c(a,y,1),v=c(a,y,2),$=c(a,y,3);const T=3,[C,I,A,O]=Sr(this.kernel.read(),o,T),[B,z,P,F]=this.useBias?Sr(this.bias.read(),o):[null,null,null,null];h=this.inputConv(h,C,B,this.padding),p=this.inputConv(p,I,z,this.padding),f=this.inputConv(f,A,P,this.padding),g=this.inputConv(g,O,F,this.padding);const[K,X,te,Q]=Sr(this.recurrentKernel.read(),o,T);x=this.recurrentConv(x,K),w=this.recurrentConv(w,X),v=this.recurrentConv(v,te),$=this.recurrentConv($,Q);const q=this.recurrentActivation.apply(Ae(h,x)),oe=this.recurrentActivation.apply(Ae(p,w)),se=Ae(ae(oe,i),ae(q,this.activation.apply(Ae(f,v)))),ee=ae(this.recurrentActivation.apply(Ae(g,$)),this.activation.apply(se));return[ee,ee,se]})}getConfig(){const e=super.getConfig(),{units:n}=e,s=MJ(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),r)}inputConv(e,n,s,r){const a=Fl(e,n,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?Ja(a,s,this.dataFormat):a}recurrentConv(e,n){return Fl(e,n,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}CC.className="ConvLSTM2DCell";De(CC);class ZL extends YL{constructor(e){const n=new CC(e);super(Object.assign(Object.assign({},e),{cell:n}))}static fromConfig(e,n){return new e(n)}}ZL.className="ConvLSTM2D";De(ZL);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class TC extends _t{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const n=e.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?n[r]:this.noiseShape[r]);return s}call(e,n){return me(()=>{this.invokeCallHook(e,n);const s=dt(e);if(0<this.rate&&this.rate<1){const r=n.training==null?!1:n.training,a=this.getNoiseShape(s);return Pm(()=>PF(s,this.rate,a,this.seed),()=>s,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=super.getConfig();return Object.assign(e,n),e}dispose(){return super.dispose()}}TC.className="Dropout";De(TC);class QL extends TC{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const n=e.shape;return[n[0],1,n[2]]}}QL.className="SpatialDropout1D";De(QL);class JL extends _t{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let n=null;e.batchSize!=null&&(n=e.batchSize),this.batchInputShape=[n,e.inputDim]}this.units=e.units,rs(this.units,"units"),this.activation=Bl(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=pn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=pn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Yn(e.kernelConstraint),this.biasConstraint=Yn(e.biasConstraint),this.kernelRegularizer=fn(e.kernelRegularizer),this.biasRegularizer=fn(e.biasRegularizer),this.activityRegularizer=fn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Wt(e);const n=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:n}}],this.built=!0}computeOutputShape(e){e=Wt(e);const n=e.slice();return n[n.length-1]=this.units,n}call(e,n){return me(()=>{this.invokeCallHook(e,n);const s=dt(e),r=DF(this.activation.getClassName());let a;return r!=null?a=Ni(s,this.kernel.read(),r,this.bias?this.bias.read():null):(a=Ni(s,this.kernel.read()),this.bias!=null&&(a=Ja(a,this.bias.read())),this.activation!=null&&(a=this.activation.apply(a))),a})}getConfig(){const e={units:this.units,activation:Ml(this.activation),useBias:this.useBias,kernelInitializer:xn(this.kernelInitializer),biasInitializer:xn(this.biasInitializer),kernelRegularizer:sn(this.kernelRegularizer),biasRegularizer:sn(this.biasRegularizer),activityRegularizer:sn(this.activityRegularizer),kernelConstraint:Xn(this.kernelConstraint),biasConstraint:Xn(this.biasConstraint)},n=super.getConfig();return Object.assign(e,n),e}}JL.className="Dense";De(JL);class eM extends _t{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Wt(e);for(const n of e.slice(1))if(n==null)throw new ue(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Al(e,1)]}call(e,n){return me(()=>{this.invokeCallHook(e,n);let s=dt(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let a=2;a<s.rank;++a)r.push(a);r.push(1),s=Ft(s,r)}return bQ(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const n=super.getConfig();return Object.assign(e,n),e}}eM.className="Flatten";De(eM);class tM extends _t{constructor(e){super(e),this.supportsMasking=!0,this.activation=Bl(e.activation)}call(e,n){return me(()=>{this.invokeCallHook(e,n);const s=dt(e);return this.activation.apply(s)})}getConfig(){const e={activation:Ml(this.activation)},n=super.getConfig();return Object.assign(e,n),e}}tM.className="Activation";De(tM);class nM extends _t{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,n){return me(()=>(e=dt(e),gQ(e,this.n)))}getConfig(){const e={n:this.n},n=super.getConfig();return Object.assign(e,n),e}}nM.className="RepeatVector";De(nM);class sM extends _t{constructor(e){super(e),this.targetShape=e.targetShape;for(let n=0;n<this.targetShape.length;++n)this.isUnknown(this.targetShape[n])&&(this.targetShape[n]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,n){const s="Total size of new array must be unchanged.",r=n.slice();let a=1,i=null;for(let l=0;l<r.length;++l){const c=r[l];if(this.isUnknown(c))if(i===null)i=l;else throw new ue("Can only specifiy one unknown dimension.");else a*=c}const o=Al(e);if(i!==null){if(a===0||o%a!==0)throw new ue(s);r[i]=o/a}else if(o!==a)throw new ue(s);return r}computeOutputShape(e){let n=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){n=!0;break}return n?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,n){return me(()=>{this.invokeCallHook(e,n);const s=dt(e),r=s.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return le(s,a)})}getConfig(){const e={targetShape:this.targetShape},n=super.getConfig();return Object.assign(e,n),e}}sM.className="Reshape";De(sM);class rM extends _t{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const n=Xa(1,e.dims.length+1);if(!Rt(e.dims.slice().sort(),n))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new jn({ndim:this.dims.length+1})]}computeOutputShape(e){e=Wt(e);const n=e.slice();return this.dims.forEach((s,r)=>{n[r+1]=e[s]}),n}call(e,n){return Ft(dt(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},n=super.getConfig();return Object.assign(e,n),e}}rM.className="Permute";De(rM);class aM extends _t{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={maskValue:this.maskValue};return Object.assign(n,e),n}computeMask(e,n){const s=dt(e);return S0(Vd(s,this.maskValue),-1)}call(e,n){return me(()=>{this.invokeCallHook(e,n);const s=dt(e),i=S0(Vd(s,this.maskValue),-1,!0);return ae(s,Ge(i,s.dtype))})}}aM.className="Masking";De(aM);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class iM extends _t{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let n=null;e.batchSize!=null&&(n=e.batchSize),e.inputLength==null?this.batchInputShape=[n,null]:this.batchInputShape=[n].concat(Qt(e.inputLength))}this.inputDim=e.inputDim,rs(this.inputDim,"inputDim"),this.outputDim=e.outputDim,rs(this.outputDim,"outputDim"),this.embeddingsInitializer=pn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=fn(e.embeddingsRegularizer),this.activityRegularizer=fn(e.activityRegularizer),this.embeddingsConstraint=Yn(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,n){return me(()=>this.maskZero?(e=dt(e),Vd(e,Lt(e))):null)}computeOutputShape(e){if(e=Wt(e),this.inputLength==null)return[...e,this.outputDim];const n=Qt(this.inputLength);if(n.length!==e.length-1)throw new ue(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let r=0;r<n.length;++r){const a=n[r],i=e[r+1];if(a!=null&&i!=null&&a!==i)throw new ue(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);a==null&&(n[s]=i),s++}}return[e[0],...n,this.outputDim]}call(e,n){return me(()=>{this.invokeCallHook(e,n);let s=dt(e);s.dtype!=="int32"&&(s=ki(s,"int32"));const r=BF(this.embeddings.read(),le(s,[s.size]));return le(r,Wt(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:xn(this.embeddingsInitializer),embeddingsRegularizer:sn(this.embeddingsRegularizer),activityRegularizer:sn(this.activityRegularizer),embeddingsConstraint:Xn(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=super.getConfig();return Object.assign(e,n),e}}iM.className="Embedding";De(iM);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Tc extends _t{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new bt}computeElementwiseOpOutputShape(e,n){if(e==null||n==null)return null;if(e.length<n.length)return this.computeElementwiseOpOutputShape(n,e);if(n.length===0)return e;const s=e.slice(0,e.length-n.length);for(let r=0;r<n.length;++r){const a=e[e.length-n.length+r],i=n[r];if(a==null||i==null||a<0||i<0)s.push(null);else if(a===1)s.push(i);else if(i===1)s.push(a);else{if(a!==i)throw new ue("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(n));s.push(a)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Wt(e)]),e=e,e.length<2)throw new ue(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let n=[];for(const a of e)a!=null&&a[0]!==null&&n.push(a[0]);if(n=El(n),n.length>1)throw new ue(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let a=1;a<e.length;++a){const i=e[a]==null?null:e[a].slice(1);s=this.computeElementwiseOpOutputShape(s,i)}const r=e.map(a=>a.length);e.indexOf(null)===-1&&El(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,n){return me(()=>{if(e=e,this.reshapeRequired){const s=[],r=e.map(a=>a.rank);if(r.indexOf(null)===-1){const a=Ll(r);for(let i of e){const o=i.rank;for(let l=0;l<a-o;++l)i=Mm(i,1);s.push(i)}return this.mergeFunction(s)}else{let a=!1;for(const l of e){const c=l.rank;if(c==null){const h=l.shape,p=h[0],f=h.slice(1).concat([p]);let g=le(l,[p].concat(Al(h.slice(1))));g=Ft(g,[1,0]),g=le(g,f),s.push(g),a=!0}else if(c>1){const h=Xa(1,c).concat([0]);s.push(Ft(l,h)),a=!0}else s.push(l)}let i=this.mergeFunction(s);const o=i.rank;if(a){if(o==null){const l=i.shape,c=l.length,h=l[c-1],p=[h].concat(l.slice(0,l.length-1));i=le(Ft(le(i,[-1,h]),[1,0]),p)}else if(o>1){const l=[o-1].concat(Xa(0,o-1));i=Ft(i,l)}}return i}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let n;e[0]==null?n=null:n=e[0].slice(1);for(let r=1;r<e.length;++r){const a=e[r]==null?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}let s=[];for(const r of e)r!=null&&r[0]!==null&&s.push(r[0]);return s=El(s),s.length===1?n=s.concat(n):n=[null].concat(n),n}computeMask(e,n){return me(()=>{if(n==null)return null;if(!Array.isArray(n))throw new ue("`mask` should be an Array");if(!Array.isArray(e))throw new ue("`inputs` should be an Array");if(n.length!==e.length)throw new ue(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${n.length})`);if(n.every(r=>r==null))return null;n=n.map(r=>r==null?r:Ws(r,0));let s=n[0];for(let r=1;r<n.length-1;++r)s=Ei(s,n[r]);return s})}}class oM extends Tc{constructor(e){super(e)}mergeFunction(e){return me(()=>{let n=e[0].clone();for(let s=1;s<e.length;++s)n=Ae(n,e[s]);return n})}}oM.className="Add";De(oM);class lM extends Tc{constructor(e){super(e)}mergeFunction(e){return me(()=>{let n=e[0].clone();for(let s=1;s<e.length;++s)n=ae(n,e[s]);return n})}}lM.className="Multiply";De(lM);class uM extends Tc{constructor(e){super(e)}mergeFunction(e){return me(()=>{let n=e[0].clone();for(let s=1;s<e.length;++s)n=Ae(n,e[s]);return ae(1/e.length,n)})}}uM.className="Average";De(uM);class cM extends Tc{constructor(e){super(e)}mergeFunction(e){return me(()=>{let n=e[0];for(let s=1;s<e.length;++s)n=Ro(n,e[s]);return n})}}cM.className="Maximum";De(cM);class dM extends Tc{constructor(e){super(e)}mergeFunction(e){return me(()=>{let n=e[0];for(let s=1;s<e.length;++s)n=uc(n,e[s]);return n})}}dM.className="Minimum";De(dM);class hM extends Tc{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new ue("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let n=!0;for(const r of e)if(r!=null){n=!1;break}if(n)return;const s=[];for(let r=0;r<e.length;++r){const a=e[r].slice();a.splice(this.axis,1);let i=!1;for(const o of s)if(Rt(o,a)){i=!0;break}i||s.push(a)}if(s.length>1)throw new ue("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return me(()=>lC(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new ue("A `Concatenate` layer should be called on a list of inputs.");const n=e,s=n[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const a of n.slice(1)){if(s[r]==null||a[r]==null){s[r]=null;break}s[r]+=a[r]}return s}computeMask(e,n){if(n==null)return null;if(!Array.isArray(n))throw new ue("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new ue("`inputs` should be an array for Concatenate");if(n.length!==e.length)throw new ue(`Mismatch in the length of mask (${n.length}) and the legnth of inputs (${e.length})`);return me(()=>{let s=!0;if(n.forEach(i=>{if(i!=null){s=!1;return}}),s)return null;const r=[];for(let i=0;i<e.length;++i)n[i]==null?r.push(Ge(Xr(e[i]),"bool")):n[i].rank<e[i].rank?r.push(Ws(n[i],-1)):r.push(n[i]);const a=Bn(r,this.axis);return XS(a,-1,!1)})}getConfig(){const e={axis:this.axis},n=super.getConfig();return Object.assign(e,n),e}}hM.className="Concatenate";De(hM);function Bp(t,e){for(;t<0;)t+=e;return t}function BJ(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new bt("batchDot is not implemented for tensors of 4D or higher rank yet");if(V(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),V(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof n=="number"&&(n=[n,n]),t.dtype==="complex64"||e.dtype==="complex64")throw new bt("batchDot is not implemented for complex64-type Tensors yet.");const s=t.shape.length,r=e.shape.length;n==null&&(n=[s-1,r-2]);const a=n;return me(()=>{let i;if(s>r){i=s-r;const l=[];for(let c=0;c<i;++c)l.push(1);e=le(e,e.shape.concat(l))}else if(r>s){i=r-s;const l=[];for(let c=0;c<i;++c)l.push(1);t=le(t,t.shape.concat(l))}else i=0;let o;if(t.shape.length===2&&e.shape.length===2)a[0]===a[1]?o=Xe(ae(t,e),a[0]):o=Xe(ae(Ft(t,[1,0]),e),a[1]);else{const l=a[0]!==t.shape.length-1,c=a[1]===e.shape.length-1;o=Tt(t,e,l,c)}if(i>0){let l;s>r?l=s+r-3:l=s-1;const c=[];for(let h=l;h<l+i;++h)c.push(h);o=Sc(o,c)}return o.shape.length===1&&(o=Ws(o,1)),o})}class pM extends Tc{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){V(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=e[0],s=e[1];if(n.length>3||s.length>3)throw new bt("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(n,s);if(n[r[0]]!==s[r[1]])throw new ue(`Dimension incompatibility: ${n[r[0]]} !== ${s[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new ue(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let n=e[0],s=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((a,i)=>Bp(a,e[i].shape.length)):r=[Bp(this.axes,n.shape.length),Bp(this.axes,s.shape.length)],this.normalize&&(n=I0(n,r[0]),s=I0(s,r[1])),BJ(n,s,r)}interpretAxes(e,n){let s;return Array.isArray(this.axes)?s=this.axes:s=[Bp(this.axes,e.length),Bp(this.axes,n.length)],s}computeOutputShape(e){V(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=e[0].slice(),s=e[1].slice();if(n.length>3||s.length>3)throw new bt("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(n,s);n.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const a=n.concat(s);return a.length===1&&a.push(1),a}computeMask(e,n){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},n=super.getConfig();return Object.assign(e,n),e}}pM.className="Dot";De(pM);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class fM extends _t{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={stddev:this.stddev};return Object.assign(n,e),n}call(e,n){return me(()=>{this.invokeCallHook(e,n);const s=dt(e);return Pm(()=>Ae(Dx(s.shape,0,this.stddev),s),()=>s,n.training||!1)})}}fM.className="GaussianNoise";De(fM);class mM extends _t{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={rate:this.rate};return Object.assign(n,e),n}call(e,n){return me(()=>{this.invokeCallHook(e,n);const s=dt(e);return this.rate>0&&this.rate<1?Pm(()=>{const a=Math.sqrt(this.rate/(1-this.rate));return ae(s,Dx(s.shape,1,a))},()=>s,n.training||!1):s})}}mM.className="GaussianDropout";De(mM);class gM extends _t{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||dt(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={rate:this.rate};return Object.assign(n,e),n}call(e,n){return me(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return Pm(()=>{const a=dt(e),o=-1.6732632423543772*1.0507009873554805;let l=Xl($c(s),this.rate);l=ki(l,"float32");const c=((1-this.rate)*(1+this.rate*o**2))**-.5,h=-c*o*this.rate,p=Ae(ae(a,l),ae(Ae(l,-1),o));return Ae(ae(p,c),h)},()=>dt(e),n.training||!1)}return e})}}gM.className="AlphaDropout";De(gM);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function vf(t,e,n,s,r,a=.001){let i;if(t.rank===2)i=UO(t,e,n,s,r,a);else if(t.rank===3)i=WO(t,e,n,s,r,a);else if(t.rank===4)i=GO(t,e,n,s,r,a);else throw new bt(`batchNormalization is not implemented for array of rank ${t.rank} yet`);return i}function PJ(t,e,n,s,r=.001){return me(()=>{const a=mx(t,s),i=a.mean,o=a.variance;return[vf(t,i,o,n,e,r),i,o]})}function VJ(t,e,n,s,r=.001){return me(()=>{const a=mx(t,s),i=a.mean,o=a.variance,l=[];for(const y of Xa(0,t.rank))s.indexOf(y)!==-1?l.push(1):l.push(t.shape[y]);const c=le(i,l),h=le(o,l),p=e==null?null:le(e,l),f=n==null?null:le(n,l);return[vf(t,c,h,f,p,r),i,o]})}function UJ(t,e,n,s,r=.001){return Rt(s.slice().sort(),Xa(0,t.rank-1))?PJ(t,e,n,s,r):VJ(t,e,n,s,r)}class yM extends _t{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=pn(e.betaInitializer||"zeros"),this.gammaInitializer=pn(e.gammaInitializer||"ones"),this.movingMeanInitializer=pn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=pn(e.movingVarianceInitializer||"ones"),this.betaConstraint=Yn(e.betaConstraint),this.gammaConstraint=Yn(e.gammaConstraint),this.betaRegularizer=fn(e.betaRegularizer),this.gammaRegularizer=fn(e.gammaRegularizer)}build(e){e=Wt(e);const n=this.axis>=0?this.axis:this.axis+e.length,s=e[n];if(s==null)throw new ue(`Axis ${n} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new jn({ndim:e.length,axes:{[n]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,n){return me(()=>{const s=n.training==null?!1:n.training,r=dt(e),a=r.shape,i=a.length,o=Xa(0,i),l=this.axis>=0?this.axis:this.axis+i;o.splice(l,1);const c=dc(1,i);c[l]=a[l];const h=o.slice();h.sort();const p=!Rt(h,Xa(0,i).slice(0,i-1)),f=()=>{if(p){const $=le(this.movingMean.read(),c),T=le(this.movingVariance.read(),c),C=this.center?le(this.beta.read(),c):null,I=this.scale?le(this.gamma.read(),c):null;return vf(r,$,T,C,I,this.epsilon)}else return vf(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return f();const[g,y,x]=UJ(r,this.gamma.read(),this.beta.read(),o,this.epsilon),w=($,T,C)=>{me(()=>{const I=1-C,A=$.read(),O=ae(qe(A,T),I);$.write(qe(A,O))})};return(()=>{w(this.movingMean,y,this.momentum),w(this.movingVariance,x,this.momentum)})(),g})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:xn(this.betaInitializer),gammaInitializer:xn(this.gammaInitializer),movingMeanInitializer:xn(this.movingMeanInitializer),movingVarianceInitializer:xn(this.movingVarianceInitializer),betaRegularizer:sn(this.betaRegularizer),gammaRegularizer:sn(this.gammaRegularizer),betaConstraint:Xn(this.betaConstraint),gammaConstraint:Xn(this.gammaConstraint)},n=super.getConfig();return Object.assign(e,n),e}}yM.className="BatchNormalization";De(yM);class bM extends _t{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const n of this.axis)if(!Number.isInteger(n))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=pn(e.betaInitializer||"zeros"),this.gammaInitializer=pn(e.gammaInitializer||"ones"),this.betaRegularizer=fn(e.betaRegularizer),this.gammaRegularizer=fn(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Wt(e);const n=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=n);for(const a of this.axis)if(a<0||a>=n)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==El(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(a=>e[a]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,n){const s=dt(e),r=s.shape,a=r.length;return me(()=>{let{mean:o,variance:l}=mx(s,this.axis,!0);const c=dc(1,a);for(const x of this.axis)c[x]=r[x];const h=x=>x!=null&&x.shape.length!==a?le(x,c):x;let p=this.scale?h(this.gamma.read()):null,f=this.center?h(this.beta.read()):null;const g=[],y=[];for(let x=0;x<a;++x)this.axis.indexOf(x)!==-1?(g.push(r[x]),y.push(1)):(g.push(1),y.push(r[x]));return o=ga(o,g),l=ga(l,g),p!=null&&(p=ga(p,y)),f!=null&&(f=ga(f,y)),vf(s,o,l,f,p,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:xn(this.betaInitializer),gammaInitializer:xn(this.gammaInitializer),betaRegularizer:sn(this.betaRegularizer),gammaRegularizer:sn(this.gammaRegularizer)},n=super.getConfig();return Object.assign(e,n),e}}bM.className="LayerNormalization";De(bM);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function WJ(t,e,n){return me(()=>{if(t.rank!==4)throw new ue(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new ue("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=Ya()),n!=="channelsLast"&&n!=="channelsFirst")throw new ue(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return n==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],Yl(t,s)})}class xM extends _t{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Ya():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new ue(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let n,s;if(typeof e.padding[0]=="number")n=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new ue(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(n=e.padding[0],e.padding[1].length!==2)throw new ue(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[n,s]}this.inputSpec=[new jn({ndim:4})]}computeOutputShape(e){e=Wt(e);let n,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?n=e[2]+this.padding[0][0]+this.padding[0][1]:n=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],n,s]):(e[1]!=null&&e[1]>=0?n=e[1]+this.padding[0][0]+this.padding[0][1]:n=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],n,s,e[3]])}call(e,n){return me(()=>WJ(dt(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}xM.className="ZeroPadding2D";De(xM);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Vx(t,e,n,s,r,a){return me(()=>{On(r),zF(a),Zr(s),n==null&&(n=[1,1]),s==null&&(s="valid"),r==null&&(r=Ya()),a==null&&(a="max"),t=vC(t,r);let i;const o=s==="same"?"same":"valid";return a==="max"?i=fx(t,e,n,o):i=ix(t,e,n,o),r==="channelsFirst"&&(i=Ft(i,[0,3,1,2])),i})}function wM(t,e,n,s,r,a){return me(()=>{On(r),zF(a),Zr(s),n==null&&(n=[1,1,1]),s==null&&(s="valid"),r==null&&(r=Ya()),a==null&&(a="max"),t=LL(t,r);let i;const o=s==="same"?"same":"valid";return a==="max"?i=fz(t,e,n,o):i=VO(t,e,n,o),r==="channelsFirst"&&(i=Ft(i,[0,4,1,2,3])),i})}class vM extends _t{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new ue(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(rs(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new ue(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);rs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Zr(this.padding),this.inputSpec=[new jn({ndim:3})]}computeOutputShape(e){e=Wt(e);const n=qa(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],n,e[2]]}call(e,n){return me(()=>{this.invokeCallHook(e,n),e=Mm(dt(e),2);const s=this.poolingFunction(dt(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Sc(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=super.getConfig();return Object.assign(e,n),e}}class $M extends vM{constructor(e){super(e)}poolingFunction(e,n,s,r,a){return On(a),Zr(r),Vx(e,n,s,r,a,"max")}}$M.className="MaxPooling1D";De($M);class SM extends vM{constructor(e){super(e)}poolingFunction(e,n,s,r,a){return On(a),Zr(r),Vx(e,n,s,r,a,"avg")}}SM.className="AveragePooling1D";De(SM);class _M extends _t{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new ue(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];rs(this.poolSize,"poolSize"),rs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,On(this.dataFormat),Zr(this.padding),this.inputSpec=[new jn({ndim:4})]}computeOutputShape(e){e=Wt(e);let n=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return n=qa(n,this.poolSize[0],this.padding,this.strides[0]),s=qa(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],n,s]:[e[0],n,s,e[3]]}call(e,n){return me(()=>(this.invokeCallHook(e,n),this.poolingFunction(dt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class CM extends _M{constructor(e){super(e)}poolingFunction(e,n,s,r,a){return On(a),Zr(r),Vx(e,n,s,r,a,"max")}}CM.className="MaxPooling2D";De(CM);class TM extends _M{constructor(e){super(e)}poolingFunction(e,n,s,r,a){return On(a),Zr(r),Vx(e,n,s,r,a,"avg")}}TM.className="AveragePooling2D";De(TM);class kM extends _t{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new ue(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];rs(this.poolSize,"poolSize"),rs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,On(this.dataFormat),Zr(this.padding),this.inputSpec=[new jn({ndim:5})]}computeOutputShape(e){e=Wt(e);let n=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return n=qa(n,this.poolSize[0],this.padding,this.strides[0]),s=qa(s,this.poolSize[1],this.padding,this.strides[1]),r=qa(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],n,s,r]:[e[0],n,s,r,e[4]]}call(e,n){return me(()=>(this.invokeCallHook(e,n),this.poolingFunction(dt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class NM extends kM{constructor(e){super(e)}poolingFunction(e,n,s,r,a){return On(a),Zr(r),wM(e,n,s,r,a,"max")}}NM.className="MaxPooling3D";De(NM);class IM extends kM{constructor(e){super(e)}poolingFunction(e,n,s,r,a){return On(a),Zr(r),wM(e,n,s,r,a,"avg")}}IM.className="AveragePooling3D";De(IM);class EM extends _t{constructor(e){super(e),this.inputSpec=[new jn({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,n){throw new bt}}class AM extends EM{constructor(e){super(e||{})}call(e,n){return me(()=>{const s=dt(e);return _n(s,1)})}}AM.className="GlobalAveragePooling1D";De(AM);class RM extends EM{constructor(e){super(e||{})}call(e,n){return me(()=>{const s=dt(e);return wa(s,1)})}}RM.className="GlobalMaxPooling1D";De(RM);class DM extends _t{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,On(this.dataFormat),this.inputSpec=[new jn({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,n){throw new bt}getConfig(){const e={dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class OM extends DM{call(e,n){return me(()=>{const s=dt(e);return this.dataFormat==="channelsLast"?_n(s,[1,2]):_n(s,[2,3])})}}OM.className="GlobalAveragePooling2D";De(OM);class zM extends DM{call(e,n){return me(()=>{const s=dt(e);return this.dataFormat==="channelsLast"?wa(s,[1,2]):wa(s,[2,3])})}}zM.className="GlobalMaxPooling2D";De(zM);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class FM extends _t{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=super.getConfig();return Object.assign(e,n),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,n,s={}){const r=n.layer,a=So(r,s);delete n.layer;const i={layer:a};return Object.assign(i,n),new e(i)}}class LM extends FM{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Wt(e),e.length<3)throw new ue(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const n=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Wt(e);const n=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(n),r=e[1];return[s[0],r].concat(s.slice(1))}call(e,n){return me(()=>(e=dt(e),qL((i,o)=>[dt(this.layer.call(i,n)),[]],e,[],!1,null,null,!1,!0)[1]))}}LM.className="TimeDistributed";De(LM);function GJ(t){Cc(dQ,"BidirectionalMergeMode",t)}const HJ="concat";class MM extends FM{constructor(e){super(e);const n=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=n,this.forwardLayer=So(s),n.goBackwards=n.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=n,this.backwardLayer=So(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?HJ:e.mergeMode,GJ(this.mergeMode),e.weights)throw new bt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const n=e.length,s=Math.floor(n/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let n=this.forwardLayer.computeOutputShape(e);Array.isArray(n)&&Array.isArray(n[0])||(n=[n]),n=n;let s,r,a;return this.returnState&&(a=n.slice(1)),s=n[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(a).concat(a.slice()):[s].concat(a).concat(a.slice()):rr(r)}apply(e,n){let s=n==null?null:n.initialState,r=n==null?null:n.constants;n==null&&(n={});const a=HL(e,s,r,this.numConstants);if(e=a.inputs,s=a.initialState,r=a.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&r==null)return super.apply(e,n);const i=[],o=[];if(s!=null){const c=s.length;if(c%2>0)throw new ue("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=s,i.push(...s);const h=s.map(p=>new jn({shape:p.shape}));this.forwardLayer.stateSpec=h.slice(0,c/2),this.backwardLayer.stateSpec=h.slice(c/2),o.push(...h)}if(r!=null)throw new bt("Support for constants in Bidirectional layers is not implemented yet.");const l=i[0]instanceof Ai;for(const c of i)if(c instanceof Ai!==l)throw new ue("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const c=[e].concat(i),h=this.inputSpec.concat(o),p=this.inputSpec;this.inputSpec=h;const f=super.apply(c,n);return this.inputSpec=p,f}else return super.apply(e,n)}call(e,n){return me(()=>{const s=n.initialState;let r,a;if(s==null)r=this.forwardLayer.call(e,n),a=this.backwardLayer.call(e,n);else{const l=s.slice(0,s.length/2),c=s.slice(s.length/2);r=this.forwardLayer.call(e,Object.assign(n,{initialState:l})),a=this.backwardLayer.call(e,Object.assign(n,{initialState:c}))}let i;this.returnState&&(Array.isArray(r)&&(i=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=$a(a,1));let o;return this.mergeMode==="concat"?o=lC([r,a]):this.mergeMode==="sum"?o=Ae(r,a):this.mergeMode==="ave"?o=ae(.5,Ae(r,a)):this.mergeMode==="mul"?o=ae(r,a):this.mergeMode==null&&(o=[r,a]),this.returnState?this.mergeMode==null?o.concat(i):[o].concat(i):o})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Ju(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Ju(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,n){Array.isArray(n)&&(n=n[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[n,n]:s=n:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const a=this.forwardLayer.states.map(i=>null);return Array.isArray(s)?s.concat(a).concat(a):[s].concat(a).concat(a)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},n=super.getConfig();return Object.assign(e,n),e}static fromConfig(e,n){const s=So(n.layer);if(delete n.layer,n.numConstants!=null)throw new bt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=n;return r.layer=s,new e(r)}}MM.className="Bidirectional";De(MM);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class BM extends _t{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},n=super.getConfig();return Object.assign(e,n),e}call(e,n){return me(()=>(e=dt(e),e.dtype!=="float32"&&(e=ki(e,"float32")),Ae(ae(e,this.scale),this.offset)))}}BM.className="Rescaling";De(BM);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:qJ,cropAndResize:jJ}=$i;class PM extends _t{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,n,s,r,a,i,o,l){return me(()=>{let c,h=!1;const p=n/i,f=s/o,g=(r+n)/i,y=(a+s)/o,x=[p,f,g,y],w=[];e.rank===3?(h=!0,c=kr([e])):c=e;for(let I=0;I<c.shape[0];I++)w.push(x);const v=Ha(w,[w.length,4]),$=Ud(0,w.length,1,"int32"),C=jJ(c,v,$,[r,a],"nearest");return ki(h?dt(Sa(C)):C,l)})}upsize(e,n,s,r){return me(()=>{const a=qJ(e,[n,s]);return ki(a,r)})}call(e,n){return me(()=>{const s=dt(e),r=s.dtype,a=s.shape,i=a[a.length-3],o=a[a.length-2];let l=0;i!==this.height&&(l=Math.floor((i-this.height)/2));let c=0;return o!==this.width&&(c=Math.floor((o-this.width)/2),c===0&&(c=1)),l>=0&&c>=0?this.centerCrop(s,l,c,this.height,this.width,i,o,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){e=Wt(e);const n=e.length-3,s=e.length-2;return e[n]=this.height,e[s]=this.width,e}}PM.className="CenterCrop";De(PM);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function KJ(t,e,n,s){let r=dt(t);if(r.dtype!=="int32"&&(r=ki(r,"int32")),e==="int")return r;const a=r.shape;if(r.rank===0&&(r=Ws(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=Ws(r,-1)),r.rank>2)throw new ue(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${a} which would result in output rank ${r.rank}.`);const i=["multiHot","oneHot"].includes(e),o=r;let l;if(typeof s<"u"&&e==="count"?l=B$(o,s,n,i):l=B$(o,[],n,i),e!=="tfIdf")return l;if(s)return ae(l,s);throw new ue("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class VM extends _t{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){return e=Wt(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,n){return me(()=>{e=dt(e),e.dtype!=="int32"&&(e=ki(e,"int32"));let s;if(typeof n.countWeights<"u"){if(this.outputMode!=="count")throw new ue(`countWeights is not used when outputMode !== count.
              Received countWeights=${n.countWeights}`);s=dt(n.countWeights)}const r=wa(e),a=pf(e),i=Ar(this.numTokens,r).bufferSync().get(0),o=Xl(a,0).bufferSync().get(0);if(!(i&&o))throw new ue(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return KJ(e,this.outputMode,this.numTokens,s)})}}VM.className="CategoryEncoding";De(VM);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const XJ=["bilinear","nearest"],iE=new Set(XJ);class UM extends _t{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(iE.has(e.interpolation))this.interpolation=e.interpolation;else throw new ue(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=Wt(e);const n=e[2];return[this.height,this.width,n]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},n=super.getConfig();return Object.assign(e,n),e}call(e,n){return me(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return $i.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return $i.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...iE]} are supported`)})}}UM.className="Resizing";De(UM);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class WM{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}WM.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class GM extends _t{constructor(e){super(e),this.randomGenerator=new WM(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},n=super.getConfig();return Object.assign(e,n),e}}GM.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const YJ=["bilinear","nearest"],oE=new Set(YJ);class HM extends GM{constructor(e){super(e);const{factor:n,interpolation:s="bilinear"}=e;if(this.factor=n,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new ue(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new ue(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new ue(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(oE.has(s))this.interpolation=s;else throw new ue(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){e=Wt(e);const n=e[2];return[this.imgHeight,-1,n]}call(e,n){return me(()=>{const s=dt(e);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=$c([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*r;a=Math.round(a);const i=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return $i.resizeBilinear(e,i);case"nearest":return $i.resizeNearestNeighbor(e,i);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...oE]} are supported`)}})}}HM.className="RandomWidth";De(HM);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZJ=ye();ZJ.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var wr;(function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"})(wr||(wr={}));var lE;(function(t){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(lE||(lE={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QJ={};function qM(t){return QJ[t]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D(t,e,n,s,r){const a=e.inputParams[t];if(a&&a.inputIndexStart!==void 0){const o=a.inputIndexStart,l=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?o+1:a.inputIndexEnd,c=o<0?e.inputNames.length+o:o;if(a.type==="tensor")return ms(e.inputNames[c],n,s,r);if(a.type==="tensors"){const f=e.inputs.slice(o,l);return e.inputNames.slice(o,l).filter((y,x)=>{var w;return((w=f[x])===null||w===void 0?void 0:w.op)!=="NoOp"}).map(y=>ms(y,n,s,r))}const h=ms(e.inputNames[c],n,s,r),p=h.dataSync();return a.type==="number"?p[0]:xa(h.shape,p)}const i=e.attrParams[t];return i&&i.value}function ms(t,e,n,s){const[r,a]=vr(t,n);if(s!=null){const o=s.getHashTableHandleByName(r);if(o!=null)return o}const i=n.currentContextIds.find(o=>!!e[O0(r,o)]);return i!==void 0?e[O0(r,i)][a]:void 0}function uE(t,e,n){return e[O0(t,n.currentContextId)]}function bo(t,e){const[n,s,r]=vr(t,e);return[O0(n,e&&e.currentContextId),s,r]}function O0(t,e){return e?`${t}-${e}`:t}function vr(t,e){if(t==="")return["",0,void 0];const n=e!=null&&e.parseNodeNameCache!=null;if(n){const a=e.parseNodeNameCache.get(t);if(a!=null)return a}const s=t.split(":");let r;if(s.length===1)r=[t,0,void 0];else{const a=s[0],i=s.length===3?s[1]:void 0,o=Number(s[s.length-1]);r=[a,o,i]}return n&&e.parseNodeNameCache.set(t,r),r}function d0(t,e,n){let s=D("pad",t,e,n);if(s==="explicit"){s=D("explicitPaddings",t,e,n);const r=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)r[a][0]=s[a*2],r[a][1]=s[a*2+1];return r}return s}function xo(t){return t.kept?t:$o(t)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JJ=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],eee=Object.freeze(Object.defineProperty({__proto__:null,json:JJ},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tee=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],nee=Object.freeze(Object.defineProperty({__proto__:null,json:tee},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const see=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],ree=Object.freeze(Object.defineProperty({__proto__:null,json:see},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aee=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],iee=Object.freeze(Object.defineProperty({__proto__:null,json:aee},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oee=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],lee=Object.freeze(Object.defineProperty({__proto__:null,json:oee},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uee=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],cee=Object.freeze(Object.defineProperty({__proto__:null,json:uee},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dee=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],hee=Object.freeze(Object.defineProperty({__proto__:null,json:dee},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pee=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],fee=Object.freeze(Object.defineProperty({__proto__:null,json:pee},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mee=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],gee=Object.freeze(Object.defineProperty({__proto__:null,json:mee},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yee=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],bee=Object.freeze(Object.defineProperty({__proto__:null,json:yee},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xee=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],wee=Object.freeze(Object.defineProperty({__proto__:null,json:xee},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vee=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],$ee=Object.freeze(Object.defineProperty({__proto__:null,json:vee},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const See=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],_ee=Object.freeze(Object.defineProperty({__proto__:null,json:See},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cee=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Tee=Object.freeze(Object.defineProperty({__proto__:null,json:Cee},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kee=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Nee=Object.freeze(Object.defineProperty({__proto__:null,json:kee},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iee=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Eee=Object.freeze(Object.defineProperty({__proto__:null,json:Iee},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aee=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Ree=Object.freeze(Object.defineProperty({__proto__:null,json:Aee},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dee=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Oee=Object.freeze(Object.defineProperty({__proto__:null,json:Dee},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zee=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Fee=Object.freeze(Object.defineProperty({__proto__:null,json:zee},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cE{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[eee,nee,ree,iee,lee,cee,hee,fee,gee,bee,wee,$ee,_ee,Tee,Nee,Eee,Ree,Oee,Fee],n=[].concat(...e.map(s=>s.json));this.opMappers=n.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(e,n={}){const s=e.node,r=[],a=[],i=[],o=s.reduce((x,w)=>(x[w.name]=this.mapNode(w),w.op.startsWith("Placeholder")?r.push(x[w.name]):w.op==="Const"?a.push(x[w.name]):(w.input==null||w.input.length===0)&&i.push(x[w.name]),x),{});let l=[];const c=[];let h={},p={};n!=null&&(h=this.mapSignatureEntries(n.inputs),p=this.mapSignatureEntries(n.outputs));const f=Object.keys(o);f.forEach(x=>{const w=o[x];w.inputNames.forEach((v,$)=>{const[T,,C]=bo(v),I=o[T];if(I.outputs!=null){const A=I.outputs.indexOf(C);if(A!==-1){const O=`${T}:${A}`;w.inputNames[$]=O}}w.inputs.push(I),I.children.push(w)})}),Object.keys(p).length===0?f.forEach(x=>{const w=o[x];w.children.length===0&&c.push(w)}):Object.keys(p).forEach(x=>{const[w]=bo(x),v=o[w];v!=null&&(v.signatureKey=p[x],c.push(v))}),Object.keys(h).length>0?Object.keys(h).forEach(x=>{const[w]=bo(x),v=o[w];v&&(v.signatureKey=h[x],l.push(v))}):l=r;let g={};e.library!=null&&e.library.function!=null&&(g=e.library.function.reduce((x,w)=>(x[w.signature.name]=this.mapFunction(w),x),{}));const y={nodes:o,inputs:l,outputs:c,weights:a,placeholders:r,signature:n,functions:g};return i.length>0&&(y.initNodes=i),y}mapSignatureEntries(e){return Object.keys(e||{}).reduce((n,s)=>(n[e[s].name]=s,n),{})}mapNode(e){const n=qM(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:n.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:n.outputs};return n.inputs!=null&&(s.inputParams=n.inputs.reduce((r,a)=>(r[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},r),{})),n.attrs!=null&&(s.attrParams=n.attrs.reduce((r,a)=>{const i=a.type;let o;switch(a.type){case"string":o=e2(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=e2(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":o=o2(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=o2(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":o=n2(e.attr,a.tfName,a.defaultValue||0),o===void 0&&a.tfDeprecatedName&&(o=n2(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":o=i2(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=i2(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":o=t2(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=t2(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":o=u2(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=u2(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":o=a2(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=a2(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":o=l2(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=l2(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":o=s2(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=s2(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":o=r2(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=r2(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":o=dE(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=dE(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return r[a.name]={value:o,type:i},r},{})),s}mapFunction(e){const n=e.nodeDef,s=[],r=[];let a={};n!=null&&(a=n.reduce((p,f)=>(p[f.name]=this.mapNode(f),f.op==="Const"&&r.push(p[f.name]),p),{}));const i=[],o=[];e.signature.inputArg.forEach(p=>{const[f]=bo(p.name),g={name:f,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:kC(p.type),type:"dtype"}},children:[]};g.signatureKey=p.name,i.push(g),a[f]=g}),Object.keys(a).forEach(p=>{const f=a[p];f.inputNames.forEach((g,y)=>{const[x,,w]=bo(g),v=a[x];if(v.outputs!=null){const $=v.outputs.indexOf(w);if($!==-1){const T=`${x}:${$}`;f.inputNames[y]=T}}f.inputs.push(v),v.children.push(f)})});const c=e.ret;e.signature.outputArg.forEach(p=>{const[f,g]=bo(c[p.name]),y=a[f];y!=null&&(y.defaultOutput=g,o.push(y))});const h=this.mapArgsToSignature(e);return{nodes:a,inputs:i,outputs:o,weights:r,placeholders:s,signature:h}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((n,s)=>(n[s.name]=this.mapArgToTensorInfo(s),n),{}),outputs:e.signature.outputArg.reduce((n,s)=>(n[s.name]=this.mapArgToTensorInfo(s,e.ret),n),{})}}mapArgToTensorInfo(e,n){let s=e.name;return n!=null&&(s=n[s]),{name:s,dtype:e.type}}}function Lee(t){const e=ye().global;if(typeof e.atob<"u")return e.atob(t);if(typeof Buffer<"u")return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function jM(t,e){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):Lee(t);return e?n:n.toLowerCase()}function e2(t,e,n,s=!1){const r=t[e];return r!=null?jM(r.s,s):n}function t2(t,e,n){const s=t[e];return s?s.b:n}function n2(t,e,n){const s=t[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:n;return typeof r=="number"?r:parseInt(r,10)}function kC(t){switch(typeof t=="string"&&(t=wr[t]),t){case wr.DT_FLOAT:case wr.DT_HALF:return"float32";case wr.DT_INT32:case wr.DT_INT64:case wr.DT_INT8:case wr.DT_UINT8:return"int32";case wr.DT_BOOL:return"bool";case wr.DT_DOUBLE:return"float32";case wr.DT_STRING:return"string";case wr.DT_COMPLEX64:case wr.DT_COMPLEX128:return"complex64";default:return null}}function dE(t,e,n){const s=t[e];return s&&s.func?s.func.name:n}function s2(t,e,n){const s=t[e];return s&&s.type?kC(s.type):n}function r2(t,e,n){const s=t[e];return s&&s.list&&s.list.type?s.list.type.map(r=>kC(r)):n}function KM(t){if(!t.unknownRank)return t.dim!=null?t.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function a2(t,e,n){const s=t[e];return s&&s.shape?KM(s.shape):n}function i2(t,e,n){const s=t[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):n}function o2(t,e,n,s=!1){const r=t[e];return r&&r.list&&r.list.s?r.list.s.map(a=>jM(a,s)):n}function l2(t,e,n){const s=t[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>KM(r)):n}function u2(t,e,n){const s=t[e];return s&&s.list&&s.list.b?s.list.b:n}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mee{constructor(e,n,s){this.node=e,this.tensorMap=n,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,a)=>(r[a]=this.getAttr(a),r),{}))}getInput(e){return ms(e,this.tensorMap,this.context)}getAttr(e,n){const s=this.node.rawAttrs[e];if(s.tensor!=null)return ms(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return n2(this.node.rawAttrs,e,n);if(s.s!=null)return e2(this.node.rawAttrs,e,n);if(s.b!=null)return t2(this.node.rawAttrs,e,n);if(s.shape!=null)return a2(this.node.rawAttrs,e,n);if(s.type!=null)return s2(this.node.rawAttrs,e,n);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return i2(this.node.rawAttrs,e,n);if(s.list.s!=null)return o2(this.node.rawAttrs,e,n);if(s.list.shape!=null)return l2(this.node.rawAttrs,e,n);if(s.list.b!=null)return u2(this.node.rawAttrs,e,n);if(s.list.type!=null)return r2(this.node.rawAttrs,e,n)}return n}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vs=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:mO,abs:Gn,acos:DO,acosh:OO,add:Ae,addN:nj,all:XS,any:S0,argMax:Bd,argMin:zO,asin:FO,asinh:LO,atan:MO,atan2:BO,atanh:PO,avgPool:ix,avgPool3d:VO,basicLSTMCell:Cj,batchNorm:Nm,batchNorm2d:UO,batchNorm3d:WO,batchNorm4d:GO,batchToSpaceND:ox,bincount:HO,bitwiseAnd:Oj,booleanMaskAsync:xX,broadcastArgs:Fj,broadcastTo:Od,buffer:xt,cast:Ge,ceil:qO,clipByValue:Cr,clone:$o,complex:Dl,concat:Bn,concat1d:jO,concat2d:KO,concat3d:XO,concat4d:YO,conv1d:ZS,conv2d:Fl,conv2dTranspose:JS,conv3d:ZO,conv3dTranspose:JO,cos:lx,cosh:e_,cosineWindow:C_,cumprod:_0,cumsum:t_,denseBincount:B$,depthToSpace:ez,depthwiseConv2d:Im,diag:a5,dilation2d:tz,div:et,divNoNan:nz,dot:sz,dropout:Nz,einsum:Td,elu:Em,enclosingPowerOfTwo:Iz,ensureShape:m5,equal:Ka,erf:n_,euclideanNorm:iz,exp:Tr,expandDims:Ws,expm1:oz,eye:r_,fft:$x,fill:nh,floor:Rm,floorDiv:KS,fused:VX,gather:Dm,gatherND:IX,greater:Ar,greaterEqual:Xl,ifft:yf,imag:ux,image:$i,inTopKAsync:DX,irfft:x_,isFinite:lz,isInf:uz,isNaN:cz,leakyRelu:cx,less:ff,lessEqual:vc,linalg:Lz,linspace:V5,localResponseNormalization:dz,log:Kr,log1p:dx,logSigmoid:hz,logSoftmax:a_,logSumExp:hx,logicalAnd:Ei,logicalNot:px,logicalOr:i_,logicalXor:pz,losses:b9,lowerBound:s8,matMul:Tt,max:wa,maxPool:fx,maxPool3d:fz,maxPoolWithArgmax:o8,maximum:Ro,mean:_n,meshgrid:c8,min:pf,minimum:uc,mirrorPad:mz,mod:gz,moments:mx,movingAverage:$X,mul:ae,multiRNNCell:g8,multinomial:b8,neg:dn,norm:Am,notEqual:Vd,oneHot:l_,ones:ir,onesLike:Xr,op:ne,outerProduct:S8,pad:Yl,pad1d:T8,pad2d:N8,pad3d:E8,pad4d:R8,pool:yz,pow:Co,prelu:yx,print:RO,prod:bz,raggedGather:P8,raggedRange:U8,raggedTensorToTensor:G8,rand:q8,randomGamma:fK,randomNormal:c_,randomStandardNormal:yK,randomUniform:$c,randomUniformInt:wK,range:Ud,real:mf,reciprocal:xz,relu:zi,relu6:d_,reshape:le,reverse:$a,reverse1d:kK,reverse2d:IK,reverse3d:AK,reverse4d:DK,rfft:Sx,round:h_,rsqrt:p_,scalar:st,scatterND:_X,searchSorted:o_,selu:f_,separableConv2d:m_,setdiff1dAsync:BK,sigmoid:Ci,sign:wz,signal:y9,sin:g_,sinh:y_,slice:Ot,slice1d:xx,slice2d:b_,slice3d:wx,slice4d:gf,softmax:vx,softplus:sh,spaceToBatchND:gx,sparse:x9,sparseToDense:kX,spectral:g9,split:Sr,sqrt:bs,square:nn,squaredDifference:w_,squeeze:Sc,stack:kr,step:rh,stridedSlice:vz,string:w9,sub:qe,sum:Xe,tan:$z,tanh:lc,tensor:Ha,tensor1d:Hs,tensor2d:of,tensor3d:aX,tensor4d:iX,tensor5d:oX,tensor6d:lX,tensorScatterUpdate:cX,tile:ga,topk:_z,transpose:Ft,truncatedNormal:$_,unique:Cz,unsortedSegmentSum:S_,unstack:Sa,upperBound:gX,variable:Tz,where:As,whereAsync:kz,zeros:Hn,zerosLike:Lt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bee=(t,e,n,s=vs)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(D("a",t,e,n),D("b",t,e,n))];case"AddN":return[s.addN(D("tensors",t,e,n))];case"FloorMod":case"Mod":return[s.mod(D("a",t,e,n),D("b",t,e,n))];case"Mul":return[s.mul(D("a",t,e,n),D("b",t,e,n))];case"RealDiv":case"Div":return[s.div(D("a",t,e,n),D("b",t,e,n))];case"DivNoNan":return[s.divNoNan(D("a",t,e,n),D("b",t,e,n))];case"FloorDiv":return[s.floorDiv(D("a",t,e,n),D("b",t,e,n))];case"Sub":return[s.sub(D("a",t,e,n),D("b",t,e,n))];case"Minimum":return[s.minimum(D("a",t,e,n),D("b",t,e,n))];case"Maximum":return[s.maximum(D("a",t,e,n),D("b",t,e,n))];case"Pow":return[s.pow(D("a",t,e,n),D("b",t,e,n))];case"SquaredDifference":return[s.squaredDifference(D("a",t,e,n),D("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pee=(t,e,n,s=vs)=>{switch(t.op){case"Abs":case"ComplexAbs":return[s.abs(D("x",t,e,n))];case"Acos":return[s.acos(D("x",t,e,n))];case"Acosh":return[s.acosh(D("x",t,e,n))];case"Asin":return[s.asin(D("x",t,e,n))];case"Asinh":return[s.asinh(D("x",t,e,n))];case"Atan":return[s.atan(D("x",t,e,n))];case"Atan2":return[s.atan2(D("x",t,e,n),D("y",t,e,n))];case"Atanh":return[s.atanh(D("x",t,e,n))];case"Ceil":return[s.ceil(D("x",t,e,n))];case"Complex":return[s.complex(D("real",t,e,n),D("imag",t,e,n))];case"Cos":return[s.cos(D("x",t,e,n))];case"Cosh":return[s.cosh(D("x",t,e,n))];case"Elu":return[s.elu(D("x",t,e,n))];case"Erf":return[s.erf(D("x",t,e,n))];case"Exp":return[s.exp(D("x",t,e,n))];case"Expm1":return[s.expm1(D("x",t,e,n))];case"Floor":return[s.floor(D("x",t,e,n))];case"Log":return[s.log(D("x",t,e,n))];case"Log1p":return[s.log1p(D("x",t,e,n))];case"Imag":return[s.imag(D("x",t,e,n))];case"Neg":return[s.neg(D("x",t,e,n))];case"Reciprocal":return[s.reciprocal(D("x",t,e,n))];case"Real":return[s.real(D("x",t,e,n))];case"Relu":return[s.relu(D("x",t,e,n))];case"Round":return[s.round(D("x",t,e,n))];case"Selu":return[s.selu(D("x",t,e,n))];case"Sigmoid":return[s.sigmoid(D("x",t,e,n))];case"Sin":return[s.sin(D("x",t,e,n))];case"Sign":return[s.sign(D("x",t,e,n))];case"Sinh":return[s.sinh(D("x",t,e,n))];case"Softplus":return[s.softplus(D("x",t,e,n))];case"Sqrt":return[s.sqrt(D("x",t,e,n))];case"Square":return[s.square(D("x",t,e,n))];case"Tanh":return[s.tanh(D("x",t,e,n))];case"Tan":return[s.tan(D("x",t,e,n))];case"ClipByValue":return[s.clipByValue(D("x",t,e,n),D("clipValueMin",t,e,n),D("clipValueMax",t,e,n))];case"Relu6":return[s.relu6(D("x",t,e,n))];case"Rsqrt":return[s.rsqrt(ms(t.inputNames[0],e,n))];case"LeakyRelu":return[s.leakyRelu(D("x",t,e,n),D("alpha",t,e,n))];case"Prelu":return[s.prelu(D("x",t,e,n),D("alpha",t,e,n))];case"IsNan":return[s.isNaN(ms(t.inputNames[0],e,n))];case"IsInf":return[s.isInf(ms(t.inputNames[0],e,n))];case"IsFinite":return[s.isFinite(ms(t.inputNames[0],e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fa(t,e,n=""){if(!(typeof t=="number"||typeof e=="number")){V(t.length===e.length,()=>n+` Shapes ${t} and ${e} must match`);for(let s=0;s<t.length;s++){const r=t[s],a=e[s];V(r<0||a<0||r===a,()=>n+` Shapes ${t} and ${e} must match`)}}}function hE(t){return!(typeof t=="number"||t.some(e=>e<0))}function Pp(t,e,n){let s=c2(t,n);const r=!hE(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(a=>{s=c2(a.shape,s)}),!hE(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function c2(t,e){if(typeof t=="number")return e;if(typeof e=="number")return t;if(t.length!==e.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);const n=[];for(let s=0;s<t.length;++s){const r=t[s],a=e[s];if(r>=0&&a>=0&&r!==a)throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);n[s]=r>=0?r:a}return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vee{constructor(e,n,s,r,a,i,o){this.name=e,this.dtype=n,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=i,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=st(0),ss(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const n=this.tensors[e];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(e){return e.map(n=>this.read(n))}write(e,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),fa(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=n,ss(n),s.written=!0,this.tensors[e]=s}writeMany(e,n){if(e.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${n.length}.`);e.forEach((s,r)=>this.write(s,n[r]))}gather(e,n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return Ha([],[0].concat(this.elementShape));const s=this.readMany(e);return fa(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),kr(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Ha([],[0].concat(this.elementShape));const n=[];for(let r=0;r<this.size();r++)n.push(r);const s=this.readMany(n);return fa(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),Bn(s,0)}scatter(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,Sa(n,0))}split(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let s=0;const r=e.map(l=>(s+=l,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const a=s===0?0:n.size/s,i=[];me(()=>{n=le(n,[1,s,a]);for(let l=0;l<e.length;++l){const h=[0,l===0?0:r[l-1],0],p=[1,e[l],a];i[l]=le(Ot(n,h,p),this.elementShape)}return i});const o=[];for(let l=0;l<e.length;l++)o[l]=l;this.writeMany(o,i)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hc{get id(){return this.idTensor.id}constructor(e,n,s,r=-1){this.tensors=e,this.elementShape=n,this.elementDtype=s,e!=null&&e.forEach(a=>{if(s!==a.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${a.dtype}`);fa(n,a.shape,"TensorList shape mismatch: "),ss(a)}),this.idTensor=st(0),this.maxNumElements=r,ss(this.idTensor)}copy(){return new hc([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,n,s=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);fa(e,this.elementShape,"TensorList shape mismatch: ");const r=Pp(this.elementShape,this.tensors,e);return me(()=>{const a=this.tensors.map(i=>le(i,r));return kr(a,0)})}popBack(e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=Pp(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,fa(r.shape,e,"TensorList shape mismatch: "),le(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(fa(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ss(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const n=new hc([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)n.tensors[s]=this.tensors[s];return n}getItem(e,n,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);fa(this.tensors[e].shape,n,"TensorList shape mismatch: ");const r=Pp(this.elementShape,this.tensors,n);return le(this.tensors[e],r)}setItem(e,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);fa(this.elementShape,n.shape,"TensorList shape mismatch: "),ss(n),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=n}gather(e,n,s){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);fa(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=Pp(this.elementShape,this.tensors,s);return e.length===0?Ha([],[0].concat(r)):me(()=>{const a=e.map(i=>le(this.tensors[i],r));return kr(a,0)})}concat(e,n){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);fa(this.elementShape,n,"TensorList shape mismatch: ");const s=Pp(this.elementShape,this.tensors,n);return this.size()===0?Ha([],[0].concat(s)):me(()=>{const r=this.tensors.map(a=>le(a,s));return Bn(r,0)})}}function Uee(t,e,n){const s=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);const r=t.shape.slice(1);fa(r,e,"TensorList shape mismatch: ");const a=Sa(t);return new hc(a,e,s)}function Wee(t,e,n,s){return new hc([],t,e,s)}function Gee(t,e,n,s){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const a=new hc([],n,t.dtype,s),i=Sa(t,0);return e.forEach((o,l)=>{a.setItem(o,i[l])}),a}function Hee(t,e,n){let s=0;const r=e.map(h=>(s+=h,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);const a=t.shape.slice(1),i=c2(a,n),o=s===0?0:t.size/s,l=me(()=>{const h=[];t=le(t,[1,s,o]);for(let p=0;p<e.length;++p){const g=[0,p===0?0:r[p-1],0],y=[1,e[p],o];h[p]=le(Ot(t,g,y),i)}return t.dispose(),h}),c=new hc([],n,t.dtype,e.length);for(let h=0;h<l.length;h++)c.setItem(h,l[h]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qee=async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{const s=D("thenBranch",t,e,n),r=D("elseBranch",t,e,n),a=D("cond",t,e,n),i=D("args",t,e,n);return(await a.data())[0]?n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const s=D("body",t,e,n),r=D("cond",t,e,n),a=D("args",t,e,n),i=await n.functionMap[r].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),o=a.map(h=>h.id);let l=await i[0].data();i.forEach(h=>{!h.kept&&o.indexOf(h.id)===-1&&h.dispose()});let c=a;for(;l[0];){const h=c;c=await n.functionMap[s].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);const p=c.map(g=>g.id);h.forEach(g=>{!g.kept&&o.indexOf(g.id)===-1&&p.indexOf(g.id)===-1&&g.dispose()});const f=await n.functionMap[r].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);l=await f[0].data(),f.forEach(g=>{!g.kept&&o.indexOf(g.id)===-1&&p.indexOf(g.id)===-1&&g.dispose()})}return c}case"LoopCond":{const s=D("pred",t,e,n);return[xo(s)]}case"Switch":{const s=D("pred",t,e,n);let r=D("data",t,e,n);return r.kept||(r=xo(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=t.inputNames.find(r=>ms(r,e,n)!==void 0);if(s){const r=ms(s,e,n);return[xo(r)]}return}case"Enter":{const s=D("frameName",t,e,n),r=D("tensor",t,e,n);return n.enterFrame(s),[xo(r)]}case"Exit":{const s=D("tensor",t,e,n);return n.exitFrame(),[xo(s)]}case"NextIteration":{const s=D("tensor",t,e,n);return n.nextIteration(),[xo(s)]}case"TensorArrayV3":{const s=D("size",t,e,n),r=D("dtype",t,e,n),a=D("elementShape",t,e,n),i=D("dynamicSize",t,e,n),o=D("clearAfterRead",t,e,n),l=D("identicalElementShapes",t,e,n),c=D("name",t,e,n),h=new Vee(c,r,s,a,l,i,o);return n.addTensorArray(h),[h.idTensor,st(1)]}case"TensorArrayWriteV3":{const s=D("tensorArrayId",t,e,n),r=D("index",t,e,n),a=D("tensor",t,e,n),i=n.getTensorArray(s.id);return i.write(r,a),[i.idTensor]}case"TensorArrayReadV3":{const s=D("tensorArrayId",t,e,n),r=D("index",t,e,n);return[n.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=D("tensorArrayId",t,e,n),r=D("indices",t,e,n),a=D("dtype",t,e,n);return[n.getTensorArray(s.id).gather(r,a)]}case"TensorArrayScatterV3":{const s=D("tensorArrayId",t,e,n),r=D("indices",t,e,n),a=D("tensor",t,e,n),i=n.getTensorArray(s.id);return i.scatter(r,a),[i.idTensor]}case"TensorArrayConcatV3":{const s=D("tensorArrayId",t,e,n),r=n.getTensorArray(s.id),a=D("dtype",t,e,n);return[r.concat(a)]}case"TensorArraySplitV3":{const s=D("tensorArrayId",t,e,n),r=D("tensor",t,e,n),a=D("lengths",t,e,n),i=n.getTensorArray(s.id);return i.split(a,r),[i.idTensor]}case"TensorArraySizeV3":{const s=D("tensorArrayId",t,e,n),r=n.getTensorArray(s.id);return[st(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=D("tensorArrayId",t,e,n),r=n.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=D("tensorListId",t,e,n),r=D("index",t,e,n),a=D("tensor",t,e,n),i=n.getTensorList(s.id);return i.setItem(r,a),[i.idTensor]}case"TensorListGetItem":{const s=D("tensorListId",t,e,n),r=D("index",t,e,n),a=D("elementShape",t,e,n),i=D("elementDType",t,e,n);return[n.getTensorList(s.id).getItem(r,a,i)]}case"TensorListScatterV2":case"TensorListScatter":{const s=D("indices",t,e,n),r=D("tensor",t,e,n),a=D("elementShape",t,e,n),i=D("numElements",t,e,n),o=Gee(r,s,a,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=D("elementShape",t,e,n),r=D("elementDType",t,e,n);let a;t.op==="TensorListReserve"?a="numElements":a="maxNumElements";const i=D(a,t,e,n),o=t.op==="TensorListReserve"?-1:i,l=Wee(s,r,i,o);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{const s=D("tensorListId",t,e,n),r=D("indices",t,e,n),a=D("elementShape",t,e,n),i=D("elementDType",t,e,n);return[n.getTensorList(s.id).gather(r,i,a)]}case"TensorListStack":{const s=D("tensorListId",t,e,n),r=D("elementShape",t,e,n),a=D("elementDType",t,e,n),i=D("numElements",t,e,n);return[n.getTensorList(s.id).stack(r,a,i)]}case"TensorListFromTensor":{const s=D("tensor",t,e,n),r=D("elementShape",t,e,n),a=D("elementDType",t,e,n),i=Uee(s,r,a);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=D("tensorListId",t,e,n),r=n.getTensorList(s.id),a=D("dtype",t,e,n),i=D("elementShape",t,e,n);return[r.concat(a,i)]}case"TensorListPushBack":{const s=D("tensorListId",t,e,n),r=D("tensor",t,e,n),a=n.getTensorList(s.id);return a.pushBack(r),[a.idTensor]}case"TensorListPopBack":{const s=D("tensorListId",t,e,n),r=D("elementShape",t,e,n),a=D("elementDType",t,e,n);return[n.getTensorList(s.id).popBack(r,a)]}case"TensorListSplit":{const s=D("tensor",t,e,n),r=D("elementShape",t,e,n),a=D("lengths",t,e,n),i=Hee(s,a,r);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{const s=D("tensorListId",t,e,n),r=n.getTensorList(s.id);return[st(r.size(),"int32")]}case"TensorListResize":{const s=D("tensorListId",t,e,n),r=D("size",t,e,n),i=n.getTensorList(s.id).resize(r);return n.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pE(t,e,n){const[s,r]=D("fusedOps",t,e,n),a=s==="biasadd",i=!a,o=r==="prelu",l=s==="fusedbatchnorm",c=D("numArgs",t,e,n);if(a){if(o&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const h=D("strides",t,e,n),p=d0(t,e,n),f=D("dataFormat",t,e,n).toUpperCase(),g=D("dilations",t,e,n);let[y,x]=D("args",t,e,n);i&&(x=y,y=void 0);const w=D("leakyreluAlpha",t,e,n);return{stride:h,pad:p,dataFormat:f,dilations:g,biasArg:y,preluArg:x,activationFunc:r,leakyreluAlpha:w}}const jee=(t,e,n,s=vs)=>{switch(t.op){case"Conv1D":{const r=D("stride",t,e,n),a=D("pad",t,e,n),i=D("dataFormat",t,e,n).toUpperCase(),o=D("dilation",t,e,n);return[s.conv1d(D("x",t,e,n),D("filter",t,e,n),r,a,i,o)]}case"Conv2D":{const r=D("strides",t,e,n),a=d0(t,e,n),i=D("dataFormat",t,e,n).toUpperCase(),o=D("dilations",t,e,n);return[s.conv2d(D("x",t,e,n),D("filter",t,e,n),[r[1],r[2]],a,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:r,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:c,activationFunc:h,leakyreluAlpha:p}=pE(t,e,n);return[s.fused.conv2d({x:D("x",t,e,n),filter:D("filter",t,e,n),strides:[r[1],r[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:h,preluActivationWeights:c,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:c,activationFunc:h,leakyreluAlpha:p}=pE(t,e,n);return[s.fused.depthwiseConv2d({x:D("x",t,e,n),filter:D("filter",t,e,n),strides:[r[1],r[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:h,preluActivationWeights:c,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=D("outputShape",t,e,n),a=D("strides",t,e,n),i=d0(t,e,n);return[s.conv2dTranspose(D("x",t,e,n),D("filter",t,e,n),r,[a[1],a[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=D("strides",t,e,n),a=d0(t,e,n),i=D("dilations",t,e,n),o=D("dataFormat",t,e,n).toUpperCase();return[s.depthwiseConv2d(D("input",t,e,n),D("filter",t,e,n),[r[1],r[2]],a,o,[i[1],i[2]])]}case"Conv3D":{const r=D("strides",t,e,n),a=D("pad",t,e,n),i=D("dataFormat",t,e,n).toUpperCase(),o=D("dilations",t,e,n);return[s.conv3d(D("x",t,e,n),D("filter",t,e,n),[r[1],r[2],r[3]],a,i,[o[1],o[2],o[3]])]}case"AvgPool":{const r=D("strides",t,e,n),a=D("pad",t,e,n),i=D("kernelSize",t,e,n);return[s.avgPool(D("x",t,e,n),[i[1],i[2]],[r[1],r[2]],a)]}case"MaxPool":{const r=D("strides",t,e,n),a=D("pad",t,e,n),i=D("kernelSize",t,e,n);return[s.maxPool(D("x",t,e,n),[i[1],i[2]],[r[1],r[2]],a)]}case"MaxPoolWithArgmax":{const r=D("strides",t,e,n),a=D("pad",t,e,n),i=D("kernelSize",t,e,n),o=D("includeBatchInIndex",t,e,n),{result:l,indexes:c}=s.maxPoolWithArgmax(D("x",t,e,n),[i[1],i[2]],[r[1],r[2]],a,o);return[l,c]}case"AvgPool3D":{const r=D("strides",t,e,n),a=D("pad",t,e,n),i=D("kernelSize",t,e,n);return[s.avgPool3d(D("x",t,e,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],a)]}case"MaxPool3D":{const r=D("strides",t,e,n),a=D("pad",t,e,n),i=D("kernelSize",t,e,n);return[s.maxPool3d(D("x",t,e,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],a)]}case"Dilation2D":{const r=D("strides",t,e,n),a=D("pad",t,e,n),i=D("dilations",t,e,n),o=r[1],l=r[2],c=i[1],h=i[2];return[s.dilation2d(D("x",t,e,n),D("filter",t,e,n),[o,l],a,[c,h],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kee=(t,e,n,s=vs)=>{switch(t.op){case"Fill":{const r=D("shape",t,e,n),a=D("dtype",t,e,n),i=D("value",t,e,n);return[s.fill(r,i,a)]}case"LinSpace":{const r=D("start",t,e,n),a=D("stop",t,e,n),i=D("num",t,e,n);return[s.linspace(r,a,i)]}case"Multinomial":{const r=D("logits",t,e,n),a=D("numSamples",t,e,n),i=D("seed",t,e,n);return[s.multinomial(r,a,i)]}case"OneHot":{const r=D("indices",t,e,n),a=D("depth",t,e,n),i=D("onValue",t,e,n),o=D("offValue",t,e,n),l=D("dtype",t,e,n);return[s.oneHot(r,a,i,o,l)]}case"Ones":return[s.ones(D("shape",t,e,n),D("dtype",t,e,n))];case"OnesLike":return[s.onesLike(D("x",t,e,n))];case"RandomStandardNormal":return[s.randomStandardNormal(D("shape",t,e,n),D("dtype",t,e,n),D("seed",t,e,n))];case"RandomUniform":return[s.randomUniform(D("shape",t,e,n),D("minval",t,e,n),D("maxval",t,e,n),D("dtype",t,e,n))];case"RandomUniformInt":return[s.randomUniformInt(D("shape",t,e,n),D("minval",t,e,n),D("maxval",t,e,n),D("seed",t,e,n))];case"Range":{const r=D("start",t,e,n),a=D("stop",t,e,n),i=D("step",t,e,n);return[s.range(r,a,i,D("dtype",t,e,n))]}case"TruncatedNormal":{const r=D("shape",t,e,n),a=D("mean",t,e,n),i=D("stdDev",t,e,n),o=D("seed",t,e,n);return[s.truncatedNormal(r,a,i,D("dtype",t,e,n),o)]}case"Zeros":return[s.zeros(D("shape",t,e,n),D("dtype",t,e,n))];case"ZerosLike":return[s.zerosLike(D("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bv(t,e,n){const s=D("boxes",t,e,n),r=D("scores",t,e,n),a=D("maxOutputSize",t,e,n),i=D("iouThreshold",t,e,n),o=D("scoreThreshold",t,e,n),l=D("softNmsSigma",t,e,n);return{boxes:s,scores:r,maxOutputSize:a,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}}const Xee=async(t,e,n,s,r=vs)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:c,softNmsSigma:h}=bv(t,e,n),p=await r.image.nonMaxSuppressionWithScoreAsync(a,i,o,l,c,h);return[p.selectedIndices,p.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=bv(t,e,n),h=D("padToMaxOutputSize",t,e,n),p=await r.image.nonMaxSuppressionPaddedAsync(a,i,o,l,c,h);return[p.selectedIndices,p.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=bv(t,e,n);return[await r.image.nonMaxSuppressionAsync(a,i,o,l,c)]}case"Where":{const a=r.cast(D("condition",t,e,n),"bool"),i=[await r.whereAsync(a)];return a.dispose(),i}case"ListDiff":return r.setdiff1dAsync(D("x",t,e,n),D("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yee=(t,e,n,s=vs)=>{switch(t.op){case"LowerBound":{const r=D("sortedSequence",t,e,n),a=D("values",t,e,n);return[s.lowerBound(r,a)]}case"TopKV2":{const r=D("x",t,e,n),a=D("k",t,e,n),i=D("sorted",t,e,n),o=s.topk(r,a,i);return[o.values,o.indices]}case"UpperBound":{const r=D("sortedSequence",t,e,n),a=D("values",t,e,n);return[s.upperBound(r,a)]}case"Unique":{const r=D("x",t,e,n),a=s.unique(r);return[a.values,a.indices]}case"UniqueV2":{const r=D("x",t,e,n),a=D("axis",t,e,n),i=s.unique(r,a);return[i.values,i.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zee=(t,e,n,s=vs)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const r=D("default",t,e,n);return[ms(t.name,e,n)||r];case"Placeholder":return[ms(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const h=D("x",t,e,n);return[xo(h)]}case"IdentityN":return D("x",t,e,n).map(h=>xo(h));case"Snapshot":const a=D("x",t,e,n);return[xo(a)];case"Shape":return[s.tensor1d(D("x",t,e,n).shape,"int32")];case"ShapeN":return D("x",t,e,n).map(h=>s.tensor1d(h.shape));case"Size":return[s.scalar(D("x",t,e,n).size,"int32")];case"Rank":return[s.scalar(D("x",t,e,n).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const i=D("x",t,e,n),o=D("data",t,e,n),l=D("message",t,e,n),c=D("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let h=0;h<o.length;h++)console.log(Array.prototype.slice.call(o[h].dataSync()).slice(0,c));return[i];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qee{get id(){return this.handle.id}constructor(e,n){this.keyDType=e,this.valueDType=n,this.handle=st(0),this.tensorMap=new Map,ss(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return st(this.size(),"int32")}async import(e,n){this.checkKeyAndValueTensor(e,n);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),me(()=>{const r=Sa(n),a=s.length,i=r.length;V(a===i,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${i} elements.`);for(let o=0;o<a;o++){const l=s[o],c=r[o];ss(c),this.tensorMap.set(l,c)}return this.handle})}async find(e,n){this.checkKeyAndValueTensor(e,n);const s=await e.data();return me(()=>{const r=[];for(let a=0;a<s.length;a++){const i=s[a],o=this.findWithDefault(i,n);r.push(o)}return kr(r)})}findWithDefault(e,n){const s=this.tensorMap.get(e);return s??n}checkKeyAndValueTensor(e,n){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jee=async(t,e,n,s)=>{switch(t.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(t.name);if(r!=null)return[r];{const a=D("keyDType",t,e,n),i=D("valueDType",t,e,n),o=new Qee(a,i);return s.addHashTable(t.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=D("tableHandle",t,e,n,s),a=D("keys",t,e,n),i=D("values",t,e,n);return[await s.getHashTableById(r.id).import(a,i)]}case"LookupTableFind":case"LookupTableFindV2":{const r=D("tableHandle",t,e,n,s),a=D("keys",t,e,n),i=D("defaultValue",t,e,n);return[await s.getHashTableById(r.id).find(a,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=D("tableHandle",t,e,n,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ete=(t,e,n,s=vs)=>{switch(t.op){case"ResizeBilinear":{const r=D("images",t,e,n),a=D("size",t,e,n),i=D("alignCorners",t,e,n),o=D("halfPixelCenters",t,e,n);return[s.image.resizeBilinear(r,[a[0],a[1]],i,o)]}case"ResizeNearestNeighbor":{const r=D("images",t,e,n),a=D("size",t,e,n),i=D("alignCorners",t,e,n),o=D("halfPixelCenters",t,e,n);return[s.image.resizeNearestNeighbor(r,[a[0],a[1]],i,o)]}case"CropAndResize":{const r=D("image",t,e,n),a=D("boxes",t,e,n),i=D("boxInd",t,e,n),o=D("cropSize",t,e,n),l=D("method",t,e,n),c=D("extrapolationValue",t,e,n);return[s.image.cropAndResize(r,a,i,o,l,c)]}case"ImageProjectiveTransformV3":{const r=D("images",t,e,n),a=D("transforms",t,e,n),i=D("outputShape",t,e,n),o=D("fillValue",t,e,n),l=D("interpolation",t,e,n),c=D("fillMode",t,e,n);return[s.image.transform(r,a,l.toLowerCase(),c.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tte=(t,e,n,s=vs)=>{switch(t.op){case"Equal":return[s.equal(D("a",t,e,n),D("b",t,e,n))];case"NotEqual":return[s.notEqual(D("a",t,e,n),D("b",t,e,n))];case"Greater":return[s.greater(D("a",t,e,n),D("b",t,e,n))];case"GreaterEqual":return[s.greaterEqual(D("a",t,e,n),D("b",t,e,n))];case"Less":return[s.less(D("a",t,e,n),D("b",t,e,n))];case"LessEqual":return[s.lessEqual(D("a",t,e,n),D("b",t,e,n))];case"LogicalAnd":return[s.logicalAnd(D("a",t,e,n),D("b",t,e,n))];case"LogicalNot":return[s.logicalNot(D("a",t,e,n))];case"LogicalOr":return[s.logicalOr(D("a",t,e,n),D("b",t,e,n))];case"Select":case"SelectV2":return[s.where(D("condition",t,e,n),D("a",t,e,n),D("b",t,e,n))];case"BitwiseAnd":return[s.bitwiseAnd(D("a",t,e,n),D("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nte=(t,e,n,s=vs)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(D("a",t,e,n),D("b",t,e,n),D("transposeA",t,e,n),D("transposeB",t,e,n))];case"Einsum":return[s.einsum(D("equation",t,e,n),...D("tensors",t,e,n))];case"Transpose":return[s.transpose(D("x",t,e,n),D("perm",t,e,n))];case"_FusedMatMul":const[r,a]=D("fusedOps",t,e,n),i=r==="biasadd",o=a==="prelu",l=D("numArgs",t,e,n),c=D("leakyreluAlpha",t,e,n);if(i){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[h,p]=D("args",t,e,n);return[s.fused.matMul({a:D("a",t,e,n),b:D("b",t,e,n),transposeA:D("transposeA",t,e,n),transposeB:D("transposeB",t,e,n),bias:h,activation:a,preluActivationWeights:p,leakyreluAlpha:c})];case"MatrixBandPart":return[s.linalg.bandPart(D("a",t,e,n),D("numLower",t,e,n),D("numUpper",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ste=(t,e,n,s=vs)=>{switch(t.op){case"EuclideanNorm":return[s.euclideanNorm(D("x",t,e,n),D("axis",t,e,n),D("keepDims",t,e,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(D("x",t,e,n),D("mean",t,e,n),D("variance",t,e,n),D("offset",t,e,n),D("scale",t,e,n),D("epsilon",t,e,n))];case"FusedBatchNormV3":return[s.batchNorm(D("x",t,e,n),D("mean",t,e,n),D("variance",t,e,n),D("offset",t,e,n),D("scale",t,e,n),D("epsilon",t,e,n))];case"LRN":return[s.localResponseNormalization(D("x",t,e,n),D("radius",t,e,n),D("bias",t,e,n),D("alpha",t,e,n),D("beta",t,e,n))];case"Softmax":return[s.softmax(D("x",t,e,n))];case"LogSoftmax":return[s.logSoftmax(D("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rte=(t,e,n,s=vs)=>{switch(t.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:a}=s.raggedGather(D("paramsNestedSplits",t,e,n),D("paramsDenseValues",t,e,n),D("indices",t,e,n),D("outputRaggedRank",t,e,n));return r.concat(a)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:a}=s.raggedRange(D("starts",t,e,n),D("limits",t,e,n),D("splits",t,e,n));return[r,a]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(D("shape",t,e,n),D("values",t,e,n),D("defaultValue",t,e,n),D("rowPartitionTensors",t,e,n),D("rowPartitionTypes",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ate=(t,e,n,s=vs)=>{switch(t.op){case"Max":{const o=D("axis",t,e,n),l=D("keepDims",t,e,n);return[s.max(D("x",t,e,n),o,l)]}case"Mean":{const o=D("axis",t,e,n),l=D("keepDims",t,e,n);return[s.mean(D("x",t,e,n),o,l)]}case"Min":{const o=D("axis",t,e,n),l=D("keepDims",t,e,n);return[s.min(D("x",t,e,n),o,l)]}case"Sum":{const o=D("axis",t,e,n),l=D("keepDims",t,e,n);return[s.sum(D("x",t,e,n),o,l)]}case"All":{const o=D("axis",t,e,n),l=D("keepDims",t,e,n);return[s.all(D("x",t,e,n),o,l)]}case"Any":{const o=D("axis",t,e,n),l=D("keepDims",t,e,n);return[s.any(D("x",t,e,n),o,l)]}case"ArgMax":{const o=D("axis",t,e,n);return[s.argMax(D("x",t,e,n),o)]}case"ArgMin":{const o=D("axis",t,e,n);return[s.argMin(D("x",t,e,n),o)]}case"Prod":{const o=D("axis",t,e,n),l=D("keepDims",t,e,n);return[s.prod(D("x",t,e,n),o,l)]}case"Cumprod":{const o=D("axis",t,e,n),l=D("exclusive",t,e,n),c=D("reverse",t,e,n);return[s.cumprod(D("x",t,e,n),o,l,c)]}case"Cumsum":{const o=D("axis",t,e,n),l=D("exclusive",t,e,n),c=D("reverse",t,e,n);return[s.cumsum(D("x",t,e,n),o,l,c)]}case"Bincount":const r=D("x",t,e,n),a=D("weights",t,e,n),i=D("size",t,e,n);return[s.bincount(r,a,i)];case"DenseBincount":{const o=D("x",t,e,n),l=D("weights",t,e,n),c=D("size",t,e,n),h=D("binaryOutput",t,e,n);return[s.denseBincount(o,l,c,h)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ite=(t,e,n,s=vs)=>{switch(t.op){case"ConcatV2":case"Concat":{const r=D("n",t,e,n),a=D("axis",t,e,n);let i=D("tensors",t,e,n);return i=i.slice(0,r),[s.concat(i,a)]}case"Gather":{const r=D("x",t,e,n),a=D("indices",t,e,n);return[s.gather(r,s.cast(a,"int32"),0)]}case"GatherV2":{const r=D("axis",t,e,n),a=D("batchDims",t,e,n),i=D("x",t,e,n),o=D("indices",t,e,n);return[s.gather(i,s.cast(o,"int32"),r,a)]}case"Reverse":{const r=D("dims",t,e,n),a=[];for(let o=0;o<r.length;o++)r[o]&&a.push(o);const i=D("x",t,e,n);return[s.reverse(i,a)]}case"ReverseV2":{const r=D("axis",t,e,n),a=D("x",t,e,n);return[s.reverse(a,r)]}case"Slice":{const r=D("begin",t,e,n),a=D("size",t,e,n);return[s.slice(D("x",t,e,n),r,a)]}case"StridedSlice":{const r=D("begin",t,e,n),a=D("end",t,e,n),i=D("strides",t,e,n),o=D("beginMask",t,e,n),l=D("endMask",t,e,n),c=D("ellipsisMask",t,e,n),h=D("newAxisMask",t,e,n),p=D("shrinkAxisMask",t,e,n),f=D("x",t,e,n);return[s.stridedSlice(f,r,a,i,o,l,c,h,p)]}case"Pack":return me(()=>{const r=D("axis",t,e,n),a=D("tensors",t,e,n),i=a[0].shape,o=s.squeeze(a[0]).shape,l=a.map(c=>{const h=Rt(c.shape,i);if(!h&&!Rt(s.squeeze(c).shape,o))throw new Error("the input tensors shape does not match");return h?c:s.reshape(c,i)});return[s.stack(l,r)]});case"Unpack":{const r=D("axis",t,e,n),a=D("tensor",t,e,n);return s.unstack(a,r)}case"Tile":{const r=D("reps",t,e,n);return[s.tile(D("x",t,e,n),r)]}case"Split":case"SplitV":{const r=D("axis",t,e,n),a=D("numOrSizeSplits",t,e,n),i=D("x",t,e,n);return s.split(i,a,r)}case"ScatterNd":{const r=D("indices",t,e,n),a=D("values",t,e,n),i=D("shape",t,e,n);return[s.scatterND(r,a,i)]}case"GatherNd":{const r=D("x",t,e,n),a=D("indices",t,e,n);return[s.gatherND(r,a)]}case"SparseToDense":{const r=D("sparseIndices",t,e,n),a=D("outputShape",t,e,n),i=D("sparseValues",t,e,n),o=D("defaultValue",t,e,n);return[s.sparseToDense(r,i,a,i.dtype===o.dtype?o:s.cast(o,i.dtype))]}case"TensorScatterUpdate":{const r=D("indices",t,e,n),a=D("values",t,e,n),i=D("tensor",t,e,n);return[s.tensorScatterUpdate(i,r,a)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ote=(t,e,n,s=vs)=>{switch(t.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:a,emptyRowIndicator:i,reverseIndexMap:o}=s.sparse.sparseFillEmptyRows(D("indices",t,e,n),D("values",t,e,n),D("denseShape",t,e,n),D("defaultValue",t,e,n));return[r,a,i,o]}case"SparseReshape":{const{outputIndices:r,outputShape:a}=s.sparse.sparseReshape(D("inputIndices",t,e,n),D("inputShape",t,e,n),D("newShape",t,e,n));return[r,a]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(D("data",t,e,n),D("indices",t,e,n),D("segmentIds",t,e,n))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(D("data",t,e,n),D("indices",t,e,n),D("segmentIds",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lte=(t,e,n,s=vs)=>{switch(t.op){case"FFT":return[s.fft(D("x",t,e,n))];case"IFFT":return[s.ifft(D("x",t,e,n))];case"RFFT":return[s.rfft(D("x",t,e,n))];case"IRFFT":return[s.irfft(D("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ute=(t,e,n,s=vs)=>{switch(t.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(D("input",t,e,n),D("pattern",t,e,n),D("rewrite",t,e,n),D("replaceGlobal",t,e,n))];case"StringNGrams":{const{nGrams:r,nGramsSplits:a}=s.string.stringNGrams(D("data",t,e,n),D("dataSplits",t,e,n),D("separator",t,e,n),D("nGramWidths",t,e,n),D("leftPad",t,e,n),D("rightPad",t,e,n),D("padWidth",t,e,n),D("preserveShortSequences",t,e,n));return[r,a]}case"StringSplit":{const{indices:r,values:a,shape:i}=s.string.stringSplit(D("input",t,e,n),D("delimiter",t,e,n),D("skipEmpty",t,e,n));return[r,a,i]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(D("input",t,e,n),D("numBuckets",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cte=(t,e,n,s=vs)=>{switch(t.op){case"Cast":return[s.cast(D("x",t,e,n),D("dtype",t,e,n))];case"ExpandDims":{const r=D("axis",t,e,n);return[s.expandDims(D("x",t,e,n),r)]}case"Squeeze":{const r=D("axis",t,e,n);return[s.squeeze(D("x",t,e,n),r)]}case"Reshape":return[s.reshape(D("x",t,e,n),D("shape",t,e,n))];case"EnsureShape":return[s.ensureShape(D("x",t,e,n),D("shape",t,e,n))];case"MirrorPad":return[s.mirrorPad(D("x",t,e,n),D("padding",t,e,n),D("mode",t,e,n))];case"PadV2":case"Pad":return[s.pad(D("x",t,e,n),D("padding",t,e,n),D("constantValue",t,e,n))];case"SpaceToBatchND":{const r=D("blockShape",t,e,n),a=D("paddings",t,e,n);return[s.spaceToBatchND(D("x",t,e,n),r,a)]}case"BatchToSpaceND":{const r=D("blockShape",t,e,n),a=D("crops",t,e,n);return[s.batchToSpaceND(D("x",t,e,n),r,a)]}case"DepthToSpace":{const r=D("blockSize",t,e,n),a=D("dataFormat",t,e,n).toUpperCase();return[s.depthToSpace(D("x",t,e,n),r,a)]}case"BroadcastTo":return[s.broadcastTo(D("x",t,e,n),D("shape",t,e,n))];case"BroadcastArgs":return[s.broadcastArgs(D("s0",t,e,n),D("s1",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fE(t,e,n,s,r=me){const a=((i,o,l)=>{switch(i.category){case"arithmetic":return r(()=>Bee(i,o,l));case"basic_math":return r(()=>Pee(i,o,l));case"control":return qee(i,o,l);case"convolution":return r(()=>jee(i,o,l));case"creation":return r(()=>Kee(i,o,l));case"dynamic":return Xee(i,o,l);case"evaluation":return r(()=>Yee(i,o,l));case"image":return r(()=>ete(i,o,l));case"graph":return r(()=>Zee(i,o,l));case"logical":return r(()=>tte(i,o,l));case"matrices":return r(()=>nte(i,o,l));case"normalization":return r(()=>ste(i,o,l));case"ragged":return r(()=>rte(i,o,l));case"reduction":return r(()=>ate(i,o,l));case"slice_join":return r(()=>ite(i,o,l));case"sparse":return r(()=>ote(i,o,l));case"spectral":return r(()=>lte(i,o,l));case"string":return r(()=>ute(i,o,l));case"transformation":return r(()=>cte(i,o,l));case"hash_table":return Jee(i,o,l,s);case"custom":const c=qM(i.op);if(c&&c.customExecutor)return c.customExecutor(new Mee(i,o,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return nc(a)?a.then(i=>[].concat(i)):[].concat(a)}class mE{constructor(e={},n={},s={},r={},a){this.weightMap=e,this.tensorArrayMap=n,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,n){return{id:e,frameName:n,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let n=0;n<this.contexts.length-1;n++){const s=this.contexts.slice(0,this.contexts.length-n);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(e);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gE(t,e,n,s){const r=new Set,a=[];let i=null,o=null;const l=new Set,c=new Set(Object.keys(t).map(f=>vr(f)[0]));s=s||[];const h=new Set(s.map(f=>vr(f.name)[0])),p=[...e];for(;p.length>0;){const f=p.pop();if((qu(f)||bte(f)||xte(f))&&i==null&&(i=f,o=i.children.map(g=>g.name).filter(g=>r.has(g))),r.add(f.name),n[f.name]==null&&!c.has(f.name)&&!h.has(f.name)){if(f.inputs.length===0){a.push(f.name);continue}f.inputs.forEach(g=>{l.has(g.name)||(l.add(g.name),p.push(g))})}}return{inputs:t,outputs:e,usedNodes:r,missingInputs:a,dynamicNode:i,syncInputs:o}}function dte(t,e){const{usedNodes:n,inputs:s}=e,r=Object.keys(s).map(w=>vr(w)[0]).map(w=>t.nodes[w]),a=t.initNodes||[],i=w=>n.has(typeof w=="string"?w:w.name);function o(w){return[...new Map(w.map(v=>[v.name,v])).values()]}const l=o([...r,...t.weights,...a]).filter(i),c=o([...l,...Object.values(t.nodes)]).filter(i),h=new Map(c.map(w=>[w.name,w])),p={};for(const w of c){p[w.name]=p[w.name]||0;for(const v of w.children)i(v)||(p[v.name]=Number.POSITIVE_INFINITY),p[v.name]=(p[v.name]||0)+1}const f=Object.entries(p).filter(([,w])=>w===0).map(([w])=>w),g=[...f];for(;f.length>0;){const w=f.pop(),v=h.get(w);for(const $ of v.children.filter(i))--p[$.name]===0&&(g.push($.name),f.push($.name))}const y=g.map(w=>h.get(w)),x=hte(y,l);return pte(x,l),x}function hte(t,e){const n=new Map(t.map(i=>[i.name,i])),s=e.map(i=>i.name),r=new Set(s);for(;s.length>0;){const i=s.pop(),o=n.get(i);for(const l of o.children)!n.has(l.name)||r.has(l.name)||(r.add(l.name),s.push(l.name))}return t.filter(i=>r.has(i.name))}class Ay extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function pte(t,e){const n=new Map(t.map((o,l)=>[o.name,l])),s=new Set(e.map(o=>o.name)),r=o=>s.has(typeof o=="string"?o:o.name),a=new Set(t.map(o=>o.name)),i=o=>a.has(typeof o=="string"?o:o.name);for(const o of t){for(const l of o.children.filter(i)){if(!n.has(l.name))throw new Ay(`Child ${l.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(l.name))throw new Ay(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!r(o))for(const l of o.inputs){if(!n.has(l.name))throw new Ay(`Input ${l.name} of node ${o.name} is unreachable.`);if(n.get(l.name)>n.get(o.name))throw new Ay(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function fte(t){const e=new Map(t.map((o,l)=>[o.name,l])),n=Number.MAX_SAFE_INTEGER,s=t.map((o,l)=>qu(o)?n:l),r=o=>{const l=s[e.get(o.name)];return l??-1},a=t.map((o,l)=>o.children.map(r).reduce((c,h)=>Math.max(c,h),s[l])),i=new Map;for(let o=0;o<t.length;++o){const l=a[o];if(l===n)continue;const c=t[o],h=t[l];i.has(h.name)||i.set(h.name,[]),i.get(h.name).push(c)}return i}const mte=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),gte=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),yte=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function qu(t){return mte.has(t.op)}function bte(t){return gte.has(t.op)}function xte(t){return yte.has(t.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class z0{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const n=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...n),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const n=e.signatureKey||e.name;return e.defaultOutput?`${n}:${e.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((e,n)=>(e[n]=this._functions[n].signature,e),{})}constructor(e,n){this.graph=e,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new z0(e.functions[s],this)})}getCompilationKey(e,n){const s=e.map(a=>a.name).sort(),r=n.map(a=>a.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,n){const s=gE(e,n,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:i}=s;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(r.length>0){const c=n.map(p=>p.name),h=Object.keys(e);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${h}]. Missing the following inputs: [${r}]`)}const o=dte(this.graph,s),l=fte(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const n=e.clone();return ss(n),n}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([n,s])=>[n,this.cloneTensorList(s)]))}execute(e,n){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n);const r=s.map(f=>this.graph.nodes[vr(f)[0]]),a=n.map(f=>vr(f)[0]),i=new Set(a);let o=a.map(f=>this.graph.nodes[f]);o.length===0&&(o=this._outputs);const l=this.getCompilationKey(r,o);let c=this.compiledMap.get(l);c==null&&(c=this.compile(e,o),this.compiledMap.set(l,c));try{this.keepIntermediateTensors=ye().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const h={},p={};return me(()=>{const f=new mE(this.weightMap,h,p,this.functionExecutorMap,this.parseNodeNameCache),g=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(v=>{const[$,T]=vr(v,f),C=[];C[T]=e[v],g[$]=C,this.keepIntermediateTensors&&(this.clonedTensorsMap[$]=this.cloneTensorList(C))});const y=this.getFrozenTensorIds(g),{orderedNodes:x,nodeLiveUntilMap:w}=c;for(const v of x){if(g[v.name])continue;const $=fE(v,g,f,this._resourceManager);if(nc($))throw new Error(`The execution of the op '${v.op}' returned a promise. Please use model.executeAsync() instead.`);g[v.name]=$,this.keepIntermediateTensors&&(this.clonedTensorsMap[v.name]=this.cloneTensorList($)),this.checkTensorForDisposalWithNodeLiveUntilInfo(v,g,f,y,i,w.get(v.name))}return this.parent==null&&f.dispose(y),n.map(v=>ms(v,g,f))})}getFrozenTensorIds(e){const n=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(n)}checkTensorForDisposal(e,n,s,r,a,i,o){if(!(qu(n)||i.has(e))){for(const l of s[e])l!=null&&(o[l.id]=(o[l.id]||0)+n.children.length);for(const l of n.inputs){if(qu(l))continue;const c=uE(l.name,s,r);if(c!=null)for(const h of c){if(!h||h.kept||a.has(h.id))continue;const p=o[h.id];p===1?(h.dispose(),delete o[h.id]):p!=null&&o[h.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,n,s,r,a,i){function o(l){return qu(l)||a.has(l.name)}if(!(qu(e)||i==null))for(const l of i){if(o(l))continue;const c=uE(l.name,n,s);for(const h of c)!h||h.kept||r.has(h.id)||h.dispose()}}async executeAsync(e,n){return this._executeAsync(e,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const n of e)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,n,s=!1,r={},a={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=ye().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const i=new mE(this.weightMap,r,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const o=await this.executeWithControlFlow(e,i,n,s),l=n.map(f=>ms(f,o,i)),c=l.map(f=>f.id),h=Object.keys(e).map(f=>e[f].id),p=new Set([...c,...h,...this.weightIds]);return Object.values(o).forEach(f=>{f.forEach(g=>{g&&!g.isDisposed&&!p.has(g.id)&&g.dispose()})}),this.parent==null&&i.dispose(p),l}async executeFunctionAsync(e,n,s){const r=e.reduce((a,i,o)=>(a[this.inputs[o].name]=i,a),{});return this._executeAsync(r,this.outputNodes,!0,n,s)}async executeWithControlFlow(e,n,s,r){const a=Object.keys(e),i=a.map(C=>this.graph.nodes[vr(C)[0]]),o=s.map(C=>vr(C)[0]),l=new Set(o);let c=o.map(C=>this.graph.nodes[C]);c.length===0&&(c=this._outputs);const{usedNodes:h,missingInputs:p,dynamicNode:f,syncInputs:g}=gE(e,c,this.weightMap,this._initNodes),y=[...i,...this.graph.weights,...this._initNodes||[]].map(C=>({node:C,contexts:n.currentContext})),x=Object.assign({},this.weightMap);Object.keys(e).forEach(C=>{const[I,A]=vr(C),O=[];O[A]=e[C],x[I]=O});const w={},v=this.getFrozenTensorIds(x),$={};for(;y.length>0;){const C=this.processStack(i,y,n,x,$,v,l,w,h);await Promise.all(C)}f==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const T=c.filter(C=>!qu(C)&&!ms(C.name,x,n)).map(C=>C.name);if(T.length>0){let C="";throw f!=null&&(C=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${g}]`),new Error(`Cannot compute the outputs [${T}] from the provided inputs [${a}]. Consider providing the following inputs: [${p}]. ${C}`)}return x}processStack(e,n,s,r,a,i,o,l,c){const h=[];for(;n.length>0;){const p=n.pop();s.currentContext=p.contexts;let f="";if(p.node.op==="Enter"&&D("isConstant",p.node,r,s)&&([f]=bo(p.node.name,s)),r[p.node.name]==null){const g=fE(p.node,r,s,this._resourceManager);f||([f]=bo(p.node.name,s));const y=s.currentContext;nc(g)?h.push(g.then(x=>(r[f]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(x)),s.currentContext=y,this.checkTensorForDisposal(f,p.node,r,s,i,o,l),this.processChildNodes(p.node,n,s,r,a,c),x))):(r[f]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(g)),this.checkTensorForDisposal(f,p.node,r,s,i,o,l),this.processChildNodes(p.node,n,s,r,a,c))}else this.processChildNodes(p.node,n,s,r,a,c)}return h}processChildNodes(e,n,s,r,a,i){e.children.forEach(o=>{const[l]=bo(o.name,s);a[l]||!i.has(o.name)||(o.op==="Merge"?o.inputNames.some(c=>!!ms(c,r,s))&&(a[l]=!0,n.push({contexts:s.currentContext,node:o})):o.inputNames.every(c=>!!ms(c,r,s))&&(a[l]=!0,n.push({contexts:s.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(n=>n.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(n=>{const s=e[n],[r]=vr(n),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){const i=a.attrParams.shape.value,o=i.length===s.shape.length&&s.shape.every((l,c)=>i[c]===-1||i[c]===l);V(o,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${i}], but was [${s.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&V(s.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var n,s;const r={};for(const a in e){const i=(s=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||s===void 0?void 0:s[a];i!=null?r[i.name]=e[a]:r[a]=e[a]}return r}checkInputs(e){const n=Object.keys(e).filter(s=>{const[r]=vr(s);return this.graph.nodes[r]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(e){return e.map(n=>{var s,r;const a=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[n];return a!=null?a.name:n},{})}checkOutputs(e){e.forEach(n=>{const[s]=vr(n);if(!this.graph.nodes[s])throw new Error(`The output '${n}' is not found in the graph`)})}}class wte{constructor(e={},n={}){this.hashTableNameToHandle=e,this.hashTableMap=n}addHashTable(e,n){this.hashTableNameToHandle[e]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vte="?tfjs-format=file",$te="model.json";class Ste{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,n={},s=Xz){this.modelUrl=e,this.loadOptions=n,this.version="n/a",this.io=s,n==null&&(this.loadOptions={}),this.resourceManager=new wte}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const n=this.io.getLoadHandlers(e,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[e]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return nc(e)?e.then(n=>n.getWeightStream==null?this.loadSync(n):this.loadStreaming(n)):this.loadSync(e)}loadSync(e){const n=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,n)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const n=await wO(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,n)}loadWithWeightMap(e,n){this.artifacts=e;const s=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const a=this.artifacts.userDefinedMetadata;a.signature!=null&&(r=a.signature),a.structuredOutputKeys!=null&&(this.structuredOutputKeys=a.structuredOutputKeys)}if(this.signature=r,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new z0(cE.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(n),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const a=cE.Instance.transformGraph(e.modelInitializer);this.initializer=new z0(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,n){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const n=e instanceof yn?[e]:e,s={};return n.forEach((r,a)=>s[this.structuredOutputKeys[a]]=r),s}return e}predict(e,n){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,n){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var n;if(!(e instanceof yn)&&!Array.isArray(e)){const a=(n=this.signature)===null||n===void 0?void 0:n.inputs;if(a!=null)for(const i in a){const o=a[i];o.resourceId!=null&&(e[i]=this.resourceIdToCapturedInput[o.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((a,i)=>{var o,l,c;const h=(c=(l=(o=this.signature)===null||o===void 0?void 0:o.inputs)===null||l===void 0?void 0:l[i])===null||c===void 0?void 0:c.resourceId;return h!=null?a[i]=this.resourceIdToCapturedInput[h]:a[i]=e[r++],a},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const n=this.initializerSignature.outputs,s=Object.keys(n);for(let r=0;r<s.length;r++){const a=s[r],i=n[a];this.resourceIdToCapturedInput[i.resourceId]=e[r]}}}execute(e,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const s=this.executor.execute(e,n);return s.length>1?s:s[0]}async executeAsync(e,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const s=await this.executor.executeAsync(e,n);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((n,s)=>(n[s]=[e[s]],n),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&$t(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function _te(t,e={},n=Xz){if(t==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof t=="string"&&(t=Cte(t));const s=new Ste(t,e,n);return await s.load(),s}function Cte(t){return t.endsWith("/")||(t=t+"/"),`${t}${$te}${vte}`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var yE;(function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"})(yE||(yE={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ye(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&V(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tte=__;class Ux extends L2{nextDataId(){return Ux.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new qD(this,Ua())}write(e,n,s){this.firstUse&&(this.firstUse=!1,ye().get("IS_NODE")&&Gr(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,n,s){let r;if(n==="string"&&s!=null&&s.length>0&&Ef(s[0])){const a=s.map(i=>Il(i));r=this.write(a,e,n)}else r=this.write(s,e,n);return{dataId:r,shape:e,dtype:n}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const n=this.data.get(e);n.refCount++}decRef(e){if(this.data.has(e)){const n=this.data.get(e);n.refCount--}}move(e,n,s,r,a){this.data.set(e,{values:n,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:n,complexTensorInfos:s}=this.data.get(e);if(n==="complex64"){const r=this.readSync(s.real.dataId),a=this.readSync(s.imag.dataId);return ko(r,a)}return I6(this.data.get(e).values,n)}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const s=n.map(r=>Rl(r));return xt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return xt(e.shape,e.dtype,n)}makeOutput(e,n,s){return Ua().makeTensorFromTensorInfo(this.makeTensorInfo(n,s,e),this)}disposeData(e,n=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!n&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const n=sr();return e(),{kernelMs:sr()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Ye([e],"where");const n=this.readSync(e.dataId);return Tte(e.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Ux.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XM(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}const kte=t=>{const{x:e}=t.inputs,n=t.backend;Ye(e,"abs");let s=new Float32Array($e(e.shape));const r=n.data.get(e.dataId).values;return s=XM(r),n.makeOutput(s,e.shape,e.dtype)},Nte={kernelName:nb,backendName:"cpu",kernelFunc:kte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zn(t){return(e,n,s,r,a)=>{const i=ft(e,n),o=i.length,l=nt(i),c=$e(i),h=ys(a,c),p=e.length,f=n.length,g=nt(e),y=nt(n),x=Pd(e,i),w=Pd(n,i);if(x.length+w.length===0)for(let v=0;v<h.length;++v)h[v]=t(s[v%s.length],r[v%r.length]);else for(let v=0;v<h.length;++v){const $=eh(v,o,l),T=$.slice(-p);x.forEach(O=>T[O]=0);const C=_i(T,p,g),I=$.slice(-f);w.forEach(O=>I[O]=0);const A=_i(I,f,y);h[v]=t(s[C],r[A])}return[h,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $r(t){const{inputs:e,backend:n}=t,{real:s,imag:r}=e,a=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values,o=n.makeTensorInfo(s.shape,"complex64"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(s.shape,"float32",a),imag:n.makeTensorInfo(r.shape,"float32",i)},o}const Ite={kernelName:j2,backendName:"cpu",kernelFunc:$r};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F0(t,e,n="float32"){if(n==="complex64"){const r=F0(t,e,"float32"),a=F0(t,e,"float32");return $r({inputs:{real:r,imag:a},backend:t})}const s=Rs($e(e),n);return t.makeTensorInfo(e,n,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ri(t){const{inputs:e,backend:n}=t,{x:s}=e;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const Ete={kernelName:Zf,backendName:"cpu",kernelFunc:Ri};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pc(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.data.get(s.dataId).complexTensorInfos.real,a=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,a)}const Ate={kernelName:CS,backendName:"cpu",kernelFunc:pc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YM(t,e,n,s){if(s==="int32"){const r=Int32Array.from(t);return[e,"int32",r]}if(s==="bool"){const r=wc([0],n),[a,i]=zn((o,l)=>o!==l?1:0)(e,[],t,r,"bool");return[i,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${s}`)}function Vl(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dtype:a}=s;if(a==="complex64"){if(r.dtype==="complex64")return Ri({inputs:{x:r},backend:n});const h=F0(n,r.shape,r.dtype),p=Vl({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),f=$r({inputs:{real:p,imag:h},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}if(r.dtype==="complex64"){const h=pc({inputs:{input:r},backend:n}),p=Vl({inputs:{x:h},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(h),p}if(!KD(r.dtype,a)){const h=Ri({inputs:{x:r},backend:n});return{dataId:h.dataId,shape:h.shape,dtype:a}}const i=n.data.get(r.dataId).values,[o,l,c]=YM(i,r.shape,r.dtype,a);return n.makeTensorInfo(o,l,c)}const Rte={kernelName:Mf,backendName:"cpu",kernelFunc:Vl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qn(t,e,n,s){return n==null?({inputs:r,backend:a})=>{const{a:i,b:o}=r,l=a;Ye([i,o],t);const c=l.data.get(i.dataId).values,h=l.data.get(o.dataId).values,p=i.dtype==="string"?No(c):c,f=i.dtype==="string"?No(h):h,g=s||i.dtype,[y,x]=e(i.shape,o.shape,p,f,g);return l.makeTensorInfo(x,g,y)}:({inputs:r,backend:a})=>{const{a:i,b:o}=r,l=a;if(i.dtype==="complex64"||o.dtype==="complex64"){const c=Vl({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),h=l.data.get(c.dataId),p=h.complexTensorInfos.real,f=h.complexTensorInfos.imag,g=l.data.get(p.dataId).values,y=l.data.get(f.dataId).values,x=Vl({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),w=l.data.get(x.dataId),v=w.complexTensorInfos.real,$=w.complexTensorInfos.imag,T=l.data.get(v.dataId).values,C=l.data.get($.dataId).values,[I,A,O]=n(i.shape,o.shape,g,y,T,C),B=l.makeTensorInfo(O,"float32",I),z=l.makeTensorInfo(O,"float32",A),P=$r({inputs:{real:B,imag:z},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(x),l.disposeIntermediateTensorInfo(B),l.disposeIntermediateTensorInfo(z),P}else{const c=l.data.get(i.dataId).values,h=l.data.get(o.dataId).values,p=s||i.dtype,[f,g]=e(i.shape,o.shape,c,h,p);return l.makeTensorInfo(g,p,f)}}}function NC(t){return(e,n,s,r,a,i)=>{const o=ft(e,n),l=$e(o),c=o.length,h=nt(o),p=ys("float32",l),f=ys("float32",l),g=Pd(e,o),y=Pd(n,o),x=ko(s,r),w=ko(a,i),v=e.length,$=nt(e),T=n.length,C=nt(n);if(g.length+y.length===0)for(let I=0;I<p.length;I++){const A=I%x.length,O=I%w.length,B=t(x[A*2],x[A*2+1],w[O*2],w[O*2+1]);p[I]=B.real,f[I]=B.imag}else for(let I=0;I<p.length;I++){const A=eh(I,c,h),O=A.slice(-v);g.forEach(K=>O[K]=0);const B=_i(O,v,$),z=A.slice(-T);y.forEach(K=>z[K]=0);const P=_i(z,T,C),F=t(x[B*2],x[B*2+1],w[P*2],w[P*2+1]);p[I]=F.real,f[I]=F.imag}return[p,f,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZM=zn((t,e)=>t+e),Dte=NC((t,e,n,s)=>({real:t+n,imag:e+s})),Gd=Qn(th,ZM,Dte),Ote={kernelName:th,backendName:"cpu",kernelFunc:Gd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IC(t,e,n,s,r){const a=$e(s),i=Rs(r,n);for(let o=0;o<t.length;o++){const l=t[o];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(a>0?i[l]+=e[o]:i[l]+=1)}return i}function QM(t,e,n,s=!1){const r=t.shape[0],a=t.shape[1],i=xt([r,n],e.dtype);for(let o=0;o<r;o++)for(let l=0;l<a;l++){const c=t.get(o,l);if(c<0)throw new Error("Input x must be non-negative!");c>=n||(s?i.set(1,o,c):e.size>0?i.set(i.get(o,c)+e.get(o,l),o,c):i.set(i.get(o,c)+1,o,c))}return i}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JM=zn((t,e)=>t&e),zte=Qn(cb,JM),Fte={kernelName:cb,backendName:"cpu",kernelFunc:zte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fi(t){return(e,n,s)=>{const r=An(n,e.length);for(let a=0;a<e.length;++a)r[a]=t(e[a],s);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jt(t,e,n){const s=Fi(e);return Jl(t,s,n)}function Jl(t,e,n){return({inputs:s,attrs:r,backend:a})=>{const{x:i}=s;Ye(i,t);const o=a,l=o.data.get(i.dataId).values;let c;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=No(l)}else c=l;const h=n||i.dtype,p=e(c,h,r);return o.makeTensorInfo(i.shape,h,p)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e4=Fi(t=>Math.ceil(t)),Lte=Jl(Bf,e4),Mte={kernelName:Bf,backendName:"cpu",kernelFunc:Lte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t4(t,e,n,s){const r=An(n,$e(e));if(s&&n!=="string"){let a=0;t.forEach(i=>{const o=$e(i.shape);r.set(i.vals,a),a+=o})}else{let a=0;t.forEach(i=>{const o=n==="string"?No(i.vals):i.vals;let l=0;for(let c=0;c<i.shape[0];++c){const h=c*e[1]+a;for(let p=0;p<i.shape[1];++p)r[h+p]=o[l++]}a+=i.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n4=zn((t,e)=>t===e?1:0),s4=Qn(xb,n4,null,"bool"),Bte={kernelName:xb,backendName:"cpu",kernelFunc:s4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r4=Fi(t=>Math.exp(t)),a4=Jl(qf,r4,"float32"),Pte={kernelName:qf,backendName:"cpu",kernelFunc:a4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i4=Fi(t=>Math.expm1(t)),Vte=Jl(jf,i4),Ute={kernelName:jf,backendName:"cpu",kernelFunc:Vte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o4=Fi(t=>Math.floor(t)),Wte=Jl(Kf,o4),Gte={kernelName:Kf,backendName:"cpu",kernelFunc:Wte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l4=zn((t,e)=>Math.floor(t/e)),Hte=Qn(Xf,l4,null,"int32"),qte={kernelName:Xf,backendName:"cpu",kernelFunc:Hte};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u4(t,e,n,s,r,a,i,o,l){const c=xt([s,a],n);for(let h=0;h<s;h++){const p=[];let f=0;for(let g=0;g<r;g++){const y=t[h*r+g];f+=y*i[g],p.push(y)}if(f<0||f>=l/a)throw new Error(`Invalid indices: ${p} does not index into ${o}`);for(let g=0;g<a;g++)c.values[h*a+g]=e.get(...e.indexToLoc(f*a+g))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c4(t,e,n){const s=xt(n,t.dtype);for(let r=0;r<s.size;++r){const i=s.indexToLoc(r).slice(),o=i[0],l=i[2],c=e.locToIndex([o,l]);i[2]=e.values[c];const h=t.locToIndex(i);0<=h&&h<t.values.length&&(s.values[r]=t.values[h])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d4=zn((t,e)=>t>e?1:0),jte=Qn(Sb,d4,null,"bool"),Kte={kernelName:Sb,backendName:"cpu",kernelFunc:jte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h4=zn((t,e)=>t>=e?1:0),Xte=Qn(Yf,h4,null,"bool"),Yte={kernelName:Yf,backendName:"cpu",kernelFunc:Xte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p4=zn((t,e)=>t<e?1:0),Zte=Qn(Cb,p4,null,"bool"),Qte={kernelName:Cb,backendName:"cpu",kernelFunc:Zte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f4=zn((t,e)=>t<=e?1:0),Jte=Qn(Tb,f4,null,"bool"),ene={kernelName:Tb,backendName:"cpu",kernelFunc:Jte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m4(t,e,n){const s=(e-t)/(n-1),r=Rs(n,"float32");r[0]=t;for(let a=1;a<r.length;a++)r[a]=r[a-1]+s;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g4=Fi(t=>Math.log(t)),tne=Jl(tm,g4),nne={kernelName:tm,backendName:"cpu",kernelFunc:tne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y4(t,e,n,s){const r=ys(s,$e(n));for(let a=0;a<r.length;++a){const i=a*e;let o=t[i];for(let l=0;l<e;++l){const c=t[i+l];(Number.isNaN(c)||c>o)&&(o=c)}r[a]=o}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b4=zn((t,e)=>Math.max(t,e)),sne=Qn(sm,b4),rne={kernelName:sm,backendName:"cpu",kernelFunc:sne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x4=zn((t,e)=>Math.min(t,e)),ane=Qn(rm,x4),ine={kernelName:rm,backendName:"cpu",kernelFunc:ane};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EC=zn((t,e)=>t*e),one=NC((t,e,n,s)=>({real:t*n-e*s,imag:t*s+e*n})),Wx=Qn(im,EC,one),lne={kernelName:im,backendName:"cpu",kernelFunc:Wx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w4(t,e,n){const s=Gl(-1,n);return EC([],e,s,t,n)}function une(t){const{inputs:e,backend:n}=t,{x:s}=e;Ye(s,"neg");const r=n.data.get(s.dataId).values,[a,i]=w4(r,s.shape,s.dtype);return n.makeTensorInfo(i,s.dtype,a)}const cne={kernelName:Lb,backendName:"cpu",kernelFunc:une};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v4=zn((t,e)=>t!==e?1:0),dne=Qn(Mb,v4,null,"bool"),hne={kernelName:Mb,backendName:"cpu",kernelFunc:dne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AC(t,e,n,s,r){const a=e.length,i=$e(e),o=nt(e),l=nt(r),c=ys(n,$e(r));for(let h=0;h<i;++h){const p=eh(h,a,o),f=new Array(p.length);for(let y=0;y<f.length;y++)f[y]=p[s[y]];const g=_i(f,a,l);c[g]=t[h]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lr(t){const{inputs:e,attrs:n,backend:s}=t,{x:r}=e,{perm:a}=n;Ye(r,"transpose");const i=r.shape.length,o=new Array(i);for(let p=0;p<o.length;p++)o[p]=r.shape[a[p]];const l=s.data.get(r.dataId).values,c=AC(l,r.shape,r.dtype,a,o);return{dataId:s.write(c,o,r.dtype),shape:o,dtype:r.dtype}}const pne={kernelName:Ad,backendName:"cpu",kernelFunc:lr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $4(t,e,n,s){const[r,a]=ls(t,s),i=_r(e,"int32"),o=Rs($e(r),i),l=$e(a);for(let c=0;c<o.length;++c){const h=c*l;let p=1;for(let f=0;f<l;++f)p*=n[h+f];o[c]=p}return{outVals:o,outShape:r,outDtype:i}}function fne(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s;Ye(r,"prod");const o=r.shape.length,l=St(a,r.shape),c=wn(l,o);let h=l,p=r;const f=[];c!=null&&(p=lr({inputs:{x:r},backend:n,attrs:{perm:c}}),f.push(p),h=Dn(h.length,o));const g=n.data.get(p.dataId).values,{outVals:y,outShape:x,outDtype:w}=$4(p.shape,p.dtype,g,h);let v=x;return i&&(v=Rn(x,l)),f.forEach($=>n.disposeIntermediateTensorInfo($)),n.makeTensorInfo(v,w,y)}const mne={kernelName:Gb,backendName:"cpu",kernelFunc:fne};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gne(t,e,n){t.forEach((s,r)=>{if(s<0||s>=n){const a=eh(r,e.length,nt(e)).join(",");throw new Error(`indices[${a}] = ${s} is not in [0, ${n})`)}})}function yne(t,e){for(let n=0;n<t.length;++n){const s=t[n],r=n===t.length-1?e:t[n+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let a=1;a<s.length;++a)if(s[a-1]>s[a])throw new Error("Ragged splits must be sorted in ascending order")}}function bne(t,e,n,s){const r=[];let a=0;const i=e.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);yne(n,s);let l=1;for(let c=0;c<e.length-1;++c){l*=e[c];const h=e[c+1];for(let p=1;p<l+1;++p)o[c].push(p*h)}for(let c=0;c<t.length;++c){let h=t[c],p=t[c]+1;for(let f=0;f<n.length;++f){const g=n[f],y=f+e.length-1;if(y>=0){const x=o[y],w=x[x.length-1]-g[h];for(let v=h;v<p;++v)o[y].push(g[v+1]+w)}h=g[h],p=g[p]}p!==h&&(r.push([h,p]),a+=p-h)}return{outSplits:o,valueSlices:r,numValues:a}}function xne(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n].length,r=An("int32",s);e.push(r),t[n].forEach((a,i)=>r[i]=a)}return e}function bE(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let s=e;s<t.length;s++)n[e-1]*=t[s];return n}function wne(t,e,n,s,r,a){const i=bE(e,2)[1],o=bE(a,2)[1];let l=0;for(const c of n)for(let h=c[0];h<c[1];++h){for(let p=0;p<s;++p)r[l*o+p]=t[h*i+p];++l}}function vne(t,e,n,s,r){const a=e.slice();a[0]=r;const i=An(n,$e(a)),o=t.length,l=o===0?0:o/e[0];return wne(t,e,s,l,i,a),[i,a]}function S4(t,e,n,s,r,a,i,o){if(t.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(gne(a,i,l),s.length===0)throw new Error("params.rank must be nonzero");const c=s[0],{outSplits:h,valueSlices:p,numValues:f}=bne(a,i,t,c),g=xne(h),y=vne(n,s,r,p,f);return[g,y[0],y[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xE=2147483647;function _4(t,e,n,s,r,a,i){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=e.length===0,l=r.length===0,c=i.length===0,h=[];o||h.push(e[0]),l||h.push(r[0]),c||h.push(i[0]);for(let w=1;w<h.length;++w)if(h[w]!==h[w-1])throw new Error("starts, limits, and deltas must have the same shape");const p=h.length===0?1:h[0],f=An("int32",p+1);f[0]=0;for(let w=0;w<p;++w){const v=o?t[0]:t[w],$=l?s[0]:s[w],T=c?a[0]:a[w];if(T===0)throw new Error("Requires delta != 0");let C;if(T>0&&$<v||T<0&&$>v)C=0;else if(C=Math.ceil(Math.abs(($-v)/T)),C>xE)throw new Error(`Requires ((limit - start) / delta) <= ${xE}`);f[w+1]=f[w]+C}const g=f[p],y=An(n,g);let x=0;for(let w=0;w<p;++w){const v=f[w+1]-f[w];let $=o?t[0]:t[w];const T=c?a[0]:a[w];for(let C=0;C<v;++C)y[x++]=$,$+=T}return[f,y]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var da=Ga;class L0{constructor(e,n,s,r,a,i,o,l,c,h){this.shape=e,this.shapeShape=n,this.values=s,this.valuesShape=r,this.valuesDType=a,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=iF(h),this.raggedRank=oF(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===da.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===da.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const n=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case da.VALUE_ROWIDS:return L0.getMaxWidthValueRowID(n);case da.ROW_SPLITS:return L0.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${da[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const n=e.length;if(n===0||n===1)return 0;let s=0;for(let r=0;r<n-1;++r){const a=e[r+1]-e[r];a>s&&(s=a)}return s}static getMaxWidthValueRowID(e){const n=e.length;if(n===0)return 0;let s=0,r=e[0],a=0;for(let i=1;i<n;++i){const o=e[i];o!==r&&(r=o,a=Math.max(i-s,a),s=i)}return Math.max(n-s,a)}tensorShapeFromTensor(e,n,s=!0){if(n.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return vE(e,s)}calculateOutputSize(e){const n=this.valuesShape,s=this.defaultValueShape;lF(s,n);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=aF(this.raggedRank,r,n);i[0]<0&&(i[0]=e);for(let o=1;o<=this.raggedRank;++o)i[o]<0&&(i[o]=this.getMaxWidth(o));return i}calculateFirstParentOutputIndex(e,n,s){const r=Math.min(e,s),a=[];let i=0;for(let o=0;o<r;++o,i+=n)a.push(i);for(let o=r;o<e;++o)a.push(-1);return V(a.length===e,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(e,n,s,r){const a=e.length,i=[];for(let o=0;o<a-1;++o){const l=e[o+1]-e[o];let c=Math.min(r,l),h=n[o];h===-1&&(c=0);for(let p=0;p<c;++p)i.push(h),h+=s;for(let p=0;p<l-c;++p)i.push(-1)}if(a>0&&i.length!==e[a-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,n,s,r){const a=e.length,i=[];if(a===0)return[];let o=0,l=e[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let c=n[l];i.push(c);for(let h=1;h<a;++h){const p=e[h];if(p===l)c>=0&&(++o,o<r?c+=s:c=-1);else{if(o=0,l=p,p>=n.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${n.length}`);c=n[p]}i.push(c)}if(i.length!==e.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(e,n,s,r){const a=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case da.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,n,s,r);case da.ROW_SPLITS:if(a.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(a,n,s,r);default:throw new Error(`Unsupported partition type: ${da[i]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case da.FIRST_DIM_SIZE:return e[0];case da.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case da.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${da[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const n=this.getFirstDimensionSize(),s=this.calculateOutputSize(n),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let l=r.length-2;l>=0;--l)r[l]=r[l+1]*s[l+1];const a=vE(s,!1),i=An(this.valuesDType,$e(a));if(r[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(n,r[0],s[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,r[c],s[c]);this.setOutput(this.raggedRank,l,i,a)}return[a,i]}setOutput(e,n,s,r){if(s.length===0)return;const a=this.values,i=s;let o=r.slice();o=o.slice(e+1);const l=$e(o),c=n.length;let h=this.defaultValue;if(h.length!==l&&h.length!==1){const y=this.defaultValueShape;me(()=>{const x=le(h,y);h=Od(x,o).dataSync()})}let p=0,f=0,g=0;for(let y=0;y<=c;++y){let x=y<c?n[y]:-1;if(x===g){++g;continue}if(f<g){const w=a.subarray(p*l),v=i.subarray(f*l),$=(g-f)*l;wE(v,w,$)}if(y>=c){const w=s.length;x=Math.floor(w/l)}if(x>g)if(this.defaultValue.length===1)i.subarray(g*l,x*l).fill(this.defaultValue[0]),g=x;else for(;x>g;){const w=i.slice(g*l);wE(w,h,l),++g}x<0?(p=y+1,f=g):(p=y,f=g,g=f+1)}}}function wE(t,e,n){for(let s=0;s<n;s++)t[s]=e[s]}function vE(t,e){const n=[];for(let s of t){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}n.push(s)}return n}function C4(t,e,n,s,r,a,i,o,l,c){return new L0(t,e,n,s,r,a,i,o,l,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T4(t,e,n,s){const r=t===e,a=t<e&&n<0,i=e<t&&n>1;if(r||a||i)return Rs(0,s);const o=Math.abs(Math.ceil((e-t)/n)),l=Rs(o,s);e<t&&n===1&&(n=-1),l[0]=t;for(let c=1;c<l.length;c++)l[c]=l[c-1]+n;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k4=Fi(t=>1/Math.sqrt(t)),$ne=Jl(hm,k4),Sne={kernelName:hm,backendName:"cpu",kernelFunc:$ne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qu(t,e,n,s,r,a,i,o,l,c){const h=[s/r,r],p=t.values,f=e.values;if(s===0)return xt(n,e.dtype);const g=l instanceof Kn?l:xt(h,e.dtype);typeof l=="string"||typeof l=="number"?g.values.fill(l):typeof l=="boolean"&&g.values.fill(+l);for(let y=0;y<a;y++){const x=[];let w=0;for(let v=0;v<i;v++){const $=p[y*i+v];x.push($),w+=$*o[v]}if(w<0||w>=s/r)throw new Error(`Invalid indices: ${x} does not index into ${n}`);for(let v=0;v<r;v++)c?g.values[w*r+v]+=f[y*r+v]:g.values[w*r+v]=e.rank===0?f[0]:f[y*r+v]}return g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ne=Fi(t=>1/(1+Math.exp(-t))),N4=Jt(ym,t=>1/(1+Math.exp(-t))),Cne={kernelName:ym,backendName:"cpu",kernelFunc:N4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I4(t,e,n,s,r){const a=L_(s,e,n),i=$e(n),o=nt(s);if(a){const p=M_(e,o);return r==="string"?t.slice(p,p+i):t.subarray(p,p+i)}const l=r==="string"?No(t):t,c=xt(s,r,l),h=xt(n,r);for(let p=0;p<h.size;++p){const f=h.indexToLoc(p),g=f.map((y,x)=>y+e[x]);h.set(c.get(...g),...f)}return r==="string"?NF(h.values):h.values}function fc(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:a,size:i}=s;Ye(r,"slice");const[o,l]=Nx(r,a,i);z_(r,o,l);const c=n.data.get(r.dataId).values,h=I4(c,o,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,h)}const Tne={kernelName:Yb,backendName:"cpu",kernelFunc:fc};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E4(t,e,n,s,r,a,i){const o=e[0],l=a[0],c=new Array(l),h=new Array(o),p=e[1];if(l===0){if(o!==0)throw new Error(mF(o));const w=An(n,0),v=An(r,0);return[w,[0,p],v,c,h]}let f=!0,g=0;const y=new Array(l).fill(0);for(let w=0;w<o;++w){const v=t[w*p];if(v<0)throw new Error(gF(w,v));if(v>=l)throw new Error(yF(w,v,l));++y[v],f=f&&v>=g,g=v}let x=!0;for(let w=0;w<l;++w){const v=y[w]===0;c[w]=v,x=x&&!v,y[w]=Math.max(y[w],1),w>0&&(y[w]+=y[w-1])}if(x&&f){const w=t,v=s;for(let $=0;$<o;++$)h[$]=$;return[w,[o,p],v,c,h]}else{const w=y[l-1],v=An(n,w*p),$=An(r,w),T=new Array(l).fill(0);for(let C=0;C<o;++C){const I=t[C*p],A=T[I],O=(I===0?0:y[I-1])+A;T[I]++;for(let B=0;B<p;++B)v[O*p+B]=t[C*p+B];$[O]=s[C],h[C]=O}for(let C=0;C<l;++C)if(T[C]===0){const A=C===0?0:y[C-1];v[A*p+0]=C;for(let O=1;O<p;++O)v[A*p+O]=0;$[A]=i}return[v,[w,p],$,c,h]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A4(t,e,n,s,r){const a=$e(s),i=e[0],o=r.length,l=[];let c=1,h=-1;for(let w=0;w<o;++w){const v=r[w];if(v===-1){if(h!==-1)throw new Error(bF(h,w));h=w,l.push(1)}else{if(v<0)throw new Error(xF(w,v));c*=v,l.push(v)}}if(h!==-1){if(c<=0)throw new Error(wF());const w=Math.trunc(a/c);if(c*w!==a)throw new Error(vF(s,l));l[h]=w}if($e(l)!==a)throw new Error($F(s,l));const f=s.length,g=[];if(f>0){g[f-1]=1;for(let w=f-2;w>=0;--w)g[w]=g[w+1]*s[w+1]}const y=[];if(o>0){y[o-1]=1;for(let w=o-2;w>=0;--w)y[w]=y[w+1]*l[w+1]}const x=An(n,i*o);for(let w=0;w<i;++w){let v=0;for(let $=0;$<f;++$)v+=t[w*f+$]*g[$];for(let $=0;$<o;++$)x[w*o+$]=Math.trunc(v/y[$]),v%=y[$]}return[x,[i,o],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RC(t,e,n,s,r,a=!1,i=0){const o=s.length,l=[e[0],t.length/e[0]],c=l[1],p=o>0?r[o-1]+1:0;if(p<0)throw new Error(W$());const f=e.slice();f[0]=p;const g=f.reduce((T,C)=>T*C,1),y=An(n,g);if(o===0)return p>0&&y.fill(i),[y,f];if(p<=0)throw new Error(W$());let x=0,w=1,v=0,$=r[x];for(;;){let T=0;if(w<o){if(T=r[w],$===T){++w;continue}if($>=T)throw new Error(SF())}if($<0||$>=p)throw new Error(_F($,p));$>v&&y.fill(i,v*c,$*c);for(let C=x;C<w;++C){const I=s[C];if(I<0||I>=l[0])throw new Error(CF(C,s[C],l[0]));for(let A=0;A<c;A++)y[$*c+A]+=t[I*c+A]}if(a)for(let C=0;C<c;C++)y[$*c+C]/=w-x;if(x=w,++w,v=$+1,$=T,w>o)break}return v<p&&y.fill(i,v*c,p*c),[y,f]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kne=Fi(t=>Math.sqrt(t)),Nne=Jt(xm,t=>Math.sqrt(t)),Ine={kernelName:xm,backendName:"cpu",kernelFunc:Nne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R4=zn((t,e)=>{const n=t-e;return n*n}),Ene=Qn(wm,R4),Ane={kernelName:wm,backendName:"cpu",kernelFunc:Ene};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D4=Fi((t,e)=>{const{pattern:n,replaceGlobal:s,rewrite:r}=e;return t.replace(new RegExp(n,s?"g":""),r)}),Rne=Jl(tx,D4),Dne={kernelName:tx,backendName:"cpu",kernelFunc:Rne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O4(t,e,n,s){const r=xt(t,e.dtype);for(let a=0;a<r.size;a++){const i=r.indexToLoc(a),o=new Array(i.length);for(let l=0;l<o.length;l++)o[l]=i[l]*n[l]+s[l];r.set(e.get(...o),...i)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class One{constructor(e,n,s,r,a,i){this.separator=Il(e),this.nGramWidths=n,this.leftPad=Il(s),this.rightPad=Il(r),this.padWidth=a,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,n){const s=this.getPadWidth(n);return Math.max(0,e+2*s-n+1)}createNGrams(e,n,s,r,a,i){for(let o=0;o<a;++o){const l=this.getPadWidth(i),c=Math.max(0,l-o),h=Math.max(0,l-(a-(o+1))),p=i-(c+h),f=n+(c>0?0:o-l);let g=0;g+=c*this.leftPad.length;for(let $=0;$<p;++$)g+=e[f+$].length;g+=h*this.rightPad.length;const y=c+h+p-1;g+=y*this.separator.length,s[r+o]=new Uint8Array(g);const x=s[r+o];let w=0;const v=$=>$.forEach(T=>x[w++]=T);for(let $=0;$<c;++$)v(this.leftPad),v(this.separator);for(let $=0;$<p-1;++$)v(e[f+$]),v(this.separator);if(p>0){v(e[f+p-1]);for(let $=0;$<h;++$)v(this.separator),v(this.rightPad)}else{for(let $=0;$<h-1;++$)v(this.rightPad),v(this.separator);v(this.rightPad)}}}compute(e,n){const s=e.length,r=n.length;if(r>0){let l=n[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<r;++c){let h=n[c]>=l;if(h=h&&n[c]<=s,!h)throw new Error(`Invalid split value ${n[c]}, must be in [${l}, ${s}]`);l=n[c]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const a=r-1,i=An("int32",r);if(s===0||r===0){const l=new Array(s);for(let c=0;c<=a;++c)i[c]=0;return[l,i]}i[0]=0;for(let l=1;l<=a;++l){const c=n[l]-n[l-1];let h=0;this.nGramWidths.forEach(p=>{h+=this.getNumNGrams(c,p)}),this.preserveShort&&c>0&&h===0&&(h=1),i[l]=i[l-1]+h}const o=new Array(i[a]);for(let l=0;l<a;++l){const c=n[l];let h=i[l];if(this.nGramWidths.forEach(p=>{const f=n[l+1]-n[l],g=this.getNumNGrams(f,p);this.createNGrams(e,c,o,h,g,p),h+=g}),this.preserveShort&&h===i[l]){const p=n[l+1]-n[l];if(p===0)continue;const f=p+2*this.padWidth;this.createNGrams(e,c,o,h,1,f)}}return[o,i]}}function z4(t,e,n,s,r,a,i,o){return new One(n,s,r,a,i,o).compute(t,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zne(t,e,n,s){if(!t.length)return;if(e.length===0){for(let a=0;a<t.length;++a)s.push(t.subarray(a,a+1));return}if(e.length===1){const a=e[0];let i=t.indexOf(a);for(;i!==-1;){const o=t.subarray(0,i);(!n||o.length!==0)&&s.push(o),t=t.subarray(i+1),i=t.indexOf(a)}(!n||t.length!==0)&&s.push(t);return}let r=0;for(let a=0;a<t.length+1;a++)if(a===t.length||e.indexOf(t[a])!==-1){const i=t.subarray(r,a);(!n||i.length!==0)&&s.push(i),r=a+1}}function F4(t,e,n){const s=t.length,r=[];let a=0,i=0;const o=new Array(s);for(let f=0;f<s;++f){const g=r.length;zne(t[f],e,n,r);const y=r.length-g;o[f]=y,a+=y,i=Math.max(i,y)}const l=An("int32",a*2),c=new Array(a),h=[s,i];let p=0;for(let f=0;f<s;++f)for(let g=0;g<o[f];++g)l[p*2]=f,l[p*2+1]=g,c[p]=r[p],++p;return[l,c,h]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L4(t,e){const n=An("int32",t.length);for(let s=0;s<t.length;++s)n[s]=K6(t[s]).modulo(e).getLowBitsUnsigned();return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M4=zn((t,e)=>t-e),Fne=NC((t,e,n,s)=>({real:t-n,imag:e-s})),DC=Qn(vm,M4,Fne),Lne={kernelName:vm,backendName:"cpu",kernelFunc:DC};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B4(t,e){const n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=t.shape[r]*e[r];const s=xt(n,t.dtype);for(let r=0;r<s.values.length;++r){const a=s.indexToLoc(r),i=new Array(t.rank);for(let l=0;l<i.length;l++)i[l]=a[l]%t.shape[l];const o=t.locToIndex(i);s.values[r]=t.values[o]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jp=(t,e)=>{const n=e.value-t.value;return n===0?t.index-e.index:n};function P4(t,e,n=0,s=t.length-1){for(;s>n;){if(s-n>600){const o=s-n+1,l=e-n+1,c=Math.log(o),h=.5*Math.exp(2*c/3),p=.5*Math.sqrt(c*h*(o-h)/o)*Math.sign(l-o/2),f=Math.max(n,Math.floor(e-l*h/o+p)),g=Math.min(s,Math.floor(e+(o-l)*h/o+p));P4(t,e,f,g)}const r=t[e];let a=n,i=s;for(Sd(t,n,e),Jp(t[s],r)>0&&Sd(t,n,s);a<i;){for(Sd(t,a,i),a++,i--;Jp(t[a],r)<0;)a=a+1;for(;Jp(t[i],r)>0;)i=i-1}Jp(t[n],r)===0?Sd(t,n,i):(i=i+1,Sd(t,i,s)),i<=e&&(n=i+1),e<=i&&(s=i-1)}}function V4(t,e,n,s,r){const a=e[e.length-1],[i,o]=[t.length/a,a],l=ys(n,i*s),c=ys("int32",i*s);for(let p=0;p<i;p++){const f=p*o,g=t.subarray(f,f+o);let y=new Array(g.length);g.forEach(($,T)=>y[T]={value:$,index:T}),s<y.length&&(P4(y,s),y=y.slice(0,s)),r&&y.sort(Jp);const x=p*s,w=l.subarray(x,x+s),v=c.subarray(x,x+s);for(let $=0;$<s;$++)w[$]=y[$].value,v[$]=y[$].index}const h=e.slice();return h[h.length-1]=s,[xt(h,n,l),xt(h,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U4(t,e,n,s){const r=St(e,n)[0],a=[1,n[0],1];for(let y=0;y<r;y++)a[0]*=n[y];a[1]=n[r];for(let y=r+1;y<n.length;y++)a[2]*=n[y];const i=new Map,o=new Int32Array(n[r]),l=new Kn(a,s,t),c=[],h=a[0]===1&&a[2]===1;for(let y=0;y<n[r];y++){let x;if(h)x=t[y].toString();else{const v=[];for(let $=0;$<a[0];$++)for(let T=0;T<a[2];T++)v.push(l.get($,y,T));x=v.join(",")}const w=i.get(x);if(w!=null)o[y]=w;else{const v=i.size;i.set(x,v),o[y]=v,c.push(y)}}const p=a.slice();p[1]=i.size;const f=new Kn(p,s);c.forEach((y,x)=>{for(let w=0;w<a[0];w++)for(let v=0;v<a[2];v++)f.set(l.get(w,y,v),w,x,v)});const g=n.slice();return g[r]=p[1],{outputValues:f.values,outputShape:g,indices:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mne=Object.freeze(Object.defineProperty({__proto__:null,addImpl:ZM,bincountImpl:IC,bincountReduceImpl:QM,bitwiseAndImpl:JM,castImpl:YM,ceilImpl:e4,concatImpl:t4,equalImpl:n4,expImpl:r4,expm1Impl:i4,floorDivImpl:l4,floorImpl:o4,gatherNdImpl:u4,gatherV2Impl:c4,greaterEqualImpl:h4,greaterImpl:d4,lessEqualImpl:f4,lessImpl:p4,linSpaceImpl:m4,logImpl:g4,maxImpl:y4,maximumImpl:b4,minimumImpl:x4,multiplyImpl:EC,negImpl:w4,notEqualImpl:v4,prodImpl:$4,raggedGatherImpl:S4,raggedRangeImpl:_4,raggedTensorToTensorImpl:C4,rangeImpl:T4,rsqrtImpl:k4,scatterImpl:Qu,sigmoidImpl:_ne,simpleAbsImpl:XM,sliceImpl:I4,sparseFillEmptyRowsImpl:E4,sparseReshapeImpl:A4,sparseSegmentReductionImpl:RC,sqrtImpl:kne,squaredDifferenceImpl:R4,staticRegexReplaceImpl:D4,stridedSliceImpl:O4,stringNGramsImpl:z4,stringSplitImpl:F4,stringToHashBucketFastImpl:L4,subImpl:M4,tileImpl:B4,topKImpl:V4,transposeImpl:AC,uniqueImpl:U4},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */gO("cpu",()=>new Ux,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W4=Jt(Gf,t=>t>=0?t:Math.exp(t)-1),Bne={kernelName:Gf,backendName:"cpu",kernelFunc:W4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G4(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{alpha:a}=s;Ye([r],"leakyRelu");const i=$e(r.shape),o=n.data.get(r.dataId).values,l=ys("float32",i);for(let c=0;c<o.length;c++)l[c]=o[c]<0?a*o[c]:o[c];return n.makeTensorInfo(r.shape,"float32",l)}const Pne={kernelName:_b,backendName:"cpu",kernelFunc:G4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vne=zn((t,e)=>t<0?e*t:t);function H4(t){const{inputs:e,backend:n}=t,{x:s,alpha:r}=e;Ye([s,r],"prelu");const a=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values,[o,l]=Vne(s.shape,r.shape,a,i,"float32");return n.makeTensorInfo(l,"float32",o)}const Une={kernelName:Wb,backendName:"cpu",kernelFunc:H4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q4=Jt(um,t=>Math.max(0,t)),Wne={kernelName:um,backendName:"cpu",kernelFunc:q4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j4=Jt(cm,t=>Math.min(Math.max(0,t),6)),Gne={kernelName:cm,backendName:"cpu",kernelFunc:j4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M0(t,e,n,s,r){if(n==="linear")return Ri({inputs:{x:e},backend:t});if(n==="relu")return q4({inputs:{x:e},backend:t});if(n==="elu")return W4({inputs:{x:e},backend:t});if(n==="relu6")return j4({inputs:{x:e},backend:t});if(n==="prelu")return H4({inputs:{x:e,alpha:s},backend:t});if(n==="leakyrelu")return G4({inputs:{x:e},backend:t,attrs:{alpha:r}});if(n==="sigmoid")return N4({inputs:{x:e},backend:t});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function on(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{shape:a}=s,i=$e(r.shape),o=jD(a,i),l=$e(o);V(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(r.dataId);const c=n.data.get(r.dataId);if(c.complexTensorInfos!=null){const h=c.complexTensorInfos.real,p=c.complexTensorInfos.imag;h.shape=o,p.shape=o}return{dataId:r.dataId,shape:o,dtype:r.dtype}}const Hne={kernelName:Hb,backendName:"cpu",kernelFunc:on};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K4(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:a}=e,{transposeA:i,transposeB:o}=s;Ye([r,a],"matMul");const l=r.shape.length,c=a.shape.length,h=i?r.shape[l-2]:r.shape[l-1],p=o?a.shape[c-1]:a.shape[c-2],f=i?r.shape[l-1]:r.shape[l-2],g=o?a.shape[c-2]:a.shape[c-1],y=r.shape.slice(0,-2),x=a.shape.slice(0,-2),w=$e(y),v=$e(x),T=ft(r.shape.slice(0,-2),a.shape.slice(0,-2)).concat([f,g]);V(h===p,()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${r.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);const C=i?[w,h,f]:[w,f,h],I=o?[v,g,p]:[v,p,g],A=on({inputs:{x:r},backend:n,attrs:{shape:C}}),O=on({inputs:{x:a},backend:n,attrs:{shape:I}}),B=i?A.shape[1]:A.shape[2],z=i?A.shape[2]:A.shape[1],P=o?O.shape[1]:O.shape[2],F=Math.max(w,v),K=n.data.get(A.dataId).values,X=n.data.get(O.dataId).values,te=nt(A.shape),Q=nt(O.shape),[q,oe,se]=i?[te[0],1,te[1]]:[te[0],te[1],1],[ee,U,G]=o?[1,Q[1],Q[0]]:[Q[1],1,Q[0]],Y=z*P,ce=xt([F,z,P],A.dtype),pe=ce.values,J=n.blockSize;for(let we=0;we<F;we++){const Be=we%w,Fe=we%v;for(let Ve=0;Ve<z;Ve+=J){const Me=Math.min(Ve+J,z);for(let Pe=0;Pe<P;Pe+=J){const pt=Math.min(Pe+J,P);for(let yt=0;yt<B;yt+=J){const Dt=Math.min(yt+J,B);for(let kt=Ve;kt<Me;kt++)for(let Ct=Pe;Ct<pt;Ct++){let Nt=0;for(let Gt=yt;Gt<Dt;Gt++){const Ss=K[Be*q+kt*oe+Gt*se],mn=X[Gt*ee+Ct*U+Fe*G];Nt+=Ss*mn}pe[we*Y+(kt*P+Ct)]+=Nt}}}}}return n.disposeIntermediateTensorInfo(A),n.disposeIntermediateTensorInfo(O),n.makeTensorInfo(T,ce.dtype,ce.values)}const qne={kernelName:lb,backendName:"cpu",kernelFunc:K4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jne(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:a,bias:i,preluActivationWeights:o}=e,{transposeA:l,transposeB:c,activation:h,leakyreluAlpha:p}=s;let f,g,y;const x=[];f=K4({inputs:{a:r,b:a},attrs:{transposeA:l,transposeB:c},backend:n}),i&&(g=Gd({inputs:{a:f,b:i},backend:n}),x.push(f),f=g),h&&(y=M0(n,f,h,o,p),x.push(f),f=y);for(const v of x)n.disposeIntermediateTensorInfo(v);return f}const Kne={kernelName:y0,backendName:"cpu",kernelFunc:jne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xne=Jt(Af,t=>Math.acos(t)),Yne={kernelName:Af,backendName:"cpu",kernelFunc:Xne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zne=Jt(Rf,t=>Math.acosh(t)),Qne={kernelName:Rf,backendName:"cpu",kernelFunc:Zne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jne(t){const{inputs:e,backend:n}=t,s=e;Ye(e,"addN");const r=s.map(o=>n.data.get(o.dataId).values),a=xt(s[0].shape,s[0].dtype),i=a.values;for(let o=0;o<s.length;o++){const l=r[o];for(let c=0;c<i.length;c++)i[c]+=l[c]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}const ese={kernelName:sb,backendName:"cpu",kernelFunc:Jne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tse(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s;Ye(r,"all");const o=St(a,r.shape);let l=o;const c=wn(l,r.shape.length);let h=r;c!=null&&(h=lr({inputs:{x:r},backend:n,attrs:{perm:c}}),l=Dn(l.length,r.shape.length)),ws("all",l,h.shape.length);const[p,f]=ls(h.shape,l),g=$e(f),y=Rs($e(p),h.dtype),x=n.data.get(h.dataId).values;for(let v=0;v<y.length;++v){const $=v*g;let T=x[$];for(let C=0;C<g;++C){const I=x[$+C];T=T&&I}y[v]=T}c!=null&&n.disposeIntermediateTensorInfo(h);const w=n.makeTensorInfo(p,h.dtype,y);if(i){const v=Rn(p,o),$=on({inputs:{x:w},backend:n,attrs:{shape:v}});return n.disposeIntermediateTensorInfo(w),$}return w}const nse={kernelName:V2,backendName:"cpu",kernelFunc:tse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sse(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s;Ye(r,"any");const o=St(a,r.shape);let l=o;const c=wn(l,r.shape.length);let h=r;c!=null&&(h=lr({inputs:{x:r},backend:n,attrs:{perm:c}}),l=Dn(l.length,r.shape.length)),ws("any",l,h.shape.length);const[p,f]=ls(h.shape,l),g=$e(f),y=Rs($e(p),h.dtype),x=n.data.get(h.dataId).values;for(let v=0;v<y.length;++v){const $=v*g;let T=x[$];for(let C=0;C<g;++C){const I=x[$+C];T=T||I}y[v]=T}c!=null&&n.disposeIntermediateTensorInfo(h);const w=n.makeTensorInfo(p,h.dtype,y);if(i){const v=Rn(p,o),$=on({inputs:{x:w},backend:n,attrs:{shape:v}});return n.disposeIntermediateTensorInfo(w),$}return w}const rse={kernelName:U2,backendName:"cpu",kernelFunc:sse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ase(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a}=s;Ye(r,"argMax");let i=St(a,r.shape);const o=wn(i,r.shape.length);let l=r;const c=[];o!=null&&(l=lr({inputs:{x:r},backend:n,attrs:{perm:o}}),c.push(l),i=Dn(i.length,l.shape.length)),i=[i[0]],ws("argMax",i,l.shape.length);const[h,p]=ls(l.shape,i),f=$e(h),g=Rs(f,"int32"),y=$e(p),x=n.data.get(l.dataId).values;for(let w=0;w<g.length;++w){const v=w*y;let $=x[v],T=0;for(let C=0;C<y;++C){const I=x[v+C];I>$&&($=I,T=C)}g[w]=T}return c.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.makeTensorInfo(h,"int32",g)}const ise={kernelName:rb,backendName:"cpu",kernelFunc:ase};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ose(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a}=s;Ye(r,"argMin");let i=St(a,r.shape);const o=wn(i,r.shape.length);let l=r;const c=[];o!=null&&(l=lr({inputs:{x:r},backend:n,attrs:{perm:o}}),c.push(l),i=Dn(i.length,l.shape.length)),i=[i[0]],ws("argMin",i,l.shape.length);const[h,p]=ls(l.shape,i),f=$e(h),g=Rs(f,"int32"),y=$e(p),x=n.data.get(l.dataId).values;for(let w=0;w<g.length;++w){const v=w*y;let $=x[v],T=0;for(let C=0;C<y;++C){const I=x[v+C];I<$&&($=I,T=C)}g[w]=T}return c.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.makeTensorInfo(h,"int32",g)}const lse={kernelName:ab,backendName:"cpu",kernelFunc:ose};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const use=Jt(Df,t=>Math.asin(t)),cse={kernelName:Df,backendName:"cpu",kernelFunc:use};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dse=Jt(Of,t=>Math.asinh(t)),hse={kernelName:Of,backendName:"cpu",kernelFunc:dse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pse=Jt(zf,t=>Math.atan(t)),fse={kernelName:zf,backendName:"cpu",kernelFunc:pse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mse=zn((t,e)=>Math.atan2(t,e)),gse=Qn(Lf,mse),yse={kernelName:Lf,backendName:"cpu",kernelFunc:gse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bse=Jt(Ff,t=>Math.atanh(t)),xse={kernelName:Ff,backendName:"cpu",kernelFunc:bse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OC(t,e,n,s,r,a){const i=r.strideHeight,o=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterHeight,p=r.effectiveFilterWidth,f=r.padInfo.top,g=r.padInfo.left,y=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=xt(r.outShape,n),w=x.values,v=r.outShape[1]*r.outShape[2]*r.outShape[3],$=r.outShape[2]*r.outShape[3],T=r.outShape[3];for(let C=0;C<r.batchSize;++C){const I=C*v,A=C*s[0];for(let O=0;O<r.inChannels;++O)for(let B=0;B<r.outHeight;++B){const z=B*i-f,P=Math.max(0,z),F=Math.min(r.inHeight,h+z),K=I+B*$;for(let X=0;X<r.outWidth;++X){const te=X*o-g,Q=Math.max(0,te),q=Math.min(r.inWidth,p+te);let oe=y,se=0,ee=0;for(let G=P;G<F;G+=l){const Y=A+G*s[1];for(let ce=Q;ce<q;ce+=c){const pe=Y+ce*s[2],J=t[pe+O];a==="max"&&J>oe?oe=J:a==="avg"&&(se+=J,ee++)}if(isNaN(oe))break}const U=K+X*T+O;w[U]=a==="avg"?se/ee:oe}}}return x}function X4(t,e,n,s,r=!1,a=!1){const i=xt(s.outShape,"int32"),o=s.strideHeight,l=s.strideWidth,c=s.dilationHeight,h=s.dilationWidth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,g=s.padInfo.top,y=s.padInfo.left,x=xt(e,n,t);for(let w=0;w<s.batchSize;++w)for(let v=0;v<s.inChannels;++v)for(let $=0;$<s.outHeight;++$){const T=$*o-g;let C=T;for(;C<0;)C+=c;const I=Math.min(s.inHeight,p+T);for(let A=0;A<s.outWidth;++A){const O=A*l-y;let B=O;for(;B<0;)B+=h;const z=Math.min(s.inWidth,f+O);let P=Number.NEGATIVE_INFINITY,F=-1;for(let K=C;K<I;K+=c){const X=K-T;for(let te=B;te<z;te+=h){const Q=te-O,q=x.get(w,K,te,v);q>P&&(P=q,r?F=a?((w*s.inHeight+K)*s.inWidth+te)*s.inChannels+v:(K*s.inWidth+te)*s.inChannels+v:F=X*f+Q)}}i.set(F,w,$,A,v)}}return i}function Y4(t,e,n,s,r,a){const i=r.strideDepth,o=r.strideHeight,l=r.strideWidth,c=r.dilationDepth,h=r.dilationHeight,p=r.dilationWidth,f=r.effectiveFilterDepth,g=r.effectiveFilterHeight,y=r.effectiveFilterWidth,x=r.padInfo.front,w=r.padInfo.top,v=r.padInfo.left,$=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,T=xt(r.outShape,n),C=T.values,I=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],A=r.outShape[2]*r.outShape[3]*r.outShape[4],O=r.outShape[3]*r.outShape[4],B=r.outShape[4];for(let z=0;z<r.batchSize;++z){const P=z*I,F=z*s[0];for(let K=0;K<r.inChannels;++K)for(let X=0;X<r.outDepth;++X){const te=X*i-x;let Q=te;for(;Q<0;)Q+=c;const q=Math.min(r.inDepth,f+te),oe=P+X*A;for(let se=0;se<r.outHeight;++se){const ee=se*o-w;let U=ee;for(;U<0;)U+=h;const G=Math.min(r.inHeight,g+ee),Y=oe+se*O;for(let ce=0;ce<r.outWidth;++ce){const pe=ce*l-v;let J=pe;for(;J<0;)J+=p;const we=Math.min(r.inWidth,y+pe),Be=Y+ce*B;let Fe=$,Ve=0,Me=0;for(let pt=Q;pt<q;pt+=c){const yt=F+pt*s[1];for(let Dt=U;Dt<G;Dt+=h){const kt=yt+Dt*s[2];for(let Ct=J;Ct<we;Ct+=p){const Nt=kt+Ct*s[3],Gt=t[Nt+K];if(a==="max"&&Gt>Fe?Fe=Gt:a==="avg"&&(Ve+=Gt,Me++),isNaN(Fe))break}if(isNaN(Fe))break}if(isNaN(Fe))break}const Pe=Be+K;C[Pe]=a==="avg"?Ve/Math.max(Me,1):Fe}}}}return T}function wse(t,e){const n=xt(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,a=e.strideWidth,i=e.dilationDepth,o=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,h=e.effectiveFilterHeight,p=e.effectiveFilterWidth,f=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;for(let x=0;x<e.batchSize;++x)for(let w=0;w<e.inChannels;++w)for(let v=0;v<e.outDepth;++v){const $=v*s-f;let T=$;for(;T<0;)T+=i;const C=Math.min(e.inDepth,c+$);for(let I=0;I<e.outHeight;++I){const A=I*r-g;let O=A;for(;O<0;)O+=o;const B=Math.min(e.inHeight,h+A);for(let z=0;z<e.outWidth;++z){const P=z*a-y;let F=P;for(;F<0;)F+=l;const K=Math.min(e.inWidth,p+P);let X=Number.NEGATIVE_INFINITY,te=-1;for(let Q=T;Q<C;Q+=i){const q=Q-$;for(let oe=O;oe<B;oe+=o){const se=oe-A;for(let ee=F;ee<K;ee+=l){const U=ee-P,G=t.get(x,Q,oe,ee,w);G>=X&&(X=G,te=q*h*p+se*h+U)}}}n.set(te,x,v,I,z,w)}}}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vse(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;Ye(r,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=s,c=1;V(xs(i,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const h=_a(r.shape,a,i,c,o,l);let p;if(h.filterWidth===1&&h.filterHeight===1&&Rt(h.inShape,h.outShape))p=Ri({inputs:{x:r},backend:n});else{const f=n.data.get(r.dataId).values,g=nt(r.shape),y=OC(f,r.shape,r.dtype,g,h,"avg");p=n.makeTensorInfo(h.outShape,r.dtype,y.values)}return p}const $se={kernelName:ib,backendName:"cpu",kernelFunc:vse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sse(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:c}=s;Ye(r,"avgPool3d");const h=Eo(r.shape,a,i,1,o,l,c),p=n.data.get(r.dataId).values,f=Y4(p,r.shape,r.dtype,nt(r.shape),h,"avg");return n.makeTensorInfo(f.shape,"float32",f.values)}const _se={kernelName:ob,backendName:"cpu",kernelFunc:Sse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cse(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:a}=e,{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=s;Ye([r,a],"avgPool3DGrad");const h=Eo(a.shape,i,o,1,l,c),p=h.strideDepth,f=h.strideHeight,g=h.strideWidth,y=h.filterDepth,x=h.filterHeight,w=h.filterWidth,v=h.dilationDepth,$=h.dilationHeight,T=h.dilationWidth,C=h.effectiveFilterDepth,I=h.effectiveFilterHeight,A=h.effectiveFilterWidth,O=C-1-h.padInfo.front,B=A-1-h.padInfo.left,z=I-1-h.padInfo.top,P=xt(a.shape,"float32"),F=1/(y*x*w),K=n.bufferSync(r);for(let X=0;X<h.batchSize;++X)for(let te=0;te<h.inChannels;++te)for(let Q=0;Q<h.inDepth;++Q)for(let q=0;q<h.inHeight;++q)for(let oe=0;oe<h.inWidth;++oe){const se=Q-O,ee=q-z,U=oe-B;let G=0;for(let Y=0;Y<C;Y+=v){const ce=(se+Y)/p;if(!(ce<0||ce>=h.outDepth||Math.floor(ce)!==ce))for(let pe=0;pe<I;pe+=$){const J=(ee+pe)/f;if(!(J<0||J>=h.outHeight||Math.floor(J)!==J))for(let we=0;we<A;we+=T){const Be=(U+we)/g;if(Be<0||Be>=h.outWidth||Math.floor(Be)!==Be)continue;const Fe=K.get(X,ce,J,Be,te);G+=Fe}}}P.set(G*F,X,Q,q,oe,te)}return n.makeTensorInfo(P.shape,P.dtype,P.values)}const Tse={kernelName:G2,backendName:"cpu",kernelFunc:Cse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kse(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:a}=e,i=a;Ye([r,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:c}=s,h=_a(i.shape,o,l,1,c),p=h.strideHeight,f=h.strideWidth,g=h.filterHeight,y=h.filterWidth,x=h.dilationHeight,w=h.dilationWidth,v=h.effectiveFilterHeight,$=h.effectiveFilterWidth,T=$-1-h.padInfo.left,C=v-1-h.padInfo.top,I=xt(i.shape,"float32"),A=1/(g*y),O=n.data.get(r.dataId).values,B=xt(r.shape,"float32",O);for(let z=0;z<h.batchSize;++z)for(let P=0;P<h.inChannels;++P)for(let F=0;F<h.inHeight;++F)for(let K=0;K<h.inWidth;++K){const X=F-C,te=K-T;let Q=0;for(let q=0;q<v;q+=x){const oe=(X+q)/p;if(!(oe<0||oe>=h.outHeight||Math.floor(oe)!==oe))for(let se=0;se<$;se+=w){const ee=(te+se)/f;if(ee<0||ee>=h.outWidth||Math.floor(ee)!==ee)continue;const U=B.get(z,oe,ee,P);Q+=U}}I.set(Q*A,z,F,K,P)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}const Nse={kernelName:W2,backendName:"cpu",kernelFunc:kse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ise(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,scale:a,offset:i,mean:o,variance:l}=e;V(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),V(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),V(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Ye([r,o,l,a,i],"batchNorm");let{varianceEpsilon:c}=s;c==null&&(c=.001);const h=n.data.get(r.dataId).values,p=n.data.get(o.dataId).values,f=n.data.get(l.dataId).values,g=a?n.data.get(a.dataId).values:new Float32Array([1]),y=i?n.data.get(i.dataId).values:new Float32Array([0]),x=new Float32Array(h.length),w=y.length,v=g.length,$=f.length,T=p.length;let C=0,I=0,A=0,O=0;for(let B=0;B<h.length;++B)x[B]=y[C++]+(h[B]-p[I++])*g[A++]/Math.sqrt(f[O++]+c),C>=w&&(C=0),I>=T&&(I=0),A>=v&&(A=0),O>=$&&(O=0);return n.makeTensorInfo(r.shape,r.dtype,x)}const Ese={kernelName:vb,backendName:"cpu",kernelFunc:Ise};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ase(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:a,crops:i}=s;Ye([r],"batchToSpaceND");const o=a.reduce((v,$)=>v*$),l=Om(r.shape,a,o),c=zm(l.length,a.length),h=Fm(r.shape,a,o),p=W_(i,a.length),f=G_(h,i,a.length),g=on({inputs:{x:r},backend:n,attrs:{shape:l}}),y=lr({inputs:{x:g},backend:n,attrs:{perm:c}}),x=on({inputs:{x:y},backend:n,attrs:{shape:h}}),w=fc({inputs:{x},backend:n,attrs:{begin:p,size:f}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x),w}const Rse={kernelName:ub,backendName:"cpu",kernelFunc:Ase};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dse(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:a}=e,{size:i}=s,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,c=IC(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}const Ose={kernelName:H2,backendName:"cpu",kernelFunc:Dse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zse(t){const{inputs:e,backend:n}=t,{s0:s,s1:r}=e,a=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values,o=ft(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const Fse={kernelName:q2,backendName:"cpu",kernelFunc:zse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lse=Jt(Pf,(t,e)=>{const n=e;return t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t}),Mse={kernelName:Pf,backendName:"cpu",kernelFunc:Lse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bse=t=>{const{x:e}=t.inputs,n=t.backend,s=new Float32Array($e(e.shape)),r=n.data.get(e.dataId),a=r.complexTensorInfos.real,i=r.complexTensorInfos.imag,o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values;for(let c=0;c<o.length;c++){const h=o[c],p=l[c];s[c]=Math.hypot(h,p)}return n.makeOutput(s,e.shape,"float32")},Pse={kernelName:db,backendName:"cpu",kernelFunc:Bse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hd(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.data.get(s.dataId).complexTensorInfos.imag,a=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,a)}const Vse={kernelName:dS,backendName:"cpu",kernelFunc:Hd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qd(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s,a=St(r,e[0].shape)[0],i=e.map(x=>x.shape);P_(i,a);let o=Ti(e.map(x=>x.shape),a);if($e(o)===0)return n.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(x=>$e(x.shape)>0);if(l.length===1)return Ri({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){const x=l.map(C=>pc({inputs:{input:C},backend:n})),w=l.map(C=>Hd({inputs:{input:C},backend:n})),v=qd({inputs:x,backend:n,attrs:{axis:a}}),$=qd({inputs:w,backend:n,attrs:{axis:a}}),T=$r({inputs:{real:v,imag:$},backend:n});return x.forEach(C=>n.disposeIntermediateTensorInfo(C)),w.forEach(C=>n.disposeIntermediateTensorInfo(C)),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo($),T}const c=l.map(x=>{const v=[-1,$e(x.shape.slice(a))];return on({inputs:{x},backend:n,attrs:{shape:v}})}),h=c.map(x=>({vals:n.data.get(x.dataId).values,shape:x.shape}));o=Ti(c.map(x=>x.shape),1);const p=c[0].shape[0]===1,f=t4(h,o,e[0].dtype,p),g=Ti(l.map(x=>x.shape),a),y=n.makeTensorInfo(g,e[0].dtype,f);return c.forEach(x=>n.disposeIntermediateTensorInfo(x)),y}const Use={kernelName:hb,backendName:"cpu",kernelFunc:qd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z4(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a}=e,{strides:i,pad:o,dataFormat:l,dilations:c,dimRoundingMode:h}=s;Ye([r,a],"conv2d");const p=Ao(l),f=os(r.shape,a.shape,i,c,o,h,!1,p),g=f.filterHeight,y=f.filterWidth,x=f.dilationHeight,w=f.dilationWidth,v=f.padInfo.left,$=f.padInfo.top,T=f.dataFormat==="channelsLast",C=new Kn(f.outShape,r.dtype),I=nt(r.shape),A=nt(a.shape),O=I[0],B=T?I[1]:I[2],z=T?I[2]:1,P=T?1:I[1],F=C.strides[0],K=T?C.strides[1]:C.strides[2],X=T?C.strides[2]:1,te=T?1:C.strides[1],Q=n.data.get(r.dataId).values,q=n.data.get(a.dataId).values,oe=C.values;for(let se=0;se<f.batchSize;++se){const ee=se*O,U=se*F;for(let G=0;G<f.outHeight;++G){const Y=U+G*K,ce=G*f.strideHeight-$;for(let pe=0;pe<g;++pe){const J=ce+pe*x;if(J<0||J>=f.inHeight)continue;const we=pe*A[0],Be=ee+J*B;for(let Fe=0;Fe<f.outWidth;++Fe){const Ve=Y+Fe*X,Me=Fe*f.strideWidth-v;for(let Pe=0;Pe<y;++Pe){const pt=Me+Pe*w;if(pt<0||pt>=f.inWidth)continue;const yt=we+Pe*A[1],Dt=Be+pt*z;let kt=yt;for(let Ct=0;Ct<f.inChannels;++Ct){const Nt=Q[Dt+Ct*P];for(let Gt=0;Gt<f.outChannels;++Gt)oe[Ve+Gt*te]+=Nt*q[kt+Gt];kt+=f.outChannels}}}}}}return n.makeTensorInfo(C.shape,C.dtype,oe)}const Wse={kernelName:pb,backendName:"cpu",kernelFunc:Z4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gse(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:a}=e,{strides:i,pad:o,dataFormat:l,dimRoundingMode:c,filterShape:h}=s;Ye([r,a],"conv2dBackpropFilter");const p=Ao(l),f=os(r.shape,h,i,1,o,c,!1,p),{strideHeight:g,strideWidth:y,filterHeight:x,filterWidth:w}=f,v=f.dataFormat==="channelsLast",$=new Kn(f.filterShape,"float32"),T=f.padInfo.left,C=f.padInfo.top,I=n.data.get(r.dataId).values,A=n.data.get(a.dataId).values,O=new Kn(r.shape,r.dtype,I),B=new Kn(a.shape,a.dtype,A);for(let z=0;z<x;++z){const P=Math.max(0,Math.ceil((C-z)/g)),F=Math.min(f.outHeight,(f.inHeight+C-z)/g);for(let K=0;K<w;++K){const X=Math.max(0,Math.ceil((T-K)/y)),te=Math.min(f.outWidth,(f.inWidth+T-K)/y);for(let Q=0;Q<f.inChannels;++Q)for(let q=0;q<f.outChannels;++q){let oe=0;for(let se=0;se<f.batchSize;++se)for(let ee=P;ee<F;++ee){const U=z+ee*g-C;for(let G=X;G<te;++G){const Y=K+G*y-T;v?oe+=O.get(se,U,Y,Q)*B.get(se,ee,G,q):oe+=O.get(se,Q,U,Y)*B.get(se,q,ee,G)}}$.set(oe,z,K,Q,q)}}}return n.makeTensorInfo($.shape,$.dtype,$.values)}const Hse={kernelName:K2,backendName:"cpu",kernelFunc:Gse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qse(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:a}=e,{inputShape:i,strides:o,pad:l,dataFormat:c,dimRoundingMode:h}=s;Ye([r,a],"conv2dBackpropInput");const p=nt(a.shape),f=nt(r.shape);let g=Ao(c);const y=os(i,a.shape,o,1,l,h,!1,g),x=new Kn(y.inShape,"float32"),w=x.values,v=n.data.get(r.dataId).values,$=n.data.get(a.dataId).values,[T,C,I]=p,{batchSize:A,filterHeight:O,filterWidth:B,inChannels:z,inHeight:P,inWidth:F,outChannels:K,outHeight:X,outWidth:te,strideHeight:Q,strideWidth:q}=y;g=y.dataFormat;const oe=O-1-y.padInfo.top,se=B-1-y.padInfo.left,ee=g==="channelsLast",U=x.strides[0],G=ee?x.strides[1]:x.strides[2],Y=ee?x.strides[2]:1,ce=ee?1:x.strides[1],pe=f[0],J=ee?f[1]:f[2],we=ee?f[2]:1,Be=ee?1:f[1];for(let Fe=0;Fe<A;++Fe)for(let Ve=0;Ve<z;++Ve)for(let Me=0;Me<P;++Me){const Pe=Me-oe,pt=Math.max(0,Math.ceil(Pe/Q)),yt=Math.min(X,(O+Pe)/Q);for(let Dt=0;Dt<F;++Dt){const kt=Dt-se,Ct=Math.max(0,Math.ceil(kt/q)),Nt=Math.min(te,(B+kt)/q);let Gt=0;for(let mn=pt;mn<yt;++mn){const ur=mn*Q-Pe;for(let Jn=Ct;Jn<Nt;++Jn){const Qr=Jn*q-kt,ln=pe*Fe+J*mn+we*Jn,cr=T*(O-1-ur)+C*(B-1-Qr)+I*Ve;for(let Pn=0;Pn<K;++Pn){const Et=v[ln+Be*Pn],_s=$[cr+Pn];Gt+=Et*_s}}}const Ss=U*Fe+G*Me+Y*Dt+ce*Ve;w[Ss]=Gt}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}const jse={kernelName:fb,backendName:"cpu",kernelFunc:qse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kse(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a}=e,{strides:i,pad:o,dilations:l}=s;Ye([r,a],"conv3d");const c=jl(r.shape,a.shape,i,l,o),{filterDepth:h,filterHeight:p,filterWidth:f,dilationDepth:g,dilationHeight:y,dilationWidth:x,padInfo:w}=c,v=w.front,$=w.left,T=w.top,C=new Kn(c.outShape,r.dtype),I=n.data.get(r.dataId).values,A=n.data.get(a.dataId).values,O=C.values,B=nt(r.shape),z=nt(a.shape);for(let P=0;P<c.batchSize;++P){const F=P*B[0],K=P*C.strides[0];for(let X=0;X<c.outDepth;++X){const te=K+X*C.strides[1],Q=X*c.strideDepth-v;for(let q=0;q<h;++q){const oe=Q+q*g;if(oe<0||oe>=c.inDepth)continue;const se=q*z[0],ee=F+oe*B[1];for(let U=0;U<c.outHeight;++U){const G=te+U*C.strides[2],Y=U*c.strideHeight-T;for(let ce=0;ce<p;++ce){const pe=Y+ce*y;if(pe<0||pe>=c.inHeight)continue;const J=se+ce*z[1],we=ee+pe*B[2];for(let Be=0;Be<c.outWidth;++Be){const Fe=G+Be*c.outChannels,Ve=Be*c.strideWidth-$;for(let Me=0;Me<f;++Me){const Pe=Ve+Me*x;if(Pe<0||Pe>=c.inWidth)continue;const pt=J+Me*z[2],yt=we+Pe*c.inChannels;let Dt=pt;for(let kt=0;kt<c.inChannels;++kt){const Ct=I[yt+kt];for(let Nt=0;Nt<c.outChannels;++Nt)O[Fe+Nt]+=Ct*A[Dt+Nt];Dt+=c.outChannels}}}}}}}}return n.makeTensorInfo(C.shape,C.dtype,C.values)}const Xse={kernelName:mb,backendName:"cpu",kernelFunc:Kse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yse(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:a}=e,{strides:i,pad:o,filterShape:l}=s;Ye([r,a],"conv3dBackpropFilterV2");const c=nt(r.shape),h=nt(a.shape),p=jl(r.shape,l,i,1,o),f=p.strideDepth,g=p.strideHeight,y=p.strideWidth,x=p.filterDepth,w=p.filterHeight,v=p.filterWidth,$=new Kn(p.filterShape,"float32"),T=$.values,[C,I,A,O]=$.strides,B=n.data.get(a.dataId).values,[z,P,F,K]=h,X=n.data.get(r.dataId).values,[te,Q,q,oe]=c,se=p.padInfo.front,ee=p.padInfo.left,U=p.padInfo.top;for(let G=0;G<x;++G){const Y=Math.max(0,Math.ceil((se-G)/f)),ce=Math.min(p.outDepth,(p.inDepth+se-G)/f),pe=G*C;for(let J=0;J<w;++J){const we=Math.max(0,Math.ceil((U-J)/g)),Be=Math.min(p.outHeight,(p.inHeight+U-J)/g),Fe=J*I+pe;for(let Ve=0;Ve<v;++Ve){const Me=Math.max(0,Math.ceil((ee-Ve)/y)),Pe=Math.min(p.outWidth,(p.inWidth+ee-Ve)/y),pt=Ve*A+Fe;for(let yt=0;yt<p.inChannels;++yt){const Dt=yt*O+pt;for(let kt=0;kt<p.outChannels;++kt){let Ct=0;for(let Nt=0;Nt<p.batchSize;++Nt){const Gt=Nt*te,Ss=Nt*z;for(let mn=Y;mn<ce;++mn){const Jn=(G+mn*f-se)*Q+Gt,Qr=mn*P+Ss;for(let ln=we;ln<Be;++ln){const Pn=(J+ln*g-U)*q+Jn,Et=ln*F+Qr;for(let _s=Me;_s<Pe;++_s){const ni=(Ve+_s*y-ee)*oe+Pn,dr=_s*K+Et;Ct+=X[ni+yt]*B[dr+kt]}}}}T[Dt+kt]=Ct}}}}}return n.makeTensorInfo($.shape,$.dtype,$.values)}const Zse={kernelName:X2,backendName:"cpu",kernelFunc:Yse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qse(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:a}=e,{pad:i,strides:o,inputShape:l}=s;Ye([r],"conv3dBackpropInputV2");const c=nt(r.shape),h=nt(a.shape),p=jl(l,a.shape,o,1,i),f=new Kn(p.inShape,"float32"),g=f.values,[y,x,w,v]=f.strides,$=n.data.get(r.dataId).values,[T,C,I,A]=c,O=n.data.get(a.dataId).values,[B,z,P,F]=h,{batchSize:K,filterDepth:X,filterHeight:te,filterWidth:Q,inChannels:q,inDepth:oe,inHeight:se,inWidth:ee,outChannels:U,outDepth:G,outHeight:Y,outWidth:ce,strideDepth:pe,strideHeight:J,strideWidth:we}=p,Be=X-1-p.padInfo.front,Fe=te-1-p.padInfo.top,Ve=Q-1-p.padInfo.left;for(let Me=0;Me<K;++Me)for(let Pe=0;Pe<q;++Pe)for(let pt=0;pt<oe;++pt){const yt=pt-Be,Dt=Math.max(0,Math.ceil(yt/pe)),kt=Math.min(G,(X+yt)/pe);for(let Ct=0;Ct<se;++Ct){const Nt=Ct-Fe,Gt=Math.max(0,Math.ceil(Nt/J)),Ss=Math.min(Y,(te+Nt)/J);for(let mn=0;mn<ee;++mn){const ur=mn-Ve,Jn=Math.max(0,Math.ceil(ur/we)),Qr=Math.min(ce,(Q+ur)/we);let ln=0;for(let cr=Dt;cr<kt;++cr){const Pn=cr*pe-yt;for(let Et=Gt;Et<Ss;++Et){const _s=Et*J-Nt;for(let ti=Jn;ti<Qr;++ti){const ni=ti*we-ur,dr=T*Me+C*cr+I*Et+A*ti,Li=B*(X-1-Pn)+z*(te-1-_s)+P*(Q-1-ni)+F*Pe;for(let Rr=0;Rr<U;++Rr){const vn=$[dr+Rr],Dc=O[Li+Rr];ln+=vn*Dc}}}}g[y*Me+x*pt+w*Ct+v*mn+Pe]=ln}}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}const Jse={kernelName:Y2,backendName:"cpu",kernelFunc:Qse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ere=Jt(Vf,t=>Math.cos(t)),tre={kernelName:Vf,backendName:"cpu",kernelFunc:ere};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nre=Jt(Uf,t=>Math.cosh(t)),sre={kernelName:Uf,backendName:"cpu",kernelFunc:nre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rre(t){const{inputs:e,backend:n,attrs:s}=t,{image:r,boxes:a,boxInd:i}=e,{cropSize:o,method:l,extrapolationValue:c}=s,[h,p,f,g]=r.shape,y=a.shape[0],[x,w]=o,v=xt([y,x,w,g],"float32"),$=n.data.get(a.dataId).values,T=n.data.get(i.dataId).values,C=n.data.get(r.dataId).values,I=nt(r.shape),A=nt(v.shape);for(let O=0;O<y;O++){const B=O*4,z=$[B],P=$[B+1],F=$[B+2],K=$[B+3],X=T[O];if(X>=h)continue;const te=x>1?(F-z)*(p-1)/(x-1):0,Q=w>1?(K-P)*(f-1)/(w-1):0;for(let q=0;q<x;q++){const oe=x>1?z*(p-1)+q*te:.5*(z+F)*(p-1);if(oe<0||oe>p-1){for(let se=0;se<w;se++)for(let ee=0;ee<g;ee++){const U=ee+se*A[2]+q*A[1]+O*A[0];v.values[U]=c}continue}if(l==="bilinear"){const se=Math.floor(oe),ee=Math.ceil(oe),U=oe-se;for(let G=0;G<w;G++){const Y=w>1?P*(f-1)+G*Q:.5*(P+K)*(f-1);if(Y<0||Y>f-1){for(let we=0;we<g;we++){const Be=we+G*A[2]+q*A[1]+O*A[0];v.values[Be]=c}continue}const ce=Math.floor(Y),pe=Math.ceil(Y),J=Y-ce;for(let we=0;we<g;we++){let Be=we+ce*I[2]+se*I[1]+X*I[0];const Fe=C[Be];Be=we+pe*I[2]+se*I[1]+X*I[0];const Ve=C[Be];Be=we+ce*I[2]+ee*I[1]+X*I[0];const Me=C[Be];Be=we+pe*I[2]+ee*I[1]+X*I[0];const Pe=C[Be],pt=Fe+(Ve-Fe)*J,yt=Me+(Pe-Me)*J;Be=we+G*A[2]+q*A[1]+O*A[0],v.values[Be]=pt+(yt-pt)*U}}}else for(let se=0;se<w;++se){const ee=w>1?P*(f-1)+se*Q:.5*(P+K)*(f-1);if(ee<0||ee>f-1){for(let Y=0;Y<g;Y++){const ce=Y+se*A[2]+q*A[1]+O*A[0];v.values[ce]=c}continue}const U=Math.round(ee),G=Math.round(oe);for(let Y=0;Y<g;Y++){const ce=Y+U*I[2]+G*I[1]+X*I[0],pe=Y+se*A[2]+q*A[1]+O*A[0];v.values[pe]=C[ce]}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}const are={kernelName:Q2,backendName:"cpu",kernelFunc:rre};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ire(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,exclusive:i,reverse:o}=s;Ye(r,"cumprod");const l=wn([a],r.shape.length);let c=r;l!=null&&(c=lr({inputs:{x:r},backend:n,attrs:{perm:l}}));const h=Dn(1,r.shape.length)[0];if(h!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${h}`);const p=_r(c.dtype,"int32"),f=B2($e(c.shape),p),g=n.data.get(c.dataId).values,y=c.shape[c.shape.length-1],x=o?(v,$)=>v+y-$-1:(v,$)=>v+$;for(let v=0;v<g.length;v+=y)for(let $=0;$<y;$++){const T=x(v,$);if($===0)f[T]=i?1:g[T];else{const C=x(v,$-1);f[T]=i?g[C]*f[C]:g[T]*f[C]}}const w=n.makeTensorInfo(c.shape,p,f);if(l!=null){const v=Kl(l),$=lr({inputs:{x:w},backend:n,attrs:{perm:v}});return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(c),$}return w}const ore={kernelName:Z2,backendName:"cpu",kernelFunc:ire};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lre(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,exclusive:i,reverse:o}=s;Ye(r,"cumsum");const l=wn([a],r.shape.length);let c=r;l!=null&&(c=lr({inputs:{x:r},backend:n,attrs:{perm:l}}));const h=Dn(1,r.shape.length)[0];if(h!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${h}`);const p=_r(c.dtype,"int32"),f=Rs($e(c.shape),p),g=n.data.get(c.dataId).values,y=c.shape[c.shape.length-1],x=o?(v,$)=>v+y-$-1:(v,$)=>v+$;for(let v=0;v<g.length;v+=y)for(let $=0;$<y;$++){const T=x(v,$);if($===0)f[T]=i?0:g[T];else{const C=x(v,$-1);f[T]=i?g[C]+f[C]:g[T]+f[C]}}const w=n.makeTensorInfo(c.shape,p,f);if(l!=null){const v=Kl(l),$=lr({inputs:{x:w},backend:n,attrs:{perm:v}});return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(c),$}return w}const ure={kernelName:gb,backendName:"cpu",kernelFunc:lre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cre(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:a}=e,{size:i,binaryOutput:o}=s;if(r.shape.length===1){const l=n.data.get(r.dataId).values,c=n.data.get(a.dataId).values,h=IC(l,c,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,h)}else if(r.shape.length===2){const l=n.bufferSync(r),c=n.bufferSync(a),h=QM(l,c,i,o);return n.makeTensorInfo(h.shape,a.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const dre={kernelName:J2,backendName:"cpu",kernelFunc:cre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hre(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockSize:a,dataFormat:i}=s;V(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const o=r.shape[0],l=r.shape[1],c=r.shape[2],h=r.shape[3],p=l*a,f=c*a,g=h/(a*a),y=n.data.get(r.dataId).values,x=new Float32Array(o*p*f*g);let w=0;for(let v=0;v<o;++v)for(let $=0;$<p;++$){const T=Math.floor($/a),C=$%a;for(let I=0;I<f;++I){const A=Math.floor(I/a),O=I%a,B=(C*a+O)*g;for(let z=0;z<g;++z){const F=z+B+h*(A+c*(T+l*v));x[w++]=y[F]}}}return n.makeTensorInfo([o,p,f,g],r.dtype,x)}const pre={kernelName:eS,backendName:"cpu",kernelFunc:hre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q4(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a}=e,{strides:i,pad:o,dilations:l,dimRoundingMode:c}=s;Ye([r,a],"depthwiseConv2DNative");const h=nt(r.shape),p=nt(a.shape);let f=l;f==null&&(f=[1,1]),V(xs(i,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${f}'`);const g=os(r.shape,a.shape,i,f,o,c,!0),{filterHeight:y,filterWidth:x,dilationHeight:w,dilationWidth:v,padInfo:$}=g,T=$.left,C=$.top,I=g.outChannels/g.inChannels,A=new Kn(g.outShape,r.dtype),O=n.data.get(r.dataId).values,B=n.data.get(a.dataId).values,z=A.values;for(let P=0;P<g.batchSize;++P){const F=P*h[0],K=P*A.strides[0];for(let X=0;X<g.outHeight;++X){const te=K+X*A.strides[1],Q=X*g.strideHeight-C;for(let q=0;q<y;++q){const oe=Q+q*w;if(oe<0||oe>=g.inHeight)continue;const se=q*p[0],ee=F+oe*h[1];for(let U=0;U<g.outWidth;++U){const G=te+U*A.strides[2],Y=U*g.strideWidth-T;for(let ce=0;ce<x;++ce){const pe=Y+ce*v;if(pe<0||pe>=g.inWidth)continue;const J=se+ce*p[1],we=ee+pe*g.inChannels;let Be=G,Fe=J;for(let Ve=0;Ve<g.inChannels;++Ve){const Me=O[we+Ve];for(let Pe=0;Pe<I;++Pe)z[Be+Pe]+=Me*B[Fe+Pe];Be+=I,Fe+=I}}}}}}return n.makeTensorInfo(A.shape,A.dtype,A.values)}const fre={kernelName:yb,backendName:"cpu",kernelFunc:Q4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mre(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:a}=e,{strides:i,dilations:o,pad:l,dimRoundingMode:c,filterShape:h}=s;Ye([r,a],"depthwiseConv2dNativeBackpropFilter");const p=os(r.shape,h,i,o,l,c,!0),{strideHeight:f,strideWidth:g,filterHeight:y,filterWidth:x}=p,w=new Kn(p.filterShape,"float32"),v=p.padInfo.left,$=p.padInfo.top,T=p.outChannels/p.inChannels,C=n.data.get(r.dataId).values,I=new Kn(r.shape,r.dtype,C),A=n.data.get(a.dataId).values,O=new Kn(a.shape,a.dtype,A);for(let B=0;B<y;++B){const z=Math.max(0,Math.ceil(($-B)/f)),P=Math.min(p.outHeight,(p.inHeight+$-B)/f);for(let F=0;F<x;++F){const K=Math.max(0,Math.ceil((v-F)/g)),X=Math.min(p.outWidth,(p.inWidth+v-F)/g);for(let te=0;te<p.outChannels;++te){const Q=Math.trunc(te/T),q=te%T;let oe=0;for(let se=0;se<p.batchSize;++se)for(let ee=z;ee<P;++ee){const U=B+ee*f-$;for(let G=K;G<X;++G){const Y=F+G*g-v;oe+=I.get(se,U,Y,Q)*O.get(se,ee,G,te)}}w.set(oe,B,F,Q,q)}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}const gre={kernelName:tS,backendName:"cpu",kernelFunc:mre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yre(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:a}=e,{strides:i,dilations:o,pad:l,dimRoundingMode:c,inputShape:h}=s;Ye([r,a],"depthwiseConv2DNativeBackpropInput");const p=nt(r.shape),f=nt(a.shape),g=os(h,a.shape,i,o,l,c,!0),y=new Kn(g.inShape,"float32"),x=y.values,[w,v,$]=y.strides,T=n.data.get(r.dataId).values,[C,I,A]=p,O=n.data.get(a.dataId).values,[B,z,P]=f,{batchSize:F,filterHeight:K,filterWidth:X,inChannels:te,inHeight:Q,inWidth:q,outChannels:oe,outHeight:se,outWidth:ee,strideHeight:U,strideWidth:G}=g,Y=K-1-g.padInfo.top,ce=X-1-g.padInfo.left,pe=oe/te;for(let J=0;J<F;++J)for(let we=0;we<te;++we)for(let Be=0;Be<Q;++Be){const Fe=Be-Y,Ve=Math.max(0,Math.ceil(Fe/U)),Me=Math.min(se,(K+Fe)/U);for(let Pe=0;Pe<q;++Pe){const pt=Pe-ce,yt=Math.max(0,Math.ceil(pt/G)),Dt=Math.min(ee,(X+pt)/G);let kt=0;for(let Ct=Ve;Ct<Me;++Ct){const Nt=Ct*U-Fe;for(let Gt=yt;Gt<Dt;++Gt){const Ss=Gt*G-pt,mn=C*J+I*Ct+A*Gt,ur=B*(K-1-Nt)+z*(X-1-Ss)+P*we;for(let Jn=0;Jn<pe;++Jn){const Qr=we*pe+Jn,ln=T[mn+Qr],cr=O[ur+Jn];kt+=ln*cr}}}x[w*J+v*Be+$*Pe+we]=kt}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}const bre={kernelName:nS,backendName:"cpu",kernelFunc:yre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xre(t){const{inputs:e,backend:n}=t,{x:s}=e,r=$e(s.shape),a=n.data.get(s.dataId).values,i=xt([r,r],s.dtype),o=i.values;for(let c=0;c<a.length;c++)o[c*r+c]=a[c];const l=[...s.shape,...s.shape];return n.makeTensorInfo(l,i.dtype,i.values)}const wre={kernelName:sS,backendName:"cpu",kernelFunc:xre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vre={kernelName:bb,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r}=t,{strides:a,pad:i,dilations:o}=n,l=e,c=l.data.get(s.dataId).values,h=s.shape.length,p=l.data.get(r.dataId).values,f=r.shape.length,{batchSize:g,inHeight:y,inWidth:x,inChannels:w,outHeight:v,outWidth:$,padInfo:T,strideHeight:C,strideWidth:I,filterHeight:A,filterWidth:O,dilationHeight:B,dilationWidth:z,outShape:P}=km(s.shape,r.shape,a,i,"NHWC",o),F=$e(P),K=P.length,X=An(s.dtype,F);for(let Q=0;Q<g;++Q)for(let q=0;q<v;++q){const oe=q*C-T.top;for(let se=0;se<$;++se){const ee=se*I-T.left;for(let U=0;U<w;++U){let G=Number.MIN_SAFE_INTEGER;for(let ce=0;ce<A;++ce){const pe=oe+ce*B;if(pe>=0&&pe<y)for(let J=0;J<O;++J){const we=ee+J*z;if(we>=0&&we<x){const Be=_i([Q,pe,we,U],h,nt(s.shape)),Fe=_i([ce,J,U],f,nt(r.shape)),Ve=c[Be]+p[Fe];Ve>G&&(G=Ve)}}}const Y=_i([Q,q,se,U],K,nt(P));X[Y]=G}}}return{dataId:l.write(wc(X,s.dtype),P,s.dtype),shape:P,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $re={kernelName:T$,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r,dy:a}=t,{strides:i,pad:o,dilations:l}=n,c=e,h=xa(s.shape,c.data.get(s.dataId).values),p=xa(r.shape,c.data.get(r.dataId).values),{batchSize:f,inHeight:g,inWidth:y,inChannels:x,outHeight:w,outWidth:v,padInfo:$,strideHeight:T,strideWidth:C,filterHeight:I,filterWidth:A,dilationHeight:O,dilationWidth:B,outShape:z}=km(s.shape,r.shape,i,o,"NHWC",l);V(a.rank===z.length,()=>`Error in ${T$}, dy must have the same rank as output ${z.length}, but got ${a.rank}`);const P=xa(z,c.data.get(a.dataId).values),F=YD(r.shape,r.dtype);for(let X=0;X<f;++X)for(let te=0;te<w;++te){const Q=te*T-$.top;for(let q=0;q<v;++q){const oe=q*C-$.left;for(let se=0;se<x;++se){let ee=Number.MIN_SAFE_INTEGER,U=0,G=0;for(let Y=0;Y<I;++Y){const ce=Q+Y*O;if(ce>=0&&ce<g)for(let pe=0;pe<A;++pe){const J=oe+pe*B;if(J>=0&&J<y){const we=h[X][ce][J][se]+p[Y][pe][se];we>ee&&(ee=we,U=Y,G=pe)}}}F[U][G][se]+=P[X][te][q][se]}}}return{dataId:c.write(wc(F,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sre={kernelName:C$,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r,dy:a}=t,{strides:i,pad:o,dilations:l}=n,c=e,h=xa(s.shape,c.data.get(s.dataId).values),p=xa(r.shape,c.data.get(r.dataId).values),{batchSize:f,inHeight:g,inWidth:y,inChannels:x,outHeight:w,outWidth:v,padInfo:$,strideHeight:T,strideWidth:C,filterHeight:I,filterWidth:A,dilationHeight:O,dilationWidth:B,outShape:z}=km(s.shape,r.shape,i,o,"NHWC",l);V(a.rank===z.length,()=>`Error in ${C$}, dy must have the same rank as output ${z.length}, but got ${a.rank}`);const P=xa(z,c.data.get(a.dataId).values),F=YD(s.shape,s.dtype);for(let X=0;X<f;++X)for(let te=0;te<w;++te){const Q=te*T-$.top;for(let q=0;q<v;++q){const oe=q*C-$.left;for(let se=0;se<x;++se){let ee=Number.MIN_SAFE_INTEGER,U=Q<0?0:Q,G=oe<0?0:oe;for(let Y=0;Y<I;++Y){const ce=Q+Y*O;if(ce>=0&&ce<g)for(let pe=0;pe<A;++pe){const J=oe+pe*B;if(J>=0&&J<y){const we=h[X][ce][J][se]+p[Y][pe][se];we>ee&&(ee=we,U=ce,G=J)}}}F[X][U][G][se]+=P[X][te][q][se]}}}return{dataId:c.write(wc(F,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _re(t){const{inputs:e,backend:n,attrs:s}=t,{image:r}=e,{canvas:a,options:i}=s,{contextOptions:o,imageOptions:l}=i||{},c=(l==null?void 0:l.alpha)||1,h=(o==null?void 0:o.contextType)||"2d";if(h!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const p=a.getContext(h,(o==null?void 0:o.contextAttributes)||{});if(p==null)throw new Error(`Could not get the context with ${h} type.`);const[f,g]=r.shape.slice(0,2),y=r.shape.length===2?1:r.shape[2],x=n.data.get(r.dataId).values,w=r.dtype==="float32"?255:1,v=new Uint8ClampedArray(g*f*4);for(let T=0;T<f*g;++T){const C=[0,0,0,255*c];for(let A=0;A<y;A++){const O=x[T*y+A];if(r.dtype==="float32"){if(O<0||O>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${O}.`)}else if(r.dtype==="int32"&&(O<0||O>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${O}.`);y===1?(C[0]=O*w,C[1]=O*w,C[2]=O*w):C[A]=O*w}const I=T*4;v[I+0]=Math.round(C[0]),v[I+1]=Math.round(C[1]),v[I+2]=Math.round(C[2]),v[I+3]=Math.round(C[3])}a.width=g,a.height=f;const $=new ImageData(v,g,f);return p.putImageData($,0,0),r}const Cre={kernelName:L6,backendName:"cpu",kernelFunc:_re};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hm(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s;Ye(r,"sum");let o;r.dtype==="bool"?o=Vl({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):o=Ri({inputs:{x:r},backend:n});const l=o.shape.length,c=St(a,o.shape),h=wn(c,l);let p=c,f=o;h!=null&&(f=lr({inputs:{x:o},backend:n,attrs:{perm:h}}),p=Dn(p.length,l)),ws("sum",p,f.shape.length);const[g,y]=ls(f.shape,p),x=_r(f.dtype,"int32");let w=F0(n,g,x);const v=$e(y),$=n.data.get(w.dataId).values,T=n.data.get(f.dataId).values;for(let C=0;C<$.length;++C){const I=C*v;let A=0;for(let O=0;O<v;++O)A+=T[I+O];$[C]=A}if(i){const C=Rn(w.shape,c),I=w;w=on({inputs:{x:w},backend:n,attrs:{shape:C}}),n.disposeIntermediateTensorInfo(I)}return n.disposeIntermediateTensorInfo(o),h!=null&&n.disposeIntermediateTensorInfo(f),w}const Tre={kernelName:Zb,backendName:"cpu",kernelFunc:Hm};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kre(t){const{inputs:e,backend:n,attrs:s}=t,{equation:r}=s,a=e,{allDims:i,summedDims:o,idDims:l}=Q_(r,a.length);eC(i.length,l,a);const{path:c,steps:h}=tC(o,l),p=h.length;let f=null,g=i.length;const y=[];for(let x=0;x<p;++x){for(const w of h[x]){const{permutationIndices:v,expandDims:$}=J_(g,l[w]);let T;nC(v)?T=a[w]:(T=lr({inputs:{x:a[w]},backend:n,attrs:{perm:v}}),y.push(T));const C=T.shape.slice();for(let I=0;I<$.length;++I)C.splice($[I],0,1);Rt(T.shape,C)||(T=on({inputs:{x:T},backend:n,attrs:{shape:C}}),y.push(T)),f===null?f=T:(f=Wx({inputs:{a:T,b:f},backend:n}),y.push(f))}x<p-1&&(c[x]>=0&&(f=Hm({inputs:{x:f},backend:n,attrs:{axis:c[x]-(i.length-g),keepDims:!1}}),y.push(f)),g--)}for(const x of y)x!==f&&n.disposeIntermediateTensorInfo(x);return f}const Nre={kernelName:rS,backendName:"cpu",kernelFunc:kre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ire(t){const{inputs:e,backend:n}=t,{dy:s,y:r}=e;Ye([s,r],"eluGrad");const a=new Float32Array($e(r.shape)),i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values;for(let l=0;l<i.length;++l){const c=i[l];c>=0?a[l]=o[l]:a[l]=o[l]*(c+1)}return n.makeTensorInfo(r.shape,"float32",a)}const Ere={kernelName:aS,backendName:"cpu",kernelFunc:Ire};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Are=H_,Rre=q_,Dre=j_,Ore=K_,zre=X_,Fre=Y_,Lre=Jt(Hf,t=>{const e=Math.sign(t),n=Math.abs(t),s=1/(1+Are*n);return e*(1-((((Fre*s+zre)*s+Ore)*s+Dre)*s+Rre)*s*Math.exp(-n*n))}),Mre={kernelName:Hf,backendName:"cpu",kernelFunc:Lre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B0(t){const{inputs:e,backend:n,attrs:s}=t,{input:r}=e,{dim:a}=s,i=r.shape.length,o=r.shape.slice();let l=a;return a<0&&(V(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),on({inputs:{x:r},backend:n,attrs:{shape:o}})}const Bre={kernelName:wb,backendName:"cpu",kernelFunc:B0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pre=zn((t,e)=>t/e),zC=Qn(Wf,Pre),d2={kernelName:Wf,backendName:"cpu",kernelFunc:zC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J4(t,e,n){const s=t.shape,r=s[0],a=s[1],i=n.data.get(t.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,c=[r,a],h=$e(c),p=ys("float32",h),f=ys("float32",h);for(let w=0;w<r;w++){const v=fc({inputs:{x:o},backend:n,attrs:{begin:[w,0],size:[1,a]}}),$=fc({inputs:{x:l},backend:n,attrs:{begin:[w,0],size:[1,a]}}),T=$r({inputs:{real:v,imag:$},backend:n}),{real:C,imag:I}=Vre(T,e,n),A=ko(C,I);for(let O=0;O<a;O++){const B=Z_(A,O);p[w*a+O]=B.real,f[w*a+O]=B.imag}n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo($),n.disposeIntermediateTensorInfo(T)}const g=n.makeTensorInfo(c,"float32",p),y=n.makeTensorInfo(c,"float32",f),x=$r({inputs:{real:g,imag:y},backend:n});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),x}function Vre(t,e,n){const s=$e(t.shape),r=n.data.get(t.dataId),a=n.data.get(r.complexTensorInfos.real.dataId).values,i=n.data.get(r.complexTensorInfos.imag.dataId).values;if(Ure(s)){const o=h2(a,i,s,e,n),l=[t.shape[0],t.shape[1]];if(e){const c=n.makeTensorInfo(l,"float32",o.real),h=n.makeTensorInfo(l,"float32",o.imag),p=n.makeTensorInfo([],"float32",Gl(s,"float32")),f=Ri({inputs:{x:p},backend:n}),g=d2.kernelFunc({inputs:{a:c,b:p},backend:n}),y=d2.kernelFunc({inputs:{a:h,b:f},backend:n}),x=n.data.get(g.dataId).values,w=n.data.get(y.dataId).values;return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),{real:x,imag:w}}return o}else{const o=ko(a,i),l=Wre(o,s,e);return uF(l)}}function Ure(t){return(t&t-1)===0}function h2(t,e,n,s,r){if(n===1)return{real:t,imag:e};const a=ko(t,e),i=n/2,o=cF(a),l=o.real,c=o.imag,h=[l.length],p=r.makeTensorInfo(h,"float32",l),f=r.makeTensorInfo(h,"float32",c),g=$r({inputs:{real:p,imag:f},backend:r}),y=dF(a),x=y.real,w=y.imag,v=[x.length],$=r.makeTensorInfo(v,"float32",x),T=r.makeTensorInfo(v,"float32",w),C=$r({inputs:{real:$,imag:T},backend:r}),I=h2(l,c,i,s,r),A=I.real,O=I.imag,B=[A.length],z=r.makeTensorInfo(B,"float32",A),P=r.makeTensorInfo(B,"float32",O),F=$r({inputs:{real:z,imag:P},backend:r}),K=h2(x,w,i,s,r),X=K.real,te=K.imag,Q=[X.length],q=r.makeTensorInfo(Q,"float32",X),oe=r.makeTensorInfo(Q,"float32",te),se=$r({inputs:{real:q,imag:oe},backend:r}),ee=pF(n,s),U=[ee.real.length],G=r.makeTensorInfo(U,"float32",ee.real),Y=r.makeTensorInfo(U,"float32",ee.imag),ce=$r({inputs:{real:G,imag:Y},backend:r}),pe=Wx({inputs:{a:ce,b:se},backend:r}),J=Gd({inputs:{a:F,b:pe},backend:r}),we=DC({inputs:{a:F,b:pe},backend:r}),Be=pc({inputs:{input:J},backend:r}),Fe=pc({inputs:{input:we},backend:r}),Ve=Hd({inputs:{input:J},backend:r}),Me=Hd({inputs:{input:we},backend:r}),Pe=qd({inputs:[Be,Fe],backend:r,attrs:{axis:0}}),pt=qd({inputs:[Ve,Me],backend:r,attrs:{axis:0}}),yt=r.data.get(Pe.dataId).values,Dt=r.data.get(pt.dataId).values;return r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo($),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(oe),r.disposeIntermediateTensorInfo(se),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(Y),r.disposeIntermediateTensorInfo(ce),r.disposeIntermediateTensorInfo(pe),r.disposeIntermediateTensorInfo(J),r.disposeIntermediateTensorInfo(we),r.disposeIntermediateTensorInfo(Be),r.disposeIntermediateTensorInfo(Ve),r.disposeIntermediateTensorInfo(Fe),r.disposeIntermediateTensorInfo(Me),r.disposeIntermediateTensorInfo(Pe),r.disposeIntermediateTensorInfo(pt),{real:yt,imag:Dt}}function Wre(t,e,n){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let a=0,i=0;for(let o=0;o<e;o++){const l=fF(r*o,e,n),c=Z_(t,o);a+=c.real*l.real-c.imag*l.imag,i+=c.real*l.imag+c.imag*l.real}n&&(a/=e,i/=e),hF(s,a,i,r)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gre(t){const{inputs:e,backend:n}=t,{input:s}=e,r=$e(s.shape),a=s.shape[s.shape.length-1],i=r/a,o=on({inputs:{x:s},backend:n,attrs:{shape:[i,a]}}),l=J4(o,!1,n),c=on({inputs:{x:l},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),c}const Hre={kernelName:iS,backendName:"cpu",kernelFunc:Gre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FC(t){const{backend:e,attrs:n}=t,{shape:s,value:r,dtype:a}=n,i=a||Jd(r),o=An(i,$e(s));return jre(o,r,i),e.makeTensorInfo(s,i,o)}const qre={kernelName:oS,backendName:"cpu",kernelFunc:FC};function jre(t,e,n){t.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kre={kernelName:lS,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,r=n,a=ys(s.dtype,$e(s.shape)),[i,o,l,c]=s.shape,h=r.data.get(s.dataId).values;for(let f=0;f<i;f++){const g=f*l*o*c;for(let y=0;y<o;y++){const x=y*(l*c);for(let w=0;w<l;w++){const v=w*c;for(let $=0;$<c;$++){const T=Math.round(l-w-1),C=g+x+v+$;let I=h[C];if(T>=0&&T<l){const A=T*c,O=g+x+A+$;I=h[O]}a[C]=I}}}}return{dataId:r.write(a,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xre(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a,bias:i,preluActivationWeights:o}=e,{strides:l,pad:c,dataFormat:h,dilations:p,dimRoundingMode:f,activation:g,leakyreluAlpha:y}=s;let x=Z4({inputs:{x:r,filter:a},backend:n,attrs:{strides:l,pad:c,dataFormat:h,dilations:p,dimRoundingMode:f}});if(i){const w=x;if(h==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){const v=on({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});x=Gd({inputs:{a:x,b:v},backend:n}),n.disposeIntermediateTensorInfo(v)}else x=Gd({inputs:{a:x,b:i},backend:n});n.disposeIntermediateTensorInfo(w)}if(g){const w=x;if(h==="NCHW"&&g==="prelu"&&o.shape.length===1&&o.shape[0]!==1){const v=on({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});x=M0(n,x,g,v,y),n.disposeIntermediateTensorInfo(v)}else x=M0(n,x,g,o,y);n.disposeIntermediateTensorInfo(w)}return x}const Yre={kernelName:b0,backendName:"cpu",kernelFunc:Xre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zre(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a,bias:i,preluActivationWeights:o}=e,{strides:l,pad:c,dataFormat:h,dilations:p,dimRoundingMode:f,activation:g,leakyreluAlpha:y}=s;let x=Q4({inputs:{x:r,filter:a},backend:n,attrs:{strides:l,pad:c,dataFormat:h,dilations:p,dimRoundingMode:f}});if(i){const w=x;x=Gd({inputs:{a:x,b:i},backend:n}),n.disposeIntermediateTensorInfo(w)}if(g){const w=x;x=M0(n,x,g,o,y),n.disposeIntermediateTensorInfo(w)}return x}const Qre={kernelName:x0,backendName:"cpu",kernelFunc:Zre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jre(t){const{inputs:e,backend:n}=t,{params:s,indices:r}=e,a=$e(s.shape),i=r.shape,o=i[i.length-1],[l,c,h,p]=O_(s,r);if(c===0)return n.makeTensorInfo(l,s.dtype,[]);const f=n.data.get(r.dataId).values,g=n.bufferSync(s),y=u4(f,g,s.dtype,c,o,h,p,s.shape,a);return n.makeTensorInfo(l,s.dtype,y.values)}const eae={kernelName:uS,backendName:"cpu",kernelFunc:Jre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,indices:a}=e,{axis:i,batchDims:o}=s;Ye([r,a],"gatherV2");const l=St(i,r.shape)[0],c=n.data.get(a.dataId).values,h=r.shape[l];for(let C=0;C<c.length;++C){const I=c[C];V(I<=h-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${h-1}]`)}let p=o;o==null&&(p=0);const f=$e(a.shape),g=rC(r,a,l,p),y=on({inputs:{x:r},backend:n,attrs:{shape:[g.batchSize,g.outerSize,g.dimSize,g.sliceSize]}}),x=on({inputs:{x:a},backend:n,attrs:{shape:[g.batchSize,f/g.batchSize]}}),w=[g.batchSize,g.outerSize,f/g.batchSize,g.sliceSize],v=n.bufferSync(x),$=n.bufferSync(y),T=c4($,v,w);return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x),n.makeTensorInfo(g.outputShape,T.dtype,T.values)}const nae={kernelName:$b,backendName:"cpu",kernelFunc:tae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sae(t){const{inputs:e,backend:n}=t,{input:s}=e,r=$e(s.shape),a=s.shape[s.shape.length-1],i=r/a,o=on({inputs:{x:s},backend:n,attrs:{shape:[i,a]}}),l=J4(o,!0,n),c=on({inputs:{x:l},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),c}const rae={kernelName:cS,backendName:"cpu",kernelFunc:sae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aae=Jt(Qf,t=>Number.isFinite(t)?1:0,"bool"),iae={kernelName:Qf,backendName:"cpu",kernelFunc:aae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oae=Jt(Jf,t=>Math.abs(t)===1/0?1:0,"bool"),lae={kernelName:Jf,backendName:"cpu",kernelFunc:oae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uae=Jt(em,t=>Number.isNaN(t)?1:0,"bool"),cae={kernelName:em,backendName:"cpu",kernelFunc:uae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dae(t){const{backend:e,attrs:n}=t,{start:s,stop:r,num:a}=n,i=m4(s,r,a);return e.makeTensorInfo([i.length],"float32",i)}const hae={kernelName:hS,backendName:"cpu",kernelFunc:dae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pae=Jt(nm,t=>Math.log1p(t)),fae={kernelName:nm,backendName:"cpu",kernelFunc:pae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mae=zn((t,e)=>t&&e),gae=Qn(kb,mae,null,"bool"),yae={kernelName:kb,backendName:"cpu",kernelFunc:gae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bae=Jt(Nb,t=>t?0:1,"bool"),xae={kernelName:Nb,backendName:"cpu",kernelFunc:bae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wae=zn((t,e)=>t||e),vae=Qn(Ib,wae,null,"bool"),$ae={kernelName:Ib,backendName:"cpu",kernelFunc:vae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{depthRadius:a,bias:i,alpha:o,beta:l}=s;Ye(r,"LRN");const c=r.shape[3],h=c-1,p=n.data.get(r.dataId).values,f=$e(r.shape),g=new Float32Array(f);function y(x){const w=x%c;let v=x-w+Math.max(0,w-a);const $=x-w+Math.min(w+a,h);let T=0;for(;v<=$;v++){const C=p[v];T+=C*C}return T}for(let x=0;x<f;x++){const w=y(x),v=p[x]*Math.pow(i+o*w,-l);g[x]=v}return n.makeTensorInfo(r.shape,r.dtype,g)}const _ae={kernelName:Eb,backendName:"cpu",kernelFunc:Sae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,y:a,dy:i}=e,{depthRadius:o,bias:l,alpha:c,beta:h}=s;Ye(i,"LRNGrad");const p=$e(i.shape),f=i.shape[3],g=n.data.get(i.dataId).values,y=n.data.get(r.dataId).values,x=n.data.get(a.dataId).values,w=new Float32Array(p),v=p;for(let $=0;$<v;$++){const T=$%f,C=$-T+Math.max(0,T-o),I=$-T+Math.min(f,T+o+1);let A=0;for(let O=C;O<I;O++)A+=Math.pow(y[O],2);A=c*A+l;for(let O=C;O<I;O++){let B=-2*c*h*y[O]*x[$]/A;$===O&&(B+=Math.pow(A,-h)),B*=g[$],w[O]+=B}}return n.makeTensorInfo(i.shape,r.dtype,w)}const Tae={kernelName:pS,backendName:"cpu",kernelFunc:Cae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eB(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reductionIndices:a,keepDims:i}=s,o=n;let l=r.shape;const c=l.length,h=St(a,l);let p=h;const f=wn(p,c);let g=o.data.get(r.dataId).values;if(f!=null){const C=new Array(c);for(let I=0;I<C.length;I++)C[I]=l[f[I]];g=AC(g,l,r.dtype,f,C),p=Dn(p.length,c),l=C}Ye(r,"max"),ws("max",p,c);const[y,x]=ls(l,p),w=$e(x),v=y4(g,w,y,r.dtype),$=o.write(v,y,r.dtype);let T=y;return i&&(T=Rn(y,h)),{dataId:$,shape:T,dtype:r.dtype}}const kae={kernelName:Ab,backendName:"cpu",kernelFunc:eB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;Ye(r,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=s,c=1;V(xs(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const h=_a(r.shape,a,i,c,o,l);let p;if(h.filterWidth===1&&h.filterHeight===1&&Rt(h.inShape,h.outShape))p=Ri({inputs:{x:r},backend:n});else{const f=n.data.get(r.dataId).values,g=nt(r.shape),y=OC(f,r.shape,r.dtype,g,h,"max");p=n.makeTensorInfo(h.outShape,r.dtype,y.values)}return p}const Iae={kernelName:Rb,backendName:"cpu",kernelFunc:Nae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:c}=s;Ye(r,"maxPool3d");const h=Eo(r.shape,a,i,1,o,l,c),p=n.data.get(r.dataId).values,f=Y4(p,r.shape,r.dtype,nt(r.shape),h,"max");return n.makeTensorInfo(f.shape,"float32",f.values)}const Aae={kernelName:Db,backendName:"cpu",kernelFunc:Eae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rae(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:a}=e,{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=s;Ye([r,a],"maxPool3DGrad");const h=Eo(a.shape,i,o,1,l,c),p=n.bufferSync(a),f=wse(p,h),g=h.strideDepth,y=h.strideHeight,x=h.strideWidth,w=h.dilationDepth,v=h.dilationHeight,$=h.dilationWidth,T=h.effectiveFilterDepth,C=h.effectiveFilterHeight,I=h.effectiveFilterWidth,A=T-1-h.padInfo.front,O=I-1-h.padInfo.left,B=C-1-h.padInfo.top,z=xt(a.shape,"float32"),P=n.bufferSync(r);for(let F=0;F<h.batchSize;++F)for(let K=0;K<h.inChannels;++K)for(let X=0;X<h.inDepth;++X)for(let te=0;te<h.inHeight;++te)for(let Q=0;Q<h.inWidth;++Q){const q=X-A,oe=te-B,se=Q-O;let ee=0;for(let U=0;U<T;U+=w){const G=(q+U)/g;if(!(G<0||G>=h.outDepth||Math.floor(G)!==G))for(let Y=0;Y<C;Y+=v){const ce=(oe+Y)/y;if(!(ce<0||ce>=h.outHeight||Math.floor(ce)!==ce))for(let pe=0;pe<I;pe+=$){const J=(se+pe)/x;if(J<0||J>=h.outWidth||Math.floor(J)!==J)continue;const we=T*C*I-1-f.get(F,G,ce,J,K),Be=U*C*I+Y*I+pe,Fe=we===Be?1:0;if(Fe===0)continue;const Ve=P.get(F,G,ce,J,K);ee+=Ve*Fe}}}z.set(ee,F,X,te,Q,K)}return n.makeTensorInfo(z.shape,z.dtype,z.values)}const Dae={kernelName:mS,backendName:"cpu",kernelFunc:Rae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oae(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:a,output:i}=e,o=a;Ye([a,i],"maxPoolGrad");const{filterSize:l,strides:c,pad:h,dimRoundingMode:p}=s,f=_a(o.shape,l,c,1,h,p),g=n.data.get(o.dataId).values,y=xt(f.outShape,o.dtype,X4(g,o.shape,o.dtype,f).values),x=f.strideHeight,w=f.strideWidth,v=f.dilationHeight,$=f.dilationWidth,T=f.effectiveFilterHeight,C=f.effectiveFilterWidth,I=C-1-f.padInfo.left,A=T-1-f.padInfo.top,O=xt(o.shape,"float32"),B=n.data.get(r.dataId).values,z=xt(r.shape,"float32",B);for(let P=0;P<f.batchSize;++P)for(let F=0;F<f.inChannels;++F)for(let K=0;K<f.inHeight;++K)for(let X=0;X<f.inWidth;++X){const te=K-A,Q=X-I;let q=0;for(let oe=0;oe<T;oe+=v){const se=(te+oe)/x;if(!(se<0||se>=f.outHeight||Math.floor(se)!==se))for(let ee=0;ee<C;ee+=$){const U=(Q+ee)/w;if(U<0||U>=f.outWidth||Math.floor(U)!==U)continue;const G=T*C-1-y.get(P,se,U,F),Y=oe*C+ee,ce=G===Y?1:0;if(ce===0)continue;const pe=z.get(P,se,U,F);q+=pe*ce}}O.set(q,P,K,X,F)}return n.makeTensorInfo(O.shape,O.dtype,O.values)}const zae={kernelName:fS,backendName:"cpu",kernelFunc:Oae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fae(t,e,n,s,r){const a=nt(e),i=OC(t,e,n,a,r,"max"),o=X4(t,e,n,r,!0,s);return[i.values,o.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lae={kernelName:gS,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{filterSize:r,strides:a,pad:i,includeBatchInIndex:o}=e,l=n;Ye(s,"MaxPoolWithArgmax");const c=l.data.get(s.dataId).values,h=_a(s.shape,r,a,[1,1],i),[p,f]=Fae(c,s.shape,s.dtype,o,h),g=l.write(p,h.outShape,s.dtype),y=l.write(f,h.outShape,s.dtype);return[{dataId:g,shape:h.outShape,dtype:s.dtype},{dataId:y,shape:h.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s,o=St(a,r.shape),c=ls(r.shape,o)[1],h=$e(c),p=[],f=n.makeTensorInfo([],"float32",new Float32Array([h]));p.push(f);const g=Vl({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});p.push(g);const y=zC({inputs:{a:g,b:f},backend:n});p.push(y);const x=Hm({inputs:{x:y},backend:n,attrs:{axis:a,keepDims:i}});return p.forEach(w=>n.disposeIntermediateTensorInfo(w)),x}const Bae={kernelName:Ob,backendName:"cpu",kernelFunc:Mae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s;Ye(r,"min");const o=St(a,r.shape);let l=o;const c=wn(l,r.shape.length);let h=r;c!=null&&(h=lr({inputs:{x:r},backend:n,attrs:{perm:c}}),l=Dn(l.length,r.shape.length)),ws("min",l,h.shape.length);const[p,f]=ls(h.shape,l),g=$e(f),y=Rs($e(p),h.dtype),x=n.data.get(h.dataId).values;for(let v=0;v<y.length;++v){const $=v*g;let T=x[$];for(let C=0;C<g;++C){const I=x[$+C];(Number.isNaN(I)||I<T)&&(T=I)}y[v]=T}c!=null&&n.disposeIntermediateTensorInfo(h);const w=n.makeTensorInfo(p,h.dtype,y);if(i){const v=Rn(p,o),$=on({inputs:{x:w},backend:n,attrs:{shape:v}});return n.disposeIntermediateTensorInfo(w),$}return w}const Vae={kernelName:zb,backendName:"cpu",kernelFunc:Pae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:a,mode:i}=s;Ye(r,"mirrorPad");const o=a.map((T,C)=>T[0]+r.shape[C]+T[1]),l=a.map(T=>T[0]),c=a.map((T,C)=>T[0]+r.shape[C]),h=i==="reflect"?0:1,p=n.data.get(r.dataId).values,f=r.shape.length,g=nt(r.shape),y=$e(o),x=o.length,w=nt(o),v=ys(r.dtype,y);for(let T=0;T<y;T++){let C=eh(T,x,w);for(let A=0;A<x;A++)C[A]<l[A]?C[A]=l[A]*2-C[A]-h:C[A]>=c[A]&&(C[A]=(c[A]-1)*2-C[A]+h);C=C.map((A,O)=>A-l[O]);const I=_i(C,f,g);v[T]=p[I]}return{dataId:n.write(v,o,r.dtype),shape:o,dtype:r.dtype}}const Wae={kernelName:Fb,backendName:"cpu",kernelFunc:Uae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gae=zn((t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e}),Hae=Qn(am,Gae),qae={kernelName:am,backendName:"cpu",kernelFunc:Hae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tB(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{dim:a}=s,i=r.shape.length;let o=a;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const l=St([o],r.shape),c=eB({inputs:{x:r},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),h=Rn(c.shape,l),p=on({inputs:{x:c},backend:n,attrs:{shape:h}}),f=DC({inputs:{a:r,b:p},backend:n}),g=a4({inputs:{x:f},backend:n}),y=Hm({inputs:{x:g},backend:n,attrs:{axis:l,keepDims:!1}}),x=on({inputs:{x:y},backend:n,attrs:{shape:h}}),w=zC({inputs:{a:g,b:x},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x),w}const jae={kernelName:ex,backendName:"cpu",kernelFunc:tB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kae(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{numSamples:a,seed:i,normalized:o}=s;Ye(r,"multinomial");const l=o?r:tB({inputs:{logits:r},backend:n,attrs:{dim:-1}}),c=l.shape[0],h=l.shape[1],p=n.data.get(l.dataId).values,f=[c,a],g=Rs($e(f),"int32");for(let y=0;y<c;++y){const x=y*h,w=new Float32Array(h-1);w[0]=p[x];for(let T=1;T<w.length;++T)w[T]=w[T-1]+p[x+T];const v=bx.alea(i.toString()),$=y*a;for(let T=0;T<a;++T){const C=v();g[$+T]=w.length;for(let I=0;I<w.length;I++)if(C<w[I]){g[$+T]=I;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(f,"int32",g)}const Xae={kernelName:yS,backendName:"cpu",kernelFunc:Kae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yae=k_;function Zae(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=s;Ye(r,"NonMaxSuppression");const c=n.data.get(r.dataId).values,h=n.data.get(a.dataId).values,{selectedIndices:p}=Yae(c,h,i,o,l);return n.makeTensorInfo([p.length],"int32",new Int32Array(p))}const Qae={kernelName:bS,backendName:"cpu",kernelFunc:Zae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jae=N_;function eie(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:c}=s;Ye(r,"NonMaxSuppressionPadded");const h=n.data.get(r.dataId).values,p=n.data.get(a.dataId).values,{selectedIndices:f,validOutputs:g}=Jae(h,p,i,o,l,c);return[n.makeTensorInfo([f.length],"int32",new Int32Array(f)),n.makeTensorInfo([],"int32",new Int32Array([g]))]}const tie={kernelName:xS,backendName:"cpu",kernelFunc:eie};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nie=I_;function sie(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:c}=s;Ye(r,"NonMaxSuppressionWithScore");const h=n.data.get(r.dataId).values,p=n.data.get(a.dataId).values,f=i,g=o,y=l,x=c,{selectedIndices:w,selectedScores:v}=nie(h,p,f,g,y,x);return[n.makeTensorInfo([w.length],"int32",new Int32Array(w)),n.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const rie={kernelName:wS,backendName:"cpu",kernelFunc:sie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aie(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r}=e,{dtype:a,depth:i,onValue:o,offValue:l}=s;Ye(r,"oneHot");const c=$e(r.shape),h=new Float32Array(c*i);h.fill(l);const p=n.data.get(r.dataId).values;for(let f=0;f<c;++f)p[f]>=0&&p[f]<i&&(h[f*i+p[f]]=o);return n.makeTensorInfo([...r.shape,i],a,h)}const iie={kernelName:Pb,backendName:"cpu",kernelFunc:aie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P0(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=pc({inputs:{input:s},backend:n}),a=P0({inputs:{x:r},backend:n}),i=Hd({inputs:{input:s},backend:n}),o=P0({inputs:{x:i},backend:n}),l=$r({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return FC({backend:n,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const oie={kernelName:rx,backendName:"cpu",kernelFunc:P0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nB(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=pc({inputs:{input:s},backend:n}),a=nB({inputs:{x:r},backend:n}),i=Hd({inputs:{input:s},backend:n}),o=P0({inputs:{x:i},backend:n}),l=$r({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return FC({backend:n,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const lie={kernelName:Bb,backendName:"cpu",kernelFunc:nB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sB(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s;if(e.length===1)return B0({inputs:{input:e[0]},backend:n,attrs:{dim:r}});const a=e[0].shape,i=e[0].dtype;e.forEach(h=>{Er(a,h.shape,"All tensors passed to stack must have matching shapes"),V(i===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=e.map(h=>{const p=B0({inputs:{input:h},backend:n,attrs:{dim:r}});return o.push(p),p}),c=qd({inputs:l,backend:n,attrs:{axis:r}});return o.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}const uie={kernelName:Vb,backendName:"cpu",kernelFunc:sB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cie(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:a,constantValue:i}=s;Ye(r,"pad");const o=a.map(($,T)=>$[0]+r.shape[T]+$[1]),l=a.map($=>$[0]),c=n.data.get(r.dataId).values,h=$e(r.shape),p=r.shape.length,f=nt(r.shape),g=$e(o),y=o.length,x=nt(o),w=ys(r.dtype,g);i!==0&&w.fill(i);for(let $=0;$<h;$++){const C=eh($,p,f).map((A,O)=>A+l[O]),I=_i(C,y,x);w[I]=c[$]}return{dataId:n.write(w,o,r.dtype),shape:o,dtype:r.dtype}}const rB={kernelName:Ub,backendName:"cpu",kernelFunc:cie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const die=zn((t,e)=>Math.pow(t,e)),hie=Qn(om,die),pie={kernelName:om,backendName:"cpu",kernelFunc:hie};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fie(t){const{inputs:e,backend:n,attrs:s}=t,{paramsNestedSplits:r,paramsDenseValues:a,indices:i}=e,{outputRaggedRank:o}=s,l=r.map(v=>n.data.get(v.dataId).values),c=r.map(v=>v.shape),h=n.data.get(a.dataId).values,p=n.data.get(i.dataId).values,[f,g,y]=S4(l,c,h,a.shape,a.dtype,p,i.shape),x=f.map(v=>n.makeTensorInfo([v.length],"int32",v)),w=n.makeTensorInfo(y,a.dtype,g);return x.concat([w])}const mie={kernelName:vS,backendName:"cpu",kernelFunc:fie};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gie(t){const{inputs:e,backend:n}=t,{starts:s,limits:r,deltas:a}=e,i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,[c,h]=_4(i,s.shape,s.dtype,o,r.shape,l,a.shape),p=n.makeTensorInfo([c.length],"int32",c),f=n.makeTensorInfo([h.length],s.dtype,h);return[p,f]}const yie={kernelName:$S,backendName:"cpu",kernelFunc:gie};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bie(t){const{inputs:e,backend:n,attrs:s}=t,{shape:r,values:a,defaultValue:i,rowPartitionTensors:o}=e,{rowPartitionTypes:l}=s,c=n.data.get(r.dataId).values,h=n.data.get(a.dataId).values,p=n.data.get(i.dataId).values,f=o.map(w=>n.data.get(w.dataId).values),g=o.map(w=>w.shape),[y,x]=C4(c,r.shape,h,a.shape,a.dtype,p,i.shape,f,g,l);return n.makeTensorInfo(y,a.dtype,x)}const xie={kernelName:SS,backendName:"cpu",kernelFunc:bie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wie(t){const{backend:e,attrs:n}=t,{start:s,stop:r,dtype:a,step:i}=n,o=T4(s,r,i,a);return e.makeTensorInfo([o.length],a,o)}const vie={kernelName:_S,backendName:"cpu",kernelFunc:wie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ie=Jt(lm,t=>1/t),Sie={kernelName:lm,backendName:"cpu",kernelFunc:$ie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ie(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:a,halfPixelCenters:i,size:o}=s;Ye(r,"resizeBilinear");const l=nt(r.shape),[c,h]=o,[p,f,g,y]=r.shape,x=n.data.get(r.dataId).values,w=new Float32Array($e([p,c,h,y])),v=[a&&c>1?f-1:f,a&&h>1?g-1:g],$=[a&&c>1?c-1:c,a&&h>1?h-1:h];let T=0;const C=v[0]/$[0],I=v[1]/$[1];for(let A=0;A<p;A++)for(let O=0;O<c;O++){let B;i?B=C*(O+.5)-.5:B=C*O;const z=Math.max(0,Math.floor(B)),P=B-z,F=Math.min(f-1,Math.ceil(B)),K=A*l[0]+z*l[1],X=A*l[0]+F*l[1];for(let te=0;te<h;te++){let Q;i?Q=I*(te+.5)-.5:Q=I*te;const q=Math.max(0,Math.floor(Q)),oe=Q-q,se=Math.min(g-1,Math.ceil(Q)),ee=K+q*l[2],U=X+q*l[2],G=K+se*l[2],Y=X+se*l[2];for(let ce=0;ce<y;ce++){const pe=x[ee+ce],J=x[U+ce],we=x[G+ce],Be=x[Y+ce],Fe=pe+(we-pe)*oe,Ve=J+(Be-J)*oe,Me=Fe+(Ve-Fe)*P;w[T++]=Me}}}return n.makeTensorInfo([p,c,h,y],"float32",w)}const Cie={kernelName:jb,backendName:"cpu",kernelFunc:_ie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tie(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:a}=e,{alignCorners:i}=s;Ye([a,r],"resizeBilinearGrad");const o=nt(r.shape),[l,c,h,p]=r.shape,[,f,g]=a.shape,y=new Float32Array(l*c*h*p),x=[i&&f>1?c-1:c,i&&g>1?h-1:h],w=[i&&f>1?f-1:f,i&&g>1?g-1:g],v=x[0]/w[0],$=x[1]/w[1],T=n.data.get(a.dataId).values;let C=0;for(let I=0;I<l;I++){const A=I*o[0];for(let O=0;O<f;O++){const B=O*v,z=Math.floor(B),P=Math.min(Math.ceil(B),c-1),F=A+z*o[1],K=A+P*o[1],X=B-z,te=1-X;for(let Q=0;Q<g;Q++){const q=Q*$,oe=Math.floor(q),se=Math.min(Math.ceil(q),h-1),ee=q-oe,U=1-ee,G=F+oe*o[2],Y=F+se*o[2],ce=K+oe*o[2],pe=K+se*o[2],J=te*U,we=te*ee,Be=X*U,Fe=X*ee;for(let Ve=0;Ve<p;Ve++){const Me=T[C++];y[G+Ve]+=Me*J,y[Y+Ve]+=Me*we,y[ce+Ve]+=Me*Be,y[pe+Ve]+=Me*Fe}}}}return n.makeTensorInfo([l,h,c,p],"float32",y)}const kie={kernelName:kS,backendName:"cpu",kernelFunc:Tie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nie(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:a,halfPixelCenters:i,size:o}=s;Ye(r,"resizeNearestNeighbor");const l=nt(r.shape),[c,h]=o,[p,f,g,y]=r.shape,x=n.data.get(r.dataId).values,w=new Float32Array(p*c*h*y),v=[a&&c>1?f-1:f,a&&h>1?g-1:g],$=[a&&c>1?c-1:c,a&&h>1?h-1:h],T=v[0]/$[0],C=v[1]/$[1];let I=0;for(let A=0;A<p;A++){const O=A*l[0];for(let B=0;B<c;B++){const z=i?T*(B+.5):T*B;let P=Math.min(f-1,a?Math.round(z):Math.floor(z));i&&(P=Math.max(0,P));const F=O+P*l[1];for(let K=0;K<h;K++){const X=i?C*(K+.5):C*K;let te=Math.min(g-1,a?Math.round(X):Math.floor(X));i&&(te=Math.max(0,te));const Q=F+te*l[2];for(let q=0;q<y;q++){const oe=x[Q+q];w[I++]=oe}}}}return n.makeTensorInfo([p,c,h,y],r.dtype,w)}const Iie={kernelName:qb,backendName:"cpu",kernelFunc:Nie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eie(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:a}=e,{alignCorners:i}=s;Ye([a,r],"resizeNearestNeighborGrad");const o=nt(r.shape),l=nt(a.shape),[c,h,p,f]=r.shape,[,g,y]=a.shape,x=new Float32Array(c*h*p*f),w=n.data.get(a.dataId).values,v=[i&&g>1?h-1:h,i&&y>1?p-1:p],$=[i&&g>1?g-1:g,i&&y>1?y-1:y],T=v[0]/$[0],C=v[1]/$[1],I=1/T,A=1/C,O=Math.ceil(I)*2+2,B=Math.ceil(A)*2+2;for(let z=0;z<c;z++){const P=z*o[0];for(let F=0;F<h;F++){const K=P+F*o[1],X=Math.floor(F*I),te=Math.floor(X-O/2);for(let Q=0;Q<p;Q++){const q=K+Q*o[2],oe=Math.floor(Q*A),se=Math.floor(oe-B/2);for(let ee=0;ee<f;ee++){let U=0;for(let G=0;G<O;G++){const Y=G+te;if(Y<0||Y>=g)continue;const ce=P+Y*l[1],pe=Y*T,J=Math.min(h-1,i?Math.round(pe):Math.floor(pe));if(F===J)for(let we=0;we<B;we++){const Be=we+se;if(Be<0||Be>=y)continue;const Fe=ce+Be*l[2],Ve=Be*C,Me=Math.min(p-1,i?Math.round(Ve):Math.floor(Ve));Q===Me&&(U+=w[Fe+ee])}}x[q+ee]=U}}}}return n.makeTensorInfo(r.shape,r.dtype,x)}const Aie={kernelName:TS,backendName:"cpu",kernelFunc:Eie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rie(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dims:a}=s;Ye(r,"reverse");const i=r.shape.length,o=St(a,r.shape);if(i===0)return Ri({inputs:{x:r},backend:n});const l=new Kn(r.shape,r.dtype),c=n.bufferSync(r);for(let h=0;h<l.size;h++){const p=l.indexToLoc(h),f=p.slice();o.forEach(g=>f[g]=r.shape[g]-1-f[g]),l.set(c.get(...f),...p)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}const Die={kernelName:Kb,backendName:"cpu",kernelFunc:Rie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oie={kernelName:GS,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,{radians:r,fillValue:a,center:i}=e,o=n,l=ys(s.dtype,$e(s.shape)),[c,h,p,f]=s.shape,[g,y]=U_(i,h,p),x=255,w=Math.sin(r),v=Math.cos(r),$=o.data.get(s.dataId).values;for(let C=0;C<c;C++){const I=C*p*h*f;for(let A=0;A<h;A++){const O=A*(p*f);for(let B=0;B<p;B++){const z=B*f;for(let P=0;P<f;P++){const F=[c,A,B,P],K=F[2],X=F[1];let te=(K-g)*v-(X-y)*w,Q=(K-g)*w+(X-y)*v;te=Math.round(te+g),Q=Math.round(Q+y);let q=a;if(typeof a!="number"&&(P===3?q=x:q=a[P]),te>=0&&te<p&&Q>=0&&Q<h){const se=Q*(p*f),ee=te*f,U=I+se+ee+P;q=$[U]}const oe=I+O+z+P;l[oe]=q}}}}return{dataId:o.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zie=Jt(dm,t=>{const e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2===0?e:e+1}),Fie={kernelName:dm,backendName:"cpu",kernelFunc:zie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lie(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r,updates:a}=e,{shape:i}=s,{sliceRank:o,numUpdates:l,sliceSize:c,strides:h,outputSize:p}=_c(a,r,i),f=!0,g=n.bufferSync(r),y=n.bufferSync(a),x=Qu(g,y,i,p,c,l,o,h,0,f);return n.makeTensorInfo(i,x.dtype,x.values)}const Mie={kernelName:NS,backendName:"cpu",kernelFunc:Lie};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bie(t,e){let n=0,s=t.length,r=0;for(;n<s;)r=Math.floor((n+s)/2),t[r]<e?n=r+1:s=r;return s}function Pie(t,e){let n=0,s=t.length,r=0;for(;n<s;)r=Math.floor((n+s)/2),t[r]<=e?n=r+1:s=r;return s}function Vie(t,e,n,s,r,a){const i=An("int32",n*r);for(let o=0;o<n;++o){const l=t.slice(o*s,(o+1)*s),c=o*r;for(let h=0;h<r;++h)i[c+h]=a==="left"?Bie(l,e[h+c]):Pie(l,e[h+c])}return i}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uie(t){const{inputs:e,backend:n,attrs:s}=t,{sortedSequence:r,values:a}=e,{side:i}=s,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,c=Vie(o,l,r.shape[0],r.shape[1],a.shape[1],i);return n.makeTensorInfo(a.shape,"int32",c)}const Wie={kernelName:ES,backendName:"cpu",kernelFunc:Uie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gie(t){const{inputs:e,backend:n}=t,{condition:s,t:r,e:a}=e;Ye([s,r,a],"select");const i=s.shape.length,o=n.data.get(s.dataId).values,l=n.data.get(r.dataId).values,c=n.data.get(a.dataId).values,h=_r(r.dtype,a.dtype),p=Rs($e(r.shape),h);let f=0;const g=i===0||i>1||r.shape.length===1?1:$e(r.shape.slice(1));for(let y=0;y<o.length;y++)for(let x=0;x<g;x++)o[y]===1?p[f++]=l[y]:p[f++]=c[y];return n.makeTensorInfo(r.shape,h,p)}const Hie={kernelName:Xb,backendName:"cpu",kernelFunc:Gie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qie=Ex,jie=Ax,Kie=Jt(pm,t=>t>=0?jie*t:qie*(Math.exp(t)-1)),Xie={kernelName:pm,backendName:"cpu",kernelFunc:Kie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yie=Jt(gm,t=>t<0?-1:t>0?1:0),Zie={kernelName:gm,backendName:"cpu",kernelFunc:Yie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qie=Jt(fm,t=>Math.sin(t)),Jie={kernelName:fm,backendName:"cpu",kernelFunc:Qie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eoe=Jt(mm,t=>Math.sinh(t)),toe={kernelName:mm,backendName:"cpu",kernelFunc:eoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const noe=11920928955078125e-23,$E=Math.log(noe)+2,soe=Jt(bm,t=>{const e=t>-$E,n=t<$E,s=Math.exp(t);let r;return n?r=s:e?r=t:r=Math.log(1+s),r}),roe={kernelName:bm,backendName:"cpu",kernelFunc:soe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aoe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:a,paddings:i}=s;Ye([r],"spaceToBatchND");const o=$e(a),l=[[0,0]];l.push(...i);for(let A=1+a.length;A<r.shape.length;++A)l.push([0,0]);const c=rB.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),h=Om(c.shape,a,o,!1),p=zm(h.length,a.length,!1),f=Fm(c.shape,a,o,!1),x=on({inputs:{x:c},backend:n,attrs:{shape:h}}),$=lr({inputs:{x},backend:n,attrs:{perm:p}}),I=on({inputs:{x:$},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo($),I}const ioe={kernelName:Qb,backendName:"cpu",kernelFunc:aoe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ooe(t){const{inputs:e,backend:n}=t,{indices:s,values:r,denseShape:a,defaultValue:i}=e;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const o=n.data.get(s.dataId).values,l=n.data.get(r.dataId).values,c=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values[0],[p,f,g,y,x]=E4(o,s.shape,s.dtype,l,r.dtype,c,h);return[n.makeTensorInfo(f,s.dtype,p),n.makeTensorInfo([f[0]],r.dtype,g),n.makeTensorInfo([y.length],"bool",new Uint8Array(y.map(w=>Number(w)))),n.makeTensorInfo([x.length],s.dtype,new Int32Array(x))]}const loe={kernelName:AS,backendName:"cpu",kernelFunc:ooe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uoe(t){const{inputs:e,backend:n}=t,{inputIndices:s,inputShape:r,newShape:a}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.data.get(r.dataId).values),o=n.data.get(s.dataId).values,l=Array.from(n.data.get(a.dataId).values),[c,h,p]=A4(o,s.shape,s.dtype,i,l);return[n.makeTensorInfo(h,s.dtype,c),n.makeTensorInfo([p.length],a.dtype,new Int32Array(p))]}const coe={kernelName:RS,backendName:"cpu",kernelFunc:uoe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function doe(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:a}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);if(r.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,[c,h]=RC(i,s.shape,s.dtype,o,l,!0);return n.makeTensorInfo(h,s.dtype,c)}const hoe={kernelName:DS,backendName:"cpu",kernelFunc:doe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function poe(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:a}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);if(r.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,[c,h]=RC(i,s.shape,s.dtype,o,l);return n.makeTensorInfo(h,s.dtype,c)}const foe={kernelName:OS,backendName:"cpu",kernelFunc:poe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function moe(t){const{inputs:e,backend:n,attrs:s}=t,{sparseIndices:r,sparseValues:a,defaultValue:i}=e,{outputShape:o}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:p,outputSize:f}=_c(a,r,o),g=!1,y=n.bufferSync(r);let x;switch(a.dtype){case"bool":{const w=n.bufferSync(a),v=!!n.data.get(i.dataId).values[0];x=Qu(y,w,o,f,h,c,l,p,v,g);break}case"float32":{const w=n.bufferSync(a),v=n.data.get(i.dataId).values[0];x=Qu(y,w,o,f,h,c,l,p,v,g);break}case"int32":{const w=n.bufferSync(a),v=n.data.get(i.dataId).values[0];x=Qu(y,w,o,f,h,c,l,p,v,g);break}case"string":{const w=n.bufferSync(a),v=Rl(n.data.get(i.dataId).values[0]);x=Qu(y,w,o,f,h,c,l,p,v,g);break}default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(o,x.dtype,x.values)}const goe={kernelName:zS,backendName:"cpu",kernelFunc:moe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yoe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{numOrSizeSplits:a,axis:i}=s,o=St(i,r.shape)[0],l=sC(r,a,o),c=new Array(r.shape.length).fill(0),h=r.shape.slice();return l.map(p=>{const f=[...h];f[o]=p;const g=fc({inputs:{x:r},backend:n,attrs:{begin:c,size:f}});return c[o]+=p,g})}const boe={kernelName:Jb,backendName:"cpu",kernelFunc:yoe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xoe={kernelName:FS,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,s=e;Ye(n,"square");const r=s.data.get(n.dataId).values,a=new Float32Array(r.length);for(let o=0;o<r.length;++o){const l=r[o];a[o]=l*l}return{dataId:s.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const woe=Jt(Cm,(t,e)=>{const n=e;return isNaN(t)?NaN:t>0?1:n.alpha}),voe={kernelName:Cm,backendName:"cpu",kernelFunc:woe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $oe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:a,end:i,strides:o,beginMask:l,endMask:c,ellipsisMask:h,newAxisMask:p,shrinkAxisMask:f}=s;Ye(r,"stridedSlice");const{finalShapeSparse:g,finalShape:y,isIdentity:x,sliceDim0:w,isSimpleSlice:v,begin:$,end:T,strides:C}=B_(r.shape,a,i,o,l,c,h,p,f);let I;if(x)I=on({inputs:{x:r},backend:n,attrs:{shape:y}});else if(w||v){V(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const A=F_($,T,C),O=fc({inputs:{x:r},backend:n,attrs:{begin:$,size:A}});I=on({inputs:{x:O},backend:n,attrs:{shape:y}}),n.disposeIntermediateTensorInfo(O)}else{const A=n.bufferSync(r),O=O4(g,A,C,$);I=n.makeTensorInfo(y,O.dtype,O.values)}return I}const Soe={kernelName:LS,backendName:"cpu",kernelFunc:$oe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _oe(t){const{inputs:e,backend:n,attrs:s}=t,{separator:r,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:c}=s,{data:h,dataSplits:p}=e,f=n.data.get(h.dataId).values,g=n.data.get(p.dataId).values,[y,x]=z4(f,g,r,a,i,o,l,c);return[n.makeTensorInfo([y.length],"string",y),n.makeTensorInfo(p.shape,"int32",x)]}const Coe={kernelName:MS,backendName:"cpu",kernelFunc:_oe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Toe(t){const{inputs:e,backend:n,attrs:s}=t,{skipEmpty:r}=s,{input:a,delimiter:i}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values[0],[c,h,p]=F4(o,l,r),f=h.length;return[n.makeTensorInfo([f,2],"int32",c),n.makeTensorInfo([f],"string",h),n.makeTensorInfo([2],"int32",new Int32Array(p))]}const koe={kernelName:BS,backendName:"cpu",kernelFunc:Toe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Noe(t){const{inputs:e,backend:n,attrs:s}=t,{numBuckets:r}=s,{input:a}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const i=n.data.get(a.dataId).values,o=L4(i,r);return n.makeTensorInfo(a.shape,"int32",o)}const Ioe={kernelName:PS,backendName:"cpu",kernelFunc:Noe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eoe=Jt($m,t=>Math.tan(t)),Aoe={kernelName:$m,backendName:"cpu",kernelFunc:Eoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Roe=Jt(Sm,t=>Math.tanh(t)),Doe={kernelName:Sm,backendName:"cpu",kernelFunc:Roe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ooe(t){const{inputs:e,backend:n}=t,{tensor:s,indices:r,updates:a}=e,{sliceRank:i,numUpdates:o,sliceSize:l,strides:c,outputSize:h}=_c(a,r,s.shape),p=!1,f=n.bufferSync(r),g=n.bufferSync(a),y=n.bufferSync(s),x=Qu(f,g,s.shape,h,l,o,i,c,y,p);return n.makeTensorInfo(s.shape,x.dtype,x.values)}const zoe={kernelName:IS,backendName:"cpu",kernelFunc:Ooe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Foe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reps:a}=s;Ye(r,"tile");const i=B4(n.bufferSync(r),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const Loe={kernelName:_m,backendName:"cpu",kernelFunc:Foe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Moe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{k:a,sorted:i}=s;Ye(r,"topk");const o=n.data.get(r.dataId).values,[l,c]=V4(o,r.shape,r.dtype,a,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}const Boe={kernelName:VS,backendName:"cpu",kernelFunc:Moe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Poe(t){const{inputs:e,attrs:n,backend:s}=t,{image:r,transforms:a}=e,{interpolation:i,fillMode:o,fillValue:l,outputShape:c}=n,[h,p,f,g]=r.shape,[y,x]=c??[p,f],w=[h,y,x,g],v=nt(r.shape),$=v[0],T=v[1],C=v[2],I=nt(w),A=I[0],O=I[1],B=I[2],z=ys(r.dtype,$e(w));z.fill(l);const P=s.data.get(r.dataId).values,F=s.data.get(a.dataId).values;for(let X=0;X<h;++X){const te=a.shape[0]===1?F:F.subarray(X*8,X*8+8);for(let Q=0;Q<y;++Q)for(let q=0;q<x;++q)for(let oe=0;oe<g;++oe){let se;const ee=te[6]*q+te[7]*Q+1;if(ee===0)continue;const U=(te[0]*q+te[1]*Q+te[2])/ee,G=(te[3]*q+te[4]*Q+te[5])/ee,Y=SE(U,f,o),ce=SE(G,p,o);switch(i){case"nearest":se=qoe(P,p,f,$,T,C,X,ce,Y,oe,l);break;case"bilinear":se=joe(P,p,f,$,T,C,X,ce,Y,oe,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}const pe=X*A+Q*O+q*B+oe;z[pe]=se}return s.makeTensorInfo(w,r.dtype,z)}return{dataId:s.write(z,w,r.dtype),shape:r.shape,dtype:r.dtype}}const Voe={kernelName:US,backendName:"cpu",kernelFunc:Poe};function SE(t,e,n){switch(n){case"reflect":return Uoe(t,e);case"wrap":return Woe(t,e);case"nearest":return Hoe(t,e);case"constant":default:return Goe(t)}}function Uoe(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const s=2*e;n<s&&(n=s*Math.trunc(-n/s)+n),n=n<-e?n+s:-n-1}else if(n>e-1)if(e<=1)n=0;else{const s=2*e;n-=s*Math.trunc(n/s),n>=e&&(n=s-n-1)}return tc(0,n,e-1)}function Woe(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const s=e-1;n+=e*(Math.trunc(-n/s)+1)}else if(n>e-1)if(e<=1)n=0;else{const s=e-1;n-=e*Math.trunc(n/s)}return tc(0,n,e-1)}function Goe(t,e){return t}function Hoe(t,e){return tc(0,t,e-1)}function ef(t,e,n,s,r,a,i,o,l,c,h){const p=i*s+o*r+l*a+c;return 0<=o&&o<e&&0<=l&&l<n?t[p]:h}function qoe(t,e,n,s,r,a,i,o,l,c,h){const p=Math.round(o),f=Math.round(l);return ef(t,e,n,s,r,a,i,p,f,c,h)}function joe(t,e,n,s,r,a,i,o,l,c,h){const p=Math.floor(o),f=Math.floor(l),g=p+1,y=f+1,x=(y-l)*ef(t,e,n,s,r,a,i,p,f,c,h)+(l-f)*ef(t,e,n,s,r,a,i,p,y,c,h),w=(y-l)*ef(t,e,n,s,r,a,i,g,f,c,h)+(l-f)*ef(t,e,n,s,r,a,i,g,y,c,h);return(g-o)*x+(o-p)*w}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Koe(t){const{inputs:e,attrs:n,backend:s}=t,{axis:r}=n,{x:a}=e;Ye(a,"unique");const i=s.data.get(a.dataId).values,{outputValues:o,outputShape:l,indices:c}=U4(i,r,a.shape,a.dtype);return[s.makeTensorInfo(l,a.dtype,o),s.makeTensorInfo([c.length],"int32",c)]}const Xoe={kernelName:WS,backendName:"cpu",kernelFunc:Koe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yoe(t){const{inputs:e,backend:n,attrs:s}=t,{value:r}=e;let{axis:a}=s;a<0&&(a+=r.shape.length);const i=r.shape.length,o=r.shape[a],l=new Array(i-1);let c=0;for(let g=0;g<i;g++)g!==a&&(l[c++]=r.shape[g]);const h=new Array(i).fill(0),p=r.shape.slice();p[a]=1;const f=new Array(o);for(let g=0;g<f.length;g++){h[a]=g;const y=fc({inputs:{x:r},backend:n,attrs:{begin:h,size:p}});f[g]=on({inputs:{x:y},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(y)}return f}const Zoe={kernelName:nx,backendName:"cpu",kernelFunc:Yoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qoe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,segmentIds:a}=e,{numSegments:i}=s;Ye(r,"unsortedSegmentSum");const o=r.shape.length,l=a.shape.length,c=[],h=[],p=o-l;let f=a;for(let y=0;y<p;++y){const x=B0({inputs:{input:f},backend:n,attrs:{dim:y+1}});f=x,h.push(x)}for(let y=0;y<i;++y){const x=Gl(y,"int32"),w=n.makeTensorInfo([],"int32",x),v=s4({inputs:{a:w,b:f},backend:n}),$=Vl({inputs:{x:v},backend:n,attrs:{dtype:"float32"}}),T=Wx({inputs:{a:$,b:r},backend:n}),C=Hm({inputs:{x:T},backend:n,attrs:{axis:0,keepDims:!1}});c.push(C),h.push(w),h.push(v),h.push($),h.push(T),h.push(C)}const g=sB({inputs:c,backend:n,attrs:{axis:0}});return h.forEach(y=>n.disposeIntermediateTensorInfo(y)),g}const Joe={kernelName:sx,backendName:"cpu",kernelFunc:Qoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ele=[Kne,Nte,Yne,Qne,Ote,ese,nse,rse,ise,lse,cse,hse,fse,yse,xse,$se,_se,Tse,Nse,qne,Ese,Rse,Ose,Fte,Fse,Rte,Mte,Mse,Ite,Pse,Use,Wse,Hse,jse,Xse,Zse,Jse,tre,sre,are,ore,ure,dre,pre,fre,gre,bre,wre,vre,$re,Sre,Cre,Nre,Bne,Ere,Bte,Mre,Pte,Bre,Ute,Hre,qre,Kre,Gte,qte,Yre,Qre,eae,nae,Kte,Yte,Ete,rae,Vse,iae,lae,cae,Pne,Qte,ene,hae,nne,fae,yae,xae,$ae,_ae,Tae,kae,rne,Iae,Aae,Dae,zae,Lae,Bae,Vae,ine,Wae,qae,Xae,lne,cne,Qae,tie,rie,hne,iie,lie,uie,rB,pie,Une,mne,mie,yie,xie,vie,Ate,d2,Sie,Wne,Gne,Hne,Cie,kie,Iie,Aie,Die,Oie,Fie,Sne,Mie,Wie,Hie,Xie,Cne,Zie,Jie,toe,Tne,jae,roe,ioe,loe,coe,hoe,foe,goe,boe,Ine,xoe,Ane,Dne,voe,Soe,Coe,koe,Ioe,Lne,Tre,Aoe,Doe,zoe,Loe,Boe,Voe,pne,Xoe,Zoe,Joe,oie];for(const t of ele)JD(t);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ju={},Ry={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function tle(t,e){ju[t]=e}function Za(t,e){if(!(t in ju)||e!=null){const s=sle(t,e);if(s!==null)ju[t]=s;else return console.log("Could not get context for WebGL version",t),null}const n=ju[t];return n==null||n.isContextLost()?(delete ju[t],Za(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),ju[t])}function nle(t){if(!ye().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&t===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function sle(t,e){if(t!==1&&t!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=e??nle(t);return n.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete ju[t]},!1),ye().getBool("SOFTWARE_WEBGL_ENABLED")&&(Ry.failIfMajorPerformanceCaveat=!1),t===1?n.getContext("webgl",Ry)||n.getContext("experimental-webgl",Ry):n.getContext("webgl2",Ry)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var $f;(function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"})($f||($f={}));var qr;(function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"})(qr||(qr={}));var gs;(function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(gs||(gs={}));function qm(t,e){return[e,t]}function rle(t,e){return t*e}function Dy(t){const e=$e(t),n=Math.ceil(e/4);return v$(n)}function lh(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function ale(t,e){const[n,s]=lh(t,e);return n*s*4}function LC(t,e){const n=t;let s,r,a,i,o,l,c,h,p,f;return ye().getNumber("WEBGL_VERSION")===2?(s=n.R32F,r=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,c=4,h=1,p=n.HALF_FLOAT,f=n.FLOAT,l=n.RGBA8):(s=t.RGBA,r=t.RGBA,a=t.RGBA,i=n.RGBA,o=t.RGBA,c=4,h=4,p=e!=null?e.HALF_FLOAT_OES:null,f=t.FLOAT,l=t.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:h,textureTypeHalfFloat:p,textureTypeFloat:f}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function He(t,e){const n=e();return ye().getBool("DEBUG")&&ile(t),n}function ile(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+cle(t,e))}const ole=596e-10,lle=65504;function ule(t){return!!(ye().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||t===0||ole<Math.abs(t)&&Math.abs(t)<lle)}function cle(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Oy(t,e){return Oo(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function dle(t,e){const n=Oo(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(He(t,()=>t.shaderSource(n,e)),He(t,()=>t.compileShader(n)),t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function hle(t,e){const n=Oo(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(He(t,()=>t.shaderSource(n,e)),He(t,()=>t.compileShader(n)),ye().get("ENGINE_COMPILE_ONLY"))return n;if(t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw aB(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const ple=/ERROR: [0-9]+:([0-9]+):/g;function aB(t,e){const n=ple.exec(e);if(n==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(t);return}const s=+n[1],r=t.split(`
`),a=r.length.toString().length+2,i=r.map((p,f)=>Ed((f+1).toString(),a)+p);let o=0;for(let p=0;p<i.length;p++)o=Math.max(i[p].length,o);const l=i.slice(0,s-1),c=i.slice(s-1,s),h=i.slice(s);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Ed(c[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join(`
`))}function fle(t){return Oo(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}function mle(t,e){if(He(t,()=>t.linkProgram(e)),!ye().get("ENGINE_COMPILE_ONLY")&&t.getProgramParameter(e,t.LINK_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function xv(t,e){if(He(t,()=>t.validateProgram(e)),t.getProgramParameter(e,t.VALIDATE_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function gle(t,e){const n=Oo(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return He(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),He(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function yle(t,e){const n=Oo(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return He(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),He(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function ble(t){return Oo(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}function xle(t,e){const n=ye().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){const s=`[${t}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(t>n||e>n){const s=`[${t}x${e}]`,r=`[${n}x${n}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function wle(t){return Oo(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function _E(t,e,n,s,r,a,i){const o=t.getAttribLocation(e,n);return o===-1?!1:(He(t,()=>t.bindBuffer(t.ARRAY_BUFFER,s)),He(t,()=>t.vertexAttribPointer(o,r,t.FLOAT,!1,a,i)),He(t,()=>t.enableVertexAttribArray(o)),!0)}function vle(t,e,n){Tle(t,n),He(t,()=>t.activeTexture(t.TEXTURE0+n)),He(t,()=>t.bindTexture(t.TEXTURE_2D,e))}function $le(t,e,n){return Oo(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}function Sle(t,e,n){return t.getUniformLocation(e,n)}function _le(t,e,n,s){He(t,()=>vle(t,e,s)),He(t,()=>t.uniform1i(n,s))}function wv(t,e,n){He(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),He(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function CE(t,e){He(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),He(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function zy(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Cle(t,e))}function Cle(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Oo(t,e,n){const s=He(t,()=>e());if(s==null)throw new Error(n);return s}function Tle(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+t.TEXTURE0;if(s<t.TEXTURE0||s>n){const r=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${r}.`)}}function jd(t,e=2){return $e(t.slice(0,t.length-e))}function Kd(t){if(t.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function Fy(t){let e=[1,1,1];return t.length===0||t.length===1&&t[0]===1||(e=[jd(t),...Kd(t)]),e}function kle(t,e=!1){let n=ye().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=ye().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&ye().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=n/2),e&&(n=n*2,s=s*2,t=t.map((o,l)=>l>=t.length-2?M2(t[l]):t[l]),t.length===1&&(t=[2,t[0]])),t.length!==2&&(t=Wl(t).newShape);let r=$e(t),a=null;t.length<=1&&r<=n?a=[1,r]:t.length===2&&t[0]<=n&&t[1]<=n?a=t:t.length===3&&t[0]*t[1]<=n&&t[2]<=n?a=[t[0]*t[1],t[2]]:t.length===3&&t[0]<=n&&t[1]*t[2]<=n?a=[t[0],t[1]*t[2]]:t.length===4&&t[0]*t[1]*t[2]<=n&&t[3]<=n?a=[t[0]*t[1]*t[2],t[3]]:t.length===4&&t[0]<=n&&t[1]*t[2]*t[3]<=n&&(a=[t[0],t[1]*t[2]*t[3]]);const i=a!=null&&Math.max(...a)>s&&Math.min(...a)<=(e?2:1)&&Math.min(...a)>0;if(a==null||i)if(e){const o=jd(t);let l=2,c=2;t.length&&([l,c]=Kd(t)),r=o*(l/2)*(c/2),a=v$(r).map(h=>h*2)}else a=v$(r);return a}function Ly(t){return t%2===0}function V0(t,e){if(t=t.slice(-2),e=e.slice(-2),Rt(t,e)||!t.length||!e.length||t[0]===0||t[1]===0||e[0]===0||e[1]===0)return!0;if(t.length!==e.length){const n=t[t.length-1],s=e[e.length-1];if(n===s||Ly(n)&&Ly(s)&&(t[0]===1||e[0]===1))return!0}return t[1]===e[1]&&Ly(t[0])&&Ly(e[0])}let vv,$v;function Nle(t){if(vv==null){const e=Za(t);vv=e.getParameter(e.MAX_TEXTURE_SIZE)}return vv}function Ile(t){if($v==null){const e=Za(t);$v=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,$v)}function Ele(t){if(t===0)return 0;let e;const n=Za(t);return ba(n,"EXT_disjoint_timer_query_webgl2")&&t===2?e=2:ba(n,"EXT_disjoint_timer_query")?e=1:e=0,e}function ba(t,e){return t.getExtension(e)!=null}function TE(t){try{if(Za(t)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function Ale(t){if(t===0)return!1;const e=Za(t);if(t===1){if(!ba(e,"OES_texture_float"))return!1}else if(!ba(e,"EXT_color_buffer_float"))return!1;return p2(e)}function Rle(t){if(t===0)return!1;const e=Za(t);if(t===1){if(!ba(e,"OES_texture_float")||!ba(e,"WEBGL_color_buffer_float"))return!1}else{if(ba(e,"EXT_color_buffer_float"))return p2(e);const s="EXT_color_buffer_half_float";if(ba(e,s)){const r=e.getExtension(s);return Dle(e,r)}return!1}return p2(e)}function p2(t){const e=LC(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const a=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,a),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(a),i}function Dle(t,e){const n=LC(t,e),s=t.createTexture();t.bindTexture(t.TEXTURE_2D,s),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,s,0);const o=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(s),t.deleteFramebuffer(i),o}function Ole(t){return t!==2?!1:Za(t).fenceSync!=null}function jm(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&V(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qe=ye();Qe.registerFlag("HAS_WEBGL",()=>Qe.getNumber("WEBGL_VERSION")>0);Qe.registerFlag("WEBGL_VERSION",()=>TE(2)?2:TE(1)?1:0);Qe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Qe.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Qe.get("WEBGL_VERSION")===2);Qe.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Qe.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Qe.registerFlag("WEBGL_PACK",()=>Qe.getBool("HAS_WEBGL"));Qe.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_CLIP",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_REDUCE",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_LAZILY_UNPACK",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_CONV_IM2COL",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Nle(Qe.getNumber("WEBGL_VERSION")));Qe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Ile(Qe.getNumber("WEBGL_VERSION")));Qe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=Qe.getNumber("WEBGL_VERSION");return t===0?0:Ele(t)});Qe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Qe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!hO());Qe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Ale(Qe.getNumber("WEBGL_VERSION")));Qe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Qe.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Qe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Qe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Rle(Qe.getNumber("WEBGL_VERSION")));Qe.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Ole(Qe.getNumber("WEBGL_VERSION")));Qe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Qe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Qe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)});Qe.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>hO()?1:-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});Qe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Qe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Qe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Qe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Qe.registerFlag("WEBGL_EXP_CONV",()=>!1);Qe.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Qe.getBool("IS_TEST"));Qe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Qe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Qe.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Qe.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ks(){let t,e,n,s,r,a,i,o,l,c;return ye().getNumber("WEBGL_VERSION")===2?(t="#version 300 es",e="in",n="out",s="in",r="texture",a="outputColor",i="out vec4 outputColor;",o=ye().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(t="",e="attribute",n="varying",s="varying",r="texture2D",a="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:t,attribute:e,varyingVs:n,varyingFs:s,texture2D:r,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kc(t,e,n="index"){const s=nt(e);return s.map((r,a)=>{const i=`int ${t[a]} = ${n} / ${r}`,o=a===s.length-1?`int ${t[a+1]} = ${n} - ${t[a]} * ${r}`:`index -= ${t[a]} * ${r}`;return`${i}; ${o};`}).join("")}function Gx(t,e,n="index"){const s=nt(e);return s.map((r,a)=>{const i=`int ${t[a]} = ${n} / outShapeStrides[${a}]`,o=a===s.length-1?`int ${t[a+1]} = ${n} - ${t[a]} * outShapeStrides[${a}]`:`index -= ${t[a]} * outShapeStrides[${a}]`;return`${i}; ${o};`}).join("")}function zle(t,e){const n=t.length,s=t.map(a=>`${e}[${a}]`),r=new Array(n-1);r[n-2]=s[n-1];for(let a=n-3;a>=0;--a)r[a]=`(${r[a+1]} * ${s[a+1]})`;return r}function Fle(t,e,n="index"){const s=t.map((a,i)=>i),r=zle(s,e);return r.map((a,i)=>{const o=`int ${t[i]} = ${n} / ${r[i]}`,l=i===r.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * ${r[i]}`:`index -= ${t[i]} * ${r[i]}`;return`${o}; ${l};`}).join("")}function MC(t){const e=nt(t).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function BC(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const iB=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:oB}=Q9;function Lle(t,e,n){const s=[];if(t.forEach(g=>{const y=$e(g.shapeInfo.logicalShape);if(g.shapeInfo.isUniform?s.push(`uniform float ${g.name}${y>1?`[${y}]`:""};`):(s.push(`uniform sampler2D ${g.name};`),s.push(`uniform int offset${g.name};`)),n.enableShapeUniforms){const{uniformShape:x}=PC(n.packedInputs,g.shapeInfo.logicalShape,g.shapeInfo.texShape);switch(x.length){case 1:s.push(`uniform int ${g.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${g.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${g.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${g.name}Shape;`);break}s.push(`uniform ivec2 ${g.name}TexShape;`)}}),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(g=>{s.push(`uniform ${g.type} ${g.name}${g.arrayIndex?`[${g.arrayIndex}]`:""};`)});const r=s.join(`
`),a=t.map(g=>Mle(g,e,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=e.texShape,o=Ks(),l=Vle(o);let c,h,p=Gle(o);return e.isPacked?(c=Ble(e.logicalShape,i,n.enableShapeUniforms),h=Wle(o)):(c=Ple(e.logicalShape,i,n.enableShapeUniforms),h=Ule(o)),n.packedInputs&&(p+=Kle),[p,l,h,r,c,a,n.userCode].join(`
`)}function uh(t,e=!1){const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return iue(t,e);case 1:return lue(t,e);case 2:return cue(t,e);case 3:return hue(t,e);case 4:return fue(t,e);case 5:return mue(t);case 6:return gue(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function lB(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return aue(t);case 1:return oue(t,e);case 2:return uue(t,e);case 3:return due(t,e);default:return pue(t,e)}}function Mle(t,e,n=!1,s){let r="";n?r+=lB(t,s):r+=uh(t,s);const a=t.shapeInfo.logicalShape,i=e.logicalShape;return a.length<=i.length&&(n?r+=yue(t,e):r+=bue(t,e)),r}function Ble(t,e,n){switch(t.length){case 0:return uB();case 1:return Xle(t,e,n);case 2:return sue(t,e,n);case 3:return Zle(t,e,n);default:return Jle(t,e,n)}}function Ple(t,e,n){switch(t.length){case 0:return uB();case 1:return Yle(t,e,n);case 2:return rue(t,e,n);case 3:return Qle(t,e,n);case 4:return eue(t,e,n);case 5:return tue(t,e);case 6:return nue(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}function Vle(t){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${t.texture2D}(textureSampler, uv).r;
    }
  `}function Ule(t){return`
    void setOutput(float val) {
      ${t.output} = vec4(val, 0, 0, 0);
    }
  `}function Wle(t){return`
    void setOutput(vec4 val) {
      ${t.output} = val;
    }
  `}function Gle(t){return`${t.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t.varyingFs} vec2 resultUV;
    ${t.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${t.defineSpecialNaN}
    ${t.defineSpecialInf}
    ${t.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Hle}
    ${qle}
    ${jle}
  `}const Hle=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,qle=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,jle=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Kle=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function uB(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function Xle(t,e,n){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function Yle(t,e,n){return e[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function Zle(t,e,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[2]/2),a=r*Math.ceil(t[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function Qle(t,e,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Gx(["r","c","d"],t)}
    return ivec3(r, c, d);
  }
`;const s=kc(["r","c","d"],t);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function Jle(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[t.length-1]/2),a=r*Math.ceil(t[t.length-2]/2);let i=a,o="",l="b, r, c";for(let c=2;c<t.length-1;c++)i*=t[t.length-c-1],o=`
      int b${c} = index / ${i};
      index -= b${c} * ${i};
    `+o,l=`b${c}, `+l;return`
    ivec${t.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${o}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${t.length}(${l});
    }
  `}function eue(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Gx(["r","c","d","d2"],t)}
      return ivec4(r, c, d, d2);
    }
  `;const s=kc(["r","c","d","d2"],t);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function tue(t,e){const n=kc(["r","c","d","d2","d3"],t);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function nue(t,e){const n=kc(["r","c","d","d2","d3","d4"],t);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function sue(t,e,n){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Rt(t,e))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(t[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function rue(t,e,n){return Rt(t,e)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:t[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:t[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${t[1]};
      int c = index - r * ${t[1]};
      return ivec2(r, c);
    }
  `}function Nc(t){return`offset${t}`}function aue(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Ks();return`
    vec4 ${n}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function iue(t,e){const n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${s}() {return ${n};}`;const[r,a]=t.shapeInfo.texShape;if(r===1&&a===1)return`
      float ${s}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const i=Nc(n);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;const[o,l]=t.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function oue(t,e){const n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t.shapeInfo.texShape,a=Ks();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${n}, uv);
    }
  `;const i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${a.texture2D}(${n}, uv);
    }
  `}function lue(t,e){const n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${ch(t)}
      }
    `;const r=t.shapeInfo.texShape,a=r[0],i=r[1];if(i===1&&a===1)return`
      float ${s}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const o=Nc(n);return i===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);
        return sampleTexture(${n}, uv);
      }
    `:a===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function uue(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=t.shapeInfo.texShape,i=a[0],o=a[1],l=Ks();if(a!=null&&Rt(n,a))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const c=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],h=Math.ceil(n[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${h}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function cue(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=t.shapeInfo.texShape;if(a!=null&&Rt(n,a)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const f=a[0],g=a[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${g}.0, ${f}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:i,keptDims:o}=Wl(n),l=i;if(l.length<n.length){const f=dh(t,l),g=["row","col"];return`
      ${uh(f,e)}
      float ${r}(int row, int col) {
        return ${r}(${hh(g,o)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${ch(t)}
      }
    `;const c=a[0],h=a[1],p=Nc(s);return h===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${s}, uv);
    }
  `:c===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${h}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${p};
    vec2 uv = uvFromFlat(${c}, ${h}, index);
    return sampleTexture(${s}, uv);
  }
`}function due(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=t.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(n[0]===1){const f=n.slice(1),g=[1,2],y=dh(t,f),x=["b","row","col"];return`
        ${lB(y,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${hh(x,g)});
        }
      `}const o=Ks();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `;const l=i[0],c=i[1],h=Math.ceil(n[2]/2),p=h*Math.ceil(n[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${p}, ${h}, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `}function hue(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=Wl(n),c=o;if(c.length<n.length){const x=dh(t,c),w=["row","col","depth"];return`
        ${uh(x,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${hh(w,l)});
        }
      `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${i}, 1)));
        ${ch(t)}
      }
    `;const h=t.shapeInfo.texShape,p=h[0],f=h[1],g=t.shapeInfo.flatOffset;if(f===a&&g==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${f}.0, ${p}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(f===i&&g==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}.0, ${p}.0);
      return sampleTexture(${s}, uv);
    }
  `;const y=Nc(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${y};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${i} + depth + ${y};
        vec2 uv = uvFromFlat(${p}, ${f}, index);
        return sampleTexture(${s}, uv);
      }
  `}function pue(t,e){const n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=Ks();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${n}, uv);
    }
  `;const a=t.shapeInfo.logicalShape,i=a.length,o=t.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=l[0],h=l[1],p=Math.ceil(a[i-1]/2);let f=p*Math.ceil(a[i-2]/2),g="int b, int row, int col",y=`b * ${f} + (row / 2) * ${p} + (col / 2)`;for(let x=2;x<i-1;x++)g=`int b${x}, `+g,f*=a[i-x-1],y=`b${x} * ${f} + `+y;return`
    vec4 ${s}(${g}) {
      int index = ${y};
      int texR = index / ${h};
      int texC = index - texR * ${h};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}, ${c});
      return ${r.texture2D}(${n}, uv);
    }
  `}function fue(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n[3],i=n[2]*a,o=n[1]*i,{newShape:l,keptDims:c}=Wl(n);if(l.length<n.length){const $=dh(t,l),T=["row","col","depth","depth2"];return`
      ${uh($,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${hh(T,c)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${a}, 1)));
        ${ch(t)}
      }
    `;const h=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,f=p[0],g=p[1],y=`int stride2 = ${s}Shape[3];`,x=`int stride1 = ${s}Shape[2] * stride2;`,w=`int stride0 = ${s}Shape[1] * stride1;`;if(g===o&&h==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${y}
        ${x}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${f}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(g===a&&h==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${f}.0);
        return sampleTexture(${s}, uv);
      }
    `;const v=Nc(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${y}
      ${x}
      ${w}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${v});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${f}, ${g}, index + ${v});
      return sampleTexture(${s}, uv);
    }
  `}function mue(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e[4],a=e[3]*r,i=e[2]*a,o=e[1]*i,{newShape:l,keptDims:c}=Wl(e);if(l.length<e.length){const x=dh(t,l),w=["row","col","depth","depth2","depth3"];return`
      ${uh(x)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${hh(w,c)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${a}, ${r})) +
          depth3;
        ${ch(t)}
      }
    `;const h=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,f=p[0],g=p[1];if(g===o&&h==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${a}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(g===r&&h==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;const y=Nc(n);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${a} +
          depth2 * ${r} + depth3 + ${y};
      vec2 uv = uvFromFlat(${f}, ${g}, index);
      return sampleTexture(${n}, uv);
    }
  `}function gue(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:a}=Wl(e);if(r.length<e.length){const w=dh(t,r),v=["row","col","depth","depth2","depth3","depth4"];return`
      ${uh(w)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${hh(v,a)});
      }
    `}const i=e[5],o=e[4]*i,l=e[3]*o,c=e[2]*l,h=e[1]*c;if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${h}, ${c}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${ch(t)}
      }
    `;const p=t.shapeInfo.flatOffset,f=t.shapeInfo.texShape,g=f[0],y=f[1];if(y===h&&p==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${g}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(y===i&&p==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${g}.0);
        return sampleTexture(${n}, uv);
      }
    `;const x=Nc(n);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${h} + col * ${c} + depth * ${l} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${x};
      vec2 uv = uvFromFlat(${g}, ${y}, index);
      return sampleTexture(${n}, uv);
    }
  `}function ch(t){const e=t.name,n=$e(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function yue(t,e){const n=t.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",a=t.shapeInfo.logicalShape.length,i=e.logicalShape.length,o=oB(t.shapeInfo.logicalShape,e.logicalShape),l=en(i),c=i-a;let h;const p=["x","y","z","w","u","v"];a===0?h="":i<2&&o.length>=1?h="coords = 0;":h=o.map($=>`coords.${p[$+c]} = 0;`).join(`
`);let f="";i<2&&a>0?f="coords":f=t.shapeInfo.logicalShape.map(($,T)=>`coords.${p[T+c]}`).join(", ");let g="return outputValue;";const x=$e(t.shapeInfo.logicalShape)===1,v=$e(e.logicalShape)===1;if(a===1&&!x&&!v)g=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(x&&!v)i===1?g=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:g=`
        return vec4(outputValue.x);
      `;else if(o.length){const $=a-2,T=a-1;o.indexOf($)>-1&&o.indexOf(T)>-1?g="return vec4(outputValue.x);":o.indexOf($)>-1?g="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(T)>-1&&(g="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${h}
      vec4 outputValue = get${s}(${f});
      ${g}
    }
  `}function bue(t,e){const n=t.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",a=e.texShape,i=t.shapeInfo.texShape,o=t.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!t.shapeInfo.isUniform&&o===l&&t.shapeInfo.flatOffset==null&&Rt(i,a))return`
      float ${r}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const c=en(l),h=oB(t.shapeInfo.logicalShape,e.logicalShape),p=l-o;let f;const g=["x","y","z","w","u","v"];o===0?f="":l<2&&h.length>=1?f="coords = 0;":f=h.map(x=>`coords.${g[x+p]} = 0;`).join(`
`);let y="";return l<2&&o>0?y="coords":y=t.shapeInfo.logicalShape.map((x,w)=>`coords.${g[w+p]}`).join(", "),`
    float ${r}() {
      ${c} coords = getOutputCoords();
      ${f}
      return get${s}(${y});
    }
  `}function en(t){if(t<=1)return"int";if(t===2)return"ivec2";if(t===3)return"ivec3";if(t===4)return"ivec4";if(t===5)return"ivec5";if(t===6)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function PC(t,e,n){const{newShape:s,keptDims:r}=Wl(e),a=e.length,i=t&&a===3&&e[0]===1,o=i?e.slice(1):s,l=!t&&a>1&&!Rt(e,n)&&s.length<a||i;return{useSqueezeShape:l,uniformShape:l?o:e,keptDims:r}}function dh(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function hh(t,e){return e.map(n=>t[n]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xue(t,e,n,s){const r=n.map((h,p)=>{const f={logicalShape:h.shape,texShape:h.isUniform?null:h.texData.texShape,isUniform:h.isUniform,isPacked:h.isUniform?!1:h.texData.isPacked,flatOffset:null};return h.texData!=null&&h.texData.slice!=null&&h.texData.slice.flatOffset>0&&(f.flatOffset=h.texData.slice.flatOffset),{name:e.variableNames[p],shapeInfo:f}}),a=r.map(h=>h.shapeInfo),i={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},o=Lle(r,i,e),l=hle(t.gl,o),c=t.createProgram(l);return ye().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:o,webGLProgram:c,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(c),Object.assign({program:e,fragmentShader:l,source:o,webGLProgram:c,inShapeInfos:a,outShapeInfo:i},cB(t,e,c)))}function cB(t,e,n){const s=[],r=[];let a,i,o,l=null,c=null;c=t.getUniformLocation(n,"NAN",!1),ye().getNumber("WEBGL_VERSION")===1&&(l=t.getUniformLocation(n,"INFINITY",!1));const h=!1;for(const p of e.variableNames){const f={name:p,uniform:t.getUniformLocation(n,p,h),offset:t.getUniformLocation(n,`offset${p}`,h)};e.enableShapeUniforms&&(f.shape=t.getUniformLocation(n,`${p}Shape`,h),f.texShape=t.getUniformLocation(n,`${p}TexShape`,h)),s.push(f)}if(e.enableShapeUniforms&&(a=t.getUniformLocation(n,"outShape",h),o=t.getUniformLocation(n,"outShapeStrides",h),i=t.getUniformLocation(n,"outTexShape",h)),e.customUniforms)for(const p of e.customUniforms)r.push(t.getUniformLocation(n,p.name,h));return{variablesLocations:s,customUniformLocations:r,infLoc:l,nanLoc:c,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function kE(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((n,s)=>{const r=n.logicalShape,a=e[s],i=a.shape;if(!Rt(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(n.isUniform&&a.isUniform)return;const o=n.texShape,l=a.isUniform?null:a.texData.texShape;if(!Rt(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function wue(t,e,n,s,r){e.program.enableShapeUniforms||(kE(e.inShapeInfos,n),kE([e.outShapeInfo],[s]));const a=s.texData.texture,i=s.texData.texShape;s.texData.isPacked?t.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):t.setOutputMatrixTexture(a.texture,i[0],i[1]),t.setProgram(e.webGLProgram),t.bindVertexArray(e.webGLProgram.vao),ye().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&t.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&t.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<n.length;++l){const c=n[l],{uniform:h,offset:p,shape:f,texShape:g}=e.variablesLocations[l];if(f){const{uniformShape:y}=PC(e.program.packedInputs,c.shape,c.texData.texShape);switch(y.length){case 1:t.gl.uniform1iv(f,new Int32Array(y));break;case 2:t.gl.uniform2iv(f,new Int32Array(y));break;case 3:t.gl.uniform3iv(f,new Int32Array(y));break;case 4:t.gl.uniform4iv(f,new Int32Array(y));break}}if(g&&t.gl.uniform2i(g,c.texData.texShape[0],c.texData.texShape[1]),h!=null){if(c.isUniform){if($e(c.shape)<2)t.gl.uniform1f(h,c.uniformValues[0]);else{let y=c.uniformValues;y instanceof Float32Array||(y=new Float32Array(y)),t.gl.uniform1fv(h,y)}continue}c.texData.slice!=null&&p!=null&&t.gl.uniform1i(p,c.texData.slice.flatOffset),t.setInputMatrixTexture(c.texData.texture.texture,h,l)}}const o=e.outShapeLocation;if(o)switch(s.shape.length){case 1:t.gl.uniform1iv(o,new Int32Array(s.shape));break;case 2:t.gl.uniform2iv(o,new Int32Array(s.shape));break;case 3:t.gl.uniform3iv(o,new Int32Array(s.shape));break;case 4:t.gl.uniform4iv(o,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const l=nt(s.shape);switch(s.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let l=0;l<e.program.customUniforms.length;++l){const c=e.program.customUniforms[l],h=e.customUniformLocations[l],p=r[l];if(c.type==="float")t.gl.uniform1fv(h,p);else if(c.type==="vec2")t.gl.uniform2fv(h,p);else if(c.type==="vec3")t.gl.uniform3fv(h,p);else if(c.type==="vec4")t.gl.uniform4fv(h,p);else if(c.type==="int")t.gl.uniform1iv(h,p);else if(c.type==="ivec2")t.gl.uniform2iv(h,p);else if(c.type==="ivec3")t.gl.uniform3iv(h,p);else if(c.type==="ivec4")t.gl.uniform4iv(h,p);else throw Error(`uniform type ${c.type} is not supported yet.`)}t.executeProgram()}function vue(t,e,n){let s="";e.concat(n).forEach(i=>{const o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!i.isUniform){const l=i.texData.texShape,{useSqueezeShape:c,uniformShape:h,keptDims:p}=PC(t.packedInputs,i.shape,l);let f="",g="",y="";if(h.length===1&&t.packedInputs){const I=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];f=`${I[0]>1}_${I[1]>1}`}else if(h.length===2&&!t.packedInputs)g=`${h[0]>1}_${h[1]>1}`;else if(h.length>2&&!t.packedInputs){const I=nt(h);y=`${I[0]===l[1]}_${I[I.length-1]===l[1]}`}const x=i.shape.length,w=h.length===2&&Rt(i.shape,l),v=$e(i.shape)===1,$=Pd(i.shape,n.shape),T=!t.packedInputs&&x===n.shape.length&&Rt(l,n.texData.texShape),C=t.packedInputs||h.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${x}_${T}_${c?p:""}_${h.length}_${v}_${$}_${w}_${f}_${g}_${y}_${C}_${o}`}else{const l=i.isUniform?"uniform":i.texData.texShape;s+=`${i.shape}_${l}_${o}`}});const r=t.userCode;let a=t.constructor.name;return a+="_"+s+"_"+r+`${ye().getNumber("WEBGL_VERSION")}`,a}function Os(t){return ye().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $ue{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=$f.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Ks();this.outputShape=e,this.enableShapeUniforms=Os(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Gx(["r","c","d"],e):kc(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sue{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=$f.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Ks();this.outputShape=e,this.enableShapeUniforms=Os(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Gx(["r","c","d"],e):kc(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _ue{constructor(e){this.variableNames=["A"],this.outTexUsage=qr.DOWNLOAD;const n=Ks();this.outputShape=e,this.userCode=`
      ${iB}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cue{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=qr.DOWNLOAD;const n=Ks();this.outputShape=e,this.userCode=`
      ${iB}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tue={R:0,G:1,B:2,A:3};class NE{constructor(e,n=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Ks();this.outputShape=e,this.enableShapeUniforms=Os(this.outputShape.length);let a="result";n&&(a="floor(result * 255. + 0.5)");let i="";for(let o=0;o<s.length;o++){const l=s[o];i+=`
          if(offset == ${o}) {
            result = values[${Tue[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?BC():MC(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${i}
        }
        ${r.output} = vec4(${a}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kue{constructor(e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Ks();this.outputShape=e,this.enableShapeUniforms=Os(this.outputShape.length);let r="",a="result";n&&(a="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let o=0;o<=1;o++){const l=i*2+o;r+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?BC():MC(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${a};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nue(t){const e=Ks(),n=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return dle(t,n)}function Iue(t){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return gle(t,e)}function Eue(t){const e=new Uint16Array([0,1,2,2,1,3]);return yle(t,e)}function Km(t,e,n,s,r,a){xle(e,n);const i=ble(t),o=t.TEXTURE_2D;return He(t,()=>t.bindTexture(o,i)),He(t,()=>t.texParameteri(o,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),He(t,()=>t.texParameteri(o,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),He(t,()=>t.texParameteri(o,t.TEXTURE_MIN_FILTER,t.NEAREST)),He(t,()=>t.texParameteri(o,t.TEXTURE_MAG_FILTER,t.NEAREST)),ye().getNumber("WEBGL_VERSION")===1?He(t,()=>t.texImage2D(o,0,s,e,n,0,r,a,null)):He(t,()=>t.texStorage2D(o,1,s,e,n)),He(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:i,texShape:[n,e]}}function dB(t){return t.internalFormatFloat}function Aue(t,e,n,s){const[r,a]=qm(e,n);return Km(t,r,a,dB(s),s.textureFormatFloat,t.FLOAT)}function hB(t){return t.internalFormatHalfFloat}function Rue(t,e,n,s){const[r,a]=qm(e,n);return Km(t,r,a,hB(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function pB(t){return t.downloadTextureFormat}function Due(t,e,n,s){const[r,a]=qm(e,n);return Km(t,r,a,pB(s),t.RGBA,t.UNSIGNED_BYTE)}function fB(t){return t.internalFormatPackedFloat}function Oue(t,e,n,s){const[r,a]=lh(e,n);return Km(t,r,a,fB(s),t.RGBA,t.FLOAT)}function mB(t){return t.internalFormatPackedHalfFloat}function zue(t,e,n,s){const[r,a]=lh(e,n);return Km(t,r,a,mB(s),t.RGBA,s.textureTypeHalfFloat)}function Fue(t,e,n){return He(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),_E(t,e,"clipSpacePos",n,3,20,0)&&_E(t,e,"uv",n,2,20,12)}function Lue(t,e,n,s,r,a){He(t,()=>t.bindTexture(t.TEXTURE_2D,e));let i,o,l;r instanceof Uint8Array?(i=new Uint8Array(n*s*4),o=t.UNSIGNED_BYTE,l=t.RGBA):(i=new Float32Array(n*s*4),o=t.FLOAT,l=a.internalFormatPackedFloat),i.set(r),ye().getNumber("WEBGL_VERSION")===2?He(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,s,t.RGBA,o,i)):He(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,n,s,0,t.RGBA,o,i)),He(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function Mue(t,e,n){He(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?ye().getNumber("WEBGL_VERSION")===2?He(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,t.RGBA,t.UNSIGNED_BYTE,n.data)):He(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):ye().getNumber("WEBGL_VERSION")===2?He(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,n)):He(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),He(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function Bue(t,e,n,s){const r=t.createBuffer();He(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,r));const o=4*4*e*n;return He(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,o,t.STREAM_READ)),He(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),He(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),r}function Pue(t,e,n){const s=t,r=new Float32Array(n);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function Vue(t,e,n,s){const[r,a]=qm(e,n),i=4,o=new Uint8Array(rle(e*n,i));return He(t,()=>t.readPixels(0,0,r,a,s.downloadTextureFormat,t.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function Uue(t,e,n,s,r,a,i,o){const l=t,c=new Float32Array(ale(a,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function Wue(t,e,n){const s=new Float32Array(e*n*4);return He(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sv{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=ye().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,tle(n,e)):this.gl=Za(n),e=this.gl,ye().getNumber("WEBGL_VERSION")===2){const a=e;this.createVertexArray=()=>He(a,()=>a.createVertexArray()),this.bindVertexArray=i=>He(a,()=>a.bindVertexArray(i)),this.deleteVertexArray=i=>He(a,()=>a.deleteVertexArray(i)),this.getVertexArray=()=>He(a,()=>a.getParameter(a.VERTEX_ARRAY_BINDING))}else if(e!=null){const a=e.getExtension("OES_vertex_array_object");if(a==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>He(e,()=>a.createVertexArrayOES()),this.bindVertexArray=i=>He(e,()=>a.bindVertexArrayOES(i)),this.deleteVertexArray=i=>He(e,()=>a.deleteVertexArrayOES(i)),this.getVertexArray=()=>He(e,()=>e.getParameter(a.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),ye().getNumber("WEBGL_VERSION")===1){const a="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=Oy(this.gl,a),ba(this.gl,i))this.textureHalfFloatExtension=Oy(this.gl,i);else if(ye().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),ba(this.gl,r))this.colorBufferHalfFloatExtension=Oy(this.gl,r);else if(ye().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",ba(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(ba(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=Iue(this.gl),this.indexBuffer=Eue(this.gl),this.framebuffer=wle(this.gl),this.textureConfig=LC(this.gl,this.textureHalfFloatExtension)}get debug(){return ye().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;He(e,()=>e.finish()),He(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),He(e,()=>e.deleteFramebuffer(this.framebuffer)),He(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),He(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),He(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,n){return this.throwIfDisposed(),Aue(this.gl,e,n,this.textureConfig)}createFloat16MatrixTexture(e,n){return this.throwIfDisposed(),Rue(this.gl,e,n,this.textureConfig)}createUnsignedBytesMatrixTexture(e,n){return this.throwIfDisposed(),Due(this.gl,e,n,this.textureConfig)}uploadPixelDataToTexture(e,n){this.throwIfDisposed(),Mue(this.gl,e,n)}uploadDenseMatrixToTexture(e,n,s,r){this.throwIfDisposed(),Lue(this.gl,e,n,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,n){return this.throwIfDisposed(),zue(this.gl,e,n,this.textureConfig)}createPackedMatrixTexture(e,n){return this.throwIfDisposed(),Oue(this.gl,e,n,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(CE(this.gl,this.framebuffer),this.outputTexture=null),He(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,n,s){return this.downloadMatrixDriver(e,()=>Vue(this.gl,n,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,n,s,r,a,i){return Uue(this.gl,e,n,s,r,a,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,n){return Pue(this.gl,e,n)}createBufferFromTexture(e,n,s){this.bindTextureToFrameBuffer(e);const r=Bue(this.gl,n,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let n,s;if(ye().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const i=r.clientWaitSync(a,0,0);return i===r.ALREADY_SIGNALED||i===r.CONDITION_SATISFIED},n=a}else ye().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(n,ye().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:n,isFencePassed:s}}downloadMatrixFromPackedTexture(e,n,s){return this.downloadMatrixDriver(e,()=>Wue(this.gl,n,s))}createProgram(e){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=Nue(n));const s=fle(n);He(n,()=>n.attachShader(s,this.vertexShader)),He(n,()=>n.attachShader(s,e)),mle(n,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&xv(n,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const n=this.gl;He(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),Fue(n,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(He(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&xv(this.gl,this.program),He(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,n,s=!0){return this.throwIfDisposed(),s?$le(this.gl,e,n):Sle(this.gl,e,n)}getAttributeLocation(e,n){return this.throwIfDisposed(),He(this.gl,()=>this.gl.getAttribLocation(e,n))}getUniformLocationNoThrow(e,n){return this.throwIfDisposed(),this.gl.getUniformLocation(e,n)}setInputMatrixTexture(e,n,s){this.throwIfDisposed(),this.throwIfNoProgram(),_le(this.gl,e,n,s)}setOutputMatrixTexture(e,n,s){this.setOutputMatrixTextureDriver(e,s,n)}setOutputPackedMatrixTexture(e,n,s){this.throwIfDisposed();const[r,a]=lh(n,s);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,n,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,n)}setOutputPackedMatrixWriteRegion(e,n,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&xv(this.gl,this.program),zy(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const n=this.getVertexArray();console.assert(n===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}He(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),He(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Oy(this.gl,ye().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ye().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,a),a}const e=this.getQueryTimerExtensionWebGL1(),n=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,n),n}endQuery(){if(ye().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,s=this.getQueryTimerExtensionWebGL2();n.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await rI(()=>this.disposed||this.isQueryAvailable(e,ye().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,ye().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,n){if(n===0)return null;if(n===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,n){if(n===0)return!0;if(n===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),a&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(n=>{this.addItemToPoll(()=>e.isFencePassed(),()=>n())})}pollItems(){const e=Gue(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=e;++n){const{resolveFn:s}=this.itemsToPoll[n];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,n){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in ye().platform&&(s=ye().platform.setTimeoutCustom.bind(ye().platform)),rI(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),wv(this.gl,e,this.framebuffer),this.debug&&zy(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(wv(this.gl,this.outputTexture,this.framebuffer),this.debug&&zy(this.gl)):CE(this.gl,this.framebuffer)}downloadMatrixDriver(e,n){this.bindTextureToFrameBuffer(e);const s=n();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,n,s){this.throwIfDisposed();const r=this.gl;wv(r,e,this.framebuffer),this.debug&&zy(r),this.outputTexture=e,He(r,()=>r.viewport(0,0,n,s)),He(r,()=>r.scissor(0,0,n,s))}setOutputMatrixWriteRegionDriver(e,n,s,r){this.throwIfDisposed(),He(this.gl,()=>this.gl.scissor(e,n,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function Gue(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:Hue,bincountImpl:gB,bincountReduceImpl:que,bitwiseAndImpl:jue,castImpl:Kue,ceilImpl:Xue,concatImpl:Yue,equalImpl:Zue,expImpl:Que,expm1Impl:Jue,floorImpl:ece,gatherNdImpl:tce,gatherV2Impl:nce,greaterImpl:sce,greaterEqualImpl:rce,lessImpl:ace,lessEqualImpl:ice,linSpaceImpl:oce,logImpl:lce,maxImpl:uce,maximumImpl:cce,minimumImpl:dce,multiplyImpl:hce,negImpl:pce,notEqualImpl:fce,prodImpl:mce,raggedGatherImpl:gce,raggedRangeImpl:yce,raggedTensorToTensorImpl:bce,rangeImpl:xce,rsqrtImpl:wce,scatterImpl:vce,sigmoidImpl:$ce,simpleAbsImpl:yB,sliceImpl:Sce,sparseFillEmptyRowsImpl:_ce,sparseReshapeImpl:Cce,sparseSegmentReductionImpl:bB,sqrtImpl:Tce,staticRegexReplaceImpl:kce,stridedSliceImpl:Nce,stringNGramsImpl:Ice,stringSplitImpl:Ece,stringToHashBucketFastImpl:Ace,subImpl:Rce,tileImpl:Dce,topKImpl:Oce,transposeImpl:VC,uniqueImpl:zce}=Mne;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xB(t,e){return["x","y","z","w","u","v"].slice(0,e).map(n=>`${t}.${n}`)}function Gs(t,e){return e===1?[t]:xB(t,e)}function Fce(t,e){if(t===1)return"rc";let n="";for(let s=0;s<t;s++)n+=e[s],s<t-1&&(n+=",");return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lce{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Os(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=Gs("rc",this.rank),s=en(this.rank),r=this.getOutOfBoundsCondition(n),a=this.getSetup(n),i=this.getOutput(n);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(e){const n=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let a=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)a=`${e[e.length-1-i]},`+a;n.push(a)}return n}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let s=this.rank-2;s<this.rank;s++)n+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(n+="||");return n}getSetup(e){if(this.rank===1)return"";const n=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const n=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wB{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Os(this.outputShape.length);let s="";for(let r=0;r<4;r++){let a="thisRC = rc;";r%2===1&&(a+="thisRC.z += 1;"),r>1&&(a+="thisRC.y += 1;"),s+=`
        ${a}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${Mce(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?BC():MC(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function Mce(t,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?Fle(["r","c","d"],"inputShape"):kc(["r","c","d"],t)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bce{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,n,s){const r=EE(n,s),a=AE(e,r,s);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const i=IE(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const l=this.freeTextures[a].pop();return this.usedTextures[a].push(l),l}let o;return r===gs.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===gs.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===gs.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===gs.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===gs.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(o),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),o}releaseTexture(e,n,s,r){if(this.freeTextures==null)return;const a=EE(s,r),i=AE(n,a,r);i in this.freeTextures||(this.freeTextures[i]=[]);const o=IE(n,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=ye().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const c=this.usedTextures[i],h=c&&c.indexOf(e);if(h==null||h<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[h]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Pce(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;if(e===n.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function IE(t,e,n,s,r){const a=Vce(e,s);let i;if(r){const[l,c]=lh(t[0],t[1]);i=l*c}else{const[l,c]=qm(t[0],t[1]);i=l*c}const o=Pce(n,a);return i*o}function Vce(t,e){switch(t){case gs.PACKED_2X2_FLOAT32:return fB(e);case gs.PACKED_2X2_FLOAT16:return mB(e);case gs.UNPACKED_FLOAT32:return dB(e);case gs.UNPACKED_FLOAT16:return hB(e);case gs.PACKED_4X1_UNSIGNED_BYTE:return pB(e);default:throw new Error(`Unknown physical texture type ${t}`)}}function Uce(t){return ye().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?gs.PACKED_2X2_FLOAT32:gs.UNPACKED_FLOAT32:t?gs.PACKED_2X2_FLOAT16:gs.UNPACKED_FLOAT16}function EE(t,e){if(t===qr.UPLOAD)return gs.PACKED_2X2_FLOAT32;if(t===qr.RENDER||t==null)return Uce(e);if(t===qr.DOWNLOAD||t===qr.PIXELS)return gs.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function AE(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Si{constructor(e,n){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Os(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Ta="if (isnan(x)) return x;",Wce="return x;",RE="return abs(x);",Gce="return (x >= 0.0) ? x : (exp(x) - 1.0);",Hce=Ta+`
  return (x < 0.0) ? 0.0 : x;
`,qce=Ta+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,_l="return x;",jce="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kce="return x;",Xce=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Yce=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Zce=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Qce="return 1.0 / (1.0 + exp(-1.0 * x));";class kl{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Os(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jce{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Os(this.outputShape.length);const n=e.length,s=Gs("rc",n),r=en(n),a=Fce(n,s),i=s.slice(-2),o=n<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ede=__,tde=1e-7,nde=1e-4,My={};function sde(t){return t in My||(My[t]={}),My[t]}const rde=ye().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),ade=600;function ide(){return ye().global.screen==null?1024:ye().global.screen.height*ye().global.screen.width*window.devicePixelRatio*ade/1024/1024}class Hx extends L2{nextDataId(){return Hx.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ye().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(e!=null){if(e instanceof Sv)n=e;else{const s=Za(ye().getNumber("WEBGL_VERSION"),e);n=new Sv(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Za(ye().getNumber("WEBGL_VERSION"));n=new Sv(s),this.binaryCache=sde(ye().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Bce(this.gpgpu),this.numMBBeforeWarning=ide(),this.texData=new qD(this,Ua())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,n,s,r,a,i){const o=this.makeTensorInfo(n,s),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[r,a]},l.texShape=[r,a];const c=Fy(n),h=new NE(c,!1,i),p=this.runWebGLProgram(h,[o],s,[[r,a]]);return p.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(o),p.dataId}write(e,n,s){if((ye().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ye().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:n,dtype:s,values:e,usage:qr.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const n=this.texData.get(e);n.refCount++}decRef(e){if(this.texData.has(e)){const n=this.texData.get(e);n.refCount--}}move(e,n,s,r,a){if(ye().getBool("DEBUG")&&this.checkNumericalProblems(n),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:n,usage:qr.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const n=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:a,slice:i,shape:o,isPacked:l}=n;if(i!=null){let f;l?f=new kl(o,_l):f=new Si(o,_l);const g=this.runWebGLProgram(f,[{dataId:e,shape:o,dtype:r}],r),y=this.readSync(g.dataId);return this.disposeIntermediateTensorInfo(g),y}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const c=this.activeTimers!=null;let h;c&&(h=sr());let p;if(r==="complex64"){const f=this.readSync(a.real.dataId),g=this.readSync(a.imag.dataId);p=ko(f,g)}else p=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=sr()-h),this.convertAndCacheOnCPU(e,p)}async read(e){if(this.pendingRead.has(e)){const y=this.pendingRead.get(e);return new Promise(x=>y.push(x))}const n=this.texData.get(e),{values:s,shape:r,slice:a,dtype:i,complexTensorInfos:o,isPacked:l}=n;if(a!=null){let y;l?y=new kl(r,_l):y=new Si(r,_l);const x=this.runWebGLProgram(y,[{dataId:e,shape:r,dtype:i}],i),w=this.read(x.dataId);return this.disposeIntermediateTensorInfo(x),w}if(s!=null)return this.convertAndCacheOnCPU(e);if(ye().getBool("DEBUG")&&!ye().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ye().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,h;if(i!=="complex64"&&ye().get("WEBGL_BUFFER_SUPPORTED")){h=this.decode(e);const y=this.texData.get(h.dataId);c=this.gpgpu.createBufferFromTexture(y.texture.texture,...Dy(r))}this.pendingRead.set(e,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let p;if(i==="complex64"){const y=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),x=y[0],w=y[1];p=ko(x,w)}else if(c==null)p=this.getValuesFromTexture(e);else{const y=$e(r);p=this.gpgpu.downloadFloat32MatrixFromBuffer(c,y)}if(h!=null&&this.disposeIntermediateTensorInfo(h),c!=null){const y=this.gpgpu.gl;He(y,()=>y.deleteBuffer(c))}const f=this.convertAndCacheOnCPU(e,p),g=this.pendingRead.get(e);return this.pendingRead.delete(e),g.forEach(y=>y(f)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Ua().removeDataId(e,this),this.pendingDeletes--),f}readToGPU(e,n={}){const s=this.texData.get(e),{values:r,shape:a,slice:i,dtype:o,isPacked:l,texture:c}=s;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let g;l?g=new kl(a,_l):g=new Si(a,_l);const y=this.runWebGLProgram(g,[{dataId:e,shape:a,dtype:o}],o),x=this.readToGPU(y,n);return this.disposeIntermediateTensorInfo(y),x}if(c==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const h=this.decode(e,n.customTexShape),p=Ua().makeTensorFromTensorInfo(h),f=this.texData.get(h.dataId);return Object.assign({tensorRef:p},f.texture)}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const s=n.map(r=>Rl(r));return xt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return xt(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let n=0;n<e.length;n++){const s=e[n];if(!ule(s))throw ye().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:n,dtype:s,isPacked:r}=this.texData.get(e),a=$e(n);if(ye().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(e),g=this.texData.get(f.dataId),y=this.gpgpu.downloadMatrixFromPackedTexture(g.texture.texture,...Dy(n)).subarray(0,a);return this.disposeIntermediateTensorInfo(f),y}const i=ye().getBool("WEBGL_PACK")&&r===!0,o=i?Fy(n):n,l=i?new Cue(o):new _ue(o),c=this.runWebGLProgram(l,[{shape:o,dtype:s,dataId:e}],"float32"),h=this.texData.get(c.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture.texture,h.texShape[0],h.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(c),p}timerAvailable(){return ye().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const n=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const a=sc(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=sc(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ye().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(a);o.kernelMs=S6(l),o.getExtraProfileInfo=()=>l.map((c,h)=>({name:i[h],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ye().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:sr(),endMs:null}}endTimer(e){return ye().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=sr(),e)}async getQueryTime(e){if(ye().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const n=e;return n.endMs-n.startMs}disposeData(e,n=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(n?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!n&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,n),this.disposeData(s.imag.dataId,n)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:n,dtype:s,texShape:r,usage:a,isPacked:i,slice:o}=this.texData.get(e),l=o&&o.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(n,r,a,i)));const h=this.texData.get(e);h.texture=null,h.texShape=null,h.isPacked=!1,h.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,n=rde){return ye().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&$e(s.shape)<n)}getGPGPUContext(){return this.gpgpu}where(e){Gr("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=e.dataSync();return ede(e.shape,n)}packedUnaryOp(e,n,s){const r=new kl(e.shape,n),a=this.compileAndRun(r,[e],s);return Ua().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=yB(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(ye().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,RE,e.dtype);const n=new Si(e.shape,RE),s=this.compileAndRun(n,[e]);return Ua().makeTensorFromTensorInfo(s)}makeTensorInfo(e,n,s){let r;if(n==="string"&&s!=null&&s.length>0&&Ef(s[0])){const a=s.map(i=>Il(i));r=this.write(a,e,n)}else r=this.write(s,e,n);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:n}}makeOutput(e,n,s){return Ua().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,s),this)}unpackTensor(e){const n=new Jce(e.shape);return this.runWebGLProgram(n,[e],e.dtype)}packTensor(e){const n=new Lce(e.shape);return this.runWebGLProgram(n,[e],e.dtype,null,!0)}packedReshape(e,n){const s=[jd(e.shape),...Kd(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},a=[jd(n),...Kd(n)],i=new wB(a,s),o=!0,l=[s],c=this.runWebGLProgram(i,[r],e.dtype,l,o);return{dataId:c.dataId,shape:n,dtype:c.dtype}}decode(e,n){const s=this.texData.get(e),{isPacked:r,shape:a,dtype:i}=s;if(n!=null){const f=$e(a),g=n[0]*n[1]*4;V(f<=g,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const o=Fy(a);let l;r?l=new Sue(o):l=new $ue(o);const c=!0,h=[n??Dy(o)],p=this.runWebGLProgram(l,[{shape:o,dtype:i,dataId:e}],i,h,c,n);return{dtype:i,shape:a,dataId:p.dataId}}runWebGLProgram(e,n,s,r,a=!1,i){const o=this.makeTensorInfo(e.outputShape,s),l=this.texData.get(o.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===$f.DENSE){const v=i??Dy(e.outputShape);l.texShape=v.map($=>$*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),$e(o.shape)===0)return l.values=ys(o.dtype,0),o;const c=[],h=n.map(v=>{if(v.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let $=this.texData.get(v.dataId);if($.texture==null){if(!e.packedInputs&&$e(v.shape)<=ye().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:v.shape,texData:null,isUniform:!0,uniformValues:$.values};e.packedInputs&&($.isPacked=!0,$.shape=v.shape)}if(this.uploadToGPU(v.dataId),!!$.isPacked!=!!e.packedInputs)v=$.isPacked?this.unpackTensor(v):this.packTensor(v),c.push(v),$=this.texData.get(v.dataId);else if($.isPacked&&!V0($.shape,v.shape)){const T=v,C=v.shape;v.shape=$.shape,v=this.packedReshape(v,C),c.push(v),$=this.texData.get(v.dataId),T.shape=C}return{shape:v.shape,texData:$,isUniform:!1}});this.uploadToGPU(o.dataId);const p={shape:o.shape,texData:l,isUniform:!1},f=vue(e,h,p),g=this.getAndSaveBinary(f,()=>xue(this.gpgpu,e,h,p)),y=this.activeTimers!=null;let x;y&&(x=this.startTimer()),ye().get("ENGINE_COMPILE_ONLY")||wue(this.gpgpu,g,h,p,r),c.forEach(v=>this.disposeIntermediateTensorInfo(v)),y&&(x=this.endTimer(x),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(x)}));const w=ye().getNumber("WEBGL_FLUSH_THRESHOLD");if(w>0){const v=sr();v-this.lastGlFlushTime>w&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=v)}if(!ye().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&a===!1){const v=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),v}return o}compileAndRun(e,n,s,r,a=!1){return s=s||n[0].dtype,this.runWebGLProgram(e,n,s,r,a)}getAndSaveBinary(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ye().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=me(()=>{if(!ye().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ye().getBool("DEBUG");ye().set("DEBUG",!1);const n=this.abs(st(1e-8)).dataSync()[0];if(ye().set("DEBUG",e),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?tde:nde}uploadToGPU(e){const n=this.texData.get(e),{shape:s,dtype:r,values:a,texture:i,usage:o,isPacked:l}=n;if(i!=null)return;const c=this.activeTimers!=null;let h;c&&(h=sr());let p=n.texShape;if(p==null&&(p=kle(s,l),n.texShape=p),a!=null){const f=Fy(s);let g,y=p[1],x=p[0];const w=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(l||!w)&&([y,x]=lh(p[0],p[1])),l?g=new kue(f,w):g=new NE(f,w);const v=w?[x,y]:p,$=this.makeTensorInfo(v,r),T=this.texData.get($.dataId);w?T.usage=qr.PIXELS:T.usage=qr.UPLOAD,T.texShape=v,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture($.dataId),y,x,a);const C=[[x,y]],A=this.runWebGLProgram(g,[$],r,C,!0),O=this.texData.get(A.dataId);n.texShape=O.texShape,n.isPacked=O.isPacked,n.usage=O.usage,ye().get("ENGINE_COMPILE_ONLY")?this.disposeData(A.dataId):(n.texture=O.texture,n.values=null,this.texData.delete(A.dataId)),this.disposeIntermediateTensorInfo($),c&&(this.uploadWaitMs+=sr()-h)}else{const f=this.acquireTexture(p,o,r,l);n.texture=f}}convertAndCacheOnCPU(e,n){const s=this.texData.get(e),{dtype:r}=s;return n!=null&&(s.values=ode(n,r)),s.values}acquireTexture(e,n,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,n,r)}computeBytes(e,n){return e[0]*e[1]*g0(n)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(n));return Promise.all(e)}else{for(const[,n]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(n),r(!0)}catch(a){throw a}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await rF(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(aB(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:n,customUniformLocations:s,infLoc:r,nanLoc:a,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:l}=cB(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=n,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=a,e.outShapeLocation=i,e.outShapeStridesLocation=o,e.outTexShapeLocation=l}}createTensorFromGPUData(e,n,s){e.channels=e.channels||"RGBA";const{texture:r,height:a,width:i,channels:o}=e,l=Ua().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(r,n,s,a,i,o);return Ua().makeTensorFromDataId(c,n,s,l)}}Hx.nextDataId=0;function ode(t,e){if(e==="float32"||e==="complex64")return t;if(e==="int32"||e==="bool"){const n=e==="int32"?new Int32Array(t.length):new Uint8Array(t.length);for(let s=0;s<n.length;++s)n[s]=Math.round(t[s]);return n}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */pO()&&gO("webgl",()=>new Hx,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UC=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class mc{constructor(e,n,s){this.variableNames=["A","B"],this.outputShape=ft(n,s),this.enableShapeUniforms=Os(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ic=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class ph{constructor(e,n,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ft(n,s);const a=this.outputShape.length;this.enableShapeUniforms=Os(a);let i="";if(r)if(a===0||$e(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${en(a)} coords = getOutputCoords();
        `,a===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=Gs("coords",a);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${l[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${l[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${l[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${l[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ir(t){const{inputs:e,backend:n}=t,{x:s}=e;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const lde={kernelName:Zf,backendName:"webgl",kernelFunc:Ir};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eu(t){const{inputs:e,backend:n}=t,{real:s,imag:r}=e,a=n.makeTensorInfo(s.shape,"complex64"),i=n.texData.get(a.dataId),o=Ir({inputs:{x:s},backend:n}),l=Ir({inputs:{x:r},backend:n});return i.complexTensorInfos={real:o,imag:l},a}const ude={kernelName:j2,backendName:"webgl",kernelFunc:eu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vB="return (a < 0.) ? b * a : a;",$B=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function cde(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{alpha:a}=s,i=n.makeTensorInfo([],"float32",Gl(a,"float32")),o=ye().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ph($B,r.shape,i.shape):new mc(vB,r.shape,i.shape),l=n.runWebGLProgram(o,[r,i],"float32");return n.disposeIntermediateTensorInfo(i),l}const dde={kernelName:_b,backendName:"webgl",kernelFunc:cde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SB="return (a < 0.) ? b * a : a;",_B=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function hde(t){const{inputs:e,backend:n}=t,{x:s,alpha:r}=e,a=ye().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ph(_B,s.shape,r.shape):new mc(SB,s.shape,r.shape);return n.runWebGLProgram(a,[s,r],"float32")}const pde={kernelName:Wb,backendName:"webgl",kernelFunc:hde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fh="if (isnan(x)) return x;";function Pt({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:s}){return({inputs:r,backend:a})=>{const{x:i}=r,o=a,l=s||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){const p=o.texData.get(i.dataId),f=n(p.values,l);return o.makeTensorInfo(i.shape,l,f)}const c=ye().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let h;return c?h=new kl(i.shape,e):h=new Si(i.shape,t),o.runWebGLProgram(h,[i],l)}}function $s({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:a}){return({inputs:i,backend:o})=>{const{a:l,b:c}=i,h=o;if(s&&l.dtype==="complex64"){const y=h.texData.get(l.dataId),x=h.texData.get(c.dataId),[w,v]=[[y.complexTensorInfos.real,x.complexTensorInfos.real],[y.complexTensorInfos.imag,x.complexTensorInfos.imag]].map(T=>{const[C,I]=T,A={dataId:C.dataId,dtype:C.dtype,shape:l.shape},O={dataId:I.dataId,dtype:I.dtype,shape:c.shape},B=new mc(t,l.shape,c.shape);return h.runWebGLProgram(B,[A,O],_r(C.dtype,I.dtype))}),$=eu({inputs:{real:w,imag:v},backend:h});return h.disposeIntermediateTensorInfo(w),h.disposeIntermediateTensorInfo(v),$}const p=a||_r(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||h.shouldExecuteOnCPU([l,c]))&&r!=null){const y=h.texData.get(l.dataId).values,x=h.texData.get(c.dataId).values,w=l.dtype==="string"?No(y):y,v=l.dtype==="string"?No(x):x,[$,T]=r(l.shape,c.shape,w,v,p),C=h.makeTensorInfo(T,p),I=h.texData.get(C.dataId);return I.values=$,C}const f=ye().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let g;return f?g=new ph(e,l.shape,c.shape,n):g=new mc(t,l.shape,c.shape),h.runWebGLProgram(g,[l,c],p)}}function Sf(t,e=!1){if(t==="linear")return e?Kce:Wce;if(t==="relu")return e?Yce:Hce;if(t==="elu")return e?Xce:Gce;if(t==="relu6")return e?Zce:qce;if(t==="prelu")return e?_B:SB;if(t==="leakyrelu")return e?$B:vB;if(t==="sigmoid")return e?Qce:jce;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CB{constructor(e,n,s,r=!1,a=!1,i=!1,o=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Os(this.outputShape.length);const h=r?e[1]:e[2],p=Math.ceil(h/2),f=r?"i * 2, rc.y":"rc.y, i * 2",g=a?"rc.z, i * 2":"i * 2, rc.z",y=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],x=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let w="",v="";o&&(l?w=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:c?w=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:w=`vec4 activation(vec4 x) {
          ${o}
        }`,v="result = activation(result);");const $=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let T="rc.x",C="rc.x";e[0]<n[0]?T=`imod(rc.x, ${e[0]})`:n[0]<e[0]&&(C=`imod(rc.x, ${n[0]})`),this.userCode=`
      ${w}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${T};
        int batchB = ${C};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${f});
          vec4 b = getMatrixB(batchB, ${g});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${y[0]} * ${x[0]});
          result += (${y[1]} * ${x[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${$}

        ${v}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DE={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class OE{constructor(e,n,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ft(n,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zE="return a * b;";function WC(t){const{inputs:e,backend:n}=t,{a:s,b:r}=e,a=_r(s.dtype,r.dtype);if(s.dtype==="complex64"){const o=n.texData.get(s.dataId),l=n.texData.get(r.dataId),c=new OE(DE.REAL,s.shape,r.shape),h=new OE(DE.IMAG,s.shape,r.shape),p=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:s.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],f=n.runWebGLProgram(c,p,"float32"),g=n.runWebGLProgram(h,p,"float32"),y=eu({inputs:{real:f,imag:g},backend:n});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),y}if(n.shouldExecuteOnCPU([s,r])){const o=n.texData.get(s.dataId),l=n.texData.get(r.dataId),[c,h]=hce(s.shape,r.shape,o.values,l.values,a),p=n.makeTensorInfo(h,a),f=n.texData.get(p.dataId);return f.values=c,p}let i;return ye().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new ph(zE,s.shape,r.shape):i=new mc(zE,s.shape,r.shape),n.runWebGLProgram(i,[s,r],a)}const fde={kernelName:im,backendName:"webgl",kernelFunc:WC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mde(t,e,n){const s=[jd(t.shape),...Kd(t.shape)],r={dtype:t.dtype,shape:s,dataId:t.dataId},a=[jd(e),...Kd(e)],i=new wB(a,s),o=!0,l=[s],c=n.runWebGLProgram(i,[r],t.dtype,l,o);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ue(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{shape:a}=s,i=n,o=$e(r.shape),l=jD(a,o),c=$e(l);V(o===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const h=i.texData.get(r.dataId);return h.isPacked&&!V0(r.shape,l)&&!(h.texture!==null&&V0(h.shape,l))?mde(r,l,i):(i.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}const gde={kernelName:Hb,backendName:"webgl",kernelFunc:Ue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FE{constructor(e,n){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:a,outSize:i}=e;this.outputShape=[r,i];const o=Math.floor(s/4)*4,l=s%4;let c="sumValue += dot(values, ones);";if(n!=null){const p=1/n;c=`sumValue += dot(values * ${Ld(p)?p.toPrecision(2):p}, ones);`}let h="";a%s>0&&(h=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${o};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yde{constructor(e,n){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:a,outSize:i}=e;this.outputShape=[r,i];let o="0.0",l="";n==="prod"?o="1.0":n==="min"?(o="1.0 / 1e-20",l="min"):n==="max"&&(o="-1.0 / 1e-20",l="max");let c=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?c="sumValue":n==="prod"?c="prodValue":n==="all"?c="allValue":n==="any"&&(c="anyValue");const h=Math.floor(s/4)*4,p=s%4;let f=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,g="vec4";n==="all"?(o="1.0",f=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,g="bvec4"):n==="any"&&(o="0.0",f=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,g="bvec4");let y="";a%s>0&&(y=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${y}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${f}
        }

        int inIdx = inOffset + ${h};
        if (${p===1}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${p===2}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${p===3}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${f}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bde(t){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const n=e.length?e[e.length-1].outSize:t[1],s=Ix(n);e.push({inSize:n,windowSize:s,outSize:Math.ceil(n/s)})}return e}function Ec(t,e,n,s){const r=bde(t.shape);let a=t;for(let i=0;i<r.length;i++){const{inSize:o,windowSize:l,outSize:c}=r[i];let h,p;n==="mean"?h=i===0?new FE({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:c},o):new FE({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:c}):h=new yde({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:c},n),p=a,a=s.runWebGLProgram(h,[a],e),p.dataId!==t.dataId&&s.disposeIntermediateTensorInfo(p)}return a}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xde{constructor(e,n){this.variableNames=["A"];const s=new Array(e.length);for(let i=0;i<s.length;i++)s[i]=e[n[i]];this.outputShape=s,this.rank=s.length;const r=en(this.rank),a=wde(n);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `}}function wde(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<t.length;r++)s[t[r]]=n[r];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vde{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let h=0;h<s.length;h++)s[h]=e[n[h]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=en(this.rank),a=xB("rc",this.rank),i=new Array(this.rank);for(let h=0;h<n.length;h++)i[n[h]]=a[h];const o=`vec2(${i.slice(-2).join()})`,l=`++${a[this.rank-1]} < ${s[this.rank-1]}`,c=`getChannel(getA(${i.join()}), ${o})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qx(t,e,n){const s=ye().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vde(t.shape,e):new xde(t.shape,e);return n.runWebGLProgram(s,[t],t.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $de(t,e,n,s){const r=e,a=t.shape.length,i=St(r,t.shape);let o=i;const l=wn(o,a),c=l!=null;let h=t;c&&(h=qx(t,l,s),o=Dn(o.length,a)),ws("sum",o,a);const[p,f]=ls(h.shape,o);let g=p;n&&(g=Rn(p,i));const y=$e(f),w=$e(t.shape)/y,v=Ue({inputs:{x:h},attrs:{shape:[w,y]},backend:s}),$=HS(t.dtype),T=Ec(v,$,"sum",s),C=Ue({inputs:{x:T},attrs:{shape:g},backend:s});return s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(T),c&&s.disposeIntermediateTensorInfo(h),C}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jx(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s;return $de(r,a,i,n)}const Sde={kernelName:Zb,backendName:"webgl",kernelFunc:jx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qs(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{perm:a}=s,i=n,o=r.shape.length,l=new Array(o);for(let h=0;h<l.length;h++)l[h]=r.shape[a[h]];let c;if(i.shouldExecuteOnCPU([r])){const p=i.texData.get(r.dataId).values,f=VC(p,r.shape,r.dtype,a,l);c=i.makeTensorInfo(l,r.dtype);const g=i.texData.get(c.dataId);g.values=f}else c=qx(r,a,i);return c}const _de={kernelName:Ad,backendName:"webgl",kernelFunc:qs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TB=1e3;function U0({a:t,b:e,transposeA:n,transposeB:s,backend:r,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const c=t.shape.length,h=e.shape.length,p=n?t.shape[c-2]:t.shape[c-1],f=s?e.shape[h-1]:e.shape[h-2],g=n?t.shape[c-1]:t.shape[c-2],y=s?e.shape[h-2]:e.shape[h-1],x=t.shape.slice(0,-2),w=e.shape.slice(0,-2),v=$e(x),$=$e(w),C=ft(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([g,y]);V(p===f,()=>`Error in matMul: inner shapes (${p}) and (${f}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${s} must match.`);const I=n?[v,p,g]:[v,g,p],A=s?[$,y,f]:[$,f,y],O=Ue({inputs:{x:t},backend:r,attrs:{shape:I}}),B=Ue({inputs:{x:e},backend:r,attrs:{shape:A}}),z=[O,B],P=Math.max(v,$),F=n?O.shape[1]:O.shape[2],K=a!=null,X=i!=null,te=l==="leakyrelu",Q=l!=null?Sf(l,!0):null,q=K||X||te||Q!=null;let oe;if((g===1||y===1)&&F>TB&&q===!1){let ee=O,U=B;n&&(ee=qs({inputs:{x:O},backend:r,attrs:{perm:[0,2,1]}}),z.push(ee)),s&&(U=qs({inputs:{x:B},backend:r,attrs:{perm:[0,2,1]}}),z.push(U));const G=y!==1,Y=y===1;let ce=ee;G&&(ce=Ue({inputs:{x:ee},backend:r,attrs:{shape:[P,F,1]}}),z.push(ce));const pe=y===1?2:1;let J=U;Y&&(J=Ue({inputs:{x:U},backend:r,attrs:{shape:[P,1,F]}}),z.push(J));const we=WC({inputs:{a:ce,b:J},backend:r});oe=jx({inputs:{x:we},backend:r,attrs:{axis:pe,keepDims:!0}}),z.push(we)}else{const ee=_r(t.dtype,e.dtype),U=new CB(I,A,[P,g,y],n,s,K,Q,X,te),G=[O,B];if(a!=null&&G.push(a),X&&G.push(i),te){const Y=r.makeTensorInfo([],"float32",Gl(o,"float32"));G.push(Y),z.push(Y)}oe=r.runWebGLProgram(U,G,ee)}const se=Ue({inputs:{x:oe},backend:r,attrs:{shape:C}});z.push(oe);for(const ee of z)r.disposeIntermediateTensorInfo(ee);return se}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cde(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:a,bias:i,preluActivationWeights:o}=e,{transposeA:l,transposeB:c,activation:h,leakyreluAlpha:p}=s;return U0({a:r,b:a,transposeA:l,transposeB:c,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:p,activation:h})}const Tde={kernelName:y0,backendName:"webgl",kernelFunc:Cde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LE="return abs(x);";function kde(t){const{inputs:e,backend:n}=t,{x:s}=e;if(n.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const a=n.texData.get(s.dataId),i=yB(a.values);return n.makeTensorInfo(s.shape,s.dtype,i)}let r;return ye().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new kl(s.shape,LE):r=new Si(s.shape,LE),n.runWebGLProgram(r,[s],s.dtype)}const Nde={kernelName:nb,backendName:"webgl",kernelFunc:kde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ide=Ta+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Ede=Pt({opSnippet:Ide}),Ade={kernelName:Af,backendName:"webgl",kernelFunc:Ede};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rde=Ta+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Dde=Pt({opSnippet:Rde}),Ode={kernelName:Rf,backendName:"webgl",kernelFunc:Dde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ME="return a + b;",zde=$s({opSnippet:ME,packedOpSnippet:ME,supportsComplex:!0,cpuKernelImpl:Hue}),Fde={kernelName:th,backendName:"webgl",kernelFunc:zde};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lde{constructor(e,n){this.outputShape=[],this.outputShape=e,this.variableNames=n.map((a,i)=>`T${i}`);const s=[];this.variableNames.forEach(a=>{s.push(`float v${a} = get${a}AtOutCoords();`)});const r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mde{constructor(e,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=n.map((a,i)=>`T${i}`);const s=[];this.variableNames.forEach(a=>{s.push(`vec4 v${a} = get${a}AtOutCoords();`)});const r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h0(t){const{inputs:e,backend:n}=t,s=e;if(s.length===1)return Ir({inputs:{x:s[0]},backend:n});if(s.length>ye().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),c=h0({inputs:s.slice(0,l),backend:n}),h=h0({inputs:s.slice(l),backend:n});return h0({inputs:[c,h],backend:n})}const r=s.map(l=>l.dtype).reduce((l,c)=>_r(l,c)),a=s.map(l=>l.shape),o=ye().getBool("WEBGL_PACK")?new Mde(s[0].shape,a):new Lde(s[0].shape,a);return n.runWebGLProgram(o,s,r)}const Bde={kernelName:sb,backendName:"webgl",kernelFunc:h0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pde(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s,o=r.shape.length,l=St(a,r.shape);let c=l;const h=wn(c,o);let p=r;h!=null&&(p=qs({inputs:{x:r},backend:n,attrs:{perm:h}}),c=Dn(c.length,o)),ws("all",c,o);const[f,g]=ls(p.shape,c),y=$e(g),x=Ue({inputs:{x:p},backend:n,attrs:{shape:[-1,y]}}),w=Ec(x,x.dtype,"all",n);let v;if(i){const $=Rn(f,l);v=Ue({inputs:{x:w},backend:n,attrs:{shape:$}})}else v=Ue({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),h!=null&&n.disposeIntermediateTensorInfo(p),v}const Vde={kernelName:V2,backendName:"webgl",kernelFunc:Pde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ude(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s,o=r.shape.length,l=St(a,r.shape);let c=l;const h=wn(c,o);let p=r;h!=null&&(p=qs({inputs:{x:r},backend:n,attrs:{perm:h}}),c=Dn(c.length,o)),ws("any",c,o);const[f,g]=ls(p.shape,c),y=$e(g),x=Ue({inputs:{x:p},backend:n,attrs:{shape:[-1,y]}}),w=Ec(x,x.dtype,"any",n);let v;if(i){const $=Rn(f,l);v=Ue({inputs:{x:w},backend:n,attrs:{shape:$}})}else v=Ue({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),h!=null&&n.disposeIntermediateTensorInfo(p),v}const Wde={kernelName:U2,backendName:"webgl",kernelFunc:Ude};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gde{constructor(e,n,s){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:i}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[a,i];const o=n==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hde{constructor(e,n,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,V(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const a=e[e.length-1],i=Math.ceil(a/n);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,l=o.length,c=en(l),h=Gs("coords",l);let p,f;if(i===1){f=l+1;const B=en(f);p=`
        ${B} sourceLocR = ${B}(${h.join()}, 0);
        ++${h[l-1]};
        ${B} sourceLocG = ${B}(${h.join()}, 0);
        ++${h[l-2]};
        ${B} sourceLocA = ${B}(${h.join()}, 0);
        --${h[l-1]};
        ${B} sourceLocB = ${B}(${h.join()}, 0);
        --${h[l-2]};`}else f=l,p=`
        ${c} sourceLocR = coords;
        ++${h[l-1]};
        ${c} sourceLocG = coords;
        ++${h[l-2]};
        ${c} sourceLocA = coords;
        --${h[l-1]};
        ${c} sourceLocB = coords;
        --${h[l-2]};`;const g=["x","y","z","w","u","v"].slice(0,f),y="."+g[f-1],x=g.map(B=>"int "+B),w=Gs("sourceLocR",f-1).concat("inIdx.r"),v=Gs("sourceLocG",f-1).concat("inIdx.g"),$=Gs("sourceLocB",f-1).concat("inIdx.b"),T=Gs("sourceLocA",f-1).concat("inIdx.a"),C=s==="max"?"greaterThan":"lessThan",I=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${$.join()}),
                             getBestIndicesAChannel(${T.join()})));`,A=`vec4(
            getAChannel(${w.join()}),
            hasNextCol ? getAChannel(${v.join()}) : 0.,
            hasNextRow ? getAChannel(${$.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${T.join()}) : 0.)`,O=r?"":`
      float getBestIndicesAChannel(${x.join()}) {
        return getChannel(getBestIndicesA(${g.join()}),
                                          vec2(${g.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${x.join()}) {
        return getChannel(getA(${g.join()}),
                               vec2(${g.slice(-2).join()}));
      }
      ${O}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${h[l-1]} < ${o[l-1]-1};
        bool hasNextRow = ${h[l-2]} < ${o[l-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${y}, sourceLocG${y},
          sourceLocB${y}, sourceLocA${y}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${A};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${I}
          vec4 candidate = ${A};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${C}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kB(t,e,n,s=null){let r=e.shape[0],a=e.shape[1];s!=null&&(r=s.shape[0],a=s.shape[1]);const i=Ix(a),o={windowSize:i,inSize:a,batchSize:r,outSize:Math.ceil(a/i)},l=new Gde(o,n,s==null),c=[e];s!=null&&c.push(s);const h=t.runWebGLProgram(l,c,"int32");if(h.shape[1]===1)return h;const p=kB(t,e,n,h);return t.disposeIntermediateTensorInfo(h),p}function NB(t,e,n,s=null){const r=s!=null?s.shape:e.shape,a=r[r.length-1],i=Ix(a),o=new Hde(r,i,n,s==null),l=s==null?[e]:[e,s],c=t.runWebGLProgram(o,l,"int32");if(c.shape.length===e.shape.length){const h=NB(t,e,n,c);return t.disposeIntermediateTensorInfo(c),h}return c}function IB(t,e,n,s){const r=[n];if(ws("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!ye().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const a=[],i=t.texData.get(e.dataId),o=i!==null&&i.isPacked;let l=e;o&&(l=t.unpackTensor(e),a.push(l));const[c,h]=ls(l.shape,r),p=$e(h),f=Ue({inputs:{x:l},backend:t,attrs:{shape:[-1,p]}});a.push(f);const g=kB(t,f,s);a.push(g);const y=Ue({inputs:{x:g},backend:t,attrs:{shape:c}});return a.forEach(x=>t.disposeIntermediateTensorInfo(x)),y}return NB(t,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qde(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a}=s;let i=St(a,r.shape);const o=wn(i,r.shape.length);let l=r;const c=[];o!=null&&(l=qs({inputs:{x:r},backend:n,attrs:{perm:o}}),c.push(l),i=Dn(i.length,l.shape.length)),ws("argMax",[i[0]],l.shape.length);const h=IB(n,l,i[0],"max");return c.forEach(p=>n.disposeIntermediateTensorInfo(p)),h}const jde={kernelName:rb,backendName:"webgl",kernelFunc:qde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kde(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a}=s;let i=St(a,r.shape);const o=wn(i,r.shape.length);let l=r;const c=[];o!=null&&(l=qs({inputs:{x:r},backend:n,attrs:{perm:o}}),c.push(l),i=Dn(i.length,l.shape.length)),ws("argMin",[i[0]],l.shape.length);const h=IB(n,l,i[0],"min");return c.forEach(p=>n.disposeIntermediateTensorInfo(p)),h}const Xde={kernelName:ab,backendName:"webgl",kernelFunc:Kde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yde=Ta+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Zde=Pt({opSnippet:Yde}),Qde={kernelName:Df,backendName:"webgl",kernelFunc:Zde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jde=Ta+"return log(x + sqrt(x * x + 1.0));",ehe=Pt({opSnippet:Jde}),the={kernelName:Of,backendName:"webgl",kernelFunc:ehe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nhe=Ta+`
  return atan(x);
`,she=Pt({opSnippet:nhe}),rhe={kernelName:zf,backendName:"webgl",kernelFunc:she};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ahe=UC+`
  return atan(a, b);
`,ihe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ic+`
  return result;
`,ohe=$s({opSnippet:ahe,packedOpSnippet:ihe}),lhe={kernelName:Lf,backendName:"webgl",kernelFunc:ohe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uhe=Ta+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,che=Pt({opSnippet:uhe}),dhe={kernelName:Ff,backendName:"webgl",kernelFunc:che};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _f{constructor(e,n,s,r=!1,a=!1){if(this.variableNames=["x"],n==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,o=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,h=e.dilationWidth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const x=n==="avg",w=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,v=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let $="0.0";if(x||($="-1.0 / 1e-20"),s){const B=">=";this.userCode=`
        const ivec2 strides = ivec2(${o}, ${l});
        const ivec2 pads = ivec2(${g}, ${y});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f};
                wC += ${h}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${B} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?a?w:v:`wR * ${f} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const T="max";let C=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(C="avgValue / max(count, 1.0)");const I=Math.floor(i/4)*4,A=i%4,O=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${T}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${g}, ${y});
      const float initializationValue = ${$};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${$});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${I}; wC += 4) {
            int xC = xCCorner + wC * ${h};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              getValue(batch, xR, xC + 3 * ${h}, d)
            );

            ${O}
          }

          int xC = xCCorner + ${I};
          if (${A===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${O}
          } else if (${A===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              initializationValue,
              initializationValue
            );

            ${O}
          } else if (${A===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              initializationValue
            );

            ${O}
          }
        }
        setOutput(${C});
      }
    `}}class GC{constructor(e,n,s,r=!1,a=!1){if(this.variableNames=["x"],n==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,o=e.strideDepth,l=e.strideHeight,c=e.strideWidth,h=e.dilationDepth,p=e.dilationHeight,f=e.dilationWidth,g=e.effectiveFilterDepth,y=e.effectiveFilterHeight,x=e.effectiveFilterWidth,w=e.padInfo.front,v=e.padInfo.top,$=e.padInfo.left;this.outputShape=e.outShape;const T=n==="avg";let C="0.0";if(T||(C="-1.0 / 1e-20"),s){const P=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${l}, ${c});
        const ivec3 pads = ivec3(${w}, ${v}, ${$});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${g};
              wD += ${h}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${y};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${x};
                  wC += ${f}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${P} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${y} * ${x} +
                      wR * ${x} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const I="max";let A=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(A="avgValue / max(count, 1.0)");const O=Math.floor(i/4)*4,B=i%4,z=`
      if (${T}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${I}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${l}, ${c});
      const ivec3 pads = ivec3(${w}, ${v}, ${$});
      const float initializationValue = ${C};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${C});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${g};
            wD += ${h}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${y};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${O}; wC += 4) {
              int xC = xCCorner + wC * ${f};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                getValue(batch, xD, xR, xC + 3 * ${f}, ch)
              );

              ${z}
            }

            int xC = xCCorner + ${O};
            if (${B===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${z}
            } else if (${B===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                initializationValue,
                initializationValue
              );

              ${z}
            } else if (${B===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                initializationValue
              );

              ${z}
            }
          }
        }
        setOutput(${A});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hhe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;jm(r,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=s,c=1;V(xs(i,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const h=_a(r.shape,a,i,c,o,l);if(h.filterWidth===1&&h.filterHeight===1&&Rt(h.inShape,h.outShape))return Ir({inputs:{x:r},backend:n});const p=new _f(h,"avg",!1);return n.runWebGLProgram(p,[r],"float32")}const phe={kernelName:ib,backendName:"webgl",kernelFunc:hhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fhe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:c}=s,h=[1,1,1],p=Eo(r.shape,a,i,h,o,l,c),f=new GC(p,"avg",!1);return n.runWebGLProgram(f,[r],"float32")}const mhe={kernelName:ob,backendName:"webgl",kernelFunc:fhe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ghe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterHeight,s=e.filterWidth,r=e.strideHeight,a=e.strideWidth,i=e.dilationHeight,o=e.dilationWidth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,h=l-1-e.padInfo.top,p=c-1-e.padInfo.left,f=1/(n*s);this.userCode=`
      const ivec2 pads = ivec2(${h}, ${p});
      const float avgMultiplier = float(${f});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class yhe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterDepth,s=e.filterHeight,r=e.filterWidth,a=e.strideDepth,i=e.strideHeight,o=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,p=e.effectiveFilterDepth,f=e.effectiveFilterHeight,g=e.effectiveFilterWidth,y=p-1-e.padInfo.front,x=f-1-e.padInfo.top,w=g-1-e.padInfo.left,v=1/(n*s*r);this.userCode=`
      const ivec3 pads = ivec3(${y}, ${x}, ${w});
      const float avgMultiplier = float(${v});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${f};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${g};
                wC += ${h}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bhe(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:a}=e,i=a,{filterSize:o,strides:l,pad:c,dimRoundingMode:h}=s,p=[1,1,1],f=Eo(i.shape,o,l,p,c,h),g=new yhe(f);return n.runWebGLProgram(g,[r],i.dtype)}const xhe={kernelName:G2,backendName:"webgl",kernelFunc:bhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function whe(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:a}=e,i=a;jm([r,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:c}=s,h=_a(i.shape,o,l,1,c),p=new ghe(h);return n.runWebGLProgram(p,[r],i.dtype)}const vhe={kernelName:W2,backendName:"webgl",kernelFunc:whe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $he(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:a}=e,{transposeA:i,transposeB:o}=s;return U0({a:r,b:a,transposeA:i,transposeB:o,backend:n})}const She={kernelName:lb,backendName:"webgl",kernelFunc:$he};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _he{constructor(e,n,s,r,a,i){this.outputShape=[],this.variableNames=["x","mean","variance"],ft(e,n),ft(e,s);let o="0.0";r!=null&&(ft(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="1.0";a!=null&&(ft(e,a),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Che{constructor(e,n,s,r,a,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],ft(e,n),ft(e,s);let o="vec4(0.0)";r!=null&&(ft(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="vec4(1.0)";a!=null&&(ft(e,a),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const The=({inputs:t,backend:e,attrs:n})=>{const{x:s,mean:r,variance:a,offset:i,scale:o}=t;V(r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),V(i==null||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),V(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);const c=[s,r,a];let h=null;i!=null&&(h=i.shape,c.push(i));let p=null;o!=null&&(p=o.shape,c.push(o));const f=ye().getBool("WEBGL_PACK_NORMALIZATION")?new Che(s.shape,r.shape,a.shape,h,p,l):new _he(s.shape,r.shape,a.shape,h,p,l);return e.runWebGLProgram(f,c,c[0].dtype)},khe={kernelName:vb,backendName:"webgl",kernelFunc:The};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nhe{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const n=en(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=Ihe(this.rank);let r;const a=e.map((i,o)=>`sourceLoc.${f2[o]} = start[${o}] + coords.${f2[o]};`);r=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${a.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const f2=["x","y","z","w","u","v"];function Ihe(t){if(t===1)return"sourceLoc";if(t<=6)return f2.slice(0,t).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ehe{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=en(this.rank),s=Gs("coords",this.rank),r=Gs("sourceLoc",this.rank),a=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,i=`getChannel(getSource(${r.join()}), ${a})`,o=`
      result.x = ${i};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${i};
        --${r[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${i};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${i};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${n}(${e.map((h,p)=>`start[${p}]`).join()});`:e.map((h,p)=>`${r[p]} = ${s[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${o}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ahe(t,e,n,s){const r=s.texData.get(t.dataId),a=s.makeTensorInfo(n,t.dtype),i=s.texData.get(a.dataId);Object.assign(i,r),i.refCount=1,i.shape=n,i.dtype=t.dtype;let o=M_(e,nt(t.shape));r.slice&&(o+=r.slice.flatOffset),i.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||t.dataId};const l=s.dataRefCount.get(i.slice.origDataId)||1;return s.dataRefCount.set(i.slice.origDataId,l+1),a}function mh(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:a,size:i}=s,[o,l]=Nx(r,a,i);if(z_(r,o,l),$e(l)===0)return n.makeTensorInfo(l,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||r.dtype==="string"){const p=n.texData.get(r.dataId),f=Sce(p.values,o,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,f)}const{isPacked:c}=n.texData.get(r.dataId),h=L_(r.shape,o,l);if(c||!h){const p=ye().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ehe(l):new Nhe(l),f=[o];return n.runWebGLProgram(p,[r],r.dtype,f)}return n.uploadToGPU(r.dataId),Ahe(r,o,l,n)}const Rhe={kernelName:Yb,backendName:"webgl",kernelFunc:mh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dhe=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:a,crops:i}=s;V(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce(($,T)=>$*T),l=Om(r.shape,a,o),c=zm(l.length,a.length),h=Fm(r.shape,a,o),p=W_(i,a.length),f=G_(h,i,a.length),g=[],y=Ue({inputs:{x:r},backend:n,attrs:{shape:l}}),x=qs({inputs:{x:y},backend:n,attrs:{perm:c}}),w=Ue({inputs:{x},backend:n,attrs:{shape:h}}),v=mh({inputs:{x:w},backend:n,attrs:{begin:p,size:f}});return g.push(y),g.push(x),g.push(w),g.forEach($=>n.disposeIntermediateTensorInfo($)),v},Ohe={kernelName:ub,backendName:"webgl",kernelFunc:Dhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zhe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:a}=e,{size:i}=s,o=n.readSync(r.dataId),l=n.readSync(a.dataId),c=gB(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}const Fhe={kernelName:H2,backendName:"webgl",kernelFunc:zhe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lhe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Mhe=`
  return float(int(a.r) & int(b.r));
`;function Bhe(t){const{inputs:e,backend:n}=t,{a:s,b:r}=e,a=ye().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=ye().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([s,r])||i===1){const l=n.texData.get(s.dataId).values,c=n.texData.get(r.dataId).values,[h,p]=jue(s.shape,r.shape,l,c,s.dtype),f=n.makeTensorInfo(p,s.dtype),g=n.texData.get(f.dataId);return g.values=h,f}let o;return a?o=new ph(Lhe,s.shape,r.shape,!1):o=new mc(Mhe,s.shape,r.shape),n.runWebGLProgram(o,[s,r],s.dtype)}const Phe={kernelName:cb,backendName:"webgl",kernelFunc:Bhe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vhe(t){const{inputs:e,backend:n}=t,{s0:s,s1:r}=e,a=n.readSync(s.dataId),i=n.readSync(r.dataId),o=ft(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const Uhe={kernelName:q2,backendName:"webgl",kernelFunc:Vhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Whe="return float(a != b);",EB=$s({opSnippet:Whe,cpuKernelImpl:fce,dtype:"bool"}),Ghe={kernelName:Mb,backendName:"webgl",kernelFunc:EB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xm(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.texData.get(s.dataId);return Ir({inputs:{x:r.complexTensorInfos.real},backend:n})}const Hhe={kernelName:CS,backendName:"webgl",kernelFunc:Xm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qhe="return float(int(x));";function jhe(t,e){const n=new Si(t.shape,qhe),s=e.runWebGLProgram(n,[t],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m2(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dtype:a}=s;if(a==="complex64"){if(r.dtype==="complex64")return Ir({inputs:{x:r},backend:n});const i=Hn(r.shape),o=m2({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),l=eu({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),l}if(r.dtype==="complex64"){const i=Xm({inputs:{input:r},backend:n}),o=m2({inputs:{x:i},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(i),o}if(!KD(r.dtype,a)){const i=Ir({inputs:{x:r},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:a}}if(n.shouldExecuteOnCPU([r])){const i=n.texData.get(r.dataId).values,[o,l,c]=Kue(i,r.shape,r.dtype,a);return n.makeTensorInfo(o,l,c)}if(a==="int32")return jhe(r,n);if(a==="bool"){const i=n.makeTensorInfo([],"bool",ys("bool",1)),l=EB({inputs:{a:r,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${a}`)}const Khe={kernelName:Mf,backendName:"webgl",kernelFunc:m2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BE="return ceil(x);",Xhe=Pt({opSnippet:BE,packedOpSnippet:BE,cpuKernelImpl:Xue}),Yhe={kernelName:Bf,backendName:"webgl",kernelFunc:Xhe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zhe{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qhe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jhe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{clipValueMin:a,clipValueMax:i}=s;let o;ye().getBool("WEBGL_PACK_CLIP")?o=new Qhe(r.shape):o=new Zhe(r.shape);const l=[[a],[i]];return n.runWebGLProgram(o,[r],r.dtype,l)}const epe={kernelName:Pf,backendName:"webgl",kernelFunc:Jhe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tpe{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PE(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function npe(t){const{inputs:e,backend:n}=t,{x:s}=e,r=n.texData.get(s.dataId),a=new tpe(s.shape),i=[PE(s,r.complexTensorInfos.real),PE(s,r.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}const spe={kernelName:db,backendName:"webgl",kernelFunc:npe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rpe{constructor(e){this.outputShape=[],this.outputShape=Ti(e,1),this.variableNames=e.map((i,o)=>`T${o}`);const n=new Array(e.length-1);n[0]=e[0][1];for(let i=1;i<n.length;i++)n[i]=n[i-1]+e[i][1];const s=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<n.length;i++){const o=n[i-1];s.push(`else if (yC < ${n[i]}) setOutput(getT${i}(yR, yC-${o}));`)}const r=n.length,a=n[n.length-1];s.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ape{constructor(e,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Ti(e,n);const s=this.outputShape,r=s.length,a=en(r),i=Gs("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((x,w)=>`T${w}`);const l=new Array(e.length-1);l[0]=e[0][n];for(let x=1;x<l.length;x++)l[x]=l[x-1]+e[x][n];const c=o[n],h=o.slice(-2),p=o.join();let f=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${p}), vec2(${h.join()}));
        }`;for(let x=1;x<l.length;x++){const w=l[x-1];f+=`
        if (${c} < ${l[x]}  && ${c} >= ${l[x-1]}) {
          return getChannel(
            getT${x}(${By(o,c,w)}),
            vec2(${By(h,c,w)}));
        }`}const g=l.length,y=l[l.length-1];f+=`
        return getChannel(
          getT${g}(${By(o,c,y)}),
          vec2(${By(h,c,y)}));`,this.userCode=`
      float getValue(${o.map(x=>"int "+x)}) {
        ${f}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[r-1]} = ${i[r-1]} + 1;
        if (${i[r-1]} < ${s[r-1]}) {
          result.g = getValue(${i});
        }

        ${i[r-2]} = ${i[r-2]} + 1;
        if (${i[r-2]} < ${s[r-2]}) {
          result.a = getValue(${i});
        }

        ${i[r-1]} = ${i[r-1]} - 1;
        if (${i[r-2]} < ${s[r-2]} &&
            ${i[r-1]} < ${s[r-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}}function By(t,e,n){const s=t.indexOf(e);return t.map((a,i)=>i===s?`${a} - ${n}`:a).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kx(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.texData.get(s.dataId);return Ir({inputs:{x:r.complexTensorInfos.imag},backend:n})}const ipe={kernelName:dS,backendName:"webgl",kernelFunc:Kx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tf(t,e,n){const s=t[0].dtype;if(s==="complex64"){const g=t.map($=>Xm({inputs:{input:$},backend:n})),y=t.map($=>Kx({inputs:{input:$},backend:n})),x=tf(g,e,n),w=tf(y,e,n),v=eu({inputs:{real:x,imag:w},backend:n});return g.forEach($=>n.disposeIntermediateTensorInfo($)),y.forEach($=>n.disposeIntermediateTensorInfo($)),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),v}let r=n.shouldExecuteOnCPU(t);if(s==="string"&&(r=!0),r){const g=t.map(C=>{const A=[-1,$e(C.shape.slice(e))];return Ue({inputs:{x:C},backend:n,attrs:{shape:A}})}),y=g.map(C=>({vals:n.readSync(C.dataId),shape:C.shape})),x=Ti(g.map(C=>C.shape),1),w=g[0].shape[0]===1,v=Yue(y,x,s,w),$=Ti(t.map(C=>C.shape),e),T=n.makeTensorInfo($,s,v);return g.forEach(C=>n.disposeIntermediateTensorInfo(C)),T}const a=t.filter(g=>$e(g.shape)>0),i=ye().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(a.length===1){const g=i?new Si(t[0].shape,_l):new kl(t[0].shape,_l);return n.runWebGLProgram(g,t,s)}const o=ye().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){const g=[];for(let x=0;x<a.length;x+=o){const w=a.slice(x,x+o);g.push(tf(w,e,n))}const y=tf(g,e,n);for(const x of g)n.disposeIntermediateTensorInfo(x);return y}if(i){const g=new ape(a.map(y=>y.shape),e);return n.runWebGLProgram(g,a,s)}const{tensors2D:l,outShape:c}=ope(a,e,n),h=new rpe(l.map(g=>g.shape)),p=n.runWebGLProgram(h,l,s);l.forEach(g=>n.disposeIntermediateTensorInfo(g));const f=Ue({inputs:{x:p},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(p),f}function ope(t,e,n){const s=Ti(t.map(a=>a.shape),e);return{tensors2D:t.map(a=>Ue({inputs:{x:a},attrs:{shape:[-1,$e(a.shape.slice(e))]},backend:n})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AB(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s,a=St(r,e[0].shape)[0],i=e.map(c=>c.shape);P_(i,a);const o=Ti(e.map(c=>c.shape),a);if($e(o)===0)return n.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(c=>$e(c.shape)>0);return l.length===1?Ir({inputs:{x:l[0]},backend:n}):tf(l,a,n)}const lpe={kernelName:hb,backendName:"webgl",kernelFunc:AB};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RB{constructor(e,n=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.padInfo.top,o=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,h=e.dilationHeight,p=e.dilationWidth,f=e.filterHeight,g=e.filterWidth,y=Math.floor(e.inChannels/4)*4,x=e.inChannels%4,w=e.dataFormat==="channelsLast",v=w?1:2,$=w?2:3,T=w?3:1;let C="",I="";s&&(r?C=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:a?C=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:C=`
          float activation(float x) {
            ${s}
          }
        `,I="result = activation(result);");const A=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${C}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${T}];

        ivec2 xRCCorner =
            ivec2(coords[${v}], coords[${$}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * ${h};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${g}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${y}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${w}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${x===1}) {

              if (${w}) {
                dotProd +=
                    getX(batch, xR, xC, ${y}) *
                    getW(wR, wC, ${y}, d2);
              } else {
                dotProd +=
                    getX(batch, ${y}, xR, xC) *
                    getW(wR, wC, ${y}, d2);
              }

            } else if (${x===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${y}, d2),
                getW(wR, wC, ${y} + 1, d2)
              );

              if (${w}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${y}),
                  getX(batch, xR, xC, ${y} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${y}, xR, xC),
                  getX(batch, ${y} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${x===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${y}, d2),
                getW(wR, wC, ${y} + 1, d2),
                getW(wR, wC, ${y} + 2, d2)
              );

              if (${w}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${y}),
                  getX(batch, xR, xC, ${y} + 1),
                  getX(batch, xR, xC, ${y} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${y}, xR, xC),
                  getX(batch, ${y} + 1, xR, xC),
                  getX(batch, ${y} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${A}
        ${I}
        setOutput(result);
      }
    `}}class upe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const n=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,i=e.strideHeight,o=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,p=e.filterDepth,f=e.filterHeight,g=e.filterWidth,y=Math.floor(e.inChannels/4)*4,x=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${i}, ${o});
      const ivec3 pads = ivec3(${n}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${g}; wC++) {
              int xC = xCCorner + wC * ${h};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${y}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${x===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${y}) *
                  getW(wF, wR, wC, ${y}, d2);
              } else if (${x===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${y}),
                  getX(batch, xF, xR, xC, ${y} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${y}, d2),
                  getW(wF, wR, wC, ${y} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${x===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${y}),
                  getX(batch, xF, xR, xC, ${y} + 1),
                  getX(batch, xF, xR, xC, ${y} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${y}, d2),
                  getW(wF, wR, wC, ${y} + 1, d2),
                  getW(wF, wR, wC, ${y} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DB{constructor(e,n=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Os(this.outputShape.length);const i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,h=e.filterWidth,p=h;let f=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let w=0;w<h;w++)f+=`
           vec4 xTexelC${w*2};
           int xTexelC${w*2}Ready;
           vec4 xTexelC${w*2+1};
           int xTexelC${w*2+1}Ready;
           vec4 xC${w};`;f+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let w=0;w<h;w++)f+=`
           xTexelC${w*2} = vec4(0.0);
           xTexelC${w*2}Ready = 0;
           xTexelC${w*2+1} = vec4(0.0);
           xTexelC${w*2+1}Ready = 0;
           xC${w} = vec4(0.0);`;f+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let w=0;w<(p+1)/2;w++){const v=w*2;if(f+=`
           xC = xCCorner + ${v*l};
           `,o===1){if(v<h&&(i%2===1?(f+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }
               `,l===1&&v>0?f+=`
                 xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);
                 `:f+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${v} = vec4(previous.zw, xTexelC${v}.xy);
                   } else {
                     xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);
                   }
                   `):f+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 xC${v} = xTexelC${v};
                 `,v+1<h)){const $=i%2===0?M2(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(f+=`
                   xCOffset = xC + imod(pads[1], 2) + ${$};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                     xTexelC${v+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${v+1}.zw = vec2(0.0);
                     }
                     xTexelC${v+1}Ready = 1;
                   }
                   `,l>1?f+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${v+1} = vec4(previous.zw, xTexelC${v+1}.xy);
                     } else {
                      xC${v+1} = vec4(0.0, 0.0, xTexelC${v+1}.xy);
                     }
                     `:f+=`
                     xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);
                     `):$===1?f+=`
                     xC${v+1} = xTexelC${v};
                     `:f+=`
                     xCOffset = xC + ${$};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                       xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${v+1}.zw = vec2(0.0);
                       }
                       xTexelC${v+1}Ready = 1;
                     }

                     xC${v+1} = xTexelC${v+1};
                     `}}else v<h&&(i%2===1?(f+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {
                   xTexelC${v+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${v+1}.zw = vec2(0.0);
                   }
                   xTexelC${v+1}Ready = 1;
                 }

                 xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
               `,v+1<h&&(f+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);
                 `)):(f+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                   xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v+1}.zw = vec2(0.);
                   }
                   xTexelC${v+1}Ready = 1;
                 }

                 xC${v} = vec4(
                   xTexelC${v}.xy, xTexelC${v+1}.xy);
               `,v+1<h&&(f+=`
                   xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
                 `)));v<h&&(f+=`
             wTexel = getW(r, ${v}, d1, d2);
             dotProd += xC${v}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${v}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,v+1<h&&(f+=`
               wTexel = getW(r, ${v+1}, d1, d2);
               dotProd += xC${v+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${v+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}f+=`
     }
   `,f+=`
     }
   `,f+=`
     }
   `;let g="",y="";s&&(r?g=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:a?g=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:g=`vec4 activation(vec4 x) {
           ${s}
         }`,y="result = activation(result);");const x=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${g}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${f}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${x}
         ${y}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cpe{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Os(this.outputShape.length);const{dataFormat:s}=n,r=Ks(),a=s==="channelsLast",i=a?1:2,o=a?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let h=0;h<=1;h++)for(let p=0;p<=1;p++)c+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${h};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${h*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${h*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W0(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function OB({x:t,filter:e,convInfo:n,backend:s,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const l=t.shape,c=s.texData.get(t.dataId),h=n.inChannels,p=l[0]*l[1]*l[2],f=n.outChannels,g=n.dataFormat==="channelsLast",y=!1,x=!1;let w;const v=[];if(a!=null){const C=W0(a.shape,g);C!=null&&(a=Ue({inputs:{x:a},backend:s,attrs:{shape:C}}),v.push(a))}if(r!=null){const C=W0(r.shape,g);C!=null&&(r=Ue({inputs:{x:r},backend:s,attrs:{shape:C}}),v.push(r))}if(!((p===1||f===1)&&h>TB)&&c.isPacked&&g&&c.texture!=null&&l[2]%2!==0&&Rt(c.shape.slice(-3),l.slice(-3))){const C=l[0]*l[1]*(l[2]+1),I={dataId:t.dataId,shape:[1,C,n.inChannels],dtype:t.dtype},A=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,V(V0(c.shape,I.shape),()=>`packed reshape ${c.shape} to ${I.shape} isn't free`);const O=Ue({inputs:{x:e},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}});v.push(O);const B=U0({a:I,b:O,backend:s,transposeA:y,transposeB:x,bias:r,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),z=s.texData.get(B.dataId);V(z.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=A,z.shape=n.outShape,w=Ir({inputs:{x:B},backend:s}),w.shape=n.outShape,v.push(B)}else{const C=n.outHeight*n.outWidth,I=Ue({inputs:{x:t},backend:s,attrs:{shape:g?[n.batchSize,C,n.inChannels]:[n.batchSize,n.inChannels,C]}}),A=Ue({inputs:{x:e},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}}),O=U0({a:g?I:A,b:g?A:I,transposeA:!g,transposeB:x,backend:s,bias:r,activation:o,preluActivationWeights:a,leakyreluAlpha:i});w=Ue({inputs:{x:O},backend:s,attrs:{shape:n.outShape}}),v.push(I),v.push(A),v.push(O)}for(const C of v)s.disposeIntermediateTensorInfo(C);return w}function zB({x:t,filter:e,convInfo:n,backend:s,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const{filterWidth:l,filterHeight:c,inChannels:h,outWidth:p,outHeight:f,dataFormat:g}=n,y=g==="channelsLast",x=l*c*h,w=f*p,v=[n.batchSize,x,w],$=!0,T=!1,C=[];if(a!=null){const se=W0(a.shape,y);se!=null&&(a=Ue({inputs:{x:a},backend:s,attrs:{shape:se}}),C.push(a))}if(r!=null){const se=W0(r.shape,y);se!=null&&(r=Ue({inputs:{x:r},backend:s,attrs:{shape:se}}),C.push(r))}const I=Ue({inputs:{x:e},backend:s,attrs:{shape:[1,x,$e(e.shape)/x]}});C.push(I);const A=new cpe(v,n),O=[t.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],B=s.runWebGLProgram(A,[t],"float32",O),z=Ue({inputs:{x:B},backend:s,attrs:{shape:v}});C.push(B),C.push(z);const P=r!=null,F=a!=null,K=o==="leakyrelu",X=o?Sf(o,!0):null,te=new CB(y?z.shape:I.shape,y?I.shape:z.shape,y?[n.batchSize,w,n.outChannels]:[n.batchSize,n.outChannels,w],$,T,P,X,F,K),Q=y?[z,I]:[I,z];if(r&&Q.push(r),F&&Q.push(a),K){const se=s.makeTensorInfo([],"float32",Gl(i,"float32"));Q.push(se),C.push(se)}const q=s.runWebGLProgram(te,Q,"float32"),oe=Ue({inputs:{x:q},backend:s,attrs:{shape:n.outShape}});C.push(q);for(const se of C)s.disposeIntermediateTensorInfo(se);return oe}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dpe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a}=e,{strides:i,pad:o,dataFormat:l,dilations:c,dimRoundingMode:h}=s,p=Ao(l),f=os(r.shape,a.shape,i,c,o,h,!1,p);let g;if(f.filterHeight===1&&f.filterWidth===1&&f.dilationHeight===1&&f.dilationWidth===1&&f.strideHeight===1&&f.strideWidth===1&&(f.padInfo.type==="SAME"||f.padInfo.type==="VALID"))g=OB({x:r,filter:a,convInfo:f,backend:n});else if(f.strideWidth<=2&&p==="channelsLast"&&ye().getBool("WEBGL_EXP_CONV")){const x=new DB(f),w=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];g=n.runWebGLProgram(x,[r,a],"float32",w)}else if(ye().getBool("WEBGL_CONV_IM2COL"))g=zB({x:r,filter:a,convInfo:f,backend:n});else{const x=new RB(f);g=n.runWebGLProgram(x,[r,a],"float32")}const y=Ue({inputs:{x:g},backend:n,attrs:{shape:f.outShape}});return n.disposeIntermediateTensorInfo(g),y}const hpe={kernelName:pb,backendName:"webgl",kernelFunc:dpe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ppe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,i=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class fpe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,s=e.filterWidth,r=e.strideHeight,a=e.strideWidth,i=e.dataFormat==="channelsLast",o=n-1-e.padInfo.top,l=s-1-e.padInfo.left,c=i?1:2,h=i?2:3,p=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${h}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class mpe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideDepth,s=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,i=e.padInfo.top,o=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${a};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${i};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${o};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class gpe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterDepth,s=e.filterHeight,r=e.filterWidth,a=e.strideDepth,i=e.strideHeight,o=e.strideWidth,l=n-1-e.padInfo.front,c=s-1-e.padInfo.top,h=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ype(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:a}=e,{strides:i,pad:o,dataFormat:l,dimRoundingMode:c,filterShape:h}=s,p=Ao(l),f=os(r.shape,h,i,1,o,c,!1,p),g=new ppe(f);return n.runWebGLProgram(g,[r,a],"float32")}const bpe={kernelName:K2,backendName:"webgl",kernelFunc:ype};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xpe{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Os(this.outputShape.length);const n=e.filterHeight,s=e.filterWidth,r=n-1-e.padInfo.top,a=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wpe(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:a}=e,{inputShape:i,strides:o,pad:l,dataFormat:c,dimRoundingMode:h}=s,p=Ao(c),f=os(i,a.shape,o,1,l,h,!1,p);if(ye().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&p==="channelsLast"){const g=[[f.strideHeight,f.strideWidth]],y=new xpe(f);return n.runWebGLProgram(y,[r,a],"float32",g)}else{const g=new fpe(f);return n.runWebGLProgram(g,[r,a],"float32")}}const vpe={kernelName:fb,backendName:"webgl",kernelFunc:wpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $pe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a}=e,{strides:i,pad:o,dilations:l}=s,c=jl(r.shape,a.shape,i,l,o),h=new upe(c);return n.runWebGLProgram(h,[r,a],"float32")}const Spe={kernelName:mb,backendName:"webgl",kernelFunc:$pe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _pe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:a}=e,{strides:i,pad:o,filterShape:l}=s,c=jl(r.shape,l,i,1,o),h=new mpe(c);return n.runWebGLProgram(h,[r,a],"float32")}const Cpe={kernelName:X2,backendName:"webgl",kernelFunc:_pe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tpe(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:a}=e,{pad:i,strides:o,inputShape:l}=s,c=jl(l,a.shape,o,1,i),h=new gpe(c);return n.runWebGLProgram(h,[r,a],"float32")}const kpe={kernelName:Y2,backendName:"webgl",kernelFunc:Tpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Npe=fh+`
  return cos(x);
`,Ipe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Ic}
  return result;
`,Epe=Pt({opSnippet:Npe,packedOpSnippet:Ipe}),Ape={kernelName:Vf,backendName:"webgl",kernelFunc:Epe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rpe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Dpe=Pt({opSnippet:Rpe}),Ope={kernelName:Uf,backendName:"webgl",kernelFunc:Dpe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zpe{constructor(e,n,s,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,o,l,c]=e,[h]=n,[p,f]=s;this.outputShape=[h,p,f,c];const g=r==="bilinear"?1:0,[y,x]=[`${o-1}.0`,`${l-1}.0`],[w,v,$]=p>1?[`${(o-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${y} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${y}`],[T,C,I]=f>1?[`${(l-1)/(f-1)}`,"(x2-x1) * width_ratio",`x1*${x} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${x}`];this.userCode=`
      const float height_ratio = float(${w});
      const float width_ratio = float(${T});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${v};
        float width_scale = ${C};

        float in_y = ${$};
        if( in_y < 0.0 || in_y > ${y} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${I};
        if( in_x < 0.0 || in_x > ${x} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${g} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fpe=t=>{const{inputs:e,backend:n,attrs:s}=t,{image:r,boxes:a,boxInd:i}=e,{cropSize:o,method:l,extrapolationValue:c}=s,h=new zpe(r.shape,a.shape,o,l,c);return n.runWebGLProgram(h,[r,a,i],"float32")},Lpe={kernelName:Q2,backendName:"webgl",kernelFunc:Fpe};var Cf;(function(t){t.Prod="*",t.Sum="+"})(Cf||(Cf={}));class VE{constructor(e,n,s,r){this.op=e,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,i=this.op===Cf.Prod?"1.0":"0.0",o=s?i:`getX(${UE(a,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",h="";s?(c=r?`end != ${l-1}`:"end != 0",h=r?"end + 1":"end - 1"):(c=r?`end + pow2 < ${l}`:"end >= pow2",h=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${en(a)} coords = getOutputCoords();
        int end = ${WE(a,"coords",this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${h};
          ${WE(a,"coords",this.op)} = idx;
          val ${this.op}= getX(${UE(a,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function UE(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function WE(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FB(t,e,n,s,r,a){const i=e.shape.length,o=wn([s],i);let l=e;o!=null&&(l=qs({inputs:{x:e},backend:n,attrs:{perm:o}}));const c=Dn(1,i)[0];if(c!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const h=l.shape[c];let p=Ir({inputs:{x:l},backend:n});for(let f=0;f<=Math.ceil(Math.log2(h))-1;f++){const g=new VE(t,l.shape,!1,a),y=[[f]],x=p;p=n.runWebGLProgram(g,[p],p.dtype,y),n.disposeIntermediateTensorInfo(x)}if(r){const f=new VE(t,l.shape,r,a),g=p;p=n.runWebGLProgram(f,[p],p.dtype),n.disposeIntermediateTensorInfo(g)}if(o!=null){const f=Kl(o),g=qs({inputs:{x:p},backend:n,attrs:{perm:f}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(l),g}return p}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mpe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,exclusive:i,reverse:o}=s;return FB(Cf.Prod,r,n,a,i,o)}const Bpe={kernelName:Z2,backendName:"webgl",kernelFunc:Mpe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ppe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,exclusive:i,reverse:o}=s;return FB(Cf.Sum,r,n,a,i,o)}const Vpe={kernelName:gb,backendName:"webgl",kernelFunc:Ppe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Upe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:a}=e,{size:i,binaryOutput:o}=s;if(r.shape.length===1){const l=n.readSync(r.dataId),c=n.readSync(a.dataId),h=gB(l,c,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,h)}else if(r.shape.length===2){const l=n.bufferSync(r),c=n.bufferSync(a),h=que(l,c,i,o);return n.makeTensorInfo(h.shape,a.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const Wpe={kernelName:J2,backendName:"webgl",kernelFunc:Upe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gpe{constructor(e,n,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=n,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hpe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockSize:a,dataFormat:i}=s,o=r.shape[0],l=i==="NHWC"?r.shape[1]:r.shape[2],c=i==="NHWC"?r.shape[2]:r.shape[3],h=i==="NHWC"?r.shape[3]:r.shape[1],p=l*a,f=c*a,g=h/(a*a),y=i==="NHWC"?[o,p,f,g]:[o,g,p,f],x=new Gpe(y,a,i);return n.runWebGLProgram(x,[r],r.dtype)}const qpe={kernelName:eS,backendName:"webgl",kernelFunc:Hpe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LB{constructor(e,n=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Os(this.outputShape.length);const i=e.filterHeight,o=e.filterWidth,l=e.outChannels/e.inChannels;let c="",h="";s&&(r?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:a?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:c=`
          float activation(float x) {
            ${s}
          }
        `,h="result = activation(result);");const p=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${h}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MB{constructor(e,n=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Os(this.outputShape.length);const i=e.outChannels/e.inChannels,o=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,h=e.filterHeight,p=e.filterWidth,f=p;let g=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let v=0;v<p;v++)g+=`
          vec4 xTexelC${v*2};
          int xTexelC${v*2}Ready;
          vec4 xTexelC${v*2+1};
          int xTexelC${v*2+1}Ready;
          vec4 xC${v};`;g+=`
    for (int r = 0; r < ${h}; r++) {
      `;for(let v=0;v<p;v++)g+=`
          xTexelC${v*2} = vec4(0.0);
          xTexelC${v*2}Ready = 0;
          xTexelC${v*2+1} = vec4(0.0);
          xTexelC${v*2+1}Ready = 0;
          xC${v} = vec4(0.0);`;g+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let v=0;v<(f+1)/2;v++){const $=v*2;if(g+=`
          xC = xCCorner + ${$*c};
          `,l===1){if($<p&&(o%2===1?(g+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }
              `,c===1&&$>0?g+=`
                xC${$} = vec4(xTexelC${$-2}.zw, xTexelC${$}.xy);
                `:g+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${$} = vec4(previous.zw, xTexelC${$}.xy);
                  } else {
                    xC${$} = vec4(0.0, 0.0, xTexelC${$}.xy);
                  }
                  `):g+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                xC${$} = xTexelC${$};
                `,$+1<p)){const T=o%2===0?M2(c):c;c%2===0&&o%2===1||c%2!==0&&o%2!==1?(g+=`
                  xCOffset = xC + imod(pads[1], 2) + ${T};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                    xTexelC${$+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${$+1}.zw = vec2(0.0);
                    }
                    xTexelC${$+1}Ready = 1;
                  }
                  `,c>1?g+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${$+1} = vec4(previous.zw, xTexelC${$+1}.xy);
                    } else {
                     xC${$+1} = vec4(0.0, 0.0, xTexelC${$+1}.xy);
                    }
                    `:g+=`
                    xC${$+1} = vec4(xTexelC${$}.zw, xTexelC${$+1}.xy);
                    `):T===1?g+=`
                    xC${$+1} = xTexelC${$};
                    `:g+=`
                    xCOffset = xC + ${T};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                      xTexelC${$+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${$+1}.zw = vec2(0.0);
                      }
                      xTexelC${$+1}Ready = 1;
                    }

                    xC${$+1} = xTexelC${$+1};
                    `}}else $<p&&(o%2===1?(g+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${$+1}Ready == 0) {
                  xTexelC${$+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${$+1}.zw = vec2(0.0);
                  }
                  xTexelC${$+1}Ready = 1;
                }

                xC${$} = vec4(xTexelC${$}.zw, xTexelC${$+1}.zw);
              `,$+1<p&&(g+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${$+1} = vec4(xTexelC${$+1}.xy, final.xy);
                `)):(g+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                  xTexelC${$+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$+1}.zw = vec2(0.);
                  }
                  xTexelC${$+1}Ready = 1;
                }

                xC${$} = vec4(
                  xTexelC${$}.xy, xTexelC${$+1}.xy);
              `,$+1<p&&(g+=`
                  xC${$+1} = vec4(xTexelC${$}.zw, xTexelC${$+1}.zw);
                `)));$<p&&(g+=`
            wTexel = getW(r, ${$}, d1, q);
            dotProd += xC${$} * vec4(wTexel.xz, wTexel.xz);
          `,$+1<p&&(g+=`
              wTexel = getW(r, ${$+1}, d1, q);
              dotProd += xC${$+1} * vec4(wTexel.xz, wTexel.xz);
            `))}g+=`
    }
  `,g+=`
      }
    `;let y="",x="";s&&(r?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:a?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:y=`vec4 activation(vec4 x) {
          ${s}
        }`,x="result = activation(result);");const w=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${y}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${g}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${w}
        ${x}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jpe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a}=e,{strides:i,pad:o,dilations:l,dimRoundingMode:c}=s;let h=l;h==null&&(h=[1,1]),V(xs(i,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const p=os(r.shape,a.shape,i,h,o,c,!0);let f;ye().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?f=new MB(p):f=new LB(p);const g=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return n.runWebGLProgram(f,[r,a],"float32",g)}const Kpe={kernelName:yb,backendName:"webgl",kernelFunc:jpe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xpe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Ype{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,s=e.filterWidth,r=e.strideHeight,a=e.strideWidth,i=n-1-e.padInfo.top,o=s-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zpe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:a}=e,{strides:i,dilations:o,pad:l,dimRoundingMode:c,filterShape:h}=s,p=os(r.shape,h,i,o,l,c,!0),f=new Xpe(p);return n.runWebGLProgram(f,[r,a],"float32")}const Qpe={kernelName:tS,backendName:"webgl",kernelFunc:Zpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jpe(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:a}=e,{strides:i,dilations:o,pad:l,dimRoundingMode:c,inputShape:h}=s,p=os(h,a.shape,i,o,l,c,!0),f=new Ype(p);return n.runWebGLProgram(f,[r,a],"float32")}const efe={kernelName:nS,backendName:"webgl",kernelFunc:Jpe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tfe{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nfe(t){const{inputs:e,backend:n}=t,{x:s}=e,r=[...s.shape,...s.shape],a=$e(s.shape),i=Ue({inputs:{x:s},backend:n,attrs:{shape:[a]}}),o=new tfe(a),l=n.runWebGLProgram(o,[i],i.dtype),c=Ue({inputs:{x:l},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),c}const sfe={kernelName:sS,backendName:"webgl",kernelFunc:nfe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rfe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:n,inWidth:s,padInfo:r,strideHeight:a,strideWidth:i,filterHeight:o,filterWidth:l,dilationHeight:c,dilationWidth:h}=e,{top:p,left:f}=r;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${i});
      const ivec2 pads = ivec2(${p}, ${f});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${h};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function afe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a}=e,{strides:i,pad:o,dilations:l}=s,c=km(r.shape,a.shape,i,o,"NHWC",l);let h;const p=new rfe(c);h=n.runWebGLProgram(p,[r,a],"float32");const f=Ue({inputs:{x:h},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(h),f}const ife={kernelName:bb,backendName:"webgl",kernelFunc:afe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ofe(t){const{inputs:e,backend:n,attrs:s}=t,{equation:r}=s,a=e,{allDims:i,summedDims:o,idDims:l}=Q_(r,a.length);eC(i.length,l,a);const{path:c,steps:h}=tC(o,l),p=h.length;let f=null,g=i.length;const y=[];for(let x=0;x<p;++x){for(const w of h[x]){const{permutationIndices:v,expandDims:$}=J_(g,l[w]);let T;nC(v)?T=a[w]:(T=qs({inputs:{x:a[w]},backend:n,attrs:{perm:v}}),y.push(T));const C=T.shape.slice();for(let I=0;I<$.length;++I)C.splice($[I],0,1);Rt(T.shape,C)||(T=Ue({inputs:{x:T},backend:n,attrs:{shape:C}}),y.push(T)),f===null?f=T:(f=WC({inputs:{a:T,b:f},backend:n}),y.push(f))}x<p-1&&(c[x]>=0&&(f=jx({inputs:{x:f},backend:n,attrs:{axis:c[x]-(i.length-g),keepDims:!1}}),y.push(f)),g--)}for(const x of y)x!==f&&n.disposeIntermediateTensorInfo(x);return f}const lfe={kernelName:rS,backendName:"webgl",kernelFunc:ofe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ufe="return (x >= 0.0) ? x : (exp(x) - 1.0);",cfe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,dfe=Pt({opSnippet:ufe,packedOpSnippet:cfe}),hfe={kernelName:Gf,backendName:"webgl",kernelFunc:dfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pfe="return (b >= 0.0) ? a : a * (b + 1.0);",ffe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,mfe=t=>{const{inputs:e,backend:n}=t,{dy:s,y:r}=e,a=ye().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ph(ffe,s.shape,r.shape):new mc(pfe,s.shape,r.shape);return n.runWebGLProgram(a,[s,r],s.dtype)},gfe={kernelName:aS,backendName:"webgl",kernelFunc:mfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yfe=`
  return vec4(equal(a, b));
`,bfe="return float(a == b);",xfe=$s({opSnippet:bfe,packedOpSnippet:yfe,dtype:"bool",cpuKernelImpl:Zue}),wfe={kernelName:xb,backendName:"webgl",kernelFunc:xfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vfe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${H_};
  float a1 = ${q_};
  float a2 = ${j_};
  float a3 = ${K_};
  float a4 = ${X_};
  float a5 = ${Y_};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,$fe=Pt({opSnippet:vfe}),Sfe={kernelName:Hf,backendName:"webgl",kernelFunc:$fe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _fe=fh+`
  return exp(x);
`,Cfe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,BB=Pt({opSnippet:_fe,packedOpSnippet:Cfe,cpuKernelImpl:Que,dtype:"float32"}),Tfe={kernelName:qf,backendName:"webgl",kernelFunc:BB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g2(t){const{inputs:e,attrs:n,backend:s}=t,{dim:r}=n,{input:a}=e,i=a.shape.length,o=a.shape.slice();let l=r;return r<0&&(V(-(i+1)<=r,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+r+1),o.splice(l,0,1),Ue({inputs:{x:a},backend:s,attrs:{shape:o}})}const kfe={kernelName:wb,backendName:"webgl",kernelFunc:g2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GE="return exp(x) - 1.0;",Nfe=Pt({opSnippet:GE,packedOpSnippet:GE,cpuKernelImpl:Jue}),Ife={kernelName:jf,backendName:"webgl",kernelFunc:Nfe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HE{constructor(e,n,s){this.variableNames=["real","imag"];const r=n[1];this.outputShape=n;const a=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=s?`${r}.0`:"1.0";let o;if(e==="real")o="return real * expR - imag * expI;";else if(e==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${a};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PB(t,e,n){const s=n.texData.get(t.dataId),r=$e(t.shape),a=t.shape[t.shape.length-1],i=r/a,o=Ue({inputs:{x:t},backend:n,attrs:{shape:[i,a]}}),l=o.shape,c=new HE("real",l,e),h=new HE("imag",l,e),p=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],f=n.runWebGLProgram(c,p,"float32"),g=n.runWebGLProgram(h,p,"float32"),y=eu({inputs:{real:f,imag:g},backend:n});n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g);const x=Ue({inputs:{x:y},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(y),x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Efe(t){const{inputs:e,backend:n}=t,{input:s}=e;return PB(s,!1,n)}const Afe={kernelName:iS,backendName:"webgl",kernelFunc:Efe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rfe{constructor(e,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ym(t){const{backend:e,attrs:n}=t,{shape:s,value:r}=n;let{dtype:a}=n;if(a=a||Jd(r),a==="string"){const i=An(a,$e(s));return i.fill(r),e.makeTensorInfo(s,a,i)}else{const i=new Rfe(s,r),o=[[r]];return e.runWebGLProgram(i,[],a,o)}}const Dfe={kernelName:oS,backendName:"webgl",kernelFunc:Ym};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ofe{constructor(e){this.variableNames=["Image"],this.outputShape=[];const n=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zfe={kernelName:lS,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,s=e,r=new Ofe(n.shape);return s.runWebGLProgram(r,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qE="return floor(x);",Ffe=Pt({opSnippet:qE,packedOpSnippet:qE,cpuKernelImpl:ece}),Lfe={kernelName:Kf,backendName:"webgl",kernelFunc:Ffe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mfe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Bfe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Pfe=$s({opSnippet:Mfe,packedOpSnippet:Bfe,dtype:"int32"}),Vfe={kernelName:Xf,backendName:"webgl",kernelFunc:Pfe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ufe{constructor(e){this.variableNames=["A"];const n=Ks(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wfe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=Ks(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gfe={kernelName:B6,backendName:"webgl",kernelFunc:Hfe};let vd,_v=ye().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Hfe(t){const{inputs:e,backend:n,attrs:s}=t;let{pixels:r}=e;const{numChannels:a}=s,i=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[l,c]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height],h=[c,l],p=[c,l,a];if(o||i){const x=ye().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(vd==null||x!==_v)&&(_v=x,vd=document.createElement("canvas").getContext("2d",{willReadFrequently:_v})),vd.canvas.width=l,vd.canvas.height=c,vd.drawImage(r,0,0,l,c),r=vd.canvas}const f=n.makeTensorInfo(h,"int32");n.texData.get(f.dataId).usage=qr.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(f.dataId),r);const g=ye().getBool("WEBGL_PACK")?new Wfe(p):new Ufe(p),y=n.runWebGLProgram(g,[f],"int32");return n.disposeData(f.dataId),y}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qfe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a,bias:i,preluActivationWeights:o}=e,{strides:l,pad:c,dataFormat:h,dilations:p,dimRoundingMode:f,activation:g,leakyreluAlpha:y}=s,x=Ao(h),w=os(r.shape,a.shape,l,p,c,f,!1,x);let v;const $=[],T=i!=null,C=o!=null,I=g==="leakyrelu",A=()=>{const B=[r,a],z=(P,F)=>{if(F==="NCHW"&&P.shape.length===1&&P.shape[0]!==1){const K=Ue({inputs:{x:P},backend:n,attrs:{shape:[P.shape[0],1,1]}});return $.push(K),K}return P};if(T&&B.push(z(i,h)),C&&B.push(z(o,h)),I){const P=n.makeTensorInfo([],"float32",Gl(y,"float32"));B.push(P),$.push(P)}return B};if(w.filterHeight===1&&w.filterWidth===1&&w.dilationHeight===1&&w.dilationWidth===1&&w.strideHeight===1&&w.strideWidth===1&&(w.padInfo.type==="SAME"||w.padInfo.type==="VALID"))v=OB({x:r,filter:a,convInfo:w,backend:n,bias:i,activation:g,preluActivationWeights:o,leakyreluAlpha:y});else if(w.strideWidth<=2&&x==="channelsLast"&&ye().getBool("WEBGL_EXP_CONV")){const B=g?Sf(g,!0):null,z=new DB(w,T,B,C,I),P=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],F=A();v=n.runWebGLProgram(z,F,"float32",P)}else if(ye().getBool("WEBGL_CONV_IM2COL"))v=zB({x:r,filter:a,convInfo:w,backend:n,bias:i,activation:g,preluActivationWeights:o,leakyreluAlpha:y});else{const B=g?Sf(g,!1):null,z=new RB(w,T,B,C,I),P=A();v=n.runWebGLProgram(z,P,"float32")}const O=Ue({inputs:{x:v},backend:n,attrs:{shape:w.outShape}});return $.push(v),$.forEach(B=>n.disposeIntermediateTensorInfo(B)),O}const jfe={kernelName:b0,backendName:"webgl",kernelFunc:qfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kfe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a,bias:i,preluActivationWeights:o}=e,{strides:l,pad:c,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:g}=s,y=[];let x=h;x==null&&(x=[1,1]),V(xs(l,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${x}'`);const w=os(r.shape,a.shape,l,x,c,p,!0),v=ye().getBool("WEBGL_PACK_DEPTHWISECONV")&&w.strideWidth<=2&&w.outChannels/w.inChannels===1,$=f?Sf(f,v):null,T=[r,a],C=i!=null,I=o!=null,A=f==="leakyrelu";if(C&&T.push(i),I&&T.push(o),A){const P=n.makeTensorInfo([],"float32",Gl(g,"float32"));T.push(P),y.push(P)}let O;v?O=new MB(w,C,$,I,A):O=new LB(w,C,$,I,A);const B=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],z=n.runWebGLProgram(O,T,"float32",B);return y.forEach(P=>n.disposeIntermediateTensorInfo(P)),z}const Xfe={kernelName:x0,backendName:"webgl",kernelFunc:Kfe};class Yfe{constructor(e,n,s,r){this.sliceDim=e,this.strides=n,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const a=en(s.length);let i=`
    int index;`;for(let o=0;o<this.sliceDim;o++)i+=`
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;this.userCode=`
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zfe(t){const{inputs:e,backend:n}=t,{params:s,indices:r}=e,a=r.shape,i=a[a.length-1],o=$e(s.shape),[l,c,h,p]=O_(s,r),f=Ue({inputs:{x:r},backend:n,attrs:{shape:[c,i]}}),g=Ue({inputs:{x:s},backend:n,attrs:{shape:[$e(s.shape)/h,h]}});if(n.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const v=n.readSync(r.dataId),$=n.bufferSync(s),T=tce(v,$,s.dtype,c,i,h,p,s.shape,o);return n.makeTensorInfo(l,s.dtype,T.values)}const y=new Yfe(i,p,[c,h],s.shape),x=n.runWebGLProgram(y,[g,f],g.dtype),w=Ue({inputs:{x},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(x),w}const Qfe={kernelName:uS,backendName:"webgl",kernelFunc:Zfe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jfe{constructor(e,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const s=en(this.rank),r=eme(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function eme(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<t.length;r++)r===2?s.push("index"):s.push(`${n[r]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VB(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,indices:a}=e,{axis:i,batchDims:o}=s,l=St(i,r.shape)[0];if(ye().get("DEBUG")){const $=n.readSync(a.dataId),T=r.shape[l];for(let C=0;C<$.length;++C){const I=$[C];V(I<=T-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${T-1}]`)}}const c=rC(r,a,l,o),h=$e(a.shape),p=[],f=Ue({inputs:{x:r},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),g=Ue({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,h/c.batchSize]}});p.push(f),p.push(g);const y=[c.batchSize,c.outerSize,h/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([r,a])||r.dtype==="string"){const $=n.bufferSync(g),T=n.bufferSync(f),C=nce(T,$,y);return p.forEach(I=>n.disposeIntermediateTensorInfo(I)),n.makeTensorInfo(c.outputShape,C.dtype,C.values)}const x=new Jfe(f.shape,y),w=n.runWebGLProgram(x,[f,g],f.dtype);p.push(w);const v=Ue({inputs:{x:w},backend:n,attrs:{shape:c.outputShape}});return p.forEach($=>n.disposeIntermediateTensorInfo($)),v}const tme={kernelName:$b,backendName:"webgl",kernelFunc:VB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nme="return float(a > b);",sme=`
  return vec4(greaterThan(a, b));
`,rme=$s({opSnippet:nme,packedOpSnippet:sme,cpuKernelImpl:sce,dtype:"bool"}),ame={kernelName:Sb,backendName:"webgl",kernelFunc:rme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ime="return float(a >= b);",ome=`
  return vec4(greaterThanEqual(a, b));
`,lme=$s({opSnippet:ime,packedOpSnippet:ome,dtype:"bool",cpuKernelImpl:rce}),ume={kernelName:Yf,backendName:"webgl",kernelFunc:lme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cme(t){const{inputs:e,backend:n}=t,{input:s}=e;return PB(s,!0,n)}const dme={kernelName:cS,backendName:"webgl",kernelFunc:cme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hme="return float(!isnan(x) && !isinf(x));",pme=Pt({opSnippet:hme,dtype:"bool"}),fme={kernelName:Qf,backendName:"webgl",kernelFunc:pme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mme="return float(isinf(x));",gme=Pt({opSnippet:mme,dtype:"bool"}),yme={kernelName:Jf,backendName:"webgl",kernelFunc:gme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bme="return float(isnan(x));",xme=Pt({opSnippet:bme,dtype:"bool"}),wme={kernelName:em,backendName:"webgl",kernelFunc:xme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vme="return float(a < b);",$me=`
  return vec4(lessThan(a, b));
`,Sme=$s({opSnippet:vme,packedOpSnippet:$me,cpuKernelImpl:ace,dtype:"bool"}),_me={kernelName:Cb,backendName:"webgl",kernelFunc:Sme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cme="return float(a <= b);",Tme=`
  return vec4(lessThanEqual(a, b));
`,kme=$s({opSnippet:Cme,packedOpSnippet:Tme,cpuKernelImpl:ice,dtype:"bool"}),Nme={kernelName:Tb,backendName:"webgl",kernelFunc:kme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ime(t){const{backend:e,attrs:n}=t,{start:s,stop:r,num:a}=n,i=oce(s,r,a);return e.makeTensorInfo([i.length],"float32",i)}const Eme={kernelName:hS,backendName:"webgl",kernelFunc:Ime};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ame=fh+`
  return x < 0.0 ? 0./0. : log(x);
`,Rme=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Dme=Pt({opSnippet:Ame,packedOpSnippet:Rme,cpuKernelImpl:lce}),Ome={kernelName:tm,backendName:"webgl",kernelFunc:Dme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zme=fh+`
  return log(1.0 + x);
`,Fme=Pt({opSnippet:zme}),Lme={kernelName:nm,backendName:"webgl",kernelFunc:Fme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mme="return float(a >= 1.0 && b >= 1.0);",Bme=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Pme=$s({opSnippet:Mme,packedOpSnippet:Bme,dtype:"bool"}),Vme={kernelName:kb,backendName:"webgl",kernelFunc:Pme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ume="return float(!(x >= 1.0));",Wme=Pt({opSnippet:Ume}),Gme={kernelName:Nb,backendName:"webgl",kernelFunc:Wme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hme="return float(a >= 1.0 || b >= 1.0);",qme=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,jme=$s({opSnippet:Hme,packedOpSnippet:qme,dtype:"bool"}),Kme={kernelName:Ib,backendName:"webgl",kernelFunc:jme};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xme{constructor(e,n,s,r,a){this.variableNames=["x"],this.outputShape=[];const i=n,o=e[3]-1;this.outputShape=e;let l;const c=`float(${s}) + float(${r}) * sum`;a===.5?l=`inversesqrt(${c})`:a===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yme{constructor(e,n,s,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=n,o=e[3]-1;this.outputShape=e;let l;const c=`float(${s}) + float(${r}) * sum`;a===.5?l=`inversesqrt(${c})`:a===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zme=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{depthRadius:a,bias:i,alpha:o,beta:l}=s,c=ye().getBool("WEBGL_PACK_NORMALIZATION")?new Yme(r.shape,a,i,o,l):new Xme(r.shape,a,i,o,l);return n.runWebGLProgram(c,[r],r.dtype)},Qme={kernelName:Eb,backendName:"webgl",kernelFunc:Zme};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jme{constructor(e,n,s,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=n,this.bias=s,this.alpha=r,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${a})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ege=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r,y:a,dy:i}=e,{depthRadius:o,bias:l,alpha:c,beta:h}=s,p=new Jme(r.shape,o,l,c,h);return n.runWebGLProgram(p,[r,a,i],r.dtype)},tge={kernelName:pS,backendName:"webgl",kernelFunc:ege};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nge(t,e,n,s){const r=$e(e),i=$e(t.shape)/r,o=Ue({inputs:{x:t},attrs:{shape:[i,r]},backend:s}),l=Ec(o,t.dtype,"max",s),c=Ue({inputs:{x:l},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UB(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reductionIndices:a,keepDims:i}=s,o=r.shape.length,l=St(a,r.shape);let c=l;const h=wn(c,o),p=h!=null,f=n.shouldExecuteOnCPU([r]);let g=r;if(p){if(f){const T=n.texData.get(g.dataId).values,C=new Array(o);for(let O=0;O<C.length;O++)C[O]=r.shape[h[O]];const I=VC(T,r.shape,r.dtype,h,C);g=n.makeTensorInfo(C,r.dtype);const A=n.texData.get(g.dataId);A.values=I}else g=qx(r,h,n);c=Dn(c.length,o)}ws("max",c,o);const[y,x]=ls(g.shape,c);let w=y;i&&(w=Rn(y,l));let v;if(f){const T=n.texData.get(g.dataId).values,C=uce(T,$e(x),w,r.dtype);v=n.makeTensorInfo(w,r.dtype);const I=n.texData.get(v.dataId);I.values=C}else v=nge(g,x,w,n);return p&&n.disposeIntermediateTensorInfo(g),v}const sge={kernelName:Ab,backendName:"webgl",kernelFunc:UB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rge=UC+`
  return max(a, b);
`,age=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ic+`
  return result;
`,ige=$s({opSnippet:rge,packedOpSnippet:age,cpuKernelImpl:cce}),oge={kernelName:sm,backendName:"webgl",kernelFunc:ige};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lge(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;jm(r,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=s,c=1;V(xs(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const h=_a(r.shape,a,i,c,o,l);if(h.filterWidth===1&&h.filterHeight===1&&Rt(h.inShape,h.outShape))return Ir({inputs:{x:r},backend:n});const p=new _f(h,"max",!1);return n.runWebGLProgram(p,[r],r.dtype)}const uge={kernelName:Rb,backendName:"webgl",kernelFunc:lge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cge(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:a,strides:i,pad:o,dataFormat:l,dimRoundingMode:c}=s,h=[1,1,1],p=Eo(r.shape,a,i,h,o,c,l),f=new GC(p,"max",!1);return n.runWebGLProgram(f,[r],r.dtype)}const dge={kernelName:Db,backendName:"webgl",kernelFunc:cge};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hge{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,i=e.effectiveFilterWidth,o=a-1-e.padInfo.top,l=i-1-e.padInfo.left,c=a*i-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class pge{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideDepth,s=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,i=e.dilationHeight,o=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=l-1-e.padInfo.front,f=c-1-e.padInfo.top,g=h-1-e.padInfo.left,y=l*c*h-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${f}, ${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${y} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${h} +
                  wR * ${h} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fge(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:a}=e,i=a,{filterSize:o,strides:l,pad:c,dimRoundingMode:h}=s,p=[1,1,1],f=Eo(i.shape,o,l,p,c,h),g=new GC(f,"max",!0),y=n.runWebGLProgram(g,[i],i.dtype),x=new pge(f),w=n.runWebGLProgram(x,[r,y],i.dtype);return n.disposeIntermediateTensorInfo(y),w}const mge={kernelName:mS,backendName:"webgl",kernelFunc:fge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gge(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:a,output:i}=e,o=a;jm([a,i],"maxPoolGrad");const{filterSize:l,strides:c,pad:h,dimRoundingMode:p}=s,f=_a(o.shape,l,c,1,h,p),g=!0,y=new _f(f,"max",g),x=n.runWebGLProgram(y,[o],o.dtype),w=new hge(f),v=n.runWebGLProgram(w,[r,x],o.dtype);return n.disposeIntermediateTensorInfo(x),v}const yge={kernelName:fS,backendName:"webgl",kernelFunc:gge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bge(t,e,n,s){let r=new _f(n,"max",!1);const a=s.runWebGLProgram(r,[t],"float32");r=new _f(n,"max",!0,!0,e);const i=s.runWebGLProgram(r,[t],"float32");return[a,i]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xge={kernelName:gS,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{filterSize:r,strides:a,pad:i,includeBatchInIndex:o}=e,l=n;V(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const c=[1,1];V(xs(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const h=_a(s.shape,r,a,c,i),[p,f]=bge(s,o,h,l);return[p,f]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wge(t,e,n,s){const r=$e(e),i=$e(t.shape)/r,o=Ue({inputs:{x:t},attrs:{shape:[i,r]},backend:s}),l=Ec(o,"float32","mean",s),c=Ue({inputs:{x:l},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vge={kernelName:Ob,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{keepDims:r,axis:a}=e,i=n,o=s.shape.length,l=St(a,s.shape);let c=l;const h=wn(c,o),p=h!=null,f=i.shouldExecuteOnCPU([s]),g=[];let y=s;if(p){if(f){const C=i.texData.get(y.dataId).values,I=new Array(o);for(let B=0;B<I.length;B++)I[B]=s.shape[h[B]];const A=VC(C,s.shape,s.dtype,h,I);y=i.makeTensorInfo(I,s.dtype);const O=i.texData.get(y.dataId);O.values=A}else y=qx(s,h,i);g.push(y),c=Dn(c.length,o)}ws("sum",c,o);const[x,w]=ls(y.shape,c);let v=x;r&&(v=Rn(x,l));const $=wge(y,w,v,i);for(const T of g)i.disposeIntermediateTensorInfo(T);return $}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ge(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s,o=r.shape.length,l=St(a,r.shape);let c=l;const h=wn(c,o);let p=r;h!=null&&(p=qs({inputs:{x:r},backend:n,attrs:{perm:h}}),c=Dn(c.length,r.shape.length)),ws("min",c,o);const[f,g]=ls(p.shape,c),y=$e(g),x=Ue({inputs:{x:p},backend:n,attrs:{shape:[-1,y]}}),w=Ec(x,x.dtype,"min",n);let v;if(i){const $=Rn(f,l);v=Ue({inputs:{x:w},backend:n,attrs:{shape:$}})}else v=Ue({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),h!=null&&n.disposeIntermediateTensorInfo(p),v}const Sge={kernelName:zb,backendName:"webgl",kernelFunc:$ge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ge=UC+`
  return min(a, b);
`,Cge=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ic+`
  return result;
`,Tge=$s({opSnippet:_ge,packedOpSnippet:Cge,cpuKernelImpl:dce}),kge={kernelName:rm,backendName:"webgl",kernelFunc:Tge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nge{constructor(e,n,s){this.variableNames=["x"],this.outputShape=n.map((h,p)=>h[0]+e[p]+h[1]);const r=e.length,a=en(r),i=n.map(h=>h[0]).join(","),o=n.map((h,p)=>h[0]+e[p]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),c=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${i};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${i});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ige{constructor(e,n,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((y,x)=>y[0]+e[x]+y[1]);const r=e.length,a=en(r),i=n.map(y=>y[0]).join(","),o=n.map((y,x)=>y[0]+e[x]).join(","),l=Gs("rc",r),c=Gs("source",r),h=`${l[r-1]} < ${this.outputShape[r-1]}`,p=r===1?"source":`vec2(${c.slice(-2).join()})`,f=s==="reflect"?0:1;let g="";if(r===1){const y=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${f};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${f};
        }
        source -= start;
      `;g=`
        ${a} rc = outputLoc;
        ${y}
        result[0] = getChannel(getX(${c.join()}), ${p});
        ${l[r-1]} += 1;
        if(${h}) {
          ${y}
          result[1] = getChannel(getX(${c.join()}), ${p});
        }
      `}else{const y=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${f}) +
                gte * ((end - 1) * 2 - source + ${f});
        source -= start;
      `;g=`
        ${a} rc = outputLoc;
        ${y}
        result[0] = getChannel(getX(${c.join()}), ${p});
        ${l[r-1]} += 1;
        if(${h}) {
          ${y}
          result[1] = getChannel(getX(${c.join()}), ${p});
        }
        rc = outputLoc;
        ${l[r-2]} += 1;
        if(${l[r-2]} < ${this.outputShape[r-2]}) {
          ${y}
          result[2] = getChannel(getX(${c.join()}), ${p});
          ${l[r-1]} += 1;
          if(${h}) {
            ${y}
            result[3] = getChannel(getX(${c.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${i});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ege=({inputs:t,backend:e,attrs:n})=>{const{x:s}=t,{paddings:r,mode:a}=n,i=ye().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ige(s.shape,r,a):new Nge(s.shape,r,a);return e.runWebGLProgram(i,[s],s.dtype)},Age={kernelName:Fb,backendName:"webgl",kernelFunc:Ege};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rge=`if (b == 0.0) return NAN;
  return mod(a, b);`,Dge=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Ic+`
  return result;
`,Oge=$s({opSnippet:Rge,packedOpSnippet:Dge}),zge={kernelName:am,backendName:"webgl",kernelFunc:Oge};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fge{constructor(e,n,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lge=`
if (a == b) {
  return 1.0;
};
return a / b;`,Mge=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,WB=$s({opSnippet:Lge,packedOpSnippet:Mge,checkOutOfBounds:!0}),Bge={kernelName:Wf,backendName:"webgl",kernelFunc:WB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jE="return a - b;",GB=$s({opSnippet:jE,packedOpSnippet:jE,supportsComplex:!0,cpuKernelImpl:Rce}),Pge={kernelName:vm,backendName:"webgl",kernelFunc:GB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HB(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{dim:a}=s,i=St([a],r.shape),o=UB({inputs:{x:r},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=Rn(o.shape,i),c=Ue({inputs:{x:o},backend:n,attrs:{shape:l}}),h=GB({inputs:{a:r,b:c},backend:n}),p=BB({inputs:{x:h},backend:n}),f=jx({inputs:{x:p},backend:n,attrs:{axis:i,keepDims:!1}}),g=Ue({inputs:{x:f},backend:n,attrs:{shape:l}}),y=WB({inputs:{a:p,b:g},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),y}const Vge={kernelName:ex,backendName:"webgl",kernelFunc:HB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uge(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{numSamples:a,seed:i,normalized:o}=s,l=o?r:HB({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),c=l.shape[0],h=l.shape[1],p=new Fge(c,h,a),f=[[i]],g=n.runWebGLProgram(p,[l],"int32",f);return o||n.disposeIntermediateTensorInfo(l),g}const Wge={kernelName:yS,backendName:"webgl",kernelFunc:Uge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gge=Ta+`
  return -x;
`,Hge=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function qge(t){const{inputs:e,backend:n}=t,{x:s}=e;if(n.shouldExecuteOnCPU([s])){const a=n.texData.get(s.dataId),[i,o]=pce(a.values,s.shape,s.dtype);return n.makeTensorInfo(o,s.dtype,i)}let r;return ye().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new kl(s.shape,Hge):r=new Si(s.shape,Gge),n.runWebGLProgram(r,[s],s.dtype)}const jge={kernelName:Lb,backendName:"webgl",kernelFunc:qge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kge=k_;function Xge(t){Gr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=s,c=n.readSync(r.dataId),h=n.readSync(a.dataId),{selectedIndices:p}=Kge(c,h,i,o,l);return n.makeTensorInfo([p.length],"int32",new Int32Array(p))}const Yge={kernelName:bS,backendName:"webgl",kernelFunc:Xge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zge=N_;function Qge(t){Gr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:c}=s,h=n.readSync(r.dataId),p=n.readSync(a.dataId),{selectedIndices:f,validOutputs:g}=Zge(h,p,i,o,l,c);return[n.makeTensorInfo([f.length],"int32",new Int32Array(f)),n.makeTensorInfo([],"int32",new Int32Array([g]))]}const Jge={kernelName:xS,backendName:"webgl",kernelFunc:Qge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eye=I_;function tye(t){Gr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:c}=s,h=n.readSync(r.dataId),p=n.readSync(a.dataId),f=i,g=o,y=l,x=c,{selectedIndices:w,selectedScores:v}=eye(h,p,f,g,y,x);return[n.makeTensorInfo([w.length],"int32",new Int32Array(w)),n.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const nye={kernelName:wS,backendName:"webgl",kernelFunc:tye};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sye{constructor(e,n,s,r){this.variableNames=["indices"],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rye=t=>{const{inputs:e,backend:n,attrs:s}=t,{indices:r}=e,{dtype:a,depth:i,onValue:o,offValue:l}=s,c=$e(r.shape),h=new sye(c,i,o,l),p=Ue({inputs:{x:r},backend:n,attrs:{shape:[c]}}),f=n.runWebGLProgram(h,[p],a);n.disposeIntermediateTensorInfo(p);const g=[...r.shape,i],y=Ue({inputs:{x:f},backend:n,attrs:{shape:g}});return n.disposeIntermediateTensorInfo(f),y},aye={kernelName:Pb,backendName:"webgl",kernelFunc:rye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G0(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="complex64"){const r=Xm({inputs:{input:s},backend:n}),a=G0({inputs:{x:r},backend:n}),i=Kx({inputs:{input:s},backend:n}),o=G0({inputs:{x:i},backend:n}),l=eu({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return Ym({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:n})}const iye={kernelName:rx,backendName:"webgl",kernelFunc:G0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qB(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=Xm({inputs:{input:s},backend:n}),a=qB({inputs:{x:r},backend:n}),i=Kx({inputs:{input:s},backend:n}),o=G0({inputs:{x:i},backend:n}),l=eu({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return Ym({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:n})}const oye={kernelName:Bb,backendName:"webgl",kernelFunc:qB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lye(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s;if(e.length===1)return g2({inputs:{input:e[0]},backend:n,attrs:{dim:r}});const a=e[0].shape,i=e[0].dtype;e.forEach(h=>{Er(a,h.shape,"All tensors passed to stack must have matching shapes"),V(i===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=e.map(h=>{const p=g2({inputs:{input:h},backend:n,attrs:{dim:r}});return o.push(p),p}),c=AB({inputs:l,backend:n,attrs:{axis:r}});return o.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}const uye={kernelName:Vb,backendName:"webgl",kernelFunc:lye};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cye{constructor(e,n,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((c,h)=>c[0]+e[h]+c[1]);const r=e.length,a=en(r),i=n.map(c=>c[0]).join(","),o=n.map((c,h)=>c[0]+e[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${i};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${i});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dye{constructor(e,n,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((x,w)=>x[0]+e[w]+x[1]);const r=e.length,a=en(r),i=n.map(x=>x[0]).join(","),o=n.map((x,w)=>x[0]+e[w]).join(","),l=Gs("rc",r),c=Gs("source",r),h=`${l[r-1]} < ${this.outputShape[r-1]}`,p=r===1?"source":`vec2(${c.slice(-2).join()})`,f=[`${a} rc = outputLoc;`,`${l[r-1]} += 1;
       if(${h}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${l[r-2]} += 1;
       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${l[r-1]} += 1;
         if(${h}) {`],g=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let y="";for(let x=0,w=r===1?2:4;x<w;x++)y+=`
        ${f[x]}
        if (${g}) {
          result[${x}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${x}] = getChannel(getX(${c.join()}), ${p});
        }
      `;y+=r===1?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${i});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${y}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jB=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:a,constantValue:i}=s;if($e(r.shape)===0){const c=a.map((h,p)=>h[0]+r.shape[p]+h[1]);return Ym({backend:n,attrs:{shape:c,value:i,dtype:r.dtype}})}const o=ye().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dye(r.shape,a,i):new cye(r.shape,a,i),l=[[i]];return n.runWebGLProgram(o,[r],r.dtype,l)},hye={kernelName:Ub,backendName:"webgl",kernelFunc:jB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pye=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,fye=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Ic+`
  return result;
`,mye=$s({opSnippet:pye,packedOpSnippet:fye}),gye={kernelName:om,backendName:"webgl",kernelFunc:mye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yye(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s,o=r.shape.length,l=[],c=St(a,r.shape);let h=c;const p=wn(h,o);let f=r;p!=null&&(f=qs({inputs:{x:r},backend:n,attrs:{perm:p}}),h=Dn(h.length,o),l.push(f)),ws("prod",h,o);let g;if(n.shouldExecuteOnCPU([f])){const y=n.texData.get(f.dataId).values,{outVals:x,outShape:w,outDtype:v}=mce(f.shape,f.dtype,y,h);g=n.makeTensorInfo(w,v,x)}else{const[y,x]=ls(f.shape,h),w=$e(x),v=Ue({inputs:{x:f},backend:n,attrs:{shape:[-1,w]}}),$=HS(r.dtype),T=Ec(v,$,"prod",n);g=Ue({inputs:{x:T},backend:n,attrs:{shape:y}}),l.push(v),l.push(T)}if(i){l.push(g);const y=Rn(g.shape,c);g=Ue({inputs:{x:g},backend:n,attrs:{shape:y}})}return l.forEach(y=>n.disposeIntermediateTensorInfo(y)),g}const bye={kernelName:Gb,backendName:"webgl",kernelFunc:yye};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xye(t){const{inputs:e,backend:n,attrs:s}=t,{paramsNestedSplits:r,paramsDenseValues:a,indices:i}=e,{outputRaggedRank:o}=s,l=r.map(v=>n.readSync(v.dataId)),c=r.map(v=>v.shape),h=n.readSync(a.dataId),p=n.readSync(i.dataId),[f,g,y]=gce(l,c,h,a.shape,a.dtype,p,i.shape,o),x=f.map(v=>n.makeTensorInfo([v.length],"int32",v)),w=n.makeTensorInfo(y,a.dtype,g);return x.concat([w])}const wye={kernelName:vS,backendName:"webgl",kernelFunc:xye};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vye(t){const{inputs:e,backend:n}=t,{starts:s,limits:r,deltas:a}=e,i=n.readSync(s.dataId),o=n.readSync(r.dataId),l=n.readSync(a.dataId),[c,h]=yce(i,s.shape,s.dtype,o,r.shape,l,a.shape),p=n.makeTensorInfo([c.length],"int32",c),f=n.makeTensorInfo([h.length],s.dtype,h);return[p,f]}const $ye={kernelName:$S,backendName:"webgl",kernelFunc:vye};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sye(t){const{inputs:e,backend:n,attrs:s}=t,{shape:r,values:a,defaultValue:i,rowPartitionTensors:o}=e,{rowPartitionTypes:l}=s,c=n.readSync(r.dataId),h=n.readSync(a.dataId),p=n.readSync(i.dataId),f=o.map(w=>n.readSync(w.dataId)),g=o.map(w=>w.shape),[y,x]=bce(c,r.shape,h,a.shape,a.dtype,p,i.shape,f,g,l);return n.makeTensorInfo(y,a.dtype,x)}const _ye={kernelName:SS,backendName:"webgl",kernelFunc:Sye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KB=t=>{const{backend:e,attrs:n}=t,{start:s,stop:r,step:a,dtype:i}=n,o=xce(s,r,a,i);return e.makeTensorInfo([o.length],i,o)},Cye={kernelName:_S,backendName:"webgl",kernelFunc:KB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tye="return 1.0 / x;",kye=Pt({opSnippet:Tye}),Nye={kernelName:lm,backendName:"webgl",kernelFunc:kye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iye=Ta+`
  return (x < 0.0) ? 0.0 : x;
`,Eye=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Aye=Pt({opSnippet:Iye,packedOpSnippet:Eye}),Rye={kernelName:um,backendName:"webgl",kernelFunc:Aye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dye=Ta+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Oye=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,zye=Pt({opSnippet:Dye,packedOpSnippet:Oye}),Fye={kernelName:cm,backendName:"webgl",kernelFunc:zye};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lye{constructor(e,n,s,r,a){this.variableNames=["A"],this.outputShape=[];const[i,o,l,c]=e;this.outputShape=[i,n,s,c];const h=[r&&n>1?o-1:o,r&&s>1?l-1:l],p=[r&&n>1?n-1:n,r&&s>1?s-1:s];let f;a?f="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${h[0]/p[0]},
          ${h[1]/p[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mye{constructor(e,n,s,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,l,c]=e;this.outputShape=[i,n,s,c];const h=[r&&n>1?o-1:o,r&&s>1?l-1:l],p=[r&&n>1?n-1:n,r&&s>1?s-1:s];let f;a?f="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${h[0]/p[0]},
          ${h[1]/p[1]},
          ${h[1]/p[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bye(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:a,halfPixelCenters:i,size:o}=s,[l,c]=o,h=ye().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Mye(r.shape,l,c,a,i):new Lye(r.shape,l,c,a,i);return n.runWebGLProgram(h,[r],"float32")}const Pye={kernelName:jb,backendName:"webgl",kernelFunc:Bye};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vye{constructor(e,n,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,r,a]=n,[,i,o]=e,l=[s&&i>1?r-1:r,s&&o>1?a-1:a],c=[s&&i>1?i-1:i,s&&o>1?o-1:o],h=l[0]/c[0],p=l[1]/c[1],f=1/h,g=1/p,y=Math.ceil(f)*2+2,x=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${h});
        const float widthScale = float(${p});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${g});

        const int winHeight = int(${y});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uye(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:a}=e,{alignCorners:i}=s,o=new Vye(a.shape,r.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}const Wye={kernelName:kS,backendName:"webgl",kernelFunc:Uye};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gye{constructor(e,n,s,r,a){this.variableNames=["A"],this.outputShape=[];const[i,o,l,c]=e;this.outputShape=[i,n,s,c];const h=[r&&n>1?o-1:o,r&&s>1?l-1:l],p=[r&&n>1?n-1:n,r&&s>1?s-1:s],f=r?"0.5":"0.0";let g;a?g="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":g="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${h[0]/p[0]},
          ${h[1]/p[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hye{constructor(e,n,s,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,l,c]=e;this.outputShape=[i,n,s,c];const h=[r&&n>1?o-1:o,r&&s>1?l-1:l],p=[r&&n>1?n-1:n,r&&s>1?s-1:s],f=r?"0.5":"0.0";let g;a?g="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":g="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${h[0]/p[0]},
          ${h[1]/p[1]},
          ${h[1]/p[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qye(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:a,halfPixelCenters:i,size:o}=s,[l,c]=o,h=ye().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Hye(r.shape,l,c,a,i):new Gye(r.shape,l,c,a,i);return n.runWebGLProgram(h,[r],r.dtype)}const jye={kernelName:qb,backendName:"webgl",kernelFunc:qye};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kye{constructor(e,n,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,r,a]=n,[,i,o]=e,l=[s&&i>1?r-1:r,s&&o>1?a-1:a],c=[s&&i>1?i-1:i,s&&o>1?o-1:o],h=l[0]/c[0],p=l[1]/c[1],f=1/h,g=1/p,y=Math.ceil(f)*2+2,x=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${h});
        const float widthScale = float(${p});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${g});

        const int winHeight = int(${y});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xye(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:a}=e,{alignCorners:i}=s,o=new Kye(a.shape,r.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}const Yye={kernelName:TS,backendName:"webgl",kernelFunc:Xye};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zye{constructor(e,n){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=o=>n.indexOf(o)!==-1&&e[o]!==1?`${e[o]} - coords[${o}] - 1`:`coords[${o}]`,a=e.map((o,l)=>r(l)).join(","),i=en(s);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qye{constructor(e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=Gs("rc",s),a=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,i=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,o=en(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(r.slice())};
          if(${a}){
            result.g = ${c(r.slice())};
          }
          if(${i}) {
            result.b = ${h(r.slice())};
            if(${a}) {
              result.a = ${p(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(y){return f(y)}function c(y){return y[s-1]="("+y[s-1]+" + 1)",f(y)}function h(y){return y[s-2]="("+y[s-2]+" + 1)",f(y)}function p(y){return y[s-1]="("+y[s-1]+" + 1)",y[s-2]="("+y[s-2]+" + 1)",f(y)}function f(y){const x=e.map(($,T)=>g(T,y)),w=x.join(","),v=x.slice(-2).join(",");return`getChannel(getX(${w}), vec2(${v}))`}function g(y,x){return n.indexOf(y)!==-1&&e[y]!==1?`${e[y]} - ${x[y]} - 1`:`${x[y]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jye(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dims:a}=s,i=r.shape.length,o=St(a,r.shape);if(i===0)return Ir({inputs:{x:r},backend:n});const l=ye().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Qye(r.shape,o):new Zye(r.shape,o);return n.runWebGLProgram(l,[r],r.dtype)}const e0e={kernelName:Kb,backendName:"webgl",kernelFunc:Jye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class t0e{constructor(e,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let a="";typeof n=="number"?a=`float outputValue = ${n.toFixed(2)};`:a=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n0e={kernelName:GS,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,{radians:r,fillValue:a,center:i}=e,o=n,l=new t0e(s.shape,a),[c,h]=U_(i,s.shape[1],s.shape[2]),p=[[c,h,Math.sin(r),Math.cos(r)]];return o.runWebGLProgram(l,[s],s.dtype,p)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s0e=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,r0e=Pt({opSnippet:s0e}),a0e={kernelName:dm,backendName:"webgl",kernelFunc:r0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i0e="return inversesqrt(x);",o0e=Pt({opSnippet:i0e,cpuKernelImpl:wce}),l0e={kernelName:hm,backendName:"webgl",kernelFunc:o0e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HC{constructor(e,n,s,r,a,i,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const c=en(a.length),h=en(i.length);let p="";s===1?p="i":s===2&&(p="i, j");const f=`getIndices(${p})`;let g="";r===1?g="i":r===2&&(g="i, coords[1]");const y=`getUpdates(${g})`;let x="";l&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,v=n>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${a});

        void main() {
          ${h} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${f});
              flattenedIndex += index * ${v};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${y};
              found = true;
            }
          }
          setOutput(mix(${w}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class u0e{constructor(e,n,s,r,a,i,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const c=en(a.length),h=en(i.length);let p="";s===1?p="i":s===2&&(p="i, j");const f=`getIndices(${p})`;let g="";r===1?g="i":r===2&&(g="i, coords[1]");const y=`getUpdates(${g})`;let x="";l&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,v=n>1?"strides[j]":"strides",$=n>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${a});

        void main() {
          ${h} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${n}; j+=2) {
              ivec4 index = round(${f});
              flattenedIndex += index.xz * ${v};
              if (j + 1 < ${n}) {
                flattenedIndex += index.yw * ${$};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${y};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${w}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c0e(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r,updates:a}=e,{shape:i}=s,{sliceRank:o,numUpdates:l,sliceSize:c,strides:h,outputSize:p}=_c(a,r,i),f=[p/c,c];if(p===0)return n.makeTensorInfo(i,r.dtype);const g=Ue({inputs:{x:r},backend:n,attrs:{shape:[l,o]}}),y=Ue({inputs:{x:a},backend:n,attrs:{shape:[l,c]}}),x=n.makeTensorInfo([],"float32",new Float32Array([0]));let w;ye().getBool("WEBGL_PACK")?w=new u0e(l,o,g.shape.length,y.shape.length,h,f):w=new HC(l,o,g.shape.length,y.shape.length,h,f);const v=n.runWebGLProgram(w,[y,g,x],y.dtype),$=Ue({inputs:{x:v},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(x),$}const d0e={kernelName:NS,backendName:"webgl",kernelFunc:c0e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class h0e{constructor(e,n,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const a="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,o=ye().getNumber("WEBGL_VERSION")===2?a:i,l=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p0e(t){const{inputs:e,backend:n,attrs:s}=t,{sortedSequence:r,values:a}=e,{side:i}=s,o=new h0e(r.shape[0],r.shape[1],a.shape[1],i),l=[[r.shape[1]]];return n.runWebGLProgram(o,[r,a],"int32",l)}const f0e={kernelName:ES,backendName:"webgl",kernelFunc:p0e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m0e{constructor(e,n,s){this.variableNames=["c","a","b"],this.outputShape=n;let r,a;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)a="resRC",r="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let h=0;h<n.length;h++)c.push(`${o[h]}`),h<e&&l.push(`${o[h]}`);r=l.join(),a=c.join()}const i=en(s);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g0e(t){const{inputs:e,backend:n}=t,{condition:s,t:r,e:a}=e,i=new m0e(s.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(i,[s,r,a],_r(r.dtype,a.dtype))}const y0e={kernelName:Xb,backendName:"webgl",kernelFunc:g0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b0e=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${Ex};
  float scale = ${Ax};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,x0e=Pt({opSnippet:b0e}),w0e={kernelName:pm,backendName:"webgl",kernelFunc:x0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v0e=fh+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,$0e=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,S0e=Pt({opSnippet:v0e,packedOpSnippet:$0e,cpuKernelImpl:$ce}),_0e={kernelName:ym,backendName:"webgl",kernelFunc:S0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C0e=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,T0e=Pt({opSnippet:C0e}),k0e={kernelName:gm,backendName:"webgl",kernelFunc:T0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N0e=fh+`
  return sin(x);
`,I0e=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Ic}
  return result;
`,E0e=Pt({opSnippet:N0e,packedOpSnippet:I0e}),A0e={kernelName:fm,backendName:"webgl",kernelFunc:E0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R0e=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,D0e=Pt({opSnippet:R0e}),O0e={kernelName:mm,backendName:"webgl",kernelFunc:D0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z0e=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,F0e=Pt({opSnippet:z0e}),L0e={kernelName:bm,backendName:"webgl",kernelFunc:F0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M0e=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:a,paddings:i}=s;V(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((v,$)=>v*$),l=[[0,0]];l.push(...i);for(let v=1+a.length;v<r.shape.length;++v)l.push([0,0]);const c=[],h=jB({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),p=Om(h.shape,a,o,!1),f=zm(p.length,a.length,!1),g=Fm(h.shape,a,o,!1),y=Ue({inputs:{x:h},backend:n,attrs:{shape:p}}),x=qs({inputs:{x:y},backend:n,attrs:{perm:f}}),w=Ue({inputs:{x},backend:n,attrs:{shape:g}});return c.push(h),c.push(y),c.push(x),c.forEach(v=>n.disposeIntermediateTensorInfo(v)),w},B0e={kernelName:Qb,backendName:"webgl",kernelFunc:M0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P0e(t){const{inputs:e,backend:n}=t,{indices:s,values:r,denseShape:a,defaultValue:i}=e;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const o=n.readSync(s.dataId),l=n.readSync(r.dataId),c=n.readSync(a.dataId),h=n.readSync(i.dataId)[0],[p,f,g,y,x]=_ce(o,s.shape,s.dtype,l,r.dtype,c,h);return[n.makeTensorInfo(f,s.dtype,p),n.makeTensorInfo([f[0]],r.dtype,g),n.makeTensorInfo([y.length],"bool",new Uint8Array(y.map(w=>Number(w)))),n.makeTensorInfo([x.length],s.dtype,new Int32Array(x))]}const V0e={kernelName:AS,backendName:"webgl",kernelFunc:P0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U0e(t){const{inputs:e,backend:n}=t,{inputIndices:s,inputShape:r,newShape:a}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.readSync(r.dataId)),o=n.readSync(s.dataId),l=Array.from(n.readSync(a.dataId)),[c,h,p]=Cce(o,s.shape,s.dtype,i,l);return[n.makeTensorInfo(h,s.dtype,c),n.makeTensorInfo([p.length],a.dtype,new Int32Array(p))]}const W0e={kernelName:RS,backendName:"webgl",kernelFunc:U0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G0e(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:a}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);const i=n.readSync(s.dataId),o=n.readSync(r.dataId),l=n.readSync(a.dataId),[c,h]=bB(i,s.shape,s.dtype,o,l,!0);return n.makeTensorInfo(h,s.dtype,c)}const H0e={kernelName:DS,backendName:"webgl",kernelFunc:G0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q0e(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:a}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);const i=n.readSync(s.dataId),o=n.readSync(r.dataId),l=n.readSync(a.dataId),[c,h]=bB(i,s.shape,s.dtype,o,l);return n.makeTensorInfo(h,s.dtype,c)}const j0e={kernelName:OS,backendName:"webgl",kernelFunc:q0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K0e(t){const{inputs:e,backend:n,attrs:s}=t,{sparseIndices:r,sparseValues:a,defaultValue:i}=e,{outputShape:o}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:p,outputSize:f}=_c(a,r,o),g=!1;if(a.dtype==="string"){const v=n.bufferSync(r),$=n.bufferSync(a),T=Rl(n.readSync(i.dataId)[0]),C=vce(v,$,o,f,h,c,l,p,T,g);return n.makeTensorInfo(o,C.dtype,C.values)}const y=new HC(c,l,r.shape.length,a.shape.length,p,[f,1],g),x=n.runWebGLProgram(y,[a,r,i],a.dtype),w=Ue({inputs:{x},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(x),w}const X0e={kernelName:zS,backendName:"webgl",kernelFunc:K0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y0e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{numOrSizeSplits:a,axis:i}=s,o=St(i,r.shape)[0],l=sC(r,a,o),c=r.shape.length,h=new Array(c).fill(0),p=r.shape.slice();return l.map(f=>{const g=[...p];g[o]=f;const y=mh({inputs:{x:r},backend:n,attrs:{begin:h,size:g}});return h[o]+=f,y})}const Z0e={kernelName:Jb,backendName:"webgl",kernelFunc:Y0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KE="return sqrt(x);",Q0e=Pt({opSnippet:KE,packedOpSnippet:KE,cpuKernelImpl:Tce}),J0e={kernelName:xm,backendName:"webgl",kernelFunc:Q0e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ebe="return x * x;",tbe=Pt({opSnippet:ebe}),nbe={kernelName:FS,backendName:"webgl",kernelFunc:tbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XE="return (a - b) * (a - b);",sbe=$s({opSnippet:XE,packedOpSnippet:XE}),rbe={kernelName:wm,backendName:"webgl",kernelFunc:sbe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function abe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const a=n.readSync(r.dataId),i=No(a),o=kce(i,"string",s);return n.makeTensorInfo(r.shape,"string",o)}const ibe={kernelName:tx,backendName:"webgl",kernelFunc:abe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function obe({inputs:t,attrs:e,backend:n}){const{x:s}=t,r=Ta+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,a=new Si(s.shape,r);return n.runWebGLProgram(a,[s],s.dtype)}const lbe={kernelName:Cm,backendName:"webgl",kernelFunc:obe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ube{constructor(e,n,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,a=en(s.length),i=en(s.length);let o="";if(r===1)o="coords * strides + begin";else{let l=0;o=s.map((c,h)=>(l++,s.length===1?`coords * strides[${h}] + begin[${h}]`:`coords[${l-1}] * strides[${h}] + begin[${h}]`)).join(",")}this.userCode=`
      ${a} begin = ${a}(${e});
      ${a} strides = ${a}(${n});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cbe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:a,end:i,strides:o,beginMask:l,endMask:c,ellipsisMask:h,newAxisMask:p,shrinkAxisMask:f}=s,{finalShapeSparse:g,finalShape:y,isIdentity:x,sliceDim0:w,isSimpleSlice:v,begin:$,end:T,strides:C}=B_(r.shape,a,i,o,l,c,h,p,f);let I;if(x)I=Ue({inputs:{x:r},backend:n,attrs:{shape:y}});else if(w||v){V(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const O=F_($,T,C),B=mh({inputs:{x:r},backend:n,attrs:{begin:$,size:O}});I=Ue({inputs:{x:B},backend:n,attrs:{shape:y}}),n.disposeIntermediateTensorInfo(B)}else if(n.shouldExecuteOnCPU([r])){const B=n.readSync(r.dataId),z=xt(r.shape,r.dtype,B),P=Nce(g,z,C,$);I=n.makeTensorInfo(y,r.dtype,P.values)}else{const B=new ube($,C,g);I=n.runWebGLProgram(B,[r],r.dtype)}const A=Ue({inputs:{x:I},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(I),A}const dbe={kernelName:LS,backendName:"webgl",kernelFunc:cbe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hbe(t){const{inputs:e,backend:n,attrs:s}=t,{separator:r,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:c}=s,{data:h,dataSplits:p}=e,f=n.readSync(h.dataId),g=n.readSync(p.dataId),[y,x]=Ice(f,g,r,a,i,o,l,c);return[n.makeTensorInfo([y.length],"string",y),n.makeTensorInfo(p.shape,"int32",x)]}const pbe={kernelName:MS,backendName:"webgl",kernelFunc:hbe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fbe(t){const{inputs:e,backend:n,attrs:s}=t,{skipEmpty:r}=s,{input:a,delimiter:i}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(a.dataId),l=n.readSync(i.dataId)[0],[c,h,p]=Ece(o,l,r),f=h.length;return[n.makeTensorInfo([f,2],"int32",c),n.makeTensorInfo([f],"string",h),n.makeTensorInfo([2],"int32",new Int32Array(p))]}const mbe={kernelName:BS,backendName:"webgl",kernelFunc:fbe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gbe(t){const{inputs:e,backend:n,attrs:s}=t,{numBuckets:r}=s,{input:a}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(a.dataId),o=Ace(i,r);return n.makeTensorInfo(a.shape,"int32",o)}const ybe={kernelName:PS,backendName:"webgl",kernelFunc:gbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bbe="return tan(x);",xbe=Pt({opSnippet:bbe}),wbe={kernelName:$m,backendName:"webgl",kernelFunc:xbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vbe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,$be=Pt({opSnippet:vbe}),Sbe={kernelName:Sm,backendName:"webgl",kernelFunc:$be};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _be(t){const{inputs:e,backend:n,attrs:s}=t,{tensor:r,indices:a,updates:i}=e,{sliceRank:o,numUpdates:l,sliceSize:c,strides:h,outputSize:p}=_c(i,a,r.shape),f=[p/c,c];if(p===0)return n.makeTensorInfo(r.shape,a.dtype);const g=Ue({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),y=Ue({inputs:{x:i},backend:n,attrs:{shape:[l,c]}}),x=Ue({inputs:{x:r},backend:n,attrs:{shape:f}}),w=new HC(l,o,g.shape.length,y.shape.length,h,f,!1,!0),v=n.runWebGLProgram(w,[y,g,x],x.dtype),$=Ue({inputs:{x:v},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(v),$}const Cbe={kernelName:IS,backendName:"webgl",kernelFunc:_be};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tbe{constructor(e,n){this.variableNames=["A"];const s=new Array(e.length);for(let i=0;i<s.length;i++)s[i]=e[i]*n[i];this.outputShape=s,this.rank=s.length;const r=en(this.rank),a=kbe(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `}}function kbe(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<t.length;r++)s.push(`imod(${n[r]}, ${t[r]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XB(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reps:a}=s;if(r.dtype==="string"||r.shape.length>5){const l=n.readSync(r.dataId),c=r.dtype==="string"?l.map(f=>Rl(f)):l,h=xt(r.shape,r.dtype,c),p=Dce(h,a);return n.makeTensorInfo(p.shape,p.dtype,p.values)}const i=new Tbe(r.shape,a);return n.runWebGLProgram(i,[r],r.dtype)}const Nbe={kernelName:_m,backendName:"webgl",kernelFunc:XB};class Ibe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class Ebe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mu(t,e){e!==null&&t.disposeIntermediateTensorInfo(e)}function YE(t){let e=1;for(;e<t;)e*=2;return e}function Abe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{k:a,sorted:i}=s,o=ye().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=ye().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=r.shape,h=c[c.length-1];if(n.shouldExecuteOnCPU([r])||h<o||a>l){const P=n.readSync(r.dataId),[F,K]=Oce(P,c,r.dtype,a,i);return[n.makeTensorInfo(F.shape,F.dtype,F.values),n.makeTensorInfo(K.shape,K.dtype,K.values)]}if(a===0)return c[c.length-1]=0,[n.makeTensorInfo(c,r.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(h===1)return[r,Ym({attrs:{shape:c,dtype:"int32",value:0},backend:n})];const p=n.texData.get(r.dataId),f=p!==null&&p.isPacked,g=f?n.unpackTensor(r):r,x=$e(c)/h,w=Ue({inputs:{x:g},attrs:{shape:[x,h]},backend:n});f&&Mu(n,g);const v=YE(a),$=YE(h);let T=null;const C=()=>T===null?[w,w]:[w,T],I=(P,F,K)=>{const X=C(),te=new Ibe(K),q=[[h],[T===null?1:0],[Number.NEGATIVE_INFINITY],[P],[F]],oe=T;T=n.runWebGLProgram(te,X,"int32",q),Mu(n,oe)};for(let P=1;P<v;P*=2){const F=P*2;for(let K=P;K>=1;K/=2)I(F,K,[x,$])}for(let P=$;P>v;P/=2){const F=C(),K=new Ebe([x,P/2]),te=[[h],[T===null?1:0],[v]],Q=T;T=n.runWebGLProgram(K,F,"int32",te),Mu(n,Q);const q=v/2,oe=q*2;for(let se=q;se>=1;se/=2)I(oe,se,T.shape)}let A=T;T=mh({inputs:{x:T},backend:n,attrs:{begin:0,size:[x,a]}}),Mu(n,A);let O=VB({inputs:{x:w,indices:T},backend:n,attrs:{axis:1,batchDims:1}});Mu(n,w);const B=c.slice(0,-1);B.push(a),A=T,T=Ue({inputs:{x:T},attrs:{shape:B},backend:n}),Mu(n,A);const z=O;return O=Ue({inputs:{x:O},attrs:{shape:B},backend:n}),Mu(n,z),[O,T]}const Rbe={kernelName:VS,backendName:"webgl",kernelFunc:Abe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dbe{constructor(e,n,s,r,a,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const o=s==="nearest"?1:2;let l;switch(r){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${e}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Obe(t){const{inputs:e,backend:n,attrs:s}=t,{image:r,transforms:a}=e,{interpolation:i,fillMode:o,fillValue:l,outputShape:c}=s,[h,p,f,g]=r.shape,[y,x]=c??[p,f],w=[h,y,x,g],v=new Dbe(p,f,i,o,l,w);return n.runWebGLProgram(v,[r,a],"float32")}const zbe={kernelName:US,backendName:"webgl",kernelFunc:Obe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fbe(t){const{inputs:e,attrs:n,backend:s}=t,{axis:r}=n,{x:a}=e;jm(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=s.readSync(a.dataId),{outputValues:o,outputShape:l,indices:c}=zce(i,r,a.shape,a.dtype);return[s.makeTensorInfo(l,a.dtype,o),s.makeTensorInfo([c.length],"int32",c)]}const Lbe={kernelName:WS,backendName:"webgl",kernelFunc:Fbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mbe(t){const{inputs:e,backend:n,attrs:s}=t,{value:r}=e;let{axis:a}=s;a<0&&(a+=r.shape.length);const i=r,o=i.shape.length,l=r.shape[a],c=new Array(o-1);let h=0;for(let x=0;x<o;x++)x!==a&&(c[h++]=i.shape[x]);const p=[],f=new Array(o).fill(0),g=i.shape.slice();g[a]=1;const y=new Array(l);for(let x=0;x<y.length;x++){f[a]=x;const w=mh({inputs:{x:i},backend:n,attrs:{begin:f,size:g}}),v=Ue({inputs:{x:w},backend:n,attrs:{shape:c}});y[x]=v,p.push(w)}return p.forEach(x=>n.disposeIntermediateTensorInfo(x)),y}const Bbe={kernelName:nx,backendName:"webgl",kernelFunc:Mbe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pbe{constructor(e,n){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,a=e.inSize,i=e.numSegments,o=i*Math.ceil(a/s);this.outputShape=[r,o];const l="0.0",c="sumValue",h=Math.floor(s/4)*4,p=s%4,f=`
        sumValue += dot(values, segFilter);
    `;let g="";a%s>0&&(g=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let y="";a%s>0&&(y=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${g}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${y}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${f}
        }

        int inIdx = inOffset + ${h};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${f}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${f}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${f}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vbe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,segmentIds:a}=e,{numSegments:i}=s,o=r.shape.length,l=[];let c=0;const h=wn([c],o);let p=r;h!=null&&(p=qs({inputs:{x:r},backend:n,attrs:{perm:h}}),l.push(p),c=Dn(1,o)[0]);const f=kF(p.shape,c,i),g=$e([p.shape[c]]),y=Ue({inputs:{x:p},backend:n,attrs:{shape:[-1,g]}});l.push(y);const x=HS(r.dtype),w=(C,I,A,O,B)=>{const z=C.shape[0],P=C.shape[1],F=TF(P,B),K={windowSize:F,inSize:P,batchSize:z,numSegments:B},X=new Pbe(K,I),te=n.compileAndRun(X,[C,A],O);if(l.push(te),te.shape[1]===B)return te;const Q=KB({backend:n,attrs:{start:0,stop:B,step:1,dtype:"float32"}}),q=XB({inputs:{x:Q},backend:n,attrs:{reps:[P/F]}});return l.push(Q),l.push(q),w(te,I,q,O,B)},v=w(y,"unsortedSegmentSum",a,x,i),$=Ue({inputs:{x:v},backend:n,attrs:{shape:f}});let T=$;if(h!=null){l.push($);const C=Kl(h);T=qs({inputs:{x:T},backend:n,attrs:{perm:C}})}return l.forEach(C=>n.disposeIntermediateTensorInfo(C)),T}const Ube={kernelName:sx,backendName:"webgl",kernelFunc:Vbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wbe=[Tde,Nde,Ade,Ode,Fde,Bde,Vde,Wde,jde,Xde,Qde,the,rhe,lhe,dhe,phe,mhe,xhe,vhe,She,khe,Ohe,Fhe,Phe,Uhe,Khe,Yhe,epe,ude,spe,lpe,hpe,bpe,vpe,Spe,Cpe,kpe,Ape,Ope,Lpe,Bpe,Vpe,Wpe,qpe,Kpe,Qpe,efe,sfe,ife,lfe,hfe,gfe,wfe,Sfe,Tfe,kfe,Ife,Afe,Dfe,zfe,Lfe,Vfe,Gfe,jfe,Xfe,Qfe,tme,ame,ume,lde,dme,ipe,fme,yme,wme,dde,_me,Nme,Eme,Ome,Lme,Vme,Gme,Kme,Qme,tge,sge,oge,uge,dge,mge,yge,xge,vge,Sge,kge,Age,zge,Wge,fde,jge,Yge,Jge,nye,Ghe,aye,oye,uye,hye,gye,pde,bye,wye,$ye,_ye,Cye,Hhe,Bge,Nye,Rye,Fye,gde,Pye,Wye,jye,Yye,e0e,n0e,a0e,l0e,d0e,f0e,y0e,w0e,_0e,k0e,A0e,O0e,Rhe,Vge,L0e,B0e,V0e,W0e,H0e,j0e,X0e,Z0e,J0e,nbe,rbe,ibe,lbe,dbe,pbe,mbe,ybe,Pge,Sde,wbe,Sbe,Cbe,Nbe,Rbe,zbe,_de,Lbe,Bbe,Ube,iye];for(const t of Wbe)JD(t);async function Gbe(){try{await pq();const t=await _te("https://dmitriywolf.github.io/test-onnnx/models/model.json");return{net:t,inputShape:t.inputs[0].shape}}catch(t){console.error("[error.load.model]",t)}}const Hbe=t=>new Promise(e=>setTimeout(e,t)),qbe=()=>performance.memory?+(performance.memory.usedJSHeapSize/1024/1024).toFixed(2):null;function jbe(){const t=Ce.useRef(null),e=Ce.useRef(!1),n=Ce.useRef(null),[s,r]=Ce.useState(0),[a,i]=Ce.useState(0),[o,l]=Ce.useState(0);return Ce.useEffect(()=>{e.current=!1;async function c(){if(!(e.current||!t.current)){try{Ua().startScope();const p=ir(t.current.inputShape),f=performance.now(),g=await t.current.net.execute(p),x=+(performance.now()-f).toFixed(2),w=qbe();$t([g]),r(v=>v+1),i(x),w!==null&&l(w)}catch(p){console.error("Inference error:",p)}await Hbe(200),n.current=requestAnimationFrame(c)}}async function h(){t.current=await Gbe(),!e.current&&t.current&&c()}return h(),()=>{e.current=!0,n.current&&cancelAnimationFrame(n.current),t.current.net.dispose(),t.current=null}},[]),Kt.jsxs("div",{children:[Kt.jsx("p",{children:"TENSOR MODEL TEST"}),Kt.jsxs("p",{children:["Inference #: ",s]}),Kt.jsxs("p",{children:["Last Inference Time: ",a," ms"]}),Kt.jsxs("p",{children:["Used JS Heap: ",o," MB"]})]})}/*!
 * ONNX Runtime Web v1.21.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var qC=Object.defineProperty,Kbe=Object.getOwnPropertyDescriptor,Xbe=Object.getOwnPropertyNames,Ybe=Object.prototype.hasOwnProperty,Zbe=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,n)=>(typeof require<"u"?require:e)[n]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')}),ze=(t,e)=>()=>(t&&(e=t(t=0)),e),Zm=(t,e)=>{for(var n in e)qC(t,n,{get:e[n],enumerable:!0})},Qbe=(t,e,n,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of Xbe(e))!Ybe.call(t,r)&&r!==n&&qC(t,r,{get:()=>e[r],enumerable:!(s=Kbe(e,r))||s.enumerable});return t},H0=t=>Qbe(qC({},"__esModule",{value:!0}),t),Vp,vl,Nd,ZE,YB,ZB=ze(()=>{Vp=new Map,vl=[],Nd=(t,e,n)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let s=Vp.get(t);if(s===void 0)Vp.set(t,{backend:e,priority:n});else{if(s.priority>n)return;if(s.priority===n&&s.backend!==e)throw new Error(`cannot register backend "${t}" using priority ${n}`)}if(n>=0){let r=vl.indexOf(t);r!==-1&&vl.splice(r,1);for(let a=0;a<vl.length;a++)if(Vp.get(vl[a]).priority<=n){vl.splice(a,0,t);return}vl.push(t)}return}throw new TypeError("not a valid backend")},ZE=async t=>{let e=Vp.get(t);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{let n=!!e.initPromise;try{return n||(e.initPromise=e.backend.init(t)),await e.initPromise,e.initialized=!0,e.backend}catch(s){return n||(e.error=`${s}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},YB=async t=>{let e=t.executionProviders||[],n=e.map(l=>typeof l=="string"?l:l.name),s=n.length===0?vl:n,r,a=[],i=new Set;for(let l of s){let c=await ZE(l);typeof c=="string"?a.push({name:l,err:c}):(r||(r=c),r===c&&i.add(l))}if(!r)throw new Error(`no available backend found. ERR: ${a.map(l=>`[${l.name}] ${l.err}`).join(", ")}`);for(let{name:l,err:c}of a)n.includes(l)&&console.warn(`removing requested execution provider "${l}" from session options because it is not available: ${c}`);let o=e.filter(l=>i.has(typeof l=="string"?l:l.name));return[r,new Proxy(t,{get:(l,c)=>c==="executionProviders"?o:Reflect.get(l,c)})]}}),Jbe=ze(()=>{ZB()}),QB,exe=ze(()=>{QB="1.21.0"}),Cv,pa,JB=ze(()=>{exe(),Cv="warning",pa={wasm:{},webgl:{},webgpu:{},versions:{common:QB},set logLevel(t){if(t!==void 0){if(typeof t!="string"||["verbose","info","warning","error","fatal"].indexOf(t)===-1)throw new Error(`Unsupported logging level: ${t}`);Cv=t}},get logLevel(){return Cv}},Object.defineProperty(pa,"logLevel",{enumerable:!0})}),hn,txe=ze(()=>{JB(),hn=pa}),eP,tP,nxe=ze(()=>{eP=(t,e)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=t.dims[3],n.height=t.dims[2];let s=n.getContext("2d");if(s!=null){let r,a;(e==null?void 0:e.tensorLayout)!==void 0&&e.tensorLayout==="NHWC"?(r=t.dims[2],a=t.dims[3]):(r=t.dims[3],a=t.dims[2]);let i=(e==null?void 0:e.format)!==void 0?e.format:"RGB",o=e==null?void 0:e.norm,l,c;o===void 0||o.mean===void 0?l=[255,255,255,255]:typeof o.mean=="number"?l=[o.mean,o.mean,o.mean,o.mean]:(l=[o.mean[0],o.mean[1],o.mean[2],0],o.mean[3]!==void 0&&(l[3]=o.mean[3])),o===void 0||o.bias===void 0?c=[0,0,0,0]:typeof o.bias=="number"?c=[o.bias,o.bias,o.bias,o.bias]:(c=[o.bias[0],o.bias[1],o.bias[2],0],o.bias[3]!==void 0&&(c[3]=o.bias[3]));let h=a*r,p=0,f=h,g=h*2,y=-1;i==="RGBA"?(p=0,f=h,g=h*2,y=h*3):i==="RGB"?(p=0,f=h,g=h*2):i==="RBG"&&(p=0,g=h,f=h*2);for(let x=0;x<a;x++)for(let w=0;w<r;w++){let v=(t.data[p++]-c[0])*l[0],$=(t.data[f++]-c[1])*l[1],T=(t.data[g++]-c[2])*l[2],C=y===-1?255:(t.data[y++]-c[3])*l[3];s.fillStyle="rgba("+v+","+$+","+T+","+C+")",s.fillRect(w,x,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},tP=(t,e)=>{let n=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),s;if(n!=null){let r,a,i;(e==null?void 0:e.tensorLayout)!==void 0&&e.tensorLayout==="NHWC"?(r=t.dims[2],a=t.dims[1],i=t.dims[3]):(r=t.dims[3],a=t.dims[2],i=t.dims[1]);let o=e!==void 0&&e.format!==void 0?e.format:"RGB",l=e==null?void 0:e.norm,c,h;l===void 0||l.mean===void 0?c=[255,255,255,255]:typeof l.mean=="number"?c=[l.mean,l.mean,l.mean,l.mean]:(c=[l.mean[0],l.mean[1],l.mean[2],255],l.mean[3]!==void 0&&(c[3]=l.mean[3])),l===void 0||l.bias===void 0?h=[0,0,0,0]:typeof l.bias=="number"?h=[l.bias,l.bias,l.bias,l.bias]:(h=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(h[3]=l.bias[3]));let p=a*r;if(e!==void 0&&(e.format!==void 0&&i===4&&e.format!=="RGBA"||i===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let f=4,g=0,y=1,x=2,w=3,v=0,$=p,T=p*2,C=-1;o==="RGBA"?(v=0,$=p,T=p*2,C=p*3):o==="RGB"?(v=0,$=p,T=p*2):o==="RBG"&&(v=0,T=p,$=p*2),s=n.createImageData(r,a);for(let I=0;I<a*r;g+=f,y+=f,x+=f,w+=f,I++)s.data[g]=(t.data[v++]-h[0])*c[0],s.data[y]=(t.data[$++]-h[1])*c[1],s.data[x]=(t.data[T++]-h[2])*c[2],s.data[w]=C===-1?255:(t.data[C++]-h[3])*c[3]}else throw new Error("Can not access image data");return s}}),Py,nP,sP,rP,aP,iP,sxe=ze(()=>{jC(),Py=(t,e)=>{if(t===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:n,width:s}=e,r=e.norm??{mean:255,bias:0},a,i;typeof r.mean=="number"?a=[r.mean,r.mean,r.mean,r.mean]:a=[r.mean[0],r.mean[1],r.mean[2],r.mean[3]??255],typeof r.bias=="number"?i=[r.bias,r.bias,r.bias,r.bias]:i=[r.bias[0],r.bias[1],r.bias[2],r.bias[3]??0];let o=e.format!==void 0?e.format:"RGBA",l=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",c=n*s,h=l==="RGBA"?new Float32Array(c*4):new Float32Array(c*3),p=4,f=0,g=1,y=2,x=3,w=0,v=c,$=c*2,T=-1;o==="RGB"&&(p=3,f=0,g=1,y=2,x=-1),l==="RGBA"?T=c*3:l==="RBG"?(w=0,$=c,v=c*2):l==="BGR"&&($=0,v=c,w=c*2);for(let C=0;C<c;C++,f+=p,y+=p,g+=p,x+=p)h[w++]=(t[f]+i[0])/a[0],h[v++]=(t[g]+i[1])/a[1],h[$++]=(t[y]+i[2])/a[2],T!==-1&&x!==-1&&(h[T++]=(t[x]+i[3])/a[3]);return l==="RGBA"?new Wr("float32",h,[1,4,n,s]):new Wr("float32",h,[1,3,n,s])},nP=async(t,e)=>{let n=typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement,s=typeof ImageData<"u"&&t instanceof ImageData,r=typeof ImageBitmap<"u"&&t instanceof ImageBitmap,a=typeof t=="string",i,o=e??{},l=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},c=h=>typeof HTMLCanvasElement<"u"&&h instanceof HTMLCanvasElement||h instanceof OffscreenCanvas?h.getContext("2d"):null;if(n){let h=l();h.width=t.width,h.height=t.height;let p=c(h);if(p!=null){let f=t.height,g=t.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(f=e.resizedHeight,g=e.resizedWidth),e!==void 0){if(o=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");o.tensorFormat="RGBA",o.height=f,o.width=g}else o.tensorFormat="RGBA",o.height=f,o.width=g;p.drawImage(t,0,0),i=p.getImageData(0,0,g,f).data}else throw new Error("Can not access image data")}else if(s){let h,p;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(h=e.resizedHeight,p=e.resizedWidth):(h=t.height,p=t.width),e!==void 0&&(o=e),o.format="RGBA",o.height=h,o.width=p,e!==void 0){let f=l();f.width=p,f.height=h;let g=c(f);if(g!=null)g.putImageData(t,0,0),i=g.getImageData(0,0,p,h).data;else throw new Error("Can not access image data")}else i=t.data}else if(r){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let h=l();h.width=t.width,h.height=t.height;let p=c(h);if(p!=null){let f=t.height,g=t.width;return p.drawImage(t,0,0,g,f),i=p.getImageData(0,0,g,f).data,o.height=f,o.width=g,Py(i,o)}else throw new Error("Can not access image data")}else{if(a)return new Promise((h,p)=>{let f=l(),g=c(f);if(!t||!g)return p();let y=new Image;y.crossOrigin="Anonymous",y.src=t,y.onload=()=>{f.width=y.width,f.height=y.height,g.drawImage(y,0,0,f.width,f.height);let x=g.getImageData(0,0,f.width,f.height);o.height=f.height,o.width=f.width,h(Py(x.data,o))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(i!==void 0)return Py(i,o);throw new Error("Input data provided is not supported - aborted tensor creation")},sP=(t,e)=>{let{width:n,height:s,download:r,dispose:a}=e,i=[1,s,n,4];return new Wr({location:"texture",type:"float32",texture:t,dims:i,download:r,dispose:a})},rP=(t,e)=>{let{dataType:n,dims:s,download:r,dispose:a}=e;return new Wr({location:"gpu-buffer",type:n??"float32",gpuBuffer:t,dims:s,download:r,dispose:a})},aP=(t,e)=>{let{dataType:n,dims:s,download:r,dispose:a}=e;return new Wr({location:"ml-tensor",type:n??"float32",mlTensor:t,dims:s,download:r,dispose:a})},iP=(t,e,n)=>new Wr({location:"cpu-pinned",type:t,data:e,dims:n??[e.length]})}),Ku,nf,Tv,oP,rxe=ze(()=>{Ku=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),nf=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Tv=!1,oP=()=>{if(!Tv){Tv=!0;let t=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,n=globalThis.Float16Array,s=typeof n<"u"&&n.from;t&&(Ku.set("int64",BigInt64Array),nf.set(BigInt64Array,"int64")),e&&(Ku.set("uint64",BigUint64Array),nf.set(BigUint64Array,"uint64")),s?(Ku.set("float16",n),nf.set(n,"float16")):Ku.set("float16",Uint16Array)}}}),lP,uP,axe=ze(()=>{jC(),lP=t=>{let e=1;for(let n=0;n<t.length;n++){let s=t[n];if(typeof s!="number"||!Number.isSafeInteger(s))throw new TypeError(`dims[${n}] must be an integer, got: ${s}`);if(s<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${s}`);e*=s}return e},uP=(t,e)=>{switch(t.location){case"cpu":return new Wr(t.type,t.data,e);case"cpu-pinned":return new Wr({location:"cpu-pinned",data:t.data,type:t.type,dims:e});case"texture":return new Wr({location:"texture",texture:t.texture,type:t.type,dims:e});case"gpu-buffer":return new Wr({location:"gpu-buffer",gpuBuffer:t.gpuBuffer,type:t.type,dims:e});case"ml-tensor":return new Wr({location:"ml-tensor",mlTensor:t.mlTensor,type:t.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${t.location} is not supported`)}}}),Wr,jC=ze(()=>{nxe(),sxe(),rxe(),axe(),Wr=class{constructor(t,e,n){oP();let s,r;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,s=t.type,r=t.dims,t.location){case"cpu-pinned":{let i=Ku.get(s);if(!i)throw new TypeError(`unsupported type "${s}" to create tensor from pinned buffer`);if(!(t.data instanceof i))throw new TypeError(`buffer should be of type ${i.name}`);this.cpuData=t.data;break}case"texture":{if(s!=="float32")throw new TypeError(`unsupported type "${s}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint8"&&s!=="bool"&&s!=="uint4"&&s!=="int4")throw new TypeError(`unsupported type "${s}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}case"ml-tensor":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint64"&&s!=="int8"&&s!=="uint8"&&s!=="bool"&&s!=="uint4"&&s!=="int4")throw new TypeError(`unsupported type "${s}" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let i,o;if(typeof t=="string")if(s=t,o=n,t==="string"){if(!Array.isArray(e))throw new TypeError("A string tensor's data must be a string array.");i=e}else{let l=Ku.get(t);if(l===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(e)){if(t==="float16"&&l===Uint16Array||t==="uint4"||t==="int4")throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${l.name} as data.`);t==="uint64"||t==="int64"?i=l.from(e,BigInt):i=l.from(e)}else if(e instanceof l)i=e;else if(e instanceof Uint8ClampedArray)if(t==="uint8")i=Uint8Array.from(e);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(t==="float16"&&e instanceof Uint16Array&&l!==Uint16Array)i=new globalThis.Float16Array(e.buffer,e.byteOffset,e.length);else throw new TypeError(`A ${s} tensor's data must be type of ${l}`)}else if(o=e,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let l=typeof t[0];if(l==="string")s="string",i=t;else if(l==="boolean")s="bool",i=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${l}.`)}else if(t instanceof Uint8ClampedArray)s="uint8",i=Uint8Array.from(t);else{let l=nf.get(t.constructor);if(l===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);s=l,i=t}if(o===void 0)o=[i.length];else if(!Array.isArray(o))throw new TypeError("A tensor's dims must be a number array");r=o,this.cpuData=i,this.dataLocation="cpu"}let a=lP(r);if(this.cpuData&&a!==this.cpuData.length&&!((s==="uint4"||s==="int4")&&Math.ceil(a/2)===this.cpuData.length))throw new Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`);this.type=s,this.dims=r,this.size=a}static async fromImage(t,e){return nP(t,e)}static fromTexture(t,e){return sP(t,e)}static fromGpuBuffer(t,e){return rP(t,e)}static fromMLTensor(t,e){return aP(t,e)}static fromPinnedBuffer(t,e,n){return iP(t,e,n)}toDataURL(t){return eP(this,t)}toImageData(t){return tP(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let e=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=e,t&&this.disposer&&(this.disposer(),this.disposer=void 0),e}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return uP(this,t)}}}),Hr,cP=ze(()=>{jC(),Hr=Wr}),q0,kv,Di,ja,dP=ze(()=>{JB(),q0=(t,e)=>{(typeof pa.trace>"u"?!pa.wasm.trace:!pa.trace)||console.timeStamp(`${t}::ORT::${e}`)},kv=(t,e)=>{var r;let n=((r=new Error().stack)==null?void 0:r.split(/\r\n|\r|\n/g))||[],s=!1;for(let a=0;a<n.length;a++){if(s&&!n[a].includes("TRACE_FUNC")){let i=`FUNC_${t}::${n[a].trim().split(" ")[1]}`;e&&(i+=`::${e}`),q0("CPU",i);return}n[a].includes("TRACE_FUNC")&&(s=!0)}},Di=t=>{(typeof pa.trace>"u"?!pa.wasm.trace:!pa.trace)||kv("BEGIN",t)},ja=t=>{(typeof pa.trace>"u"?!pa.wasm.trace:!pa.trace)||kv("END",t)}}),hP,ixe=ze(()=>{ZB(),cP(),dP(),hP=class pP{constructor(e){this.handler=e}async run(e,n,s){Di();let r={},a={};if(typeof e!="object"||e===null||e instanceof Hr||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof Hr)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");i=!1;for(let c of n){if(typeof c!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(c)===-1)throw new RangeError(`'fetches' contains invalid output name: ${c}.`);r[c]=null}if(typeof s=="object"&&s!==null)a=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else{let c=!1,h=Object.getOwnPropertyNames(n);for(let p of this.outputNames)if(h.indexOf(p)!==-1){let f=n[p];(f===null||f instanceof Hr)&&(c=!0,i=!1,r[p]=f)}if(c){if(typeof s=="object"&&s!==null)a=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else a=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let c of this.inputNames)if(typeof e[c]>"u")throw new Error(`input '${c}' is missing in 'feeds'.`);if(i)for(let c of this.outputNames)r[c]=null;let o=await this.handler.run(e,r,a),l={};for(let c in o)if(Object.hasOwnProperty.call(o,c)){let h=o[c];h instanceof Hr?l[c]=h:l[c]=new Hr(h.type,h.data,h.dims)}return ja(),l}async release(){return this.handler.dispose()}static async create(e,n,s,r){Di();let a,i={};if(typeof e=="string"){if(a=e,typeof n=="object"&&n!==null)i=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(a=e,typeof n=="object"&&n!==null)i=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let h=e,p=0,f=e.byteLength;if(typeof n=="object"&&n!==null)i=n;else if(typeof n=="number"){if(p=n,!Number.isSafeInteger(p))throw new RangeError("'byteOffset' must be an integer.");if(p<0||p>=h.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${h.byteLength}).`);if(f=e.byteLength-p,typeof s=="number"){if(f=s,!Number.isSafeInteger(f))throw new RangeError("'byteLength' must be an integer.");if(f<=0||p+f>h.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${h.byteLength-p}].`);if(typeof r=="object"&&r!==null)i=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(typeof s<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");a=new Uint8Array(h,p,f)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[o,l]=await YB(i),c=await o.createInferenceSessionHandler(a,l);return ja(),new pP(c)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),Xx,oxe=ze(()=>{ixe(),Xx=hP}),lxe=ze(()=>{}),uxe=ze(()=>{}),cxe=ze(()=>{}),dxe=ze(()=>{}),hxe={};Zm(hxe,{InferenceSession:()=>Xx,TRACE:()=>q0,TRACE_FUNC_BEGIN:()=>Di,TRACE_FUNC_END:()=>ja,Tensor:()=>Hr,env:()=>hn,registerBackend:()=>Nd});var ei=ze(()=>{Jbe(),txe(),oxe(),cP(),lxe(),uxe(),dP(),cxe(),dxe()}),KC=ze(()=>{}),fP={};Zm(fP,{default:()=>mP});var Nv,Iv,mP,pxe=ze(()=>{var t;bW(),Ac(),XC(),Nv="ort-wasm-proxy-worker",Iv=((t=globalThis.self)==null?void 0:t.name)===Nv,Iv&&(self.onmessage=e=>{let{type:n,in:s}=e.data;try{switch(n){case"init-wasm":YC(s.wasm).then(()=>{fT(s).then(()=>{postMessage({type:n})},r=>{postMessage({type:n,err:r})})},r=>{postMessage({type:n,err:r})});break;case"init-ep":{let{epName:r,env:a}=s;mT(a,r).then(()=>{postMessage({type:n})},i=>{postMessage({type:n,err:i})});break}case"copy-from":{let{buffer:r}=s,a=Q0(r);postMessage({type:n,out:a});break}case"create":{let{model:r,options:a}=s;gT(r,a).then(i=>{postMessage({type:n,out:i})},i=>{postMessage({type:n,err:i})});break}case"release":yT(s),postMessage({type:n});break;case"run":{let{sessionId:r,inputIndices:a,inputs:i,outputIndices:o,options:l}=s;bT(r,a,i,o,new Array(o.length).fill(null),l).then(c=>{c.some(h=>h[3]!=="cpu")?postMessage({type:n,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:n,out:c},wT([...i,...c]))},c=>{postMessage({type:n,err:c})});break}case"end-profiling":xT(s),postMessage({type:n});break;default:}}catch(r){postMessage({type:n,err:r})}}),mP=Iv?null:e=>new Worker(e??Ur,{type:"module",name:Nv})}),gP={};Zm(gP,{default:()=>yP});var Ev,Av,yP,QE,fxe=ze(()=>{var t,e;Av=(Ev=import.meta.url,async function(n={}){var to;var s,r,a=n,i=new Promise((S,k)=>{s=S,r=k}),o=typeof window=="object",l=typeof WorkerGlobalScope<"u",c=l&&((to=self.name)==null?void 0:to.startsWith("em-pthread"));a.mountExternalData=(S,k)=>{S.startsWith("./")&&(S=S.substring(2)),(a.Bd||(a.Bd=new Map)).set(S,k)},a.unmountExternalData=()=>{delete a.Bd};var h=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor;let p=()=>{let S=(E,R,L)=>(...j)=>{let re=Fr,ge=R==null?void 0:R();j=E(...j);let Se=R==null?void 0:R();return ge!==Se&&(E=Se,L(ge),R=L=null),Fr!=re?new Promise((Re,Le)=>{lu={resolve:Re,reject:Le}}):j},k=E=>async(...R)=>{var L;try{if(a.Cd)throw Error("Session already started");let j=a.Cd={be:R[0],errors:[]},re=await E(...R);if(a.Cd!==j)throw Error("Session mismatch");(L=a.Dd)==null||L.flush();let ge=j.errors;if(0<ge.length){let Se=await Promise.all(ge);if(Se=Se.filter(Re=>Re),0<Se.length)throw Error(Se.join(`
`))}return re}finally{a.Cd=null}};a._OrtCreateSession=S(a._OrtCreateSession,()=>a._OrtCreateSession,E=>a._OrtCreateSession=E),a._OrtRun=k(S(a._OrtRun,()=>a._OrtRun,E=>a._OrtRun=E)),a._OrtRunWithBinding=k(S(a._OrtRunWithBinding,()=>a._OrtRunWithBinding,E=>a._OrtRunWithBinding=E)),a._OrtBindInput=S(a._OrtBindInput,()=>a._OrtBindInput,E=>a._OrtBindInput=E),p=void 0};a.jsepInit=(S,k)=>{if(p==null||p(),S==="webgpu"){[a.Dd,a.Rd,a.Vd,a.Hd,a.Ud,a.hc,a.Wd,a.Zd,a.Sd,a.Td,a.Xd]=k;let E=a.Dd;a.jsepRegisterBuffer=(R,L,j,re)=>E.registerBuffer(R,L,j,re),a.jsepGetBuffer=R=>E.getBuffer(R),a.jsepCreateDownloader=(R,L,j)=>E.createDownloader(R,L,j),a.jsepOnCreateSession=R=>{E.onCreateSession(R)},a.jsepOnReleaseSession=R=>{E.onReleaseSession(R)},a.jsepOnRunStart=R=>E.onRunStart(R),a.$d=(R,L)=>{E.upload(R,L)}}else if(S==="webnn"){[a.Dd,a.Yd,a.Id,a.jsepEnsureTensor,a.Jd,a.jsepDownloadTensor]=k,a.jsepReleaseTensorId=a.Id,a.jsepUploadTensor=a.Jd;let E=a.Dd;a.jsepOnRunStart=R=>E.onRunStart(R),a.jsepOnRunEnd=E.onRunEnd.bind(E),a.jsepRegisterMLContext=(R,L)=>{E.registerMLContext(R,L)},a.jsepOnReleaseSession=R=>{E.onReleaseSession(R)},a.jsepCreateMLTensorDownloader=(R,L)=>E.createMLTensorDownloader(R,L),a.jsepRegisterMLTensor=(R,L,j,re)=>E.registerMLTensor(R,L,j,re),a.jsepCreateMLContext=R=>E.createMLContext(R),a.jsepRegisterMLConstant=(R,L,j,re,ge)=>E.registerMLConstant(R,L,j,re,ge,a.Bd),a.jsepRegisterGraphInput=E.registerGraphInput.bind(E),a.jsepIsGraphInput=E.isGraphInput.bind(E),a.jsepCreateTemporaryTensor=E.createTemporaryTensor.bind(E)}};var f,g,y=Object.assign({},a),x=(S,k)=>{throw k},w="";(o||l)&&(l?w=self.location.href:typeof document<"u"&&document.currentScript&&(w=document.currentScript.src),Ev&&(w=Ev),w=w.startsWith("blob:")?"":w.slice(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1),l&&(g=S=>{var k=new XMLHttpRequest;return k.open("GET",S,!1),k.responseType="arraybuffer",k.send(null),new Uint8Array(k.response)}),f=async S=>{if(U(S))return new Promise((E,R)=>{var L=new XMLHttpRequest;L.open("GET",S,!0),L.responseType="arraybuffer",L.onload=()=>{L.status==200||L.status==0&&L.response?E(L.response):R(L.status)},L.onerror=R,L.send(null)});var k=await fetch(S,{credentials:"same-origin"});if(k.ok)return k.arrayBuffer();throw Error(k.status+" : "+k.url)});var v=console.log.bind(console),$=console.error.bind(console),T=v,C=$;Object.assign(a,y),y=null;var I,A,O,B,z,P,F,K,X,te,Q,q,oe,se=a.wasmBinary,ee=!1,U=S=>S.startsWith("file://");function G(){return I.buffer!=B.buffer&&Pe(),B}function Y(){return I.buffer!=B.buffer&&Pe(),z}function ce(){return I.buffer!=B.buffer&&Pe(),P}function pe(){return I.buffer!=B.buffer&&Pe(),F}function J(){return I.buffer!=B.buffer&&Pe(),K}function we(){return I.buffer!=B.buffer&&Pe(),X}function Be(){return I.buffer!=B.buffer&&Pe(),te}function Fe(){return I.buffer!=B.buffer&&Pe(),oe}if(c){let S=function(k){try{var E=k.data,R=E.yd;if(R==="load"){let L=[];self.onmessage=j=>L.push(j),self.startWorker=()=>{postMessage({yd:"loaded"});for(let j of L)S(j);self.onmessage=S};for(let j of E.Od)a[j]&&!a[j].proxy||(a[j]=(...re)=>{postMessage({yd:"callHandler",Nd:j,args:re})},j=="print"&&(T=a[j]),j=="printErr"&&(C=a[j]));I=E.he,Pe(),Ve(E.ie)}else if(R==="run"){Yx(E.xd),fu(E.xd,0,0,1,0,0),ka(),ai(E.xd),Me||(Og(),Me=!0);try{Zx(E.de,E.Fd)}catch(L){if(L!="unwind")throw L}}else E.target!=="setimmediate"&&(R==="checkMailbox"?Me&&Ia():R&&(C(`worker: received unknown command ${R}`),C(E)))}catch(L){throw Vh(),L}};var Ve,Me=!1;C=function(...k){k=k.join(" "),console.error(k)},self.alert=function(...k){postMessage({yd:"alert",text:k.join(" "),fe:Ea()})},self.onunhandledrejection=k=>{throw k.reason||k},self.onmessage=S}function Pe(){var S=I.buffer;a.HEAP8=B=new Int8Array(S),a.HEAP16=P=new Int16Array(S),a.HEAPU8=z=new Uint8Array(S),a.HEAPU16=F=new Uint16Array(S),a.HEAP32=K=new Int32Array(S),a.HEAPU32=X=new Uint32Array(S),a.HEAPF32=te=new Float32Array(S),a.HEAPF64=oe=new Float64Array(S),a.HEAP64=Q=new BigInt64Array(S),a.HEAPU64=q=new BigUint64Array(S)}function pt(){c?startWorker(a):Ie.Bb()}c||(I=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0}),Pe());var yt,Dt=0,kt=null;function Ct(){if(--Dt==0&&kt){var S=kt;kt=null,S()}}function Nt(S){throw C(S="Aborted("+S+")"),ee=!0,S=new WebAssembly.RuntimeError(S+". Build with -sASSERTIONS for more info."),r(S),S}function Gt(){return{a:{Ta:ur,Va:mn,W:Oc,la:zc,b:Jm,u:gh,R:nu,Za:Jx,d:eg,pb:bh,g:Qx,T:es,Ga:Cs,lb:ng,nb:sg,Ha:wh,Ea:Fo,wb:Lc,Da:ri,pa:Vi,mb:Lo,jb:Ui,Fa:Fn,kb:vh,Ma:Mo,za:Bc,eb:Na,cb:pr,ya:ag,V:Th,N:Po,db:ig,ma:s1,fb:Pc,zb:Ih,hb:ug,qb:cg,ab:au,Aa:Eh,yb:ai,Ja:iu,S:Uc,Wa:dg,$:Wc,G:a1,E:Rh,m:_h,H:o1,B:fg,X:c1,J:d1,v:h1,O:p1,D:Dh,t:f1,A:m1,z:g1,w:mg,r:y1,tb:b1,ub:x1,vb:w1,rb:xg,sb:wg,bb:vg,Oa:$g,La:_g,y:Go,ja:v1,Ba:$1,Ka:Sg,qa:S1,Ia:Cg,ib:Tg,U:cu,fa:du,Sa:hu,gb:_1,Qa:Fh,Pa:Lh,Ab:kg,Ca:Ng,ob:ni,aa:Ig,oa:Eg,xb:Ag,na:qo,$a:_u,ia:fi,sa:rl,ga:Mn,da:Pg,ua:kn,p:T1,e:Qi,c:zg,ea:sl,f:Lg,n:ed,k:Ra,Y:sp,ka:Ln,j:k1,wa:nl,Ra:Tu,ca:nd,Ua:rd,P:N1,K:yr,_:op,Q:ap,Z:wt,x:rp,l:Fg,va:Ji,i:Jc,h:Mg,ra:eo,ta:sd,o:tl,q:ra,s:Bg,I:pi,C:C1,L:td,xa:ip,_a:Cu,F:Ug,Ya:I1,ba:Zt,M:hi,Xa:Vg,ha:Rg,a:I,Na:_s}}}var Ss={1319426:()=>typeof wasmOffsetConverter<"u",1319483:(S,k,E,R,L)=>{if(a===void 0||!a.Bd)return 1;if((S=Yt(Number(S>>>0))).startsWith("./")&&(S=S.substring(2)),!(S=a.Bd.get(S)))return 2;if(k=Number(k>>>0),E=Number(E>>>0),R=Number(R>>>0),k+E>S.byteLength)return 3;try{let j=S.subarray(k,k+E);switch(L){case 0:Y().set(j,R>>>0);break;case 1:a.$d(R,j);break;default:return 4}return 0}catch{return 4}},1320198:(S,k,E)=>{a.Jd(S,Y().subarray(k>>>0,k+E>>>0))},1320261:()=>a.Yd(),1320302:S=>{a.Id(S)},1320338:()=>{a.Sd()},1320369:()=>{a.Td()},1320398:()=>{a.Xd()},1320423:S=>a.Rd(S),1320456:S=>a.Vd(S),1320488:(S,k,E)=>{a.Hd(Number(S),Number(k),Number(E),!0)},1320551:(S,k,E)=>{a.Hd(Number(S),Number(k),Number(E))},1320608:S=>{a.hc("Abs",S,void 0)},1320659:S=>{a.hc("Neg",S,void 0)},1320710:S=>{a.hc("Floor",S,void 0)},1320763:S=>{a.hc("Ceil",S,void 0)},1320815:S=>{a.hc("Reciprocal",S,void 0)},1320873:S=>{a.hc("Sqrt",S,void 0)},1320925:S=>{a.hc("Exp",S,void 0)},1320976:S=>{a.hc("Erf",S,void 0)},1321027:S=>{a.hc("Sigmoid",S,void 0)},1321082:(S,k,E)=>{a.hc("HardSigmoid",S,{alpha:k,beta:E})},1321161:S=>{a.hc("Log",S,void 0)},1321212:S=>{a.hc("Sin",S,void 0)},1321263:S=>{a.hc("Cos",S,void 0)},1321314:S=>{a.hc("Tan",S,void 0)},1321365:S=>{a.hc("Asin",S,void 0)},1321417:S=>{a.hc("Acos",S,void 0)},1321469:S=>{a.hc("Atan",S,void 0)},1321521:S=>{a.hc("Sinh",S,void 0)},1321573:S=>{a.hc("Cosh",S,void 0)},1321625:S=>{a.hc("Asinh",S,void 0)},1321678:S=>{a.hc("Acosh",S,void 0)},1321731:S=>{a.hc("Atanh",S,void 0)},1321784:S=>{a.hc("Tanh",S,void 0)},1321836:S=>{a.hc("Not",S,void 0)},1321887:(S,k,E)=>{a.hc("Clip",S,{min:k,max:E})},1321956:S=>{a.hc("Clip",S,void 0)},1322008:(S,k)=>{a.hc("Elu",S,{alpha:k})},1322066:S=>{a.hc("Gelu",S,void 0)},1322118:S=>{a.hc("Relu",S,void 0)},1322170:(S,k)=>{a.hc("LeakyRelu",S,{alpha:k})},1322234:(S,k)=>{a.hc("ThresholdedRelu",S,{alpha:k})},1322304:(S,k)=>{a.hc("Cast",S,{to:k})},1322362:S=>{a.hc("Add",S,void 0)},1322413:S=>{a.hc("Sub",S,void 0)},1322464:S=>{a.hc("Mul",S,void 0)},1322515:S=>{a.hc("Div",S,void 0)},1322566:S=>{a.hc("Pow",S,void 0)},1322617:S=>{a.hc("Equal",S,void 0)},1322670:S=>{a.hc("Greater",S,void 0)},1322725:S=>{a.hc("GreaterOrEqual",S,void 0)},1322787:S=>{a.hc("Less",S,void 0)},1322839:S=>{a.hc("LessOrEqual",S,void 0)},1322898:(S,k,E,R,L)=>{a.hc("ReduceMean",S,{keepDims:!!k,noopWithEmptyAxes:!!E,axes:R?Array.from(J().subarray(Number(R)>>>0,Number(L)>>>0)):[]})},1323073:(S,k,E,R,L)=>{a.hc("ReduceMax",S,{keepDims:!!k,noopWithEmptyAxes:!!E,axes:R?Array.from(J().subarray(Number(R)>>>0,Number(L)>>>0)):[]})},1323247:(S,k,E,R,L)=>{a.hc("ReduceMin",S,{keepDims:!!k,noopWithEmptyAxes:!!E,axes:R?Array.from(J().subarray(Number(R)>>>0,Number(L)>>>0)):[]})},1323421:(S,k,E,R,L)=>{a.hc("ReduceProd",S,{keepDims:!!k,noopWithEmptyAxes:!!E,axes:R?Array.from(J().subarray(Number(R)>>>0,Number(L)>>>0)):[]})},1323596:(S,k,E,R,L)=>{a.hc("ReduceSum",S,{keepDims:!!k,noopWithEmptyAxes:!!E,axes:R?Array.from(J().subarray(Number(R)>>>0,Number(L)>>>0)):[]})},1323770:(S,k,E,R,L)=>{a.hc("ReduceL1",S,{keepDims:!!k,noopWithEmptyAxes:!!E,axes:R?Array.from(J().subarray(Number(R)>>>0,Number(L)>>>0)):[]})},1323943:(S,k,E,R,L)=>{a.hc("ReduceL2",S,{keepDims:!!k,noopWithEmptyAxes:!!E,axes:R?Array.from(J().subarray(Number(R)>>>0,Number(L)>>>0)):[]})},1324116:(S,k,E,R,L)=>{a.hc("ReduceLogSum",S,{keepDims:!!k,noopWithEmptyAxes:!!E,axes:R?Array.from(J().subarray(Number(R)>>>0,Number(L)>>>0)):[]})},1324293:(S,k,E,R,L)=>{a.hc("ReduceSumSquare",S,{keepDims:!!k,noopWithEmptyAxes:!!E,axes:R?Array.from(J().subarray(Number(R)>>>0,Number(L)>>>0)):[]})},1324473:(S,k,E,R,L)=>{a.hc("ReduceLogSumExp",S,{keepDims:!!k,noopWithEmptyAxes:!!E,axes:R?Array.from(J().subarray(Number(R)>>>0,Number(L)>>>0)):[]})},1324653:S=>{a.hc("Where",S,void 0)},1324706:(S,k,E)=>{a.hc("Transpose",S,{perm:k?Array.from(J().subarray(Number(k)>>>0,Number(E)>>>0)):[]})},1324830:(S,k,E,R)=>{a.hc("DepthToSpace",S,{blocksize:k,mode:Yt(E),format:R?"NHWC":"NCHW"})},1324963:(S,k,E,R)=>{a.hc("DepthToSpace",S,{blocksize:k,mode:Yt(E),format:R?"NHWC":"NCHW"})},1325096:(S,k,E,R,L,j,re,ge,Se,Re,Le,We,at,Ht,ks)=>{a.hc("ConvTranspose",S,{format:Se?"NHWC":"NCHW",autoPad:k,dilations:[E],group:R,kernelShape:[L],pads:[j,re],strides:[ge],wIsConst:()=>!!G()[Re>>>0],outputPadding:Le?Array.from(J().subarray(Number(Le)>>>0,Number(We)>>>0)):[],outputShape:at?Array.from(J().subarray(Number(at)>>>0,Number(Ht)>>>0)):[],activation:Yt(ks)})},1325529:(S,k,E,R,L,j,re,ge,Se,Re,Le,We,at,Ht)=>{a.hc("ConvTranspose",S,{format:ge?"NHWC":"NCHW",autoPad:k,dilations:Array.from(J().subarray(Number(E)>>>0,2+(Number(E)>>>0)>>>0)),group:R,kernelShape:Array.from(J().subarray(Number(L)>>>0,2+(Number(L)>>>0)>>>0)),pads:Array.from(J().subarray(Number(j)>>>0,4+(Number(j)>>>0)>>>0)),strides:Array.from(J().subarray(Number(re)>>>0,2+(Number(re)>>>0)>>>0)),wIsConst:()=>!!G()[Se>>>0],outputPadding:Re?Array.from(J().subarray(Number(Re)>>>0,Number(Le)>>>0)):[],outputShape:We?Array.from(J().subarray(Number(We)>>>0,Number(at)>>>0)):[],activation:Yt(Ht)})},1326190:(S,k,E,R,L,j,re,ge,Se,Re,Le,We,at,Ht,ks)=>{a.hc("ConvTranspose",S,{format:Se?"NHWC":"NCHW",autoPad:k,dilations:[E],group:R,kernelShape:[L],pads:[j,re],strides:[ge],wIsConst:()=>!!G()[Re>>>0],outputPadding:Le?Array.from(J().subarray(Number(Le)>>>0,Number(We)>>>0)):[],outputShape:at?Array.from(J().subarray(Number(at)>>>0,Number(Ht)>>>0)):[],activation:Yt(ks)})},1326623:(S,k,E,R,L,j,re,ge,Se,Re,Le,We,at,Ht)=>{a.hc("ConvTranspose",S,{format:ge?"NHWC":"NCHW",autoPad:k,dilations:Array.from(J().subarray(Number(E)>>>0,2+(Number(E)>>>0)>>>0)),group:R,kernelShape:Array.from(J().subarray(Number(L)>>>0,2+(Number(L)>>>0)>>>0)),pads:Array.from(J().subarray(Number(j)>>>0,4+(Number(j)>>>0)>>>0)),strides:Array.from(J().subarray(Number(re)>>>0,2+(Number(re)>>>0)>>>0)),wIsConst:()=>!!G()[Se>>>0],outputPadding:Re?Array.from(J().subarray(Number(Re)>>>0,Number(Le)>>>0)):[],outputShape:We?Array.from(J().subarray(Number(We)>>>0,Number(at)>>>0)):[],activation:Yt(Ht)})},1327284:(S,k)=>{a.hc("GlobalAveragePool",S,{format:k?"NHWC":"NCHW"})},1327375:(S,k,E,R,L,j,re,ge,Se,Re,Le,We,at,Ht)=>{a.hc("AveragePool",S,{format:Ht?"NHWC":"NCHW",auto_pad:k,ceil_mode:E,count_include_pad:R,storage_order:L,dilations:j?Array.from(J().subarray(Number(j)>>>0,Number(re)>>>0)):[],kernel_shape:ge?Array.from(J().subarray(Number(ge)>>>0,Number(Se)>>>0)):[],pads:Re?Array.from(J().subarray(Number(Re)>>>0,Number(Le)>>>0)):[],strides:We?Array.from(J().subarray(Number(We)>>>0,Number(at)>>>0)):[]})},1327854:(S,k)=>{a.hc("GlobalAveragePool",S,{format:k?"NHWC":"NCHW"})},1327945:(S,k,E,R,L,j,re,ge,Se,Re,Le,We,at,Ht)=>{a.hc("AveragePool",S,{format:Ht?"NHWC":"NCHW",auto_pad:k,ceil_mode:E,count_include_pad:R,storage_order:L,dilations:j?Array.from(J().subarray(Number(j)>>>0,Number(re)>>>0)):[],kernel_shape:ge?Array.from(J().subarray(Number(ge)>>>0,Number(Se)>>>0)):[],pads:Re?Array.from(J().subarray(Number(Re)>>>0,Number(Le)>>>0)):[],strides:We?Array.from(J().subarray(Number(We)>>>0,Number(at)>>>0)):[]})},1328424:(S,k)=>{a.hc("GlobalMaxPool",S,{format:k?"NHWC":"NCHW"})},1328511:(S,k,E,R,L,j,re,ge,Se,Re,Le,We,at,Ht)=>{a.hc("MaxPool",S,{format:Ht?"NHWC":"NCHW",auto_pad:k,ceil_mode:E,count_include_pad:R,storage_order:L,dilations:j?Array.from(J().subarray(Number(j)>>>0,Number(re)>>>0)):[],kernel_shape:ge?Array.from(J().subarray(Number(ge)>>>0,Number(Se)>>>0)):[],pads:Re?Array.from(J().subarray(Number(Re)>>>0,Number(Le)>>>0)):[],strides:We?Array.from(J().subarray(Number(We)>>>0,Number(at)>>>0)):[]})},1328986:(S,k)=>{a.hc("GlobalMaxPool",S,{format:k?"NHWC":"NCHW"})},1329073:(S,k,E,R,L,j,re,ge,Se,Re,Le,We,at,Ht)=>{a.hc("MaxPool",S,{format:Ht?"NHWC":"NCHW",auto_pad:k,ceil_mode:E,count_include_pad:R,storage_order:L,dilations:j?Array.from(J().subarray(Number(j)>>>0,Number(re)>>>0)):[],kernel_shape:ge?Array.from(J().subarray(Number(ge)>>>0,Number(Se)>>>0)):[],pads:Re?Array.from(J().subarray(Number(Re)>>>0,Number(Le)>>>0)):[],strides:We?Array.from(J().subarray(Number(We)>>>0,Number(at)>>>0)):[]})},1329548:(S,k,E,R,L)=>{a.hc("Gemm",S,{alpha:k,beta:E,transA:R,transB:L})},1329652:S=>{a.hc("MatMul",S,void 0)},1329706:(S,k,E,R)=>{a.hc("ArgMax",S,{keepDims:!!k,selectLastIndex:!!E,axis:R})},1329814:(S,k,E,R)=>{a.hc("ArgMin",S,{keepDims:!!k,selectLastIndex:!!E,axis:R})},1329922:(S,k)=>{a.hc("Softmax",S,{axis:k})},1329985:(S,k)=>{a.hc("Concat",S,{axis:k})},1330045:(S,k,E,R,L)=>{a.hc("Split",S,{axis:k,numOutputs:E,splitSizes:R?Array.from(J().subarray(Number(R)>>>0,Number(L)>>>0)):[]})},1330201:S=>{a.hc("Expand",S,void 0)},1330255:(S,k)=>{a.hc("Gather",S,{axis:Number(k)})},1330326:(S,k)=>{a.hc("GatherElements",S,{axis:Number(k)})},1330405:(S,k)=>{a.hc("GatherND",S,{batch_dims:Number(k)})},1330484:(S,k,E,R,L,j,re,ge,Se,Re,Le)=>{a.hc("Resize",S,{antialias:k,axes:E?Array.from(J().subarray(Number(E)>>>0,Number(R)>>>0)):[],coordinateTransformMode:Yt(L),cubicCoeffA:j,excludeOutside:re,extrapolationValue:ge,keepAspectRatioPolicy:Yt(Se),mode:Yt(Re),nearestMode:Yt(Le)})},1330846:(S,k,E,R,L,j,re)=>{a.hc("Slice",S,{starts:k?Array.from(J().subarray(Number(k)>>>0,Number(E)>>>0)):[],ends:R?Array.from(J().subarray(Number(R)>>>0,Number(L)>>>0)):[],axes:j?Array.from(J().subarray(Number(j)>>>0,Number(re)>>>0)):[]})},1331110:S=>{a.hc("Tile",S,void 0)},1331162:(S,k,E)=>{a.hc("InstanceNormalization",S,{epsilon:k,format:E?"NHWC":"NCHW"})},1331276:(S,k,E)=>{a.hc("InstanceNormalization",S,{epsilon:k,format:E?"NHWC":"NCHW"})},1331390:S=>{a.hc("Range",S,void 0)},1331443:(S,k)=>{a.hc("Einsum",S,{equation:Yt(k)})},1331524:(S,k,E,R,L)=>{a.hc("Pad",S,{mode:k,value:E,pads:R?Array.from(J().subarray(Number(R)>>>0,Number(L)>>>0)):[]})},1331667:(S,k,E,R,L,j)=>{a.hc("BatchNormalization",S,{epsilon:k,momentum:E,spatial:!!L,trainingMode:!!R,format:j?"NHWC":"NCHW"})},1331836:(S,k,E,R,L,j)=>{a.hc("BatchNormalization",S,{epsilon:k,momentum:E,spatial:!!L,trainingMode:!!R,format:j?"NHWC":"NCHW"})},1332005:(S,k,E)=>{a.hc("CumSum",S,{exclusive:Number(k),reverse:Number(E)})},1332102:(S,k,E)=>{a.hc("DequantizeLinear",S,{axis:k,blockSize:E})},1332192:(S,k,E,R,L)=>{a.hc("GridSample",S,{align_corners:k,mode:Yt(E),padding_mode:Yt(R),format:L?"NHWC":"NCHW"})},1332362:(S,k,E,R,L)=>{a.hc("GridSample",S,{align_corners:k,mode:Yt(E),padding_mode:Yt(R),format:L?"NHWC":"NCHW"})},1332532:(S,k)=>{a.hc("ScatterND",S,{reduction:Yt(k)})},1332617:(S,k,E,R,L,j,re,ge,Se)=>{a.hc("Attention",S,{numHeads:k,isUnidirectional:E,maskFilterValue:R,scale:L,doRotary:j,qkvHiddenSizes:re?Array.from(J().subarray(Number(ge)>>>0,Number(ge)+re>>>0)):[],pastPresentShareBuffer:!!Se})},1332889:S=>{a.hc("BiasAdd",S,void 0)},1332944:S=>{a.hc("BiasSplitGelu",S,void 0)},1333005:S=>{a.hc("FastGelu",S,void 0)},1333061:(S,k,E,R,L,j,re,ge,Se,Re,Le,We,at,Ht,ks,no)=>{a.hc("Conv",S,{format:We?"NHWC":"NCHW",auto_pad:k,dilations:E?Array.from(J().subarray(Number(E)>>>0,Number(R)>>>0)):[],group:L,kernel_shape:j?Array.from(J().subarray(Number(j)>>>0,Number(re)>>>0)):[],pads:ge?Array.from(J().subarray(Number(ge)>>>0,Number(Se)>>>0)):[],strides:Re?Array.from(J().subarray(Number(Re)>>>0,Number(Le)>>>0)):[],w_is_const:()=>!!G()[Number(at)>>>0],activation:Yt(Ht),activation_params:ks?Array.from(Be().subarray(Number(ks)>>>0,Number(no)>>>0)):[]})},1333645:S=>{a.hc("Gelu",S,void 0)},1333697:(S,k,E,R,L,j,re,ge,Se)=>{a.hc("GroupQueryAttention",S,{numHeads:k,kvNumHeads:E,scale:R,softcap:L,doRotary:j,rotaryInterleaved:re,smoothSoftmax:ge,localWindowSize:Se})},1333914:(S,k,E,R)=>{a.hc("LayerNormalization",S,{axis:k,epsilon:E,simplified:!!R})},1334025:(S,k,E,R)=>{a.hc("LayerNormalization",S,{axis:k,epsilon:E,simplified:!!R})},1334136:(S,k,E,R,L,j)=>{a.hc("MatMulNBits",S,{k,n:E,accuracyLevel:R,bits:L,blockSize:j})},1334263:(S,k,E,R,L,j)=>{a.hc("MultiHeadAttention",S,{numHeads:k,isUnidirectional:E,maskFilterValue:R,scale:L,doRotary:j})},1334422:(S,k)=>{a.hc("QuickGelu",S,{alpha:k})},1334486:(S,k,E,R,L)=>{a.hc("RotaryEmbedding",S,{interleaved:!!k,numHeads:E,rotaryEmbeddingDim:R,scale:L})},1334625:(S,k,E)=>{a.hc("SkipLayerNormalization",S,{epsilon:k,simplified:!!E})},1334727:(S,k,E)=>{a.hc("SkipLayerNormalization",S,{epsilon:k,simplified:!!E})},1334829:(S,k,E,R)=>{a.hc("GatherBlockQuantized",S,{gatherAxis:k,quantizeAxis:E,blockSize:R})},1334950:S=>{a.Wd(S)},1334984:(S,k)=>a.Zd(Number(S),Number(k),a.Cd.be,a.Cd.errors)};function mn(S,k,E){return Wo(async()=>{await a.Ud(Number(S),Number(k),Number(E))})}function ur(){return typeof wasmOffsetConverter<"u"}class Jn{constructor(k){PN(this,"name","ExitStatus");this.message=`Program terminated with exit(${k})`,this.status=k}}var Qr=S=>{S.terminate(),S.onmessage=()=>{}},ln=[],cr=S=>{dr.length==0&&(Qm(),zs(dr[0]));var k=dr.pop();if(!k)return 6;Li.push(k),vn[S.xd]=k,k.xd=S.xd;var E={yd:"run",de:S.ce,Fd:S.Fd,xd:S.xd};return k.postMessage(E,S.Ld),0},Pn=0,Et=(S,k,...E)=>{for(var R=2*E.length,L=ut(),j=Gh(8*R),re=j>>>3,ge=0;ge<E.length;ge++){var Se=E[ge];typeof Se=="bigint"?(Q[re+2*ge]=1n,Q[re+2*ge+1]=Se):(Q[re+2*ge]=0n,Fe()[re+2*ge+1>>>0]=Se)}return S=oi(S,0,R,j,k),ot(L),S};function _s(S){if(c)return Et(0,1,S);if(O=S,!(0<Pn)){for(var k of Li)Qr(k);for(k of dr)Qr(k);dr=[],Li=[],vn={},ee=!0}x(0,new Jn(S))}function ti(S){if(c)return Et(1,0,S);ni(S)}var ni=S=>{if(O=S,c)throw ti(S),"unwind";_s(S)},dr=[],Li=[],Rr=[],vn={},Dc=S=>{var k=S.xd;delete vn[k],dr.push(S),Li.splice(Li.indexOf(S),1),S.xd=0,qi(k)};function ka(){Rr.forEach(S=>S())}var zs=S=>new Promise(k=>{S.onmessage=L=>{var j=(L=L.data).yd;if(L.Ed&&L.Ed!=Ea()){var re=vn[L.Ed];re?re.postMessage(L,L.Ld):C(`Internal error! Worker sent a message "${j}" to target pthread ${L.Ed}, but that thread no longer exists!`)}else j==="checkMailbox"?Ia():j==="spawnThread"?cr(L):j==="cleanupThread"?Dc(vn[L.ee]):j==="loaded"?(S.loaded=!0,k(S)):j==="alert"?alert(`Thread ${L.fe}: ${L.text}`):L.target==="setimmediate"?S.postMessage(L):j==="callHandler"?a[L.Nd](...L.args):j&&C(`worker sent an unknown command ${j}`)},S.onerror=L=>{throw C(`worker sent an error! ${L.filename}:${L.lineno}: ${L.message}`),L};var E,R=[];for(E of[])a.propertyIsEnumerable(E)&&R.push(E);S.postMessage({yd:"load",Od:R,he:I,ie:A})});function Qm(){var S=new Worker(import.meta.url.startsWith("file:")?new URL("/test-onnnx/assets/ort.bundle.min-OfoG_cy9.mjs",import.meta.url):new URL(import.meta.url),{type:"module",workerData:"em-pthread",name:"em-pthread"});dr.push(S)}var Yx=S=>{Pe();var k=we()[S+52>>>2>>>0];S=we()[S+56>>>2>>>0],Wh(k,k-S),ot(k)},Zx=(S,k)=>{Pn=0,S=gu(S,k),0<Pn?O=S:mu(S)},Mi=[];function Oc(S){var k=new Bi(S>>>=0);if(G()[k.wd+12>>>0]==0){var E=1;G()[k.wd+12>>>0]=E}return E=0,G()[k.wd+13>>>0]=E,Mi.push(k),qh(S),mr(S)}var hr=0,zc=()=>{lt(0,0);var S=Mi.pop();Hh(S.Gd),hr=0};class Bi{constructor(k){this.Gd=k,this.wd=k-24}}function Qx(S){throw hr||(hr=S>>>0),hr}var Fc=S=>{var k=hr;if(!k)return jo(0),0;var E=new Bi(k);we()[E.wd+16>>>2>>>0]=k;var R=we()[E.wd+4>>>2>>>0];if(!R)return jo(0),k;for(var L of S){if(L===0||L===R)break;if(jh(L,R,E.wd+16))return jo(L),k}return jo(R),k};function Jm(){return Fc([])}function gh(S){return Fc([S>>>0])}function nu(S,k){return Fc([S>>>0,k>>>0])}var Jx=()=>{var S=Mi.pop();S||Nt("no exception to throw");var k=S.Gd;if(G()[S.wd+13>>>0]==0){Mi.push(S);var E=1;G()[S.wd+13>>>0]=E,E=0,G()[S.wd+12>>>0]=E}throw hr=k};function eg(S,k,E){var R=new Bi(S>>>=0);throw k>>>=0,E>>>=0,we()[R.wd+16>>>2>>>0]=0,we()[R.wd+4>>>2>>>0]=k,we()[R.wd+8>>>2>>>0]=E,hr=S}function yh(S,k,E,R){return c?Et(2,1,S,k,E,R):bh(S,k,E,R)}function bh(S,k,E,R){if(S>>>=0,E>>>=0,R>>>=0,h===void 0)return 6;var L=[];return c&&L.length===0?yh(S,k>>>=0,E,R):(S={ce:E,xd:S,Fd:R,Ld:L},c?(S.yd="spawnThread",postMessage(S,L),0):cr(S))}var xh=typeof TextDecoder<"u"?new TextDecoder:void 0,tg=(S,k=0,E=NaN)=>{var R=(k>>>=0)+E;for(E=k;S[E]&&!(E>=R);)++E;if(16<E-k&&S.buffer&&xh)return xh.decode(S.buffer instanceof ArrayBuffer?S.subarray(k,E):S.slice(k,E));for(R="";k<E;){var L=S[k++];if(128&L){var j=63&S[k++];if((224&L)==192)R+=String.fromCharCode((31&L)<<6|j);else{var re=63&S[k++];65536>(L=(240&L)==224?(15&L)<<12|j<<6|re:(7&L)<<18|j<<12|re<<6|63&S[k++])?R+=String.fromCharCode(L):(L-=65536,R+=String.fromCharCode(55296|L>>10,56320|1023&L))}}else R+=String.fromCharCode(L)}return R},Yt=(S,k)=>(S>>>=0)?tg(Y(),S,k):"";function es(S,k,E){return c?Et(3,1,S,k,E):0}function Cs(S,k){if(c)return Et(4,1,S,k)}var Pi=S=>{for(var k=0,E=0;E<S.length;++E){var R=S.charCodeAt(E);127>=R?k++:2047>=R?k+=2:55296<=R&&57343>=R?(k+=4,++E):k+=3}return k},si=(S,k,E)=>{var R=Y();if(k>>>=0,0<E){var L=k;E=k+E-1;for(var j=0;j<S.length;++j){var re=S.charCodeAt(j);if(55296<=re&&57343>=re&&(re=65536+((1023&re)<<10)|1023&S.charCodeAt(++j)),127>=re){if(k>=E)break;R[k++>>>0]=re}else{if(2047>=re){if(k+1>=E)break;R[k++>>>0]=192|re>>6}else{if(65535>=re){if(k+2>=E)break;R[k++>>>0]=224|re>>12}else{if(k+3>=E)break;R[k++>>>0]=240|re>>18,R[k++>>>0]=128|re>>12&63}R[k++>>>0]=128|re>>6&63}R[k++>>>0]=128|63&re}}R[k>>>0]=0,S=k-L}else S=0;return S};function ng(S,k){if(c)return Et(5,1,S,k)}function sg(S,k,E){if(c)return Et(6,1,S,k,E)}function wh(S,k,E){return c?Et(7,1,S,k,E):0}function Fo(S,k){if(c)return Et(8,1,S,k)}function Lc(S,k,E){if(c)return Et(9,1,S,k,E)}function ri(S,k,E,R){if(c)return Et(10,1,S,k,E,R)}function Vi(S,k,E,R){if(c)return Et(11,1,S,k,E,R)}function Lo(S,k,E,R){if(c)return Et(12,1,S,k,E,R)}function Ui(S){if(c)return Et(13,1,S)}function Fn(S,k){if(c)return Et(14,1,S,k)}function vh(S,k,E){if(c)return Et(15,1,S,k,E)}var $h,Fs,Mo=()=>Nt(""),Vn=S=>{for(var k="";Y()[S>>>0];)k+=$h[Y()[S++>>>0]];return k},Sh={},Mc={};function Jr(S,k,E={}){return function(R,L,j={}){var re=L.name;if(!R)throw new Fs(`type "${re}" must have a positive integer typeid pointer`);if(Mc.hasOwnProperty(R)){if(j.Pd)return;throw new Fs(`Cannot register type '${re}' twice`)}Mc[R]=L,Sh.hasOwnProperty(R)&&(L=Sh[R],delete Sh[R],L.forEach(ge=>ge()))}(S,k,E)}var rg=(S,k,E)=>{switch(k){case 1:return E?R=>G()[R>>>0]:R=>Y()[R>>>0];case 2:return E?R=>ce()[R>>>1>>>0]:R=>pe()[R>>>1>>>0];case 4:return E?R=>J()[R>>>2>>>0]:R=>we()[R>>>2>>>0];case 8:return E?R=>Q[R>>>3]:R=>q[R>>>3];default:throw new TypeError(`invalid integer width (${k}): ${S}`)}};function Bc(S,k,E){E>>>=0,Jr(S>>>=0,{name:k=Vn(k>>>0),fromWireType:R=>R,toWireType:function(R,L){if(typeof L!="bigint"&&typeof L!="number")throw L=L===null?"null":(R=typeof L)=="object"||R==="array"||R==="function"?L.toString():""+L,new TypeError(`Cannot convert "${L}" to ${this.name}`);return typeof L=="number"&&(L=BigInt(L)),L},zd:Dr,readValueFromPointer:rg(k,E,k.indexOf("u")==-1),Ad:null})}var Dr=8;function Na(S,k,E,R){Jr(S>>>=0,{name:k=Vn(k>>>0),fromWireType:function(L){return!!L},toWireType:function(L,j){return j?E:R},zd:Dr,readValueFromPointer:function(L){return this.fromWireType(Y()[L>>>0])},Ad:null})}var Ls=[],ea=[];function _h(S){9<(S>>>=0)&&--ea[S+1]==0&&(ea[S]=void 0,Ls.push(S))}var us=S=>{if(!S)throw new Fs("Cannot use deleted val. handle = "+S);return ea[S]},Xs=S=>{switch(S){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let k=Ls.pop()||ea.length;return ea[k]=S,ea[k+1]=1,k}};function Bo(S){return this.fromWireType(we()[S>>>2>>>0])}var e1={name:"emscripten::val",fromWireType:S=>{var k=us(S);return _h(S),k},toWireType:(S,k)=>Xs(k),zd:Dr,readValueFromPointer:Bo,Ad:null};function pr(S){return Jr(S>>>0,e1)}var Ch=(S,k)=>{switch(k){case 4:return function(E){return this.fromWireType(Be()[E>>>2>>>0])};case 8:return function(E){return this.fromWireType(Fe()[E>>>3>>>0])};default:throw new TypeError(`invalid float width (${k}): ${S}`)}};function ag(S,k,E){E>>>=0,Jr(S>>>=0,{name:k=Vn(k>>>0),fromWireType:R=>R,toWireType:(R,L)=>L,zd:Dr,readValueFromPointer:Ch(k,E),Ad:null})}function Th(S,k,E,R,L){if(S>>>=0,E>>>=0,k=Vn(k>>>0),L===-1&&(L=4294967295),L=ge=>ge,R===0){var j=32-8*E;L=ge=>ge<<j>>>j}var re=k.includes("unsigned")?function(ge,Se){return Se>>>0}:function(ge,Se){return Se};Jr(S,{name:k,fromWireType:L,toWireType:re,zd:Dr,readValueFromPointer:rg(k,E,R!==0),Ad:null})}function Po(S,k,E){function R(j){var re=we()[j>>>2>>>0];return j=we()[j+4>>>2>>>0],new L(G().buffer,j,re)}var L=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][k];Jr(S>>>=0,{name:E=Vn(E>>>0),fromWireType:R,zd:Dr,readValueFromPointer:R},{Pd:!0})}function ig(S,k){Jr(S>>>=0,{name:k=Vn(k>>>0),fromWireType:function(E){for(var R,L=we()[E>>>2>>>0],j=E+4,re=j,ge=0;ge<=L;++ge){var Se=j+ge;ge!=L&&Y()[Se>>>0]!=0||(re=Yt(re,Se-re),R===void 0?R=re:(R+="\0",R+=re),re=Se+1)}return fr(E),R},toWireType:function(E,R){R instanceof ArrayBuffer&&(R=new Uint8Array(R));var L=typeof R=="string";if(!(L||R instanceof Uint8Array||R instanceof Uint8ClampedArray||R instanceof Int8Array))throw new Fs("Cannot pass non-string to std::string");var j=L?Pi(R):R.length,re=ii(4+j+1),ge=re+4;if(we()[re>>>2>>>0]=j,L)si(R,ge,j+1);else if(L)for(L=0;L<j;++L){var Se=R.charCodeAt(L);if(255<Se)throw fr(re),new Fs("String has UTF-16 code units that do not fit in 8 bits");Y()[ge+L>>>0]=Se}else for(L=0;L<j;++L)Y()[ge+L>>>0]=R[L];return E!==null&&E.push(fr,re),re},zd:Dr,readValueFromPointer:Bo,Ad(E){fr(E)}})}var kh=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,Vo=(S,k)=>{for(var E=S>>1,R=E+k/2;!(E>=R)&&pe()[E>>>0];)++E;if(32<(E<<=1)-S&&kh)return kh.decode(Y().slice(S,E));for(E="",R=0;!(R>=k/2);++R){var L=ce()[S+2*R>>>1>>>0];if(L==0)break;E+=String.fromCharCode(L)}return E},t1=(S,k,E)=>{if(E??(E=2147483647),2>E)return 0;var R=k;E=(E-=2)<2*S.length?E/2:S.length;for(var L=0;L<E;++L){var j=S.charCodeAt(L);ce()[k>>>1>>>0]=j,k+=2}return ce()[k>>>1>>>0]=0,k-R},og=S=>2*S.length,lg=(S,k)=>{for(var E=0,R="";!(E>=k/4);){var L=J()[S+4*E>>>2>>>0];if(L==0)break;++E,65536<=L?(L-=65536,R+=String.fromCharCode(55296|L>>10,56320|1023&L)):R+=String.fromCharCode(L)}return R},Nh=(S,k,E)=>{if(k>>>=0,E??(E=2147483647),4>E)return 0;var R=k;E=R+E-4;for(var L=0;L<S.length;++L){var j=S.charCodeAt(L);if(55296<=j&&57343>=j&&(j=65536+((1023&j)<<10)|1023&S.charCodeAt(++L)),J()[k>>>2>>>0]=j,(k+=4)+4>E)break}return J()[k>>>2>>>0]=0,k-R},n1=S=>{for(var k=0,E=0;E<S.length;++E){var R=S.charCodeAt(E);55296<=R&&57343>=R&&++E,k+=4}return k};function s1(S,k,E){if(S>>>=0,k>>>=0,E=Vn(E>>>=0),k===2)var R=Vo,L=t1,j=og,re=ge=>pe()[ge>>>1>>>0];else k===4&&(R=lg,L=Nh,j=n1,re=ge=>we()[ge>>>2>>>0]);Jr(S,{name:E,fromWireType:ge=>{for(var Se,Re=we()[ge>>>2>>>0],Le=ge+4,We=0;We<=Re;++We){var at=ge+4+We*k;We!=Re&&re(at)!=0||(Le=R(Le,at-Le),Se===void 0?Se=Le:(Se+="\0",Se+=Le),Le=at+k)}return fr(ge),Se},toWireType:(ge,Se)=>{if(typeof Se!="string")throw new Fs(`Cannot pass non-string to C++ string type ${E}`);var Re=j(Se),Le=ii(4+Re+k);return we()[Le>>>2>>>0]=Re/k,L(Se,Le+4,Re+k),ge!==null&&ge.push(fr,Le),Le},zd:Dr,readValueFromPointer:Bo,Ad(ge){fr(ge)}})}function Pc(S,k){Jr(S>>>=0,{Qd:!0,name:k=Vn(k>>>0),zd:0,fromWireType:()=>{},toWireType:()=>{}})}function Ih(S){fu(S>>>0,!l,1,!o,131072,!1),ka()}var su=S=>{if(!ee)try{if(S(),!(0<Pn))try{c?mu(O):ni(O)}catch(k){k instanceof Jn||k=="unwind"||x(0,k)}}catch(k){k instanceof Jn||k=="unwind"||x(0,k)}};function ai(S){S>>>=0,typeof Atomics.ge=="function"&&(Atomics.ge(J(),S>>>2,S).value.then(Ia),S+=128,Atomics.store(J(),S>>>2,1))}var Ia=()=>{var S=Ea();S&&(ai(S),su(li))};function ug(S,k){(S>>>=0)==k>>>0?setTimeout(Ia):c?postMessage({Ed:S,yd:"checkMailbox"}):(S=vn[S])&&S.postMessage({yd:"checkMailbox"})}var ru=[];function cg(S,k,E,R,L){for(k>>>=0,R/=2,ru.length=R,E=L>>>0>>>3,L=0;L<R;L++)ru[L]=Q[E+2*L]?Q[E+2*L+1]:Fe()[E+2*L+1>>>0];return(k?Ss[k]:Ph[S])(...ru)}var au=()=>{Pn=0};function Eh(S){S>>>=0,c?postMessage({yd:"cleanupThread",ee:S}):Dc(vn[S])}function iu(S){}var Or=(S,k)=>{var E=Mc[S];if(E===void 0)throw S=Dg(S),E=Vn(S),fr(S),new Fs(`${k} has unknown type ${E}`);return E},Vc=(S,k,E)=>{var R=[];return S=S.toWireType(R,E),R.length&&(we()[k>>>2>>>0]=Xs(R)),S};function Uc(S,k,E){return k>>>=0,E>>>=0,S=us(S>>>0),k=Or(k,"emval::as"),Vc(k,E,S)}function dg(S,k){return k>>>=0,S=us(S>>>0),(k=Or(k,"emval::as")).toWireType(null,S)}var Wi=S=>{try{S()}catch(k){Nt(k)}},zr=0,Fr=null,Ts=0,ta=[],ou={},Uo={},r1=0,lu=null,Ah=[];function Wo(S){return function(k){if(!ee){if(zr===0){var E=!1,R=!1;k((L=0)=>{if(!ee&&(Ts=L,E=!0,R)){zr=2,Wi(()=>Su(Fr)),typeof MainLoop<"u"&&MainLoop.Md&&MainLoop.resume(),L=!1;try{var j=function(){var Se=J()[Fr+8>>>2>>>0];return Se=Ie[Uo[Se]],--Pn,Se()}()}catch(Se){j=Se,L=!0}var re=!1;if(!Fr){var ge=lu;ge&&(lu=null,(L?ge.reject:ge.resolve)(j),re=!0)}if(L&&!re)throw j}}),R=!0,E||(zr=1,Fr=function(){var L=ii(65548),j=L+12;we()[L>>>2>>>0]=j,we()[L+4>>>2>>>0]=j+65536,j=ta[0];var re=ou[j];return re===void 0&&(re=r1++,ou[j]=re,Uo[re]=j),j=re,J()[L+8>>>2>>>0]=j,L}(),typeof MainLoop<"u"&&MainLoop.Md&&MainLoop.pause(),Wi(()=>Zi(Fr)))}else zr===2?(zr=0,Wi(el),fr(Fr),Fr=null,Ah.forEach(su)):Nt(`invalid state: ${zr}`);return Ts}}(k=>{S().then(k)})}function Wc(S){return S>>>=0,Wo(async()=>{var k=await us(S);return Xs(k)})}var uu=[];function a1(S,k,E,R){return E>>>=0,R>>>=0,(S=uu[S>>>0])(null,k=us(k>>>0),E,R)}var i1={},Gc=S=>{var k=i1[S];return k===void 0?Vn(S):k};function Rh(S,k,E,R,L){return E>>>=0,R>>>=0,L>>>=0,(S=uu[S>>>0])(k=us(k>>>0),k[E=Gc(E)],R,L)}var hg=()=>typeof globalThis=="object"?globalThis:Function("return this")();function o1(S){return(S>>>=0)==0?Xs(hg()):(S=Gc(S),Xs(hg()[S]))}var l1=S=>{var k=uu.length;return uu.push(S),k},u1=(S,k)=>{for(var E=Array(S),R=0;R<S;++R)E[R]=Or(we()[k+4*R>>>2>>>0],"parameter "+R);return E},pg=(S,k)=>Object.defineProperty(k,"name",{value:S});function fg(S,k,E){var R=(k=u1(S,k>>>0)).shift();S--;var L=`return function (obj, func, destructorsRef, args) {
`,j=0,re=[];E===0&&re.push("obj");for(var ge=["retType"],Se=[R],Re=0;Re<S;++Re)re.push("arg"+Re),ge.push("argType"+Re),Se.push(k[Re]),L+=`  var arg${Re} = argType${Re}.readValueFromPointer(args${j?"+"+j:""});
`,j+=k[Re].zd;return L+=`  var rv = ${E===1?"new func":"func.call"}(${re.join(", ")});
`,R.Qd||(ge.push("emval_returnValue"),Se.push(Vc),L+=`  return emval_returnValue(retType, destructorsRef, rv);
`),ge.push(L+`};
`),S=function(Le){var We=Function;if(!(We instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof We} which is not a function`);var at=pg(We.name||"unknownFunctionName",function(){});return at.prototype=We.prototype,at=new at,(Le=We.apply(at,Le))instanceof Object?Le:at}(ge)(...Se),E=`methodCaller<(${k.map(Le=>Le.name).join(", ")}) => ${R.name}>`,l1(pg(E,S))}function c1(S){return S=Gc(S>>>0),Xs(a[S])}function d1(S,k){return k>>>=0,S=us(S>>>0),k=us(k),Xs(S[k])}function h1(S){9<(S>>>=0)&&(ea[S+1]+=1)}function p1(){return Xs([])}function Dh(S){S=us(S>>>0);for(var k=Array(S.length),E=0;E<S.length;E++)k[E]=S[E];return Xs(k)}function f1(S){return Xs(Gc(S>>>0))}function m1(){return Xs({})}function g1(S){for(var k=us(S>>>=0);k.length;){var E=k.pop();k.pop()(E)}_h(S)}function mg(S,k,E){k>>>=0,E>>>=0,S=us(S>>>0),k=us(k),E=us(E),S[k]=E}function y1(S,k){return k>>>=0,S=(S=Or(S>>>0,"_emval_take_value")).readValueFromPointer(k),Xs(S)}function b1(S,k){S=-9007199254740992>S||9007199254740992<S?NaN:Number(S),k>>>=0,S=new Date(1e3*S),J()[k>>>2>>>0]=S.getUTCSeconds(),J()[k+4>>>2>>>0]=S.getUTCMinutes(),J()[k+8>>>2>>>0]=S.getUTCHours(),J()[k+12>>>2>>>0]=S.getUTCDate(),J()[k+16>>>2>>>0]=S.getUTCMonth(),J()[k+20>>>2>>>0]=S.getUTCFullYear()-1900,J()[k+24>>>2>>>0]=S.getUTCDay(),S=(S.getTime()-Date.UTC(S.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,J()[k+28>>>2>>>0]=S}var gg=S=>S%4==0&&(S%100!=0||S%400==0),yg=[0,31,60,91,121,152,182,213,244,274,305,335],bg=[0,31,59,90,120,151,181,212,243,273,304,334];function x1(S,k){S=-9007199254740992>S||9007199254740992<S?NaN:Number(S),k>>>=0,S=new Date(1e3*S),J()[k>>>2>>>0]=S.getSeconds(),J()[k+4>>>2>>>0]=S.getMinutes(),J()[k+8>>>2>>>0]=S.getHours(),J()[k+12>>>2>>>0]=S.getDate(),J()[k+16>>>2>>>0]=S.getMonth(),J()[k+20>>>2>>>0]=S.getFullYear()-1900,J()[k+24>>>2>>>0]=S.getDay();var E=(gg(S.getFullYear())?yg:bg)[S.getMonth()]+S.getDate()-1|0;J()[k+28>>>2>>>0]=E,J()[k+36>>>2>>>0]=-60*S.getTimezoneOffset(),E=new Date(S.getFullYear(),6,1).getTimezoneOffset();var R=new Date(S.getFullYear(),0,1).getTimezoneOffset();S=0|(E!=R&&S.getTimezoneOffset()==Math.min(R,E)),J()[k+32>>>2>>>0]=S}function w1(S){S>>>=0;var k=new Date(J()[S+20>>>2>>>0]+1900,J()[S+16>>>2>>>0],J()[S+12>>>2>>>0],J()[S+8>>>2>>>0],J()[S+4>>>2>>>0],J()[S>>>2>>>0],0),E=J()[S+32>>>2>>>0],R=k.getTimezoneOffset(),L=new Date(k.getFullYear(),6,1).getTimezoneOffset(),j=new Date(k.getFullYear(),0,1).getTimezoneOffset(),re=Math.min(j,L);return 0>E?J()[S+32>>>2>>>0]=+(L!=j&&re==R):0<E!=(re==R)&&(L=Math.max(j,L),k.setTime(k.getTime()+6e4*((0<E?re:L)-R))),J()[S+24>>>2>>>0]=k.getDay(),E=(gg(k.getFullYear())?yg:bg)[k.getMonth()]+k.getDate()-1|0,J()[S+28>>>2>>>0]=E,J()[S>>>2>>>0]=k.getSeconds(),J()[S+4>>>2>>>0]=k.getMinutes(),J()[S+8>>>2>>>0]=k.getHours(),J()[S+12>>>2>>>0]=k.getDate(),J()[S+16>>>2>>>0]=k.getMonth(),J()[S+20>>>2>>>0]=k.getYear(),S=k.getTime(),BigInt(isNaN(S)?-1:S/1e3)}function xg(S,k,E,R,L,j,re){return c?Et(16,1,S,k,E,R,L,j,re):-52}function wg(S,k,E,R,L,j){if(c)return Et(17,1,S,k,E,R,L,j)}var Gi={},cu=()=>performance.timeOrigin+performance.now();function vg(S,k){if(c)return Et(18,1,S,k);if(Gi[S]&&(clearTimeout(Gi[S].id),delete Gi[S]),!k)return 0;var E=setTimeout(()=>{delete Gi[S],su(()=>Uh(S,performance.timeOrigin+performance.now()))},k);return Gi[S]={id:E,ke:k},0}function $g(S,k,E,R){S>>>=0,k>>>=0,E>>>=0,R>>>=0;var L=new Date().getFullYear(),j=new Date(L,0,1).getTimezoneOffset();L=new Date(L,6,1).getTimezoneOffset();var re=Math.max(j,L);we()[S>>>2>>>0]=60*re,J()[k>>>2>>>0]=+(j!=L),S=(k=ge=>{var Se=Math.abs(ge);return`UTC${0<=ge?"-":"+"}${String(Math.floor(Se/60)).padStart(2,"0")}${String(Se%60).padStart(2,"0")}`})(j),k=k(L),L<j?(si(S,E,17),si(k,R,17)):(si(S,R,17),si(k,E,17))}var Sg=()=>Date.now();function _g(S,k,E){return 0<=S&&3>=S?(S===0?S=Date.now():S=performance.timeOrigin+performance.now(),Q[E>>>0>>>3]=BigInt(Math.round(1e6*S)),0):28}var Hc=[],Oh=(S,k)=>{Hc.length=0;for(var E;E=Y()[S++>>>0];){var R=E!=105;k+=(R&=E!=112)&&k%8?4:0,Hc.push(E==112?we()[k>>>2>>>0]:E==106?Q[k>>>3]:E==105?J()[k>>>2>>>0]:Fe()[k>>>3>>>0]),k+=R?8:4}return Hc};function Go(S,k,E){return S>>>=0,k=Oh(k>>>0,E>>>0),Ss[S](...k)}function v1(S,k,E){return S>>>=0,k=Oh(k>>>0,E>>>0),Ss[S](...k)}var $1=()=>{};function S1(S,k){return C(Yt(S>>>0,k>>>0))}var Cg=()=>{throw Pn+=1,"unwind"};function Tg(){return 4294901760}var du=()=>navigator.hardwareConcurrency;function hu(){return Nt("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function _1(S){S>>>=0;var k=Y().length;if(S<=k||4294901760<S)return!1;for(var E=1;4>=E;E*=2){var R=k*(1+.2/E);R=Math.min(R,S+100663296);e:{R=(Math.min(4294901760,65536*Math.ceil(Math.max(S,R)/65536))-I.buffer.byteLength+65535)/65536|0;try{I.grow(R),Pe();var L=1;break e}catch{}L=void 0}if(L)return!0}return!1}var Hi=()=>(Nt("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),Ho={},zh=S=>{S.forEach(k=>{Hi()})};function Fh(){var S=Error().stack.toString().split(`
`);return S[0]=="Error"&&S.shift(),zh(S),Ho.Kd=Hi(),Ho.ae=S,Ho.Kd}function Lh(S,k,E){if(S>>>=0,k>>>=0,Ho.Kd==S)var R=Ho.ae;else(R=Error().stack.toString().split(`
`))[0]=="Error"&&R.shift(),zh(R);for(var L=3;R[L]&&Hi()!=S;)++L;for(S=0;S<E&&R[S+L];++S)J()[k+4*S>>>2>>>0]=Hi();return S}var qc,jc={},Mh=()=>{if(!qc){var S,k={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:"./this.program"};for(S in jc)jc[S]===void 0?delete k[S]:k[S]=jc[S];var E=[];for(S in k)E.push(`${S}=${k[S]}`);qc=E}return qc};function kg(S,k){if(c)return Et(19,1,S,k);S>>>=0,k>>>=0;var E=0;return Mh().forEach((R,L)=>{var j=k+E;for(L=we()[S+4*L>>>2>>>0]=j,j=0;j<R.length;++j)G()[L++>>>0]=R.charCodeAt(j);G()[L>>>0]=0,E+=R.length+1}),0}function Ng(S,k){if(c)return Et(20,1,S,k);S>>>=0,k>>>=0;var E=Mh();we()[S>>>2>>>0]=E.length;var R=0;return E.forEach(L=>R+=L.length+1),we()[k>>>2>>>0]=R,0}function Ig(S){return c?Et(21,1,S):52}function Eg(S,k,E,R){return c?Et(22,1,S,k,E,R):52}function Ag(S,k,E,R){return c?Et(23,1,S,k,E,R):70}var Ys=[null,[],[]];function qo(S,k,E,R){if(c)return Et(24,1,S,k,E,R);k>>>=0,E>>>=0,R>>>=0;for(var L=0,j=0;j<E;j++){var re=we()[k>>>2>>>0],ge=we()[k+4>>>2>>>0];k+=8;for(var Se=0;Se<ge;Se++){var Re=Y()[re+Se>>>0],Le=Ys[S];Re===0||Re===10?((S===1?T:C)(tg(Le)),Le.length=0):Le.push(Re)}L+=ge}return we()[R>>>2>>>0]=L,0}function Rg(S){return S>>>0}c||function(){for(var S=a.numThreads-1;S--;)Qm();ln.unshift(()=>{Dt++,function(k){c?k():Promise.all(dr.map(zs)).then(k)}(()=>Ct())})}();for(var Bh=Array(256),pu=0;256>pu;++pu)Bh[pu]=String.fromCharCode(pu);$h=Bh,Fs=a.BindingError=class extends Error{constructor(S){super(S),this.name="BindingError"}},a.InternalError=class extends Error{constructor(S){super(S),this.name="InternalError"}},ea.push(0,1,void 0,1,null,1,!0,1,!1,1),a.count_emval_handles=()=>ea.length/2-5-Ls.length;var Ie,Ph=[_s,ti,yh,es,Cs,ng,sg,wh,Fo,Lc,ri,Vi,Lo,Ui,Fn,vh,xg,wg,vg,kg,Ng,Ig,Eg,Ag,qo];(async function(){function S(R,L){return Ie=R.exports,Ie=function(){var j=Ie,re={};for(let[ge,Se]of Object.entries(j))re[ge]=typeof Se=="function"?(...Re)=>{ta.push(ge);try{return Se(...Re)}finally{ee||(ta.pop(),Fr&&zr===1&&ta.length===0&&(zr=0,Pn+=1,Wi(Jo),typeof Fibers<"u"&&Fibers.le()))}}:Se;return re}(),Ie=function(){var j=Ie,re=Se=>Re=>Se(Re)>>>0,ge=Se=>()=>Se()>>>0;return(j=Object.assign({},j)).Cb=re(j.Cb),j.fc=ge(j.fc),j.ic=re(j.ic),j.vc=re(j.vc),j.wc=ge(j.wc),j.Ac=re(j.Ac),j}(),Rr.push(Ie.jc),A=L,Ct(),Ie}Dt++;var k=Gt();if(a.instantiateWasm)return new Promise(R=>{a.instantiateWasm(k,(L,j)=>{S(L,j),R(L.exports)})});if(c)return new Promise(R=>{Ve=L=>{var j=new WebAssembly.Instance(L,Gt());R(S(j,L))}});yt??(yt=a.locateFile?a.locateFile?a.locateFile("ort-wasm-simd-threaded.jsep.wasm",w):w+"ort-wasm-simd-threaded.jsep.wasm":new URL("/test-onnnx/assets/ort-wasm-simd-threaded.jsep-D5Jk56-t.wasm",import.meta.url).href);try{var E=await async function(R){var L=yt;if(!se&&typeof WebAssembly.instantiateStreaming=="function"&&!U(L))try{var j=fetch(L,{credentials:"same-origin"});return await WebAssembly.instantiateStreaming(j,R)}catch(re){C(`wasm streaming compile failed: ${re}`),C("falling back to ArrayBuffer instantiation")}return async function(re,ge){try{var Se=await async function(Re){if(!se)try{var Le=await f(Re);return new Uint8Array(Le)}catch{}if(Re==yt&&se)Re=new Uint8Array(se);else{if(!g)throw"both async and sync fetching of the wasm failed";Re=g(Re)}return Re}(re);return await WebAssembly.instantiate(Se,ge)}catch(Re){C(`failed to asynchronously prepare wasm: ${Re}`),Nt(Re)}}(L,R)}(k);return S(E.instance,E.module)}catch(R){return r(R),Promise.reject(R)}})();var Dg=S=>(Dg=Ie.Cb)(S),Og=()=>(Og=Ie.Db)();a._OrtInit=(S,k)=>(a._OrtInit=Ie.Eb)(S,k),a._OrtGetLastError=(S,k)=>(a._OrtGetLastError=Ie.Fb)(S,k),a._OrtCreateSessionOptions=(S,k,E,R,L,j,re,ge,Se,Re)=>(a._OrtCreateSessionOptions=Ie.Gb)(S,k,E,R,L,j,re,ge,Se,Re),a._OrtAppendExecutionProvider=(S,k)=>(a._OrtAppendExecutionProvider=Ie.Hb)(S,k),a._OrtAddFreeDimensionOverride=(S,k,E)=>(a._OrtAddFreeDimensionOverride=Ie.Ib)(S,k,E),a._OrtAddSessionConfigEntry=(S,k,E)=>(a._OrtAddSessionConfigEntry=Ie.Jb)(S,k,E),a._OrtReleaseSessionOptions=S=>(a._OrtReleaseSessionOptions=Ie.Kb)(S),a._OrtCreateSession=(S,k,E)=>(a._OrtCreateSession=Ie.Lb)(S,k,E),a._OrtReleaseSession=S=>(a._OrtReleaseSession=Ie.Mb)(S),a._OrtGetInputOutputCount=(S,k,E)=>(a._OrtGetInputOutputCount=Ie.Nb)(S,k,E),a._OrtGetInputName=(S,k)=>(a._OrtGetInputName=Ie.Ob)(S,k),a._OrtGetOutputName=(S,k)=>(a._OrtGetOutputName=Ie.Pb)(S,k),a._OrtFree=S=>(a._OrtFree=Ie.Qb)(S),a._OrtCreateTensor=(S,k,E,R,L,j)=>(a._OrtCreateTensor=Ie.Rb)(S,k,E,R,L,j),a._OrtGetTensorData=(S,k,E,R,L)=>(a._OrtGetTensorData=Ie.Sb)(S,k,E,R,L),a._OrtReleaseTensor=S=>(a._OrtReleaseTensor=Ie.Tb)(S),a._OrtCreateRunOptions=(S,k,E,R)=>(a._OrtCreateRunOptions=Ie.Ub)(S,k,E,R),a._OrtAddRunConfigEntry=(S,k,E)=>(a._OrtAddRunConfigEntry=Ie.Vb)(S,k,E),a._OrtReleaseRunOptions=S=>(a._OrtReleaseRunOptions=Ie.Wb)(S),a._OrtCreateBinding=S=>(a._OrtCreateBinding=Ie.Xb)(S),a._OrtBindInput=(S,k,E)=>(a._OrtBindInput=Ie.Yb)(S,k,E),a._OrtBindOutput=(S,k,E,R)=>(a._OrtBindOutput=Ie.Zb)(S,k,E,R),a._OrtClearBoundOutputs=S=>(a._OrtClearBoundOutputs=Ie._b)(S),a._OrtReleaseBinding=S=>(a._OrtReleaseBinding=Ie.$b)(S),a._OrtRunWithBinding=(S,k,E,R,L)=>(a._OrtRunWithBinding=Ie.ac)(S,k,E,R,L),a._OrtRun=(S,k,E,R,L,j,re,ge)=>(a._OrtRun=Ie.bc)(S,k,E,R,L,j,re,ge),a._OrtEndProfiling=S=>(a._OrtEndProfiling=Ie.cc)(S),a._JsepOutput=(S,k,E)=>(a._JsepOutput=Ie.dc)(S,k,E),a._JsepGetNodeName=S=>(a._JsepGetNodeName=Ie.ec)(S);var Ea=()=>(Ea=Ie.fc)(),fr=a._free=S=>(fr=a._free=Ie.gc)(S),ii=a._malloc=S=>(ii=a._malloc=Ie.ic)(S),fu=(S,k,E,R,L,j)=>(fu=Ie.kc)(S,k,E,R,L,j),Vh=()=>(Vh=Ie.lc)(),oi=(S,k,E,R,L)=>(oi=Ie.mc)(S,k,E,R,L),qi=S=>(qi=Ie.nc)(S),mu=S=>(mu=Ie.oc)(S),Uh=(S,k)=>(Uh=Ie.pc)(S,k),li=()=>(li=Ie.qc)(),lt=(S,k)=>(lt=Ie.rc)(S,k),jo=S=>(jo=Ie.sc)(S),Wh=(S,k)=>(Wh=Ie.tc)(S,k),ot=S=>(ot=Ie.uc)(S),Gh=S=>(Gh=Ie.vc)(S),ut=()=>(ut=Ie.wc)(),Hh=S=>(Hh=Ie.xc)(S),qh=S=>(qh=Ie.yc)(S),jh=(S,k,E)=>(jh=Ie.zc)(S,k,E),mr=S=>(mr=Ie.Ac)(S),Zs=a.dynCall_iii=(S,k,E)=>(Zs=a.dynCall_iii=Ie.Bc)(S,k,E),ji=a.dynCall_vi=(S,k)=>(ji=a.dynCall_vi=Ie.Cc)(S,k),gu=a.dynCall_ii=(S,k)=>(gu=a.dynCall_ii=Ie.Dc)(S,k),yu=a.dynCall_vii=(S,k,E)=>(yu=a.dynCall_vii=Ie.Ec)(S,k,E),bu=a.dynCall_iiii=(S,k,E,R)=>(bu=a.dynCall_iiii=Ie.Fc)(S,k,E,R),Kc=a.dynCall_viii=(S,k,E,R)=>(Kc=a.dynCall_viii=Ie.Gc)(S,k,E,R),Aa=a.dynCall_iiiii=(S,k,E,R,L)=>(Aa=a.dynCall_iiiii=Ie.Hc)(S,k,E,R,L),Kh=a.dynCall_viiii=(S,k,E,R,L)=>(Kh=a.dynCall_viiii=Ie.Ic)(S,k,E,R,L),xu=a.dynCall_viiiiii=(S,k,E,R,L,j,re)=>(xu=a.dynCall_viiiiii=Ie.Jc)(S,k,E,R,L,j,re),Ki=a.dynCall_viiiiiii=(S,k,E,R,L,j,re,ge)=>(Ki=a.dynCall_viiiiiii=Ie.Kc)(S,k,E,R,L,j,re,ge),Xh=a.dynCall_ji=(S,k)=>(Xh=a.dynCall_ji=Ie.Lc)(S,k),Qs=a.dynCall_v=S=>(Qs=a.dynCall_v=Ie.Mc)(S),Xi=a.dynCall_viiiii=(S,k,E,R,L,j)=>(Xi=a.dynCall_viiiii=Ie.Nc)(S,k,E,R,L,j),Yi=a.dynCall_i=S=>(Yi=a.dynCall_i=Ie.Oc)(S),wu=a.dynCall_fii=(S,k,E)=>(wu=a.dynCall_fii=Ie.Pc)(S,k,E),vu=a.dynCall_viiiiiiii=(S,k,E,R,L,j,re,ge,Se)=>(vu=a.dynCall_viiiiiiii=Ie.Qc)(S,k,E,R,L,j,re,ge,Se),Js=a.dynCall_viiiiiiiiii=(S,k,E,R,L,j,re,ge,Se,Re,Le)=>(Js=a.dynCall_viiiiiiiiii=Ie.Rc)(S,k,E,R,L,j,re,ge,Se,Re,Le),er=a.dynCall_jiii=(S,k,E,R)=>(er=a.dynCall_jiii=Ie.Sc)(S,k,E,R),ui=a.dynCall_dii=(S,k,E)=>(ui=a.dynCall_dii=Ie.Tc)(S,k,E),na=a.dynCall_viiiiiiiii=(S,k,E,R,L,j,re,ge,Se,Re)=>(na=a.dynCall_viiiiiiiii=Ie.Uc)(S,k,E,R,L,j,re,ge,Se,Re),sa=a.dynCall_viiiiiiiiiii=(S,k,E,R,L,j,re,ge,Se,Re,Le,We)=>(sa=a.dynCall_viiiiiiiiiii=Ie.Vc)(S,k,E,R,L,j,re,ge,Se,Re,Le,We),ci=a.dynCall_iiiiii=(S,k,E,R,L,j)=>(ci=a.dynCall_iiiiii=Ie.Wc)(S,k,E,R,L,j),Yh=a.dynCall_iij=(S,k,E)=>(Yh=a.dynCall_iij=Ie.Xc)(S,k,E),Xc=a.dynCall_iiiiiiiiii=(S,k,E,R,L,j,re,ge,Se,Re)=>(Xc=a.dynCall_iiiiiiiiii=Ie.Yc)(S,k,E,R,L,j,re,ge,Se,Re),Yc=a.dynCall_iiiiiiiiiii=(S,k,E,R,L,j,re,ge,Se,Re,Le)=>(Yc=a.dynCall_iiiiiiiiiii=Ie.Zc)(S,k,E,R,L,j,re,ge,Se,Re,Le),cs=a.dynCall_vij=(S,k,E)=>(cs=a.dynCall_vij=Ie._c)(S,k,E),Un=a.dynCall_iiif=(S,k,E,R)=>(Un=a.dynCall_iiif=Ie.$c)(S,k,E,R),Mt=a.dynCall_iiij=(S,k,E,R)=>(Mt=a.dynCall_iiij=Ie.ad)(S,k,E,R),gr=a.dynCall_fiii=(S,k,E,R)=>(gr=a.dynCall_fiii=Ie.bd)(S,k,E,R),Lr=a.dynCall_viiiiiiiiiiiii=(S,k,E,R,L,j,re,ge,Se,Re,Le,We,at,Ht)=>(Lr=a.dynCall_viiiiiiiiiiiii=Ie.cd)(S,k,E,R,L,j,re,ge,Se,Re,Le,We,at,Ht),Zc=a.dynCall_vjiii=(S,k,E,R,L)=>(Zc=a.dynCall_vjiii=Ie.dd)(S,k,E,R,L),di=a.dynCall_vif=(S,k,E)=>(di=a.dynCall_vif=Ie.ed)(S,k,E),Zh=a.dynCall_iiiiiii=(S,k,E,R,L,j,re)=>(Zh=a.dynCall_iiiiiii=Ie.fd)(S,k,E,R,L,j,re),Qh=a.dynCall_iiiij=(S,k,E,R,L)=>(Qh=a.dynCall_iiiij=Ie.gd)(S,k,E,R,L),Ko=a.dynCall_iiiiiiii=(S,k,E,R,L,j,re,ge)=>(Ko=a.dynCall_iiiiiiii=Ie.hd)(S,k,E,R,L,j,re,ge),Xo=a.dynCall_viiiiiiiiiiii=(S,k,E,R,L,j,re,ge,Se,Re,Le,We,at)=>(Xo=a.dynCall_viiiiiiiiiiii=Ie.id)(S,k,E,R,L,j,re,ge,Se,Re,Le,We,at),Yo=a.dynCall_diii=(S,k,E,R)=>(Yo=a.dynCall_diii=Ie.jd)(S,k,E,R),Zo=a.dynCall_jiiii=(S,k,E,R,L)=>(Zo=a.dynCall_jiiii=Ie.kd)(S,k,E,R,L),Jh=a.dynCall_viiij=(S,k,E,R,L)=>(Jh=a.dynCall_viiij=Ie.ld)(S,k,E,R,L),Qc=a.dynCall_fiiii=(S,k,E,R,L)=>(Qc=a.dynCall_fiiii=Ie.md)(S,k,E,R,L),ep=a.dynCall_viiif=(S,k,E,R,L)=>(ep=a.dynCall_viiif=Ie.nd)(S,k,E,R,L),$u=a.dynCall_diiii=(S,k,E,R,L)=>($u=a.dynCall_diiii=Ie.od)(S,k,E,R,L),tp=a.dynCall_viiid=(S,k,E,R,L)=>(tp=a.dynCall_viiid=Ie.pd)(S,k,E,R,L),Qo=a.dynCall_iiiijii=(S,k,E,R,L,j,re)=>(Qo=a.dynCall_iiiijii=Ie.qd)(S,k,E,R,L,j,re),np=a.dynCall_iiiiiij=(S,k,E,R,L,j,re)=>(np=a.dynCall_iiiiiij=Ie.rd)(S,k,E,R,L,j,re),Zi=S=>(Zi=Ie.sd)(S),Jo=()=>(Jo=Ie.td)(),Su=S=>(Su=Ie.ud)(S),el=()=>(el=Ie.vd)();function Jc(S,k,E){var R=ut();try{yu(S,k,E)}catch(L){if(ot(R),L!==L+0)throw L;lt(1,0)}}function zg(S,k,E){var R=ut();try{return Zs(S,k,E)}catch(L){if(ot(R),L!==L+0)throw L;lt(1,0)}}function Fg(S,k){var E=ut();try{ji(S,k)}catch(R){if(ot(E),R!==R+0)throw R;lt(1,0)}}function Qi(S,k){var E=ut();try{return gu(S,k)}catch(R){if(ot(E),R!==R+0)throw R;lt(1,0)}}function Lg(S,k,E,R){var L=ut();try{return bu(S,k,E,R)}catch(j){if(ot(L),j!==j+0)throw j;lt(1,0)}}function tl(S,k,E,R,L){var j=ut();try{Kh(S,k,E,R,L)}catch(re){if(ot(j),re!==re+0)throw re;lt(1,0)}}function ed(S,k,E,R,L){var j=ut();try{return Aa(S,k,E,R,L)}catch(re){if(ot(j),re!==re+0)throw re;lt(1,0)}}function Mg(S,k,E,R){var L=ut();try{Kc(S,k,E,R)}catch(j){if(ot(L),j!==j+0)throw j;lt(1,0)}}function sp(S,k,E,R,L,j,re){var ge=ut();try{return Zh(S,k,E,R,L,j,re)}catch(Se){if(ot(ge),Se!==Se+0)throw Se;lt(1,0)}}function rp(S){var k=ut();try{Qs(S)}catch(E){if(ot(k),E!==E+0)throw E;lt(1,0)}}function yr(S,k,E){var R=ut();try{return Yh(S,k,E)}catch(L){if(ot(R),L!==L+0)throw L;lt(1,0)}}function ra(S,k,E,R,L,j){var re=ut();try{Xi(S,k,E,R,L,j)}catch(ge){if(ot(re),ge!==ge+0)throw ge;lt(1,0)}}function hi(S,k,E){var R=ut();try{cs(S,k,E)}catch(L){if(ot(R),L!==L+0)throw L;lt(1,0)}}function Bg(S,k,E,R,L,j,re){var ge=ut();try{xu(S,k,E,R,L,j,re)}catch(Se){if(ot(ge),Se!==Se+0)throw Se;lt(1,0)}}function pi(S,k,E,R,L,j,re,ge){var Se=ut();try{Ki(S,k,E,R,L,j,re,ge)}catch(Re){if(ot(Se),Re!==Re+0)throw Re;lt(1,0)}}function Ra(S,k,E,R,L,j){var re=ut();try{return ci(S,k,E,R,L,j)}catch(ge){if(ot(re),ge!==ge+0)throw ge;lt(1,0)}}function Ln(S,k,E,R,L,j,re,ge){var Se=ut();try{return Ko(S,k,E,R,L,j,re,ge)}catch(Re){if(ot(Se),Re!==Re+0)throw Re;lt(1,0)}}function td(S,k,E,R,L,j,re,ge,Se,Re){var Le=ut();try{na(S,k,E,R,L,j,re,ge,Se,Re)}catch(We){if(ot(Le),We!==We+0)throw We;lt(1,0)}}function C1(S,k,E,R,L,j,re,ge,Se){var Re=ut();try{vu(S,k,E,R,L,j,re,ge,Se)}catch(Le){if(ot(Re),Le!==Le+0)throw Le;lt(1,0)}}function T1(S){var k=ut();try{return Yi(S)}catch(E){if(ot(k),E!==E+0)throw E;lt(1,0)}}function k1(S,k,E,R,L,j,re,ge,Se,Re){var Le=ut();try{return Xc(S,k,E,R,L,j,re,ge,Se,Re)}catch(We){if(ot(Le),We!==We+0)throw We;lt(1,0)}}function Mn(S,k,E){var R=ut();try{return wu(S,k,E)}catch(L){if(ot(R),L!==L+0)throw L;lt(1,0)}}function ap(S,k,E,R){var L=ut();try{return er(S,k,E,R)}catch(j){if(ot(L),j!==j+0)throw j;return lt(1,0),0n}}function _u(S,k,E){var R=ut();try{return ui(S,k,E)}catch(L){if(ot(R),L!==L+0)throw L;lt(1,0)}}function Cu(S,k,E,R,L,j,re,ge,Se,Re,Le,We){var at=ut();try{sa(S,k,E,R,L,j,re,ge,Se,Re,Le,We)}catch(Ht){if(ot(at),Ht!==Ht+0)throw Ht;lt(1,0)}}function ip(S,k,E,R,L,j,re,ge,Se,Re,Le){var We=ut();try{Js(S,k,E,R,L,j,re,ge,Se,Re,Le)}catch(at){if(ot(We),at!==at+0)throw at;lt(1,0)}}function nl(S,k,E,R,L,j,re,ge,Se,Re,Le){var We=ut();try{return Yc(S,k,E,R,L,j,re,ge,Se,Re,Le)}catch(at){if(ot(We),at!==at+0)throw at;lt(1,0)}}function sl(S,k,E,R){var L=ut();try{return Un(S,k,E,R)}catch(j){if(ot(L),j!==j+0)throw j;lt(1,0)}}function N1(S,k,E,R){var L=ut();try{return Mt(S,k,E,R)}catch(j){if(ot(L),j!==j+0)throw j;lt(1,0)}}function Pg(S,k,E,R){var L=ut();try{return gr(S,k,E,R)}catch(j){if(ot(L),j!==j+0)throw j;lt(1,0)}}function I1(S,k,E,R,L,j,re,ge,Se,Re,Le,We,at,Ht){var ks=ut();try{Lr(S,k,E,R,L,j,re,ge,Se,Re,Le,We,at,Ht)}catch(no){if(ot(ks),no!==no+0)throw no;lt(1,0)}}function Vg(S,k,E,R,L){var j=ut();try{Zc(S,k,E,R,L)}catch(re){if(ot(j),re!==re+0)throw re;lt(1,0)}}function Ji(S,k,E){var R=ut();try{di(S,k,E)}catch(L){if(ot(R),L!==L+0)throw L;lt(1,0)}}function op(S,k){var E=ut();try{return Xh(S,k)}catch(R){if(ot(E),R!==R+0)throw R;return lt(1,0),0n}}function nd(S,k,E,R,L){var j=ut();try{return Qh(S,k,E,R,L)}catch(re){if(ot(j),re!==re+0)throw re;lt(1,0)}}function Ug(S,k,E,R,L,j,re,ge,Se,Re,Le,We,at){var Ht=ut();try{Xo(S,k,E,R,L,j,re,ge,Se,Re,Le,We,at)}catch(ks){if(ot(Ht),ks!==ks+0)throw ks;lt(1,0)}}function fi(S,k,E,R){var L=ut();try{return Yo(S,k,E,R)}catch(j){if(ot(L),j!==j+0)throw j;lt(1,0)}}function wt(S,k,E,R,L){var j=ut();try{return Zo(S,k,E,R,L)}catch(re){if(ot(j),re!==re+0)throw re;return lt(1,0),0n}}function Zt(S,k,E,R,L){var j=ut();try{Jh(S,k,E,R,L)}catch(re){if(ot(j),re!==re+0)throw re;lt(1,0)}}function kn(S,k,E,R,L){var j=ut();try{return Qc(S,k,E,R,L)}catch(re){if(ot(j),re!==re+0)throw re;lt(1,0)}}function sd(S,k,E,R,L){var j=ut();try{ep(S,k,E,R,L)}catch(re){if(ot(j),re!==re+0)throw re;lt(1,0)}}function rl(S,k,E,R,L){var j=ut();try{return $u(S,k,E,R,L)}catch(re){if(ot(j),re!==re+0)throw re;lt(1,0)}}function eo(S,k,E,R,L){var j=ut();try{tp(S,k,E,R,L)}catch(re){if(ot(j),re!==re+0)throw re;lt(1,0)}}function rd(S,k,E,R,L,j,re){var ge=ut();try{return Qo(S,k,E,R,L,j,re)}catch(Se){if(ot(ge),Se!==Se+0)throw Se;lt(1,0)}}function Tu(S,k,E,R,L,j,re){var ge=ut();try{return np(S,k,E,R,L,j,re)}catch(Se){if(ot(ge),Se!==Se+0)throw Se;lt(1,0)}}return a.stackSave=()=>ut(),a.stackRestore=S=>ot(S),a.stackAlloc=S=>Gh(S),a.setValue=function(S,k,E="i8"){switch(E.endsWith("*")&&(E="*"),E){case"i1":case"i8":G()[S>>>0]=k;break;case"i16":ce()[S>>>1>>>0]=k;break;case"i32":J()[S>>>2>>>0]=k;break;case"i64":Q[S>>>3]=BigInt(k);break;case"float":Be()[S>>>2>>>0]=k;break;case"double":Fe()[S>>>3>>>0]=k;break;case"*":we()[S>>>2>>>0]=k;break;default:Nt(`invalid type for setValue: ${E}`)}},a.getValue=function(S,k="i8"){switch(k.endsWith("*")&&(k="*"),k){case"i1":case"i8":return G()[S>>>0];case"i16":return ce()[S>>>1>>>0];case"i32":return J()[S>>>2>>>0];case"i64":return Q[S>>>3];case"float":return Be()[S>>>2>>>0];case"double":return Fe()[S>>>3>>>0];case"*":return we()[S>>>2>>>0];default:Nt(`invalid type for getValue: ${k}`)}},a.UTF8ToString=Yt,a.stringToUTF8=si,a.lengthBytesUTF8=Pi,function S(){if(0<Dt)kt=S;else if(c)s(a),pt();else{for(;0<ln.length;)ln.shift()(a);0<Dt?kt=S:(a.calledRun=!0,ee||(pt(),s(a)))}}(),a.PTR_SIZE=4,i}),yP=Av,QE=(e=(t=globalThis.self)==null?void 0:t.name)==null?void 0:e.startsWith("em-pthread"),QE&&Av()}),Rv,JE,Ur,bP,Vy,eA,tA,Dv,nA,Ov,xP,zv,wP,XC=ze(()=>{KC(),Rv=typeof location>"u"?void 0:location.origin,JE=()=>{var t;return(t=import.meta.url)!=null&&t.startsWith("file:")?new URL(new URL("/test-onnnx/assets/ort.bundle.min-OfoG_cy9.mjs",import.meta.url).href,Rv).href:import.meta.url},Ur=JE(),bP=()=>{if(Ur&&!Ur.startsWith("blob:"))return Ur.substring(0,Ur.lastIndexOf("/")+1)},Vy=(t,e)=>{try{let n=e??Ur;return(n?new URL(t,n):new URL(t)).origin===Rv}catch{return!1}},eA=(t,e)=>{let n=e??Ur;try{return(n?new URL(t,n):new URL(t)).href}catch{return}},tA=(t,e)=>`${e??"./"}${t}`,Dv=async t=>{let e=await(await fetch(t,{credentials:"same-origin"})).blob();return URL.createObjectURL(e)},nA=async t=>(await import(t)).default,Ov=(pxe(),H0(fP)).default,xP=async()=>{if(!Ur)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Vy(Ur))return[void 0,Ov()];let t=await Dv(Ur);return[t,Ov(t)]},zv=(fxe(),H0(gP)).default,wP=async(t,e,n)=>{if(!t&&!e&&zv&&Ur&&Vy(Ur))return[void 0,zv];{let s="ort-wasm-simd-threaded.jsep.mjs",r=t??eA(s,e),a=n&&r&&!Vy(r,e),i=a?await Dv(r):r??tA(s,e);return[a?i:void 0,await nA(i)]}}}),Fv,Uy,Up,Lv,sA,rA,YC,ts,Ac=ze(()=>{XC(),Uy=!1,Up=!1,Lv=!1,sA=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},rA=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},YC=async t=>{if(Uy)return Promise.resolve();if(Up)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Lv)throw new Error("previous call to 'initializeWebAssembly()' failed.");Up=!0;let e=t.initTimeout,n=t.numThreads;if(!rA())throw new Error("WebAssembly SIMD is not supported in the current environment.");let s=sA();n>1&&!s&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),t.numThreads=n=1);let r=t.wasmPaths,a=typeof r=="string"?r:void 0,i=r==null?void 0:r.mjs,o=(i==null?void 0:i.href)??i,l=r==null?void 0:r.wasm,c=(l==null?void 0:l.href)??l,h=t.wasmBinary,[p,f]=await wP(o,a,n>1),g=!1,y=[];if(e>0&&y.push(new Promise(x=>{setTimeout(()=>{g=!0,x()},e)})),y.push(new Promise((x,w)=>{let v={numThreads:n};if(h)v.wasmBinary=h;else if(c||a)v.locateFile=$=>c??a+$;else if(o&&o.indexOf("blob:")!==0)v.locateFile=$=>new URL($,o).href;else if(p){let $=bP();$&&(v.locateFile=T=>$+T)}f(v).then($=>{Up=!1,Uy=!0,Fv=$,x(),p&&URL.revokeObjectURL(p)},$=>{Up=!1,Lv=!0,w($)})})),await Promise.race(y),g)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},ts=()=>{if(Uy&&Fv)return Fv;throw new Error("WebAssembly is not initialized yet.")}}),Es,j0,qt,ZC=ze(()=>{Ac(),Es=(t,e)=>{let n=ts(),s=n.lengthBytesUTF8(t)+1,r=n._malloc(s);return n.stringToUTF8(t,r,s),e.push(r),r},j0=(t,e,n,s)=>{if(typeof t=="object"&&t!==null){if(n.has(t))throw new Error("Circular reference in options");n.add(t)}Object.entries(t).forEach(([r,a])=>{let i=e?e+r:r;if(typeof a=="object")j0(a,i+".",n,s);else if(typeof a=="string"||typeof a=="number")s(i,a.toString());else if(typeof a=="boolean")s(i,a?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof a}`)})},qt=t=>{let e=ts(),n=e.stackSave();try{let s=e.PTR_SIZE,r=e.stackAlloc(2*s);e._OrtGetLastError(r,r+s);let a=Number(e.getValue(r,s===4?"i32":"i64")),i=e.getValue(r+s,"*"),o=i?e.UTF8ToString(i):"";throw new Error(`${t} ERROR_CODE: ${a}, ERROR_MESSAGE: ${o}`)}finally{e.stackRestore(n)}}}),vP,mxe=ze(()=>{Ac(),ZC(),vP=t=>{let e=ts(),n=0,s=[],r=t||{};try{if((t==null?void 0:t.logSeverityLevel)===void 0)r.logSeverityLevel=2;else if(typeof t.logSeverityLevel!="number"||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if((t==null?void 0:t.logVerbosityLevel)===void 0)r.logVerbosityLevel=0;else if(typeof t.logVerbosityLevel!="number"||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);(t==null?void 0:t.terminate)===void 0&&(r.terminate=!1);let a=0;return(t==null?void 0:t.tag)!==void 0&&(a=Es(t.tag,s)),n=e._OrtCreateRunOptions(r.logSeverityLevel,r.logVerbosityLevel,!!r.terminate,a),n===0&&qt("Can't create run options."),(t==null?void 0:t.extra)!==void 0&&j0(t.extra,"",new WeakSet,(i,o)=>{let l=Es(i,s),c=Es(o,s);e._OrtAddRunConfigEntry(n,l,c)!==0&&qt(`Can't set a run config entry: ${i} - ${o}.`)}),[n,s]}catch(a){throw n!==0&&e._OrtReleaseRunOptions(n),s.forEach(i=>e._free(i)),a}}}),aA,iA,oA,lA,$P,gxe=ze(()=>{Ac(),ZC(),aA=t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}},iA=t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}},oA=t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});let e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),t.executionProviders&&t.executionProviders.some(n=>(typeof n=="string"?n:n.name)==="webgpu")&&(t.enableMemPattern=!1)},lA=(t,e,n)=>{for(let s of e){let r=typeof s=="string"?s:s.name;switch(r){case"webnn":if(r="WEBNN",typeof s!="string"){let i=s==null?void 0:s.deviceType;if(i){let o=Es("deviceType",n),l=Es(i,n);ts()._OrtAddSessionConfigEntry(t,o,l)!==0&&qt(`Can't set a session config entry: 'deviceType' - ${i}.`)}}break;case"webgpu":if(r="JS",typeof s!="string"){let i=s;if(i!=null&&i.preferredLayout){if(i.preferredLayout!=="NCHW"&&i.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${i.preferredLayout}`);let o=Es("preferredLayout",n),l=Es(i.preferredLayout,n);ts()._OrtAddSessionConfigEntry(t,o,l)!==0&&qt(`Can't set a session config entry: 'preferredLayout' - ${i.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${r}`)}let a=Es(r,n);ts()._OrtAppendExecutionProvider(t,a)!==0&&qt(`Can't append execution provider: ${r}.`)}},$P=t=>{let e=ts(),n=0,s=[],r=t||{};oA(r);try{let a=aA(r.graphOptimizationLevel??"all"),i=iA(r.executionMode??"sequential"),o=typeof r.logId=="string"?Es(r.logId,s):0,l=r.logSeverityLevel??2;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log serverity level is not valid: ${l}`);let c=r.logVerbosityLevel??0;if(!Number.isInteger(c)||c<0||c>4)throw new Error(`log verbosity level is not valid: ${c}`);let h=typeof r.optimizedModelFilePath=="string"?Es(r.optimizedModelFilePath,s):0;if(n=e._OrtCreateSessionOptions(a,!!r.enableCpuMemArena,!!r.enableMemPattern,i,!!r.enableProfiling,0,o,l,c,h),n===0&&qt("Can't create session options."),r.executionProviders&&lA(n,r.executionProviders,s),r.enableGraphCapture!==void 0){if(typeof r.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);let p=Es("enableGraphCapture",s),f=Es(r.enableGraphCapture.toString(),s);e._OrtAddSessionConfigEntry(n,p,f)!==0&&qt(`Can't set a session config entry: 'enableGraphCapture' - ${r.enableGraphCapture}.`)}if(r.freeDimensionOverrides)for(let[p,f]of Object.entries(r.freeDimensionOverrides)){if(typeof p!="string")throw new Error(`free dimension override name must be a string: ${p}`);if(typeof f!="number"||!Number.isInteger(f)||f<0)throw new Error(`free dimension override value must be a non-negative integer: ${f}`);let g=Es(p,s);e._OrtAddFreeDimensionOverride(n,g,f)!==0&&qt(`Can't set a free dimension override: ${p} - ${f}.`)}return r.extra!==void 0&&j0(r.extra,"",new WeakSet,(p,f)=>{let g=Es(p,s),y=Es(f,s);e._OrtAddSessionConfigEntry(n,g,y)!==0&&qt(`Can't set a session config entry: ${p} - ${f}.`)}),[n,s]}catch(a){throw n!==0&&e._OrtReleaseSessionOptions(n)!==0&&qt("Can't release session options."),s.forEach(i=>e._free(i)),a}}}),kd,Xu,Yu,QC,K0,JC,eT,y2,it=ze(()=>{kd=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${t}`)}},Xu=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${t}`)}},Yu=(t,e)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][t],s=typeof e=="number"?e:e.reduce((r,a)=>r*a,1);return n>0?Math.ceil(s*n):void 0},QC=t=>{switch(t){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}},K0=t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${t}`)}},JC=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint8"||t==="bool"||t==="uint4"||t==="int4",eT=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint64"||t==="int8"||t==="uint8"||t==="bool"||t==="uint4"||t==="int4",y2=t=>{switch(t){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${t}`)}}}),tT,SP=ze(()=>{KC(),tT=async t=>{if(typeof t=="string"){let e=await fetch(t);if(!e.ok)throw new Error(`failed to load external data file: ${t}`);let n=e.headers.get("Content-Length"),s=n?parseInt(n,10):0;if(s<1073741824)return new Uint8Array(await e.arrayBuffer());{if(!e.body)throw new Error(`failed to load external data file: ${t}, no response body.`);let r=e.body.getReader(),a;try{a=new ArrayBuffer(s)}catch(o){if(o instanceof RangeError){let l=Math.ceil(s/65536);a=new WebAssembly.Memory({initial:l,maximum:l}).buffer}else throw o}let i=0;for(;;){let{done:o,value:l}=await r.read();if(o)break;let c=l.byteLength;new Uint8Array(a,i,c).set(l),i+=c}return new Uint8Array(a,0,s)}}else return t instanceof Blob?new Uint8Array(await t.arrayBuffer()):t instanceof Uint8Array?t:new Uint8Array(t)}}),uA,cA,dA,hA,nT,pA,zt,zo=ze(()=>{it(),uA=["V","I","W","E","F"],cA=(t,e)=>{console.log(`[${uA[t]},${new Date().toISOString()}]${e}`)},nT=(t,e)=>{dA=t,hA=e},pA=(t,e)=>{let n=K0(t),s=K0(dA);n>=s&&cA(n,typeof e=="function"?e():e)},zt=(...t)=>{hA&&pA(...t)}}),sT,_P=ze(()=>{it(),sT=(t,e)=>new(QC(e))(t)}),rT=ze(()=>{}),Mv,Wy,Gy,fA,mA,Bv,b2,gA,CP,yxe=ze(()=>{zo(),rT(),Mv=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),Wy=[],Gy=t=>Math.ceil(Number(t)/16)*16,fA=t=>{for(let e=0;e<Wy.length;e++){let n=Wy[e];if(t<=n)return n}return Math.ceil(t/16)*16},mA=1,Bv=()=>mA++,b2=async(t,e,n,s)=>{let r=Gy(n),a=t.device.createBuffer({size:r,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let i=t.getCommandEncoder();t.endComputePass(),i.copyBufferToBuffer(e,0,a,0,r),t.flush(),await a.mapAsync(GPUMapMode.READ);let o=a.getMappedRange();if(s){let l=s();return l.set(new Uint8Array(o,0,n)),l}else return new Uint8Array(o.slice(0,n))}finally{a.destroy()}},gA=class{constructor(t){this.backend=t,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[e]of Mv)Wy.push(e),this.freeBuffers.set(e,[]),this.freeUniformBuffers.set(e,[]);this.sessionCount=0}upload(t,e){let n=e.buffer,s=e.byteOffset,r=e.byteLength,a=Gy(r),i=this.storageCache.get(t);if(!i)throw new Error("gpu data for uploading does not exist");if(Number(i.originalSize)!==r)throw new Error(`inconsistent data size. gpu data size=${i.originalSize}, data size=${r}`);let o=this.backend.device.createBuffer({mappedAtCreation:!0,size:a,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),l=o.getMappedRange();new Uint8Array(l).set(new Uint8Array(n,s,r)),o.unmap();let c=this.backend.device.createCommandEncoder();c.copyBufferToBuffer(o,0,i.gpuData.buffer,0,a),this.backend.device.queue.submit([c.finish()]),o.destroy(),zt("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`)}memcpy(t,e){let n=this.storageCache.get(t);if(!n)throw new Error("source gpu data for memcpy does not exist");let s=this.storageCache.get(e);if(!s)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==s.originalSize)throw new Error("inconsistent source and destination gpu data size");let r=Gy(n.originalSize),a=this.backend.getCommandEncoder();this.backend.endComputePass(),a.copyBufferToBuffer(n.gpuData.buffer,0,s.gpuData.buffer,0,r)}registerExternalBuffer(t,e,n){let s;if(n){if(s=n[0],t===n[1])return zt("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${s}, buffer is the same, skip.`),s;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`)}else s=Bv();return this.storageCache.set(s,{gpuData:{id:s,type:0,buffer:t},originalSize:e}),zt("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${s}, registered.`),s}unregisterExternalBuffer(t){t!==void 0&&(this.storageCache.delete(t),zt("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${t}`))}create(t,e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n=fA(t),s,r=(e&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,a=(e&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(r||a){let o=(r?this.freeBuffers:this.freeUniformBuffers).get(n);o?o.length>0?s=o.pop():s=this.backend.device.createBuffer({size:n,usage:e}):s=this.backend.device.createBuffer({size:n,usage:e})}else s=this.backend.device.createBuffer({size:n,usage:e});let i={id:Bv(),type:0,buffer:s};return this.storageCache.set(i.id,{gpuData:i,originalSize:Number(t)}),zt("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${i.id}`),i}get(t){var e;return(e=this.storageCache.get(t))==null?void 0:e.gpuData}release(t){let e=typeof t=="bigint"?Number(t):t,n=this.storageCache.get(e);if(!n){if(this.storageCache.size===0)return 0;throw new Error("releasing data does not exist")}return zt("verbose",()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${n.gpuData.id}`),this.storageCache.delete(e),this.buffersPending.push(n.gpuData.buffer),n.originalSize}async download(t,e){let n=this.storageCache.get(Number(t));if(!n)throw new Error("data does not exist");await b2(this.backend,n.gpuData.buffer,n.originalSize,e)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let t of this.buffersPending){let e=Mv.get(t.size);if((t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let n=this.freeBuffers.get(t.size)||[];e===void 0||n.length>=e?t.destroy():n.push(t)}else if((t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let n=this.freeUniformBuffers.get(t.size)||[];e===void 0||n.length>=e?t.destroy():n.push(t)}else t.destroy()}this.buffersPending=[]}else{let t=this.capturedPendingBuffers.get(this.backend.currentSessionId);t||(t=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,t));for(let e of this.buffersPending)t.push(e);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(t=>{t.forEach(e=>{e.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(e=>{e.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(t=>{t.forEach(e=>{e.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(t){let e=this.capturedPendingBuffers.get(t);e&&(e.forEach(n=>{n.destroy()}),this.capturedPendingBuffers.delete(t)),this.sessionCount-=1,this.sessionCount===0&&(zt("warning",()=>"[WebGPU] Clearing webgpu buffer cache"),this.storageCache.forEach(n=>{n.gpuData.buffer.destroy()}),this.storageCache=new Map)}},CP=(...t)=>new gA(...t)}),yA,Xt,Tn=ze(()=>{yA=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this.key}},Xt=t=>new yA(t)}),bA,Xd,ve,X0,TP,kP,NP,ht=ze(()=>{bA=class{static calcMatMulShape(t,e){return t[1]!==e[0]?void 0:[t[0],e[1]]}},Xd=class{static calcShape(t,e,n=!1){let s=t.length,r=e.length;if(s===0)return e;if(r===0)return t;let a=Math.max(t.length,e.length),i=new Array(a);if(n){if(s<2||r<2)return;let o=bA.calcMatMulShape([t[s-2],t[s-1]],[e[r-2],e[r-1]]);if(o===void 0)return;[i[a-2],i[a-1]]=o}for(let o=n?3:1;o<=a;o++){let l=s-o<0?1:t[s-o],c=r-o<0?1:e[r-o];if(l!==c&&l>1&&c>1)return;let h=Math.max(l,c);if(l&&c)i[a-o]=Math.max(l,c);else{if(h>1)return;i[a-o]=0}}return i}static isValidBroadcast(t,e){let n=t.length,s=e.length;if(n>s)return!1;for(let r=1;r<=n;r++)if(t[n-r]!==1&&t[n-r]!==e[s-r])return!1;return!0}},ve=class p0{static size(e){return p0.getSizeFromDimensionRange(e,0,e.length)}static convertShape(e,n=4){let s=e.length;if(s===0)return[];let r=new Array(s),a=s-1;for(;a>=0;){if(e[a]%n===0){r[a]=e[a]/n;break}if(n%e[a]!==0)throw new Error("cannot convert shape");r[a]=1,n/=e[a],a--}for(a--;a>=0;a--)r[a]=e[a];return r}static sizeFromDimension(e,n){if(n<0||n>e.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return p0.getSizeFromDimensionRange(e,n,e.length)}static sizeToDimension(e,n){if(n<0||n>e.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${e.length} dimensions.`);return p0.getSizeFromDimensionRange(e,0,n)}static getSizeFromDimensionRange(e,n,s){let r=1;for(let a=n;a<s;a++){if(e[a]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");r*=Number(e[a])}return r}static computeStrides(e){let n=e.length;if(n===0)return[];if(n===1)return[1];let s=new Array(n);s[n-1]=1,s[n-2]=e[n-1];for(let r=n-3;r>=0;--r)s[r]=s[r+1]*e[r+1];return s}static normalizeAxis(e,n){if(e<-n&&e>=n)throw new Error("unsupported axis for this operation.");return e<0?e+n:e}static normalizeAxes(e,n){return e.map(s=>this.normalizeAxis(s,n??e.length))}static sortBasedOnPerm(e,n){return n?n.map(s=>e[s]):e.slice().reverse()}static padShape(e,n){let s=e.length;return e.map((r,a)=>r+n[a]+n[a+s])}static areEqual(e,n){return e.length!==n.length?!1:e.every((s,r)=>s===n[r])}},X0=class sf{static adjustPoolAttributes(e,n,s,r,a,i){if(!e&&s.length!==n.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let o=0;o<n.length-2;o++)o>=s.length?s.push(n[o+2]):s[o]=n[o+2];for(let o=0;o<s.length;o++)if(o<r.length){if(r[o]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let o=0;o<s.length;o++)if(o<a.length){if(a[o]<0)throw new Error("dilations should be greater than or equal to 1")}else a.push(1);for(let o=0;o<s.length*2;o++)if(o<i.length){if(i[o]<0)throw new Error("pad should be greater than or equal to 1")}else i.push(0);for(let o=0;o<s.length;o++){if(s[o]<=0)throw new Error("kernel shapes need to be greater than 0");if(i[o]>=s[o]||i[o+s.length]>=s[o])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,n,s,r,a,i,o){if(o){if(a.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(r.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let l=0;l<e.length-2;l++)sf.adjustPadAndReturnShape(e[l+(i?1:2)],n[l],s[l],r[l],a,l,l+e.length-2,o)}}static computePoolOutputShape(e,n,s,r,a,i,o){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let l=[n[0],n[1]];return sf.computeShapeHelper(e,n,l,s,r,a,i,o),l}static computeConvOutputShape(e,n,s,r,a,i,o){if(e.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let l=[e[0],n[0]];return sf.computeShapeHelper(!1,e,l,s,r,a,i,o),l}static computeShapeHelper(e,n,s,r,a,i,o,l){if(e)for(let c=0;c<n.length-2;c++)s.push(1);else for(let c=0;c<n.length-2;c++)s.push(sf.adjustPadAndReturnShape(n[c+2],r[c],a[c],i[c],o,c,c+n.length-2,l))}static adjustPadAndReturnShape(e,n,s,r,a,i,o,l){let c=s*(r-1)+1;if(l&&l!=="NOTSET")switch(l){case"VALID":return a[i]=0,a[o]=0,Math.floor((e-c)/n+1);case"SAME_LOWER":case"SAME_UPPER":if(s!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let h=((e+n-1)/n-1)*n+r-e;return a[i]=Math.floor(l==="SAME_LOWER"?(h+1)/2:h/2),a[o]=h-a[i],Math.floor((e+h-r)/n+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((e+a[i]+a[o]-c)/n+1)}},TP=class{static getShapeOfGemmResult(t,e,n,s,r){if(t.length!==2||n.length!==2)throw new Error("shape need to be of size 2");let a,i,o;e?(a=t[1],i=t[0]):(a=t[0],i=t[1]);let l=-1;if(s?(o=n[0],l=1):(o=n[1],l=0),n[l]!==i)throw new Error("dimension mismatch");if(a<=0||o<=0||i<=0)throw new Error("invalid shape specified");if(r&&!Xd.isValidBroadcast(r,[a,o]))throw new Error("gemm: invalid bias shape for broadcast");return[a,o,i]}},kP=-34028234663852886e22,NP=34028234663852886e22}),Yd,Hy,is,Ps,Je,bn,x2,Id,Ul,Ke,Wp,Te,je,IP,aT,xA,EP,mt=ze(()=>{it(),ht(),Yd=64,Hy=(t,e)=>{if(e===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(t)){case 10:return e>1?`vec${e}<f16>`:"f16";case 1:return e>1?`vec${e}<f32>`:"f32";case 6:return e>1?`vec${e}<i32>`:"i32";case 12:return e>1?`vec${e}<u32>`:"u32";case 7:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(e!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${t}`)}},is=(t,e=1)=>{let n=Hy(t,e);return typeof n=="string"?n:n[0]},Ps=(t,e=1)=>{let n=Hy(t,e);return typeof n=="string"?n:n[1]},Je=(...t)=>{let e=[];return t.forEach(n=>{n.length!==0&&e.push({type:12,data:n},{type:12,data:ve.computeStrides(n)})}),e},bn=t=>t%4===0?4:t%2===0?2:1,x2=(t="f32",e,n="0")=>!e||e===1?`${t}(${n})`:`vec${e}<${t}>(${n})`,Id=(t,e,n)=>t==="f32"?n:e===1?`f32(${n})`:`vec${e}<f32>(${n})`,Ul=(t,e)=>e===4?`(${t}.x + ${t}.y + ${t}.z + ${t}.w)`:e===2?`(${t}.x + ${t}.y)`:e===3?`(${t}.x + ${t}.y + ${t}.z)`:t,Ke=(t,e,n,s)=>t.startsWith("uniforms.")&&n>4?typeof e=="string"?s==="f16"?`${t}[(${e}) / 8][(${e}) % 8 / 4][(${e}) % 8 % 4]`:`${t}[(${e}) / 4][(${e}) % 4]`:s==="f16"?`${t}[${Math.floor(e/8)}][${Math.floor(e%8/4)}][${e%8%4}]`:`${t}[${Math.floor(e/4)}][${e%4}]`:n>1?`${t}[${e}]`:t,Wp=(t,e,n,s,r)=>{let a=typeof n=="number",i=a?n:n.length,o=[...new Array(i).keys()],l=i<2?"u32":i<=4?`vec${i}<u32>`:`array<u32, ${i}>`,c=Hy(e,r),h=typeof c=="string"?c:c[1],p=typeof c=="string"?c:c[0],f={indices:l,value:h,storage:p,tensor:e},g=G=>typeof G=="string"?G:`${G}u`,y={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},x=a?"uniforms.":"",w=`${x}${t}_shape`,v=`${x}${t}_strides`,$="";for(let G=0;G<i-1;G++)$+=`
    let dim${G} = current / ${Ke(v,G,i)};
    let rest${G} = current % ${Ke(v,G,i)};
    indices[${G}] = dim${G};
    current = rest${G};
    `;$+=`indices[${i-1}] = current;`;let T=i<2?"":`
  fn o2i_${t}(offset: u32) -> ${f.indices} {
    var indices: ${f.indices};
    var current = offset;
    ${$}
    return indices;
  }`,C=G=>(y.offsetToIndices=!0,i<2?G:`o2i_${t}(${G})`),I=[];if(i>=2)for(let G=i-1;G>=0;G--)I.push(`${Ke(v,G,i)} * (indices[${G}])`);let A=i<2?"":`
  fn i2o_${t}(indices: ${f.indices}) -> u32 {
    return ${I.join("+")};
  }`,O=G=>(y.indicesToOffset=!0,i<2?G:`i2o_${t}(${G})`),B=(...G)=>i===0?"0u":`${f.indices}(${G.map(g).join(",")})`,z=(G,Y)=>i<2?`${G}`:`${Ke(G,Y,i)}`,P=(G,Y,ce)=>i<2?`${G}=${ce};`:`${Ke(G,Y,i)}=${ce};`,F={},K=(G,Y)=>{y.broadcastedIndicesToOffset=!0;let ce=`${Y.name}broadcastedIndicesTo${t}Offset`;if(ce in F)return`${ce}(${G})`;let pe=[];for(let J=i-1;J>=0;J--){let we=Y.indicesGet("outputIndices",J+Y.rank-i);pe.push(`${z(v,J)} * (${we} % ${z(w,J)})`)}return F[ce]=`fn ${ce}(outputIndices: ${Y.type.indices}) -> u32 {
             return ${pe.length>0?pe.join("+"):"0u"};
           }`,`${ce}(${G})`},X=(G,Y)=>(()=>{if(f.storage===f.value)return`${t}[${G}]=${Y};`;if(f.storage==="vec2<u32>"&&f.value==="i32")return`${t}[${G}]=vec2<u32>(u32(${Y}), select(0u, 0xFFFFFFFFu, ${Y} < 0));`;if(f.storage==="vec2<u32>"&&f.value==="u32")return`${t}[${G}]=vec2<u32>(u32(${Y}), 0u);`;if(f.storage==="u32"&&f.value==="vec4<bool>")return`${t}[${G}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${Y}));`;throw new Error(`not supported combination of storage type ${f.storage} and value type ${f.value} yet`)})(),te=G=>(()=>{if(f.storage===f.value)return`${t}[${G}]`;if(f.storage==="vec2<u32>"&&f.value==="i32")return`i32(${t}[${G}].x)`;if(f.storage==="vec2<u32>"&&f.value==="u32")return`u32(${t}[${G}].x)`;if(f.storage==="u32"&&f.value==="vec4<bool>")return`vec4<bool>(bool(${t}[${G}] & 0xFFu), bool(${t}[${G}] & 0xFF00u), bool(${t}[${G}] & 0xFF0000u), bool(${t}[${G}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${f.storage} and value type ${f.value} yet`)})(),Q=i<2?"":`
  fn get_${t}ByIndices(indices: ${f.indices}) -> ${h} {
    return ${te(`i2o_${t}(indices)`)};
  }`,q=i<2?"":(()=>{let G=o.map(ce=>`d${ce}: u32`).join(", "),Y=o.map(ce=>`d${ce}`).join(", ");return`
  fn get_${t}(${G}) -> ${h} {
    return get_${t}ByIndices(${B(Y)});
  }`})(),oe=(...G)=>{if(G.length!==i)throw new Error(`indices length must be ${i}`);let Y=G.map(g).join(",");return i===0?te("0u"):i===1?te(Y[0]):(y.get=!0,y.getByIndices=!0,y.indicesToOffset=!0,`get_${t}(${Y})`)},se=G=>i<2?te(G):(y.getByIndices=!0,y.indicesToOffset=!0,`get_${t}ByIndices(${G})`),ee=i<2?"":`
  fn set_${t}ByIndices(indices: ${f.indices}, value: ${h}) {
    ${X(`i2o_${t}(indices)`,"value")}
  }`,U=i<2?"":(()=>{let G=o.map(ce=>`d${ce}: u32`).join(", "),Y=o.map(ce=>`d${ce}`).join(", ");return`
  fn set_${t}(${G}, value: ${h}) {
    set_${t}ByIndices(${B(Y)}, value);
  }`})();return{impl:()=>{let G=[],Y=!1;return y.offsetToIndices&&(G.push(T),Y=!0),y.indicesToOffset&&(G.push(A),Y=!0),y.broadcastedIndicesToOffset&&(Object.values(F).forEach(ce=>G.push(ce)),Y=!0),y.set&&(G.push(U),Y=!0),y.setByIndices&&(G.push(ee),Y=!0),y.get&&(G.push(q),Y=!0),y.getByIndices&&(G.push(Q),Y=!0),!a&&Y&&G.unshift(`const ${w} = ${f.indices}(${n.join(",")});`,`const ${v} = ${f.indices}(${ve.computeStrides(n).join(",")});`),G.join(`
`)},type:f,offsetToIndices:C,indicesToOffset:O,broadcastedIndicesToOffset:K,indices:B,indicesGet:z,indicesSet:P,set:(...G)=>{if(G.length!==i+1)throw new Error(`indices length must be ${i}`);let Y=G[i];if(typeof Y!="string")throw new Error("value must be string");let ce=G.slice(0,i).map(g).join(",");return i===0?X("0u",Y):i===1?X(ce[0],Y):(y.set=!0,y.setByIndices=!0,y.indicesToOffset=!0,`set_${t}(${ce}, ${Y})`)},setByOffset:X,setByIndices:(G,Y)=>i<2?X(G,Y):(y.setByIndices=!0,y.indicesToOffset=!0,`set_${t}ByIndices(${G}, ${Y});`),get:oe,getByOffset:te,getByIndices:se,usage:s,name:t,strides:v,shape:w,rank:i}},Te=(t,e,n,s=1)=>Wp(t,e,n,"input",s),je=(t,e,n,s=1)=>Wp(t,e,n,"output",s),IP=(t,e,n)=>Wp(t,e,n,"atomicOutput",1),aT=(t,e,n,s=1)=>Wp(t,e,n,"internal",s),xA=class{constructor(t,e){this.normalizedDispatchGroup=t,this.limits=e,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=Yd){let e=typeof t=="number"?t:t[0],n=typeof t=="number"?1:t[1],s=typeof t=="number"?1:t[2];if(e>this.limits.maxComputeWorkgroupSizeX||n>this.limits.maxComputeWorkgroupSizeY||s>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${e}, ${n}, ${s}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(e*n*s>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${e}, ${n}, ${s}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let r=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,a=r?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,i=r?`let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${e*n*s}u + local_idx;`;return`@compute @workgroup_size(${e}, ${n}, ${s})
  fn main(${a}) {
    ${i}
  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:"u32",length:t.rank}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:"u32",length:t.rank}))}declareVariable(t,e){if(t.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(t),this.appendVariableUniforms(t);let n=t.usage==="input"?"read":"read_write",s=t.usage==="atomicOutput"?"atomic<i32>":t.type.storage;return`@group(0) @binding(${e}) var<storage, ${n}> ${t.name}: array<${s}>;`}declareVariables(...t){return t.map(e=>this.declareVariable(e,this.variableIndex++)).join(`
`)}registerInternalVariable(t){if(t.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(e=>this.registerInternalVariable(e)),this}registerUniform(t,e,n=1){return this.uniforms.push({name:t,type:e,length:n}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:e,type:n,length:s}of this.uniforms)if(s&&s>4)n==="f16"?t.push(`@align(16) ${e}:array<mat2x4<${n}>, ${Math.ceil(s/8)}>`):t.push(`${e}:array<vec4<${n}>, ${Math.ceil(s/4)}>`);else{let r=s==null||s===1?n:`vec${s}<${n}>`;t.push(`${e}:${r}`)}return`
      struct Uniforms { ${t.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`
`)+this.internalVariables.map(t=>t.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let t=e=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(e)];return this.uniforms.map(e=>[t(e.type),e.length??1])}},EP=(t,e)=>new xA(t,e)}),wA,Pv,vA,$A,SA,_A,jr,AP,RP,tu=ze(()=>{it(),ht(),Tn(),mt(),wA=(t,e)=>{if(!t||t.length!==1)throw new Error("Transpose requires 1 input.");if(e.length!==0&&e.length!==t[0].dims.length)throw new Error(`perm size ${e.length} does not match input rank ${t[0].dims.length}`)},Pv=(t,e)=>e.length!==0?e:[...new Array(t).keys()].reverse(),vA=(t,e)=>ve.sortBasedOnPerm(t,Pv(t.length,e)),$A=(t,e,n,s)=>{let r=`fn perm(i: ${s.type.indices}) -> ${n.type.indices} {
    var a: ${n.type.indices};`;for(let a=0;a<e;++a)r+=`a[${t[a]}]=i[${a}];`;return r+="return a;}"},SA=(t,e)=>{let n=[],s=[];for(let r=0;r<t.length;++r)t[r]!==1&&n.push(t[r]),t[e[r]]!==1&&s.push(e[r]);return{newShape:n,newPerm:s}},_A=(t,e)=>{let n=0;for(let s=0;s<t.length;++s)if(e[t[s]]!==1){if(t[s]<n)return!1;n=t[s]}return!0},jr=(t,e)=>{let n=t.dataType,s=t.dims.length,r=Pv(s,e),a=vA(t.dims,r),i=t.dims,o=a,l=s<2||_A(r,t.dims),c;if(l)return c=y=>{let x=Te("input",n,i,4),w=je("output",n,o,4);return`
  ${y.registerUniform("output_size","u32").declareVariables(x,w)}
  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let y=ve.size(a);return{outputs:[{dims:a,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(y/64/4)},programUniforms:[{type:12,data:Math.ceil(y/4)}]}},getShaderSource:c};let{newShape:h,newPerm:p}=SA(t.dims,r),f=ve.areEqual(p,[2,3,1]),g=ve.areEqual(p,[3,1,2]);if(h.length===2||f||g){i=f?[h[0],h[1]*h[2]]:g?[h[0]*h[1],h[2]]:h,o=[i[1],i[0]];let y=16;return c=x=>{let w=Te("a",n,i.length),v=je("output",n,o.length);return`
  ${x.registerUniform("output_size","u32").declareVariables(w,v)}
  var<workgroup> tile : array<array<${v.type.value}, ${y+1}>, ${y}>;
  ${x.mainStart([y,y,1])}
    let stride = (uniforms.output_shape[1] - 1) / ${y} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${y}u + local_id.x;
    let input_row = workgroup_id_x * ${y}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${w.getByIndices(`${w.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${y}u + local_id.x;
    let output_row = workgroup_id_y * ${y}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${v.setByIndices(`${v.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}
    }
  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let x=ve.size(a);return{outputs:[{dims:a,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(o[1]/y),y:Math.ceil(o[0]/y)},programUniforms:[{type:12,data:x},...Je(i,o)]}},getShaderSource:c}}return c=y=>{let x=Te("a",n,i.length),w=je("output",n,o.length);return`
  ${y.registerUniform("output_size","u32").declareVariables(x,w)}

  ${$A(r,s,x,w)}

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${w.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${w.setByOffset("global_idx",x.getByIndices("aIndices"))}
  }`},{name:"Transpose",shaderCache:{hint:`${e}`,inputDependencies:["rank"]},getRunData:()=>{let y=ve.size(a);return{outputs:[{dims:a,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:[{type:12,data:y},...Je(i,o)]}},getShaderSource:c}},AP=(t,e)=>{wA(t.inputs,e.perm),t.compute(jr(t.inputs[0],e.perm))},RP=t=>Xt({perm:t.perm})}),CA,TA,kA,NA,IA,EA,AA,RA,DA,OA,Fa,DP,OP,zP,FP,LP,MP,BP,PP,VP,UP,bxe=ze(()=>{it(),ht(),mt(),iT(),tu(),CA={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},TA={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},kA={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},NA={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},IA=(t,e)=>{let n=[];for(let s=e-t;s<e;++s)n.push(s);return n},EA=(t,e)=>{let n=[],s=t.length;for(let a=0;a<s;a++)e.indexOf(a)===-1&&n.push(t[a]);let r=e.map(a=>t[a]);return[n,r]},AA=(t,e)=>{let n=t.length+e.length,s=[],r=0;for(let a=0;a<n;a++)e.indexOf(a)===-1?s.push(t[r++]):s.push(1);return s},RA=(t,e)=>{for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0},DA=(t,e)=>{let n=[];if(!RA(t,e)){for(let s=0;s<e;++s)t.indexOf(s)===-1&&n.push(s);t.forEach(s=>n.push(s))}return n},OA=(t,e,n,s,r,a,i)=>{let o=n[0].dims,l=ve.size(a),c=ve.size(i),h=Te("_A",n[0].dataType,o),p=je("output",r,a),f=64;l===1&&(f=256);let g=`
          var<workgroup> aBestValues : array<f32, ${f}>;
       `,y=x=>`
        ${x.registerUniform("reduceSize","u32").declareVariables(h,p)}
        ${g}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${x.mainStart(f)}

          let outputIndex = global_idx / ${f};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${kA[s]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${f}) {
           let candidate = f32(${h.getByOffset("offset + k")});
           bestValue = ${CA[s]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${f}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${TA[s]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${p.setByOffset("outputIndex",`${s==="mean"?`${p.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${p.type.storage}(${NA[s]})`}`)};
         }
        }`;return{name:t,shaderCache:{hint:`${e};${f}`,inputDependencies:["type"]},getShaderSource:y,getRunData:()=>({outputs:[{dims:a,dataType:r}],dispatchGroup:{x:l},programUniforms:[{type:12,data:c}]})}},Fa=(t,e,n,s)=>{let r=t.inputs.length===1?n:w2(t.inputs,n),a=r.axes;a.length===0&&!r.noopWithEmptyAxes&&(a=t.inputs[0].dims.map((g,y)=>y));let i=ve.normalizeAxes(a,t.inputs[0].dims.length),o=i,l=t.inputs[0],c=DA(o,t.inputs[0].dims.length);c.length>0&&(l=t.compute(jr(t.inputs[0],c),{inputs:[0],outputs:[-1]})[0],o=IA(o.length,l.dims.length));let[h,p]=EA(l.dims,o),f=h;r.keepDims&&(f=AA(h,i)),t.compute(OA(e,r.cacheKey,[l],s,t.inputs[0].dataType,f,p),{inputs:[l]})},DP=(t,e)=>{Fa(t,"ReduceMeanShared",e,"mean")},OP=(t,e)=>{Fa(t,"ReduceL1Shared",e,"l1")},zP=(t,e)=>{Fa(t,"ReduceL2Shared",e,"l2")},FP=(t,e)=>{Fa(t,"ReduceLogSumExpShared",e,"logSumExp")},LP=(t,e)=>{Fa(t,"ReduceMaxShared",e,"max")},MP=(t,e)=>{Fa(t,"ReduceMinShared",e,"min")},BP=(t,e)=>{Fa(t,"ReduceProdShared",e,"prod")},PP=(t,e)=>{Fa(t,"ReduceSumShared",e,"sum")},VP=(t,e)=>{Fa(t,"ReduceSumSquareShared",e,"sumSquare")},UP=(t,e)=>{Fa(t,"ReduceLogSumShared",e,"logSum")}}),La,zA,Y0,w2,Ma,FA,LA,MA,BA,PA,VA,UA,WA,GA,HA,Ba,WP,GP,HP,qP,jP,KP,XP,YP,ZP,QP,iT=ze(()=>{it(),ht(),Tn(),mt(),bxe(),La=t=>{if(!t||t.length===0||t.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(t.length===2&&t[1].dims.length!==1)throw new Error("Invalid axes input dims.")},zA=t=>["","",`var value = ${t.getByIndices("input_indices")};`,""],Y0=(t,e,n,s,r,a,i=!1,o=!1)=>{let l=[],c=n[0].dims,h=c.length,p=ve.normalizeAxes(r,h),f=!o&&p.length===0;c.forEach((x,w)=>{f||p.indexOf(w)>=0?i&&l.push(1):l.push(x)});let g=l.length,y=ve.size(l);return{name:t,shaderCache:e,getShaderSource:x=>{let w=[],v=Te("_A",n[0].dataType,h),$=je("output",a,g),T=s(v,$,p),C=T[2];for(let I=0,A=0;I<h;I++)f||p.indexOf(I)>=0?(i&&A++,C=`for(var j${I}: u32 = 0; j${I} < ${c[I]}; j${I}++) {
                  ${T[2].includes("last_index")?`let last_index = j${I};`:""}
                  ${v.indicesSet("input_indices",I,`j${I}`)}
                  ${C}
                }`):(w.push(`${v.indicesSet("input_indices",I,$.indicesGet("output_indices",A))};`),A++);return`

        ${x.registerUniform("output_size","u32").declareVariables(v,$)}

        ${x.mainStart()}
          ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${v.type.indices};
          let output_indices = ${$.offsetToIndices("global_idx")};

          ${w.join(`
`)}
          ${T[0]}       // init ops for reduce max/min
          ${T[1]}
          ${C}
          ${T[3]}
          ${T.length===4?$.setByOffset("global_idx","value"):T.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:l,dataType:a}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:[{type:12,data:y},...Je(c,l)]})}},w2=(t,e)=>{let n=[];return t[1].dims[0]>0&&t[1].getBigInt64Array().forEach(s=>n.push(Number(s))),Xt({axes:n,keepDims:e.keepDims,noopWithEmptyAxes:e.noopWithEmptyAxes})},Ma=(t,e,n,s)=>{let r=t.inputs,a=r.length===1?n:w2(r,n);t.compute(Y0(e,{hint:a.cacheKey,inputDependencies:["rank"]},[r[0]],a.noopWithEmptyAxes&&a.axes.length===0?zA:s,a.axes,r[0].dataType,a.keepDims,a.noopWithEmptyAxes),{inputs:[0]})},FA=(t,e)=>{La(t.inputs),Ma(t,"ReduceLogSum",e,(n,s)=>[`var value = ${s.type.storage}(0);`,"",`value += ${n.getByIndices("input_indices")};`,"value = log(value);"])},LA=(t,e)=>{La(t.inputs),Ma(t,"ReduceL1",e,(n,s)=>[`var value = ${s.type.storage}(0);`,"",`value += abs(${n.getByIndices("input_indices")});`,""])},MA=(t,e)=>{La(t.inputs),Ma(t,"ReduceL2",e,(n,s)=>[`var t = ${s.type.value}(0); var value = ${s.type.value}(0);`,"",`t = ${n.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},BA=(t,e)=>{La(t.inputs),Ma(t,"ReduceLogSumExp",e,(n,s)=>[`var value = ${s.type.storage}(0);`,"",`value += exp(${n.getByIndices("input_indices")});`,"value = log(value);"])},PA=(t,e)=>{La(t.inputs),Ma(t,"ReduceMax",e,(n,s,r)=>{let a=[];for(let i=0;i<n.rank;i++)(r.indexOf(i)>=0||r.length===0)&&a.push(n.indicesSet("input_indices",i,0));return[`${a.join(`
`)}`,`var value = ${n.getByIndices("input_indices")};`,`value = max(value, ${n.getByIndices("input_indices")});`,""]})},VA=(t,e)=>{La(t.inputs),Ma(t,"ReduceMean",e,(n,s,r)=>{let a=1;for(let i=0;i<n.rank;i++)(r.indexOf(i)>=0||r.length===0)&&(a*=t.inputs[0].dims[i]);return["var sum = f32(0);","",`sum += f32(${n.getByIndices("input_indices")});`,`let value = ${s.type.value}(sum / ${a});`]})},UA=(t,e)=>{La(t.inputs),Ma(t,"ReduceMin",e,(n,s,r)=>{let a=[];for(let i=0;i<n.rank;i++)(r.indexOf(i)>=0||r.length===0)&&a.push(`input_indices[${i}] = 0;`);return[`${a.join(`
`)}`,`var value = ${n.getByIndices("input_indices")};`,`value = min(value, ${n.getByIndices("input_indices")});`,""]})},WA=(t,e)=>{La(t.inputs),Ma(t,"ReduceProd",e,(n,s)=>[`var value = ${s.type.storage}(1);`,"",`value *= ${n.getByIndices("input_indices")};`,""])},GA=(t,e)=>{La(t.inputs),Ma(t,"ReduceSum",e,(n,s)=>[`var value = ${s.type.storage}(0);`,"",`value += ${n.getByIndices("input_indices")};`,""])},HA=(t,e)=>{La(t.inputs),Ma(t,"ReduceSumSquare",e,(n,s)=>[`var t = ${s.type.value}(0); var value = ${s.type.value}(0);`,"",`t = ${n.getByIndices("input_indices")}; value += t * t;`,""])},Ba=(t,e,n)=>{if(e.length===0)return n;let s=1,r=1;for(let a=0;a<e.length;a++)e.indexOf(a)===-1?s*=t[a]:r*=t[a];return r<32&&s>1024},WP=(t,e)=>{Ba(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?VA(t,e):DP(t,e)},GP=(t,e)=>{Ba(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?LA(t,e):OP(t,e)},HP=(t,e)=>{Ba(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?MA(t,e):zP(t,e)},qP=(t,e)=>{Ba(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?BA(t,e):FP(t,e)},jP=(t,e)=>{Ba(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?PA(t,e):LP(t,e)},KP=(t,e)=>{Ba(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?UA(t,e):MP(t,e)},XP=(t,e)=>{Ba(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?WA(t,e):BP(t,e)},YP=(t,e)=>{Ba(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?GA(t,e):PP(t,e)},ZP=(t,e)=>{Ba(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?HA(t,e):VP(t,e)},QP=(t,e)=>{Ba(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?FA(t,e):UP(t,e)}}),Vv,JP,eV,v2,xxe=ze(()=>{it(),Tn(),iT(),Vv=t=>{if(!t||t.length===0||t.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(t[0].dataType!==1)throw new Error("Invalid input type.")},JP=(t,e)=>{Vv(t.inputs);let n=(s,r,a)=>{let i=[];for(let o=0;o<s.rank;o++)(a.indexOf(o)>=0||a.length===0)&&i.push(`input_indices[${o}] = 0;`);return[`${i.join(`
`)}`,`var value = ${s.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${s.getByIndices("input_indices")} ${e.selectLastIndex>0?"<=":"<"} value) {
         value = ${s.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",r.setByOffset("global_idx","best_index")]};t.compute(Y0("ArgMin",{hint:e.cacheKey,inputDependencies:["rank"]},[t.inputs[0]],n,[e.axis],7,e.keepDims),{inputs:[0]})},eV=(t,e)=>{Vv(t.inputs);let n=(s,r,a)=>{let i=[];for(let o=0;o<s.rank;o++)(a.indexOf(o)>=0||a.length===0)&&i.push(`input_indices[${o}] = 0;`);return[`${i.join(`
`)}`,`var value = ${s.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${s.getByIndices("input_indices")} ${e.selectLastIndex>0?">=":">"} value) {
         value = ${s.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",r.setByOffset("global_idx","best_index")]};t.compute(Y0("argMax",{hint:e.cacheKey,inputDependencies:["rank"]},[t.inputs[0]],n,[e.axis],7,e.keepDims),{inputs:[0]})},v2=t=>Xt(t)}),qA,qy,jA,KA,XA,Tf,YA,tV,oT=ze(()=>{it(),ht(),rT(),mt(),qA=(t,e)=>{let n=t[0],s=t[1],r=t[2],a=t[3],i=t[4],o=t[5];if(i&&o)throw new Error("Attention cannot have both past and attention_bias");if(n.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let l=n.dims[0],c=n.dims[1],h=n.dims[2];if(r.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(s.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(s.dims[0]!==h)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(r.dims[0]!==s.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let p=r.dims[0]/3,f=p,g=f;if(e.qkvHiddenSizes.length>0){if(e.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let T of e.qkvHiddenSizes)if(T%e.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");p=e.qkvHiddenSizes[0],f=e.qkvHiddenSizes[1],g=e.qkvHiddenSizes[2]}let y=c;if(p!==f)throw new Error("qkv_hidden_sizes first element should be same as the second");if(r.dims[0]!==p+f+g)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let x=0;if(i){if(f!==g)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(i.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(i.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(i.dims[1]!==l)throw new Error('Input "past" second dimension must be batch_size');if(i.dims[2]!==e.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(i.dims[4]!==f/e.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');e.pastPresentShareBuffer||(x=i.dims[3])}let w=y+x,v=-1,$=0;if(a)throw new Error("Mask not supported");if(i)throw new Error("past is not supported");if(o){if(o.dims.length!==4)throw new Error('Input "attention_bias" must have 4 dimensions');if(o.dims[0]!==l||o.dims[1]!==e.numHeads||o.dims[2]!==c||o.dims[3]!==w)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:l,sequenceLength:c,pastSequenceLength:x,kvSequenceLength:y,totalSequenceLength:w,maxSequenceLength:v,inputHiddenSize:h,hiddenSize:p,vHiddenSize:g,headSize:Math.floor(p/e.numHeads),vHeadSize:Math.floor(g/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:$,scale:e.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},qy=(t,e,n)=>e&&t?`
      let total_sequence_length_input = u32(${e.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${t==null?void 0:t.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `:`
    ${n?"let past_sequence_length = uniforms.past_sequence_length":""};
    let present_sequence_length = total_sequence_length;
    `,jA=(t,e,n,s,r,a,i,o)=>{let l=bn(i?1:a),c=64,h=a/l;h<c&&(c=32);let p=Math.ceil(a/l/c),f=[{type:12,data:e},{type:12,data:n},{type:12,data:s},{type:12,data:r},{type:12,data:h},{type:12,data:p}],g=is(t.dataType,l),y=Ps(1,l),x=["type"];i&&x.push("type"),o&&x.push("type");let w=v=>{let $=je("x",t.dataType,t.dims,l),T=[$],C=i?Te("seq_lens",i.dataType,i.dims):void 0;C&&T.push(C);let I=o?Te("total_sequence_length_input",o.dataType,o.dims):void 0;I&&T.push(I);let A=Ps(t.dataType),O=[{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${c}>;
  var<workgroup> thread_sum: array<f32, ${c}>;
  ${v.registerUniforms(O).declareVariables(...T)}
  ${v.mainStart([c,1,1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${qy(C,I,!1)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${c}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${i?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};
    var thread_max_vector = ${y}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${y}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(l){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${l}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${c}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${y}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${y}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(l){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${l}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${c}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${$.type.value}(${A}(1.0) / ${A}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${y}(x[offset + i]);
        x[offset + i] = ${$.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${i?`
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${$.type.value}(${A}(0));
        }`:""};
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${c};${g};${l}`,inputDependencies:x},getShaderSource:w,getRunData:()=>({outputs:[],dispatchGroup:{x:Math.ceil(a/c),y:r,z:e*n},programUniforms:f})}},KA=(t,e,n,s,r,a,i,o,l)=>{let c=i+a.kvSequenceLength,h=[a.batchSize,a.numHeads,a.sequenceLength,c],p=t>1&&s,f=a.kvNumHeads?a.kvNumHeads:a.numHeads,g=p?[a.batchSize,f,c,a.headSize]:void 0,y=a.nReps?a.nReps:1,x=a.scale===0?1/Math.sqrt(a.headSize):a.scale,w=bn(a.headSize),v=a.headSize/w,$=12,T={x:Math.ceil(c/$),y:Math.ceil(a.sequenceLength/$),z:a.batchSize*a.numHeads},C=[{type:12,data:a.sequenceLength},{type:12,data:v},{type:12,data:c},{type:12,data:a.numHeads},{type:12,data:a.headSize},{type:1,data:x},{type:12,data:i},{type:12,data:a.kvSequenceLength},{type:12,data:y}],I=p&&s&&ve.size(s.dims)>0,A=["type","type"];I&&A.push("type"),r&&A.push("type"),o&&A.push("type"),l&&A.push("type");let O=[{dims:h,dataType:e.dataType,gpuDataType:0}];p&&O.push({dims:g,dataType:e.dataType,gpuDataType:0});let B=z=>{let P=Te("q",e.dataType,e.dims,w),F=Te("key",n.dataType,n.dims,w),K=[P,F];if(I){let ee=Te("past_key",s.dataType,s.dims,w);K.push(ee)}r&&K.push(Te("attention_bias",r.dataType,r.dims));let X=o?Te("seq_lens",o.dataType,o.dims):void 0;X&&K.push(X);let te=l?Te("total_sequence_length_input",l.dataType,l.dims):void 0;te&&K.push(te);let Q=je("output",e.dataType,h),q=[Q];p&&q.push(je("present_key",e.dataType,g,w));let oe=Ps(1,w),se=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${$}u;

  var<workgroup> tileQ: array<${P.type.storage}, ${$*$}>;
  var<workgroup> tileK: array<${P.type.storage}, ${$*$}>;
  ${z.registerUniforms(se).declareVariables(...K,...q)}
  ${z.mainStart([$,$,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${y===1?"headIdx":"headIdx / uniforms.n_reps"};
    let kv_num_heads = ${y===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${qy(X,te,!0)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${I&&p?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${p?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}
    var value = ${oe}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${I&&p?`
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`:`
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`}
      ${p?`if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }`:""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${oe}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(w){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${w}`)}})()};
        output[outputIdx] = ${Q.type.value} (sum * uniforms.alpha) + ${r?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${w};${r!==void 0};${s!==void 0};${t}`,inputDependencies:A},getRunData:()=>({outputs:O,dispatchGroup:T,programUniforms:C}),getShaderSource:B}},XA=(t,e,n,s,r,a,i=void 0,o=void 0)=>{let l=a+r.kvSequenceLength,c=r.nReps?r.nReps:1,h=r.vHiddenSize*c,p=t>1&&s,f=r.kvNumHeads?r.kvNumHeads:r.numHeads,g=p?[r.batchSize,f,l,r.headSize]:void 0,y=[r.batchSize,r.sequenceLength,h],x=12,w={x:Math.ceil(r.vHeadSize/x),y:Math.ceil(r.sequenceLength/x),z:r.batchSize*r.numHeads},v=[{type:12,data:r.sequenceLength},{type:12,data:l},{type:12,data:r.vHeadSize},{type:12,data:r.numHeads},{type:12,data:r.headSize},{type:12,data:h},{type:12,data:a},{type:12,data:r.kvSequenceLength},{type:12,data:c}],$=p&&s&&ve.size(s.dims)>0,T=["type","type"];$&&T.push("type"),i&&T.push("type"),o&&T.push("type");let C=[{dims:y,dataType:e.dataType,gpuDataType:0}];p&&C.push({dims:g,dataType:e.dataType,gpuDataType:0});let I=A=>{let O=Te("probs",e.dataType,e.dims),B=Te("v",n.dataType,n.dims),z=[O,B];$&&z.push(Te("past_value",s.dataType,s.dims));let P=i?Te("seq_lens",i.dataType,i.dims):void 0;i&&z.push(P);let F=o?Te("total_sequence_length_input",o.dataType,o.dims):void 0;o&&z.push(F);let K=[je("output",e.dataType,y)];p&&K.push(je("present_value",e.dataType,g));let X=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${x}u;
  var<workgroup> tileQ: array<${O.type.value}, ${x*x}>;
  var<workgroup> tileV: array<${O.type.value}, ${x*x}>;
  ${A.registerUniforms(X).declareVariables(...z,...K)}
  ${A.mainStart([x,x,1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${c===1?"headIdx":"headIdx / uniforms.n_reps"};
   let kv_num_heads = ${c===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${qy(P,F,!0)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${$&&p?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${p?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${O.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${$&&p?`
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `:`
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`}
        ${p?`
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }`:""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${s!==void 0};${t}`,inputDependencies:T},getRunData:()=>({outputs:C,dispatchGroup:w,programUniforms:v}),getShaderSource:I}},Tf=(t,e,n,s,r,a,i,o,l,c,h=void 0,p=void 0)=>{let f=Math.min(t.outputCount,1+(i?1:0)+(o?1:0)),g=f>1?c.pastSequenceLength:0,y=g+c.kvSequenceLength,x=l&&ve.size(l.dims)>0?l:void 0,w=[e,n];f>1&&i&&ve.size(i.dims)>0&&w.push(i),x&&w.push(x),h&&w.push(h),p&&w.push(p);let v=t.compute(KA(f,e,n,i,x,c,g,h,p),{inputs:w,outputs:f>1?[-1,1]:[-1]})[0];t.compute(jA(v,c.batchSize,c.numHeads,g,c.sequenceLength,y,h,p),{inputs:h&&p?[v,h,p]:[v],outputs:[]});let $=[v,s];f>1&&o&&ve.size(o.dims)>0&&$.push(o),h&&$.push(h),p&&$.push(p),t.compute(XA(f,v,s,o,c,g,h,p),{inputs:$,outputs:f>1?[0,2]:[0]})},YA=(t,e)=>{let n=[e.batchSize,e.numHeads,e.sequenceLength,e.headSize],s=e.sequenceLength,r=e.inputHiddenSize,a=e.headSize,i=12,o={x:Math.ceil(e.headSize/i),y:Math.ceil(e.sequenceLength/i),z:e.batchSize*e.numHeads},l=[t.inputs[0],t.inputs[1],t.inputs[2]],c=[{type:12,data:s},{type:12,data:r},{type:12,data:a},{type:12,data:e.numHeads},{type:12,data:e.headSize},{type:12,data:e.hiddenSize},{type:12,data:e.hiddenSize+e.hiddenSize+e.vHiddenSize}],h=p=>{let f=je("output_q",l[0].dataType,n),g=je("output_k",l[0].dataType,n),y=je("output_v",l[0].dataType,n),x=Te("input",l[0].dataType,l[0].dims),w=Te("weight",l[1].dataType,l[1].dims),v=Te("bias",l[2].dataType,l[2].dims),$=x.type.storage,T=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${i}u;
  var<workgroup> tileInput: array<${$}, ${i*i}>;
  var<workgroup> tileWeightQ: array<${$}, ${i*i}>;
  var<workgroup> tileWeightK: array<${$}, ${i*i}>;
  var<workgroup> tileWeightV: array<${$}, ${i*i}>;
  ${p.registerUniforms(T).declareVariables(x,w,v,f,g,y)}
  ${p.mainStart([i,i,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${$}(0);
    var valueK = ${$}(0);
    var valueV = ${$}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return t.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:t.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:t.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:t.inputs[0].dataType,gpuDataType:0}],dispatchGroup:o,programUniforms:c}),getShaderSource:h},{inputs:l,outputs:[-1,-1,-1]})},tV=(t,e)=>{let n=qA(t.inputs,e),[s,r,a]=YA(t,n);return Tf(t,s,r,a,t.inputs[4],void 0,void 0,void 0,t.inputs[5],n)}}),ZA,QA,JA,nV,wxe=ze(()=>{ei(),it(),ht(),Tn(),mt(),ZA=(t,e)=>{if(!t||t.length!==5)throw new Error("BatchNormalization requires 5 inputs");let n=(s,r,a)=>{let i=r.length;if(i!==s.length)throw new Error(`${a}: num dimensions != ${i}`);r.forEach((o,l)=>{if(o!==s[l])throw new Error(`${a}: dim[${l}] do not match`)})};if(t[0].dims.length>1){let s=e.format==="NHWC"?e.spatial?t[0].dims.slice(-1):t[0].dims.slice(-1).concat(t[0].dims.slice(1,t[0].dims.length-1)):t[0].dims.slice(1,e.spatial?2:void 0);n(t[1].dims,s,"Invalid input scale"),n(t[2].dims,s,"Invalid input B"),n(t[3].dims,s,"Invalid input mean"),n(t[4].dims,s,"Invalid input var")}else n(t[1].dims,[1],"Invalid input scale"),n(t[2].dims,[1],"Invalid input B"),n(t[3].dims,[1],"Invalid input mean"),n(t[4].dims,[1],"Invalid input var")},QA=(t,e)=>{let{epsilon:n,spatial:s,format:r}=e,a=t[0].dims,i=s?bn(a[a.length-1]):1,o=r==="NHWC"&&a.length>1?i:1,l=ve.size(a)/i,c=s,h=c?a.length:a,p=Te("x",t[0].dataType,t[0].dims,i),f=Te("scale",t[1].dataType,t[1].dims,o),g=Te("bias",t[2].dataType,t[2].dims,o),y=Te("inputMean",t[3].dataType,t[3].dims,o),x=Te("inputVar",t[4].dataType,t[4].dims,o),w=je("y",t[0].dataType,h,i),v=()=>{let T="";if(s)T=`let cOffset = ${a.length===1?"0u":r==="NHWC"?`outputIndices[${a.length-1}] / ${i}`:"outputIndices[1]"};`;else if(r==="NCHW")T=`
            ${w.indicesSet("outputIndices","0","0")}
            let cOffset = ${w.indicesToOffset("outputIndices")};`;else{T=`var cIndices = ${f.type.indices}(0);
                       cIndices[0] = outputIndices[${a.length-1}];`;for(let C=1;C<f.rank;C++)T+=`cIndices[${C}] = outputIndices[${C}];`;T+=`let cOffset = ${f.indicesToOffset("cIndices")};`}return T},$=T=>`
  const epsilon = ${n};
  ${T.registerUniform("outputSize","u32").declareVariables(p,f,g,y,x,w)}
  ${T.mainStart()}
  ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${w.offsetToIndices(`global_idx * ${i}`)};
    ${v()}
    let scale = ${f.getByOffset("cOffset")};
    let bias = ${g.getByOffset("cOffset")};
    let inputMean = ${y.getByOffset("cOffset")};
    let inputVar = ${x.getByOffset("cOffset")};
    let x = ${p.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${w.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${e.epsilon}_${e.format}_${s}_${i}`,inputDependencies:c?["rank","type","type","type","type"]:void 0},getShaderSource:$,getRunData:()=>({outputs:[{dims:t[0].dims,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:c?[{type:12,data:l},...Je(a)]:[{type:12,data:l}]})}},JA=t=>Xt(t),nV=(t,e)=>{let{inputs:n,outputCount:s}=t,r=JA({...e,outputCount:s});if(hn.webgpu.validateInputContent&&ZA(n,r),e.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");t.compute(QA(n,r))}}),eR,tR,sV,vxe=ze(()=>{ht(),mt(),eR=t=>{if(t[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(t[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(t[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(t[0].dims[2]!==t[1].dims[0])throw new Error("last dimension of input and bias are not the same")},tR=t=>{let e=t[0].dims,n=t[0].dims[2],s=ve.size(e)/4,r=t[0].dataType,a=Te("input",r,e,4),i=Te("bias",r,[n],4),o=Te("residual",r,e,4),l=je("output",r,e,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:c=>`
  const channels = ${n}u / 4;
  ${c.declareVariables(a,i,o,l)}

  ${c.mainStart()}
    ${c.guardAgainstOutOfBoundsWorkgroupSizes(s)}
    let value = ${a.getByOffset("global_idx")}
      + ${i.getByOffset("global_idx % channels")} + ${o.getByOffset("global_idx")};
    ${l.setByOffset("global_idx","value")}
  }`}},sV=t=>{eR(t.inputs),t.compute(tR(t.inputs))}}),nR,Ut,rV,aV,iV,oV,lV,uV,cV,dV,hV,sR,pV,fV,mV,gV,rf,yV,f0,bV,xV,wV,vV,$V,SV,_V,CV,TV,kV,NV,IV,EV,AV,RV,DV,Uv,OV,$2,S2,zV,FV,LV,rR,aR,MV,lT=ze(()=>{it(),ht(),Tn(),mt(),nR=(t,e,n,s,r,a,i)=>{let o=Math.ceil(e/4),l="";typeof r=="string"?l=`${r}(a)`:l=r("a");let c=Te("inputData",n,[o],4),h=je("outputData",s,[o],4),p=[{name:"vec_size",type:"u32"}];return i&&p.push(...i),`
      ${t.registerUniforms(p).declareVariables(c,h)}

  ${a??""}

  ${t.mainStart()}
    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${c.getByOffset("global_idx")};
    ${h.setByOffset("global_idx",l)}
  }`},Ut=(t,e,n,s,r,a=t.dataType,i,o)=>{let l=[{type:12,data:Math.ceil(ve.size(t.dims)/4)}];return i&&l.push(...i),{name:e,shaderCache:{hint:r,inputDependencies:["type"]},getShaderSource:c=>nR(c,ve.size(t.dims),t.dataType,a,n,s,o),getRunData:c=>({outputs:[{dims:t.dims,dataType:a}],dispatchGroup:{x:Math.ceil(ve.size(c[0].dims)/64/4)},programUniforms:l})}},rV=t=>{t.compute(Ut(t.inputs[0],"Abs","abs"))},aV=t=>{t.compute(Ut(t.inputs[0],"Acos","acos"))},iV=t=>{t.compute(Ut(t.inputs[0],"Acosh","acosh"))},oV=t=>{t.compute(Ut(t.inputs[0],"Asin","asin"))},lV=t=>{t.compute(Ut(t.inputs[0],"Asinh","asinh"))},uV=t=>{t.compute(Ut(t.inputs[0],"Atan","atan"))},cV=t=>{t.compute(Ut(t.inputs[0],"Atanh","atanh"))},dV=t=>Xt(t),hV=(t,e)=>{let n;switch(e.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${e.to}`)}t.compute(Ut(t.inputs[0],"Cast",n,void 0,e.cacheKey,e.to))},sR=t=>{let e,n,s=t.length>=2&&t[1].data!==0,r=t.length>=3&&t[2].data!==0;switch(t[0].dataType){case 1:e=s?t[1].getFloat32Array()[0]:-34028234663852886e22,n=r?t[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:e=s?t[1].getUint16Array()[0]:64511,n=r?t[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return Xt({min:e,max:n})},pV=(t,e)=>{let n=e||sR(t.inputs),s=Ps(t.inputs[0].dataType);t.compute(Ut(t.inputs[0],"Clip",r=>`clamp(${r}, vec4<${s}>(uniforms.min), vec4<${s}>(uniforms.max))`,void 0,n.cacheKey,void 0,[{type:t.inputs[0].dataType,data:n.min},{type:t.inputs[0].dataType,data:n.max}],[{name:"min",type:s},{name:"max",type:s}]),{inputs:[0]})},fV=t=>{t.compute(Ut(t.inputs[0],"Ceil","ceil"))},mV=t=>{t.compute(Ut(t.inputs[0],"Cos","cos"))},gV=t=>{t.compute(Ut(t.inputs[0],"Cosh","cosh"))},rf=t=>Xt(t),yV=(t,e)=>{let n=Ps(t.inputs[0].dataType);t.compute(Ut(t.inputs[0],"Elu",s=>`elu_vf32(${s})`,`
  const elu_alpha_ = ${n}(${e.alpha});

  fn elu_f32(a: ${n}) -> ${n} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,e.cacheKey))},f0=(t="f32")=>`
const r0: ${t} = 0.3275911;
const r1: ${t} = 0.254829592;
const r2: ${t} = -0.284496736;
const r3: ${t} = 1.421413741;
const r4: ${t} = -1.453152027;
const r5: ${t} = 1.061405429;

fn erf_vf32(v: vec4<${t}>) -> vec4<${t}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,bV=t=>{let e=Ps(t.inputs[0].dataType);t.compute(Ut(t.inputs[0],"Erf",n=>`erf_vf32(${n})`,f0(e)))},xV=t=>{t.compute(Ut(t.inputs[0],"Exp","exp"))},wV=t=>{t.compute(Ut(t.inputs[0],"Floor","floor"))},vV=t=>{let e=Ps(t.inputs[0].dataType);t.compute(Ut(t.inputs[0],"Gelu",n=>`0.5 * ${n} * (1.0 + erf_vf32(${n} * 0.7071067811865475))`,f0(e)))},$V=(t,e)=>{let n=Ps(t.inputs[0].dataType);t.compute(Ut(t.inputs[0],"LeakyRelu",s=>`select(leaky_relu_alpha_ * ${s}, ${s}, ${s} >= vec4<${n}>(0.0))`,`const leaky_relu_alpha_ = ${n}(${e.alpha});`,e.cacheKey))},SV=t=>{t.compute(Ut(t.inputs[0],"Not",e=>`!${e}`))},_V=t=>{t.compute(Ut(t.inputs[0],"Neg",e=>`-${e}`))},CV=t=>{t.compute(Ut(t.inputs[0],"Reciprocal",e=>`1.0/${e}`))},TV=t=>{let e=Ps(t.inputs[0].dataType);t.compute(Ut(t.inputs[0],"Relu",n=>`select(vec4<${e}>(0.0), ${n}, ${n} > vec4<${e}>(0.0))`))},kV=t=>{t.compute(Ut(t.inputs[0],"Sigmoid",e=>`(1.0 / (1.0 + exp(-${e})))`))},NV=t=>Xt(t),IV=(t,e)=>{let n=Ps(t.inputs[0].dataType);t.compute(Ut(t.inputs[0],"HardSigmoid",s=>`max(vec4<${n}>(0.0), min(vec4<${n}>(1.0), ${e.alpha} * ${s} + vec4<${n}>(${e.beta})))`,void 0,e.cacheKey))},EV=t=>{t.compute(Ut(t.inputs[0],"Sin","sin"))},AV=t=>{t.compute(Ut(t.inputs[0],"Sinh","sinh"))},RV=t=>{t.compute(Ut(t.inputs[0],"Sqrt","sqrt"))},DV=t=>{t.compute(Ut(t.inputs[0],"Tan","tan"))},Uv=t=>`sign(${t}) * (1 - exp(-2 * abs(${t}))) / (1 + exp(-2 * abs(${t})))`,OV=t=>{t.compute(Ut(t.inputs[0],"Tanh",Uv))},$2=(t="f32")=>`
const fast_gelu_a: ${t} = 0.5;
const fast_gelu_b: ${t} = 0.7978845608028654;
const fast_gelu_c: ${t} = 0.035677408136300125;

fn tanh_v(v: vec4<${t}>) -> vec4<${t}> {
  return ${Uv("v")};
}
`,S2=t=>`(fast_gelu_a + fast_gelu_a * tanh_v(${t} * (fast_gelu_c * ${t} * ${t} + fast_gelu_b))) * ${t}`,zV=t=>{let e=Ps(t.inputs[0].dataType);t.compute(Ut(t.inputs[0],"FastGelu",S2,$2(e),void 0,t.inputs[0].dataType))},FV=(t,e)=>{let n=Ps(t.inputs[0].dataType);return t.compute(Ut(t.inputs[0],"ThresholdedRelu",s=>`select(vec4<${n}>(0.0), ${s}, ${s} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${n}>(${e.alpha});`,e.cacheKey)),0},LV=t=>{t.compute(Ut(t.inputs[0],"Log","log"))},rR=(t,e)=>`
const alpha = vec4<${t}>(${e});
const one = ${t}(1.0);
const zero = ${t}(0.0);

fn quick_gelu_impl(x: vec4<${t}>) -> vec4<${t}> {
  let v = x *alpha;
  var x1 : vec4<${t}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,aR=t=>`quick_gelu_impl(${t})`,MV=(t,e)=>{let n=Ps(t.inputs[0].dataType);t.compute(Ut(t.inputs[0],"QuickGelu",aR,rR(n,e.alpha),e.cacheKey,t.inputs[0].dataType))}}),iR,oR,BV,$xe=ze(()=>{ht(),mt(),lT(),iR=t=>{if(t[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(t[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(t[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(t[0].dims[2]!==t[1].dims[0])throw new Error("last dimension of input and bias are not the same")},oR=t=>{let e=t[0].dims.slice();e[2]=e[2]/2;let n=Te("input",t[0].dataType,t[0].dims,4),s=Te("bias",t[0].dataType,[t[0].dims[2]],4),r=je("output",t[0].dataType,e,4),a=ve.size(e)/4,i=is(t[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:o=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${t[0].dims[2]/4/2}u;

  ${o.declareVariables(n,s,r)}

  ${f0(i)}

  ${o.mainStart()}
    ${o.guardAgainstOutOfBoundsWorkgroupSizes(a)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${r.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},BV=t=>{iR(t.inputs),t.compute(oR(t.inputs))}}),lR,uR,Pa,PV,VV,UV,WV,GV,HV,qV,jV,KV,XV,Sxe=ze(()=>{it(),ht(),mt(),lR=(t,e,n,s,r,a,i,o,l,c,h,p)=>{let f,g;typeof o=="string"?f=g=($,T)=>`${o}((${$}),(${T}))`:typeof o=="function"?f=g=o:(f=o.scalar,g=o.vector);let y=je("outputData",h,s.length,4),x=Te("aData",l,e.length,4),w=Te("bData",c,n.length,4),v;if(r)if(a){let $=ve.size(e)===1,T=ve.size(n)===1,C=e.length>0&&e[e.length-1]%4===0,I=n.length>0&&n[n.length-1]%4===0;$||T?v=y.setByOffset("global_idx",g($?`${x.type.value}(${x.getByOffset("0")}.x)`:x.getByOffset("global_idx"),T?`${w.type.value}(${w.getByOffset("0")}.x)`:w.getByOffset("global_idx"))):v=`
            let outputIndices = ${y.offsetToIndices("global_idx * 4u")};
            let offsetA = ${x.broadcastedIndicesToOffset("outputIndices",y)};
            let offsetB = ${w.broadcastedIndicesToOffset("outputIndices",y)};
            ${y.setByOffset("global_idx",g(i||C?x.getByOffset("offsetA / 4u"):`${x.type.value}(${x.getByOffset("offsetA / 4u")}[offsetA % 4u])`,i||I?w.getByOffset("offsetB / 4u"):`${w.type.value}(${w.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else v=y.setByOffset("global_idx",g(x.getByOffset("global_idx"),w.getByOffset("global_idx")));else{if(!a)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let $=(T,C,I="")=>{let A=`aData[indexA${C}][componentA${C}]`,O=`bData[indexB${C}][componentB${C}]`;return`
            let outputIndices${C} = ${y.offsetToIndices(`global_idx * 4u + ${C}u`)};
            let offsetA${C} = ${x.broadcastedIndicesToOffset(`outputIndices${C}`,y)};
            let offsetB${C} = ${w.broadcastedIndicesToOffset(`outputIndices${C}`,y)};
            let indexA${C} = offsetA${C} / 4u;
            let indexB${C} = offsetB${C} / 4u;
            let componentA${C} = offsetA${C} % 4u;
            let componentB${C} = offsetB${C} % 4u;
            ${T}[${C}] = ${I}(${f(A,O)});
          `};h===9?v=`
            var data = vec4<u32>(0);
            ${$("data",0,"u32")}
            ${$("data",1,"u32")}
            ${$("data",2,"u32")}
            ${$("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:v=`
            ${$("outputData[global_idx]",0)}
            ${$("outputData[global_idx]",1)}
            ${$("outputData[global_idx]",2)}
            ${$("outputData[global_idx]",3)}
          `}return`
        ${t.registerUniform("vec_size","u32").declareVariables(x,w,y)}

        ${p??""}

        ${t.mainStart()}
        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${v}
      }`},uR=(t,e,n,s,r,a,i=n.dataType)=>{let o=n.dims.map(x=>Number(x)??1),l=s.dims.map(x=>Number(x)??1),c=!ve.areEqual(o,l),h=o,p=ve.size(o),f=!1,g=!1,y=[c];if(c){let x=Xd.calcShape(o,l,!1);if(!x)throw new Error("Can't perform binary op on the given tensors");h=x.slice(),p=ve.size(h);let w=ve.size(o)===1,v=ve.size(l)===1,$=o.length>0&&o[o.length-1]%4===0,T=l.length>0&&l[l.length-1]%4===0;y.push(w),y.push(v),y.push($),y.push(T);let C=1;for(let I=1;I<h.length;I++){let A=o[o.length-I],O=l[l.length-I];if(A===O)C*=A;else break}C%4===0?(g=!0,f=!0):(w||v||$||T)&&(f=!0)}else f=!0;return y.push(f),{name:t,shaderCache:{hint:e+y.map(x=>x.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:x=>lR(x,o,l,h,f,c,g,r,n.dataType,s.dataType,i,a),getRunData:()=>({outputs:[{dims:h,dataType:i}],dispatchGroup:{x:Math.ceil(p/64/4)},programUniforms:[{type:12,data:Math.ceil(ve.size(h)/4)},...Je(o,l,h)]})}},Pa=(t,e,n,s,r,a)=>{t.compute(uR(e,r??"",t.inputs[0],t.inputs[1],n,s,a))},PV=t=>{Pa(t,"Add",(e,n)=>`${e}+${n}`)},VV=t=>{Pa(t,"Div",(e,n)=>`${e}/${n}`)},UV=t=>{Pa(t,"Equal",{scalar:(e,n)=>`u32(${e}==${n})`,vector:(e,n)=>`vec4<u32>(${e}==${n})`},void 0,void 0,9)},WV=t=>{Pa(t,"Mul",(e,n)=>`${e}*${n}`)},GV=t=>{let e=Te("input",t.inputs[0].dataType,t.inputs[0].dims).type.value;Pa(t,"Pow",{scalar:(n,s)=>`pow_custom(${n},${s})`,vector:(n,s)=>`pow_vector_custom(${n},${s})`},`
    fn pow_custom(a : ${e}, b : ${e}) -> ${e} {
      if (b == ${e}(0.0)) {
        return ${e}(1.0);
      } else if (a < ${e}(0.0) && f32(b) != floor(f32(b))) {
        return ${e}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${e}(1.0), round(f32(abs(b) % ${e}(2.0))) != 1.0) * ${e}(${e==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${e}>, b : vec4<${e}>) -> vec4<${e}> {
      // TODO: implement vectorized pow
      return vec4<${e}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},HV=t=>{Pa(t,"Sub",(e,n)=>`${e}-${n}`)},qV=t=>{Pa(t,"Greater",{scalar:(e,n)=>`u32(${e}>${n})`,vector:(e,n)=>`vec4<u32>(${e}>${n})`},void 0,void 0,9)},jV=t=>{Pa(t,"Less",{scalar:(e,n)=>`u32(${e}<${n})`,vector:(e,n)=>`vec4<u32>(${e}<${n})`},void 0,void 0,9)},KV=t=>{Pa(t,"GreaterOrEqual",{scalar:(e,n)=>`u32(${e}>=${n})`,vector:(e,n)=>`vec4<u32>(${e}>=${n})`},void 0,void 0,9)},XV=t=>{Pa(t,"LessOrEqual",{scalar:(e,n)=>`u32(${e}<=${n})`,vector:(e,n)=>`vec4<u32>(${e}<=${n})`},void 0,void 0,9)}}),cR,dR,hR,pR,YV,ZV,_xe=ze(()=>{it(),ht(),Tn(),mt(),cR=(t,e)=>{if(!t||t.length<1)throw new Error("too few inputs");let n=0,s=t[n],r=s.dataType,a=s.dims.length;t.forEach((i,o)=>{if(o!==n){if(i.dataType!==r)throw new Error("input tensors should be one type");if(i.dims.length!==a)throw new Error("input tensors should have the same shape");i.dims.forEach((l,c)=>{if(c!==e&&l!==s.dims[c])throw new Error("non concat dimensions must match")})}})},dR=(t,e)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${t}u>(${e});
    for (var i: u32 = 0u; i < ${t}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${t}u;
  }`,hR=(t,e)=>{let n=t.length,s=[];for(let r=0;r<n;++r){let a=e.setByOffset("global_idx",t[r].getByIndices("indices"));n===1?s.push(a):r===0?s.push(`if (inputIndex == ${r}u) { ${a} }`):r===n-1?s.push(`else { ${a} }`):s.push(`else if (inputIndex == ${r}) { ${a} }`)}return s.join(`
`)},pR=(t,e,n,s)=>{let r=ve.size(n),a=new Array(t.length),i=new Array(t.length),o=0,l=[],c=[],h=[{type:12,data:r}];for(let x=0;x<t.length;++x)o+=t[x].dims[e],a[x]=o,c.push(t[x].dims.length),i[x]=Te(`input${x}`,s,c[x]),l.push("rank"),h.push({type:12,data:a[x]});for(let x=0;x<t.length;++x)h.push(...Je(t[x].dims));h.push(...Je(n));let p=je("output",s,n.length),f=p.indicesGet("indices",e),g=Array.from(Array(a.length).keys()).map(x=>`uniforms.sizeInConcatAxis${x}`).join(","),y=x=>`

  ${(()=>{x.registerUniform("outputSize","u32");for(let w=0;w<t.length;w++)x.registerUniform(`sizeInConcatAxis${w}`,"u32");return x.declareVariables(...i,p)})()}

  ${dR(a.length,g)}

  ${x.mainStart()}
    ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${p.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${f});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${a.length}u>(${g});
      ${f} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${hR(i,p)}
  }`;return{name:"Concat",shaderCache:{hint:`${e}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:n,dataType:s}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:h}),getShaderSource:y}},YV=(t,e)=>{let n=t.inputs,s=n[0].dims,r=ve.normalizeAxis(e.axis,s.length);cR(n,r);let a=s.slice();a[r]=n.reduce((o,l)=>o+(l.dims.length>r?l.dims[r]:0),0);let i=n.filter(o=>ve.size(o.dims)>0);t.compute(pR(i,r,a,n[0].dataType),{inputs:i})},ZV=t=>Xt({axis:t.axis})}),gc,yc,bc,uT,Rc=ze(()=>{it(),ht(),gc=(t,e,n="f32")=>{switch(t.activation){case"Relu":return`value = max(value, ${e}(0.0));`;case"Sigmoid":return`value = (${e}(1.0) / (${e}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${e}(${n}(uniforms.clip_min)), ${e}(${n}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${e}(0.0), min(${e}(1.0), ${n}(uniforms.alpha) * value + ${n}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${n}(uniforms.alpha) * value, value, value >= ${e}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw new Error(`Unsupported activation ${t.activation}`)}},yc=(t,e)=>{t.activation==="Clip"?e.push({type:1,data:t.clipMax},{type:1,data:t.clipMin}):t.activation==="HardSigmoid"?e.push({type:1,data:t.alpha},{type:1,data:t.beta}):t.activation==="LeakyRelu"&&e.push({type:1,data:t.alpha})},bc=(t,e)=>{t.activation==="Clip"?e.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):t.activation==="HardSigmoid"?e.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):t.activation==="LeakyRelu"&&e.push({name:"alpha",type:"f32"})},uT=t=>{let e=(t==null?void 0:t.activation)||"";if(e==="HardSigmoid"){let[n,s]=(t==null?void 0:t.activation_params)||[.2,.5];return{activation:e,alpha:n,beta:s}}else if(e==="Clip"){let[n,s]=(t==null?void 0:t.activation_params)||[kP,NP];return{activation:e,clipMax:s,clipMin:n}}else if(e==="LeakyRelu"){let[n]=(t==null?void 0:t.activation_params)||[.01];return{activation:e,alpha:n}}return{activation:e}}}),fs,QV,cT=ze(()=>{fs=(t,e)=>{switch(t){case 1:return e;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${t}-component is not supported.`)}},QV=t=>`
      ${t?"value = value + getBiasByOutputCoords(coords);":""}
      `}),JV,Cxe=ze(()=>{JV=t=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${t}.x), i32(${t}.y), i32(${t}.z), 1));
}
`}),uf,dT,hT=ze(()=>{it(),ht(),mt(),Rc(),uf=(t,e,n,s,r)=>{let a=s-n;return`
      ${Array.from({length:n}).map((i,o)=>`
      if (${Ke(e.shape,o,e.rank)} != 1) {
        ${e.indicesSet(t,o,Ke(r,o+a,s))}
      } else {
        ${e.indicesSet(t,o,0)}
      }`).join("")}
`},dT=(t,e,n,s,r=!1,a)=>{let i=t[0].dims,o=t[1].dims,l=i[i.length-2],c=o[o.length-1],h=i[i.length-1],p=bn(c),f=bn(h),g=bn(l),y=ve.size(n)/p/g,x=t.length>2,w=s?s.slice(0,-2):n.slice(0,-2),v=[ve.size(w),l,c],$=[{type:12,data:y},{type:12,data:l},{type:12,data:c},{type:12,data:h}];yc(e,$),$.push(...Je(w,i,o)),x&&$.push(...Je(t[2].dims)),$.push(...Je(v));let T=C=>{let I=aT("batch_dims",t[0].dataType,w.length),A=Te("a",t[0].dataType,i.length,f),O=Te("b",t[1].dataType,o.length,p),B=je("output",t[0].dataType,v.length,p),z=is(B.type.tensor),P=gc(e,B.type.value,z),F=[A,O],K="";if(x){let Q=r?p:1;F.push(Te("bias",t[2].dataType,t[2].dims.length,Q)),K=`${r?`value += bias[col / ${Q}];`:`value += ${B.type.value}(bias[row + i]);`}`}let X=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];bc(e,X);let te=()=>{let Q=`var a_data: ${A.type.value};`;for(let q=0;q<f;q++)Q+=`
              let b_data${q} = b[(b_offset + (k + ${q}) * uniforms.N + col) / ${p}];`;for(let q=0;q<g;q++){Q+=`a_data = a[(a_offset + (row + ${q}) * uniforms.K + k) / ${f}];`;for(let oe=0;oe<f;oe++)Q+=`
            values[${q}] = fma(${O.type.value}(a_data${f===1?"":`[${oe}]`}), b_data${oe}, values[${q}]);
`}return Q};return`
  ${C.registerUniforms(X).registerInternalVariables(I).declareVariables(...F,B)}
  ${C.mainStart()}
    ${C.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${p})) * ${p};
    var index1 = global_idx / (uniforms.N / ${p});
    let stride1 = uniforms.M / ${g};
    let row = (index1 % stride1) * ${g};
    let batch = index1 / stride1;

    ${n.length===2?"":`let batch_indices = ${I.offsetToIndices("batch")};`}

    var a_indices: ${A.type.indices};
    ${uf("a_indices",A,A.rank-2,I.rank,"batch_indices")}
    ${A.indicesSet("a_indices",A.rank-2,0)}
    ${A.indicesSet("a_indices",A.rank-1,0)}
    let a_offset = ${A.indicesToOffset("a_indices")};

    var b_indices: ${O.type.indices};
    ${uf("b_indices",O,O.rank-2,I.rank,"batch_indices")}
    ${O.indicesSet("b_indices",O.rank-2,0)}
    ${O.indicesSet("b_indices",O.rank-1,0)}
    let b_offset = ${O.indicesToOffset("b_indices")};
    var values: array<${B.type.value}, ${g}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${f}) {
      ${te()}
    }
    for (var i = 0u; i < ${g}u; i++) {
      var value = values[i];
      ${K}
      ${P}
      let cur_indices = ${B.type.indices}(batch, row + i, col);
      let offset = ${B.indicesToOffset("cur_indices")};
      ${B.setByOffset(`offset / ${p}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${e.activation};${p};${f};${g};${r}`,inputDependencies:x?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:a?a(n):n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:$}),getShaderSource:T}}}),fR,mR,_2,Wv,gR,C2,yR,Z0,pT=ze(()=>{it(),ht(),mt(),Rc(),hT(),cT(),fR=(t,e)=>t?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${e?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${e?", batchIndices":""});
        `,mR=(t,e)=>t?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${e===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,_2=(t,e,n="f32",s,r=!1,a=32,i=!1,o=32)=>{let l=e[1]*t[1],c=e[0]*t[0],h=r?l:a,p=r?a:l,f=h/e[0],g=a/e[1];if(!((r&&f===4&&t[1]===4||!r&&(f===3||f===4))&&h%e[0]===0&&a%e[1]===0&&t[0]===4))throw new Error(`If transposeA ${r} is true, innerElementSize ${f} and workPerThread[1] ${t[1]} must be 4.
      Otherwise, innerElementSize ${f} must be 3 or 4.
  tileAWidth ${h} must be divisible by workgroupSize[0]${e[0]}. tileInner ${a} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${t[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${f}<${n}>, ${h/f}>, ${p}>;
var<workgroup> mm_Bsub: array<array<vec4<${n}>, ${c/t[0]}>, ${a}>;

const rowPerThread = ${t[1]};
const colPerThread = ${t[0]};
const innerElementSize = ${f};
const tileInner = ${a};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${i?"0":"i32(globalId.z)"};
  ${s?`let batchIndices = ${s.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${l};

  let num_tiles = ${i?`${Math.ceil(o/a)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${i?`i32(globalId.z) * ${o}`:"0"};

  var acc: array<vec4<${n}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${g};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${fR(r,s)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${g}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${s?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${f===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${mR(r,f)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},Wv=(t,e)=>t?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${e?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${e?", batchIndices":""});
            `,gR=t=>t?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",C2=(t,e,n="f32",s,r=!1,a=32,i=!1,o=32,l=!1)=>{let c=t[1]*e[1],h=t[0]*e[0],p=r?c:a,f=r?a:c;if(!(f%e[1]===0&&p%e[0]===0&&a%e[1]===0))throw new Error(`tileAHight ${f} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${p} must be divisible by workgroupSize[0]${e[0]}, tileInner ${a} must be divisible by workgroupSize[1]${e[1]}`);let g=f/e[1],y=p/e[0],x=a/e[1],w=l?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${c};
    let globalColStart = i32(workgroupId.x) * ${h};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${f}; inputRow = inputRow + ${e[1]}) {
        for (var inputCol = localCol; inputCol < ${p}; inputCol = inputCol + ${e[0]}) {
          ${Wv(r,s)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${a}; inputRow = inputRow + ${e[1]}) {
            for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${e[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${s?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${n}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${r?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${e[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${e[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${c};

let tileRowA = i32(localId.y) * ${g};
let tileColA = i32(localId.x) * ${y};
let tileRowB = i32(localId.y) * ${x};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${g}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${y}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${Wv(r,s)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${x}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${s?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${n}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${gR(r)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${n}, ${p}>, ${f}>;
  var<workgroup> mm_Bsub : array<array<${n}, ${h}>, ${a}>;
  const rowPerThread = ${t[1]};
  const colPerThread = ${t[0]};
  const tileInner = ${a};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${i?"0":"i32(globalId.z)"};
    ${s?`let batchIndices = ${s.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${i?`${Math.ceil(o/a)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${i?`i32(globalId.z) * ${o}`:"0"};

    var acc : array<array<${n}, colPerThread>, rowPerThread>;
    ${w}
  }
`},yR=(t,e,n,s,r=!1)=>{let[a,i,o,l]=s,c=is(s[0].type.tensor);return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${fs(t,c)} {
      var value = ${fs(t,c)}(0.0);
      let col = colIn * ${t};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${i.type.indices};
        ${uf("aIndices",i,i.rank-2,a.rank,"batchIndices")}
        ${i.indicesSet("aIndices",i.rank-2,"u32(row)")}
        ${i.indicesSet("aIndices",i.rank-1,"u32(colIn)")}
        value = ${i.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${fs(t,c)} {
      var value = ${fs(t,c)}(0.0);
      let col = colIn * ${t};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${o.type.indices};
        ${uf("bIndices",o,o.rank-2,a.rank,"batchIndices")}
        ${o.indicesSet("bIndices",o.rank-2,"u32(row)")}
        ${o.indicesSet("bIndices",o.rank-1,"u32(colIn)")}
        value = ${o.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${fs(t,c)}) {
      let col = colIn * ${t};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${e?`value = value + ${r?"bias[colIn]":`${fs(t,c)}(bias[row])`};`:""}
        ${n}
        ${l.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},Z0=(t,e,n,s,r=!1,a)=>{let i=t[0].dims,o=t[1].dims,l=i.slice(0,-2),c=o.slice(0,-2),h=s?s.slice(0,-2):n.slice(0,-2),p=ve.size(h),f=i[i.length-2],g=i[i.length-1],y=o[o.length-1],x=g%4===0&&y%4===0,w=f<=8?[4,1,1]:[4,4,1],v=[8,8,1],$=[Math.ceil(y/v[0]/w[0]),Math.ceil(f/v[1]/w[1]),Math.ceil(p/v[2]/w[2])],T=x?4:1,C=[...l,f,g/T],I=C.length,A=[...c,g,y/T],O=A.length,B=[p,f,y/T],z=[{type:6,data:f},{type:6,data:y},{type:6,data:g}];yc(e,z),z.push(...Je(h,C,A));let P=["rank","rank"],F=t.length>2;F&&(z.push(...Je(t[2].dims)),P.push("rank")),z.push(...Je(B));let K=X=>{let te=h.length,Q=aT("batchDims",t[0].dataType,te,1),q=is(t[0].dataType),oe=Te("a",t[0].dataType,I,T),se=Te("b",t[1].dataType,O,T),ee=je("result",t[0].dataType,B.length,T),U=[oe,se];if(F){let J=r?T:1;U.push(Te("bias",t[2].dataType,t[2].dims.length,J))}let G=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];bc(e,G);let Y=is(ee.type.tensor),ce=gc(e,ee.type.value,Y),pe=yR(T,F,ce,[Q,oe,se,ee],r);return`
  ${X.registerUniforms(G).registerInternalVariables(Q).declareVariables(...U,ee)}
  ${pe}
  ${x?_2(w,v,q,Q):C2(w,v,q,Q)}
                   `};return{name:"MatMul",shaderCache:{hint:`${w};${e.activation};${x};${r}`,inputDependencies:P},getRunData:()=>({outputs:[{dims:a?a(n):n,dataType:t[0].dataType}],dispatchGroup:{x:$[0],y:$[1],z:$[2]},programUniforms:z}),getShaderSource:K}}}),bR,eU,Txe=ze(()=>{it(),zo(),mt(),Rc(),cT(),Cxe(),pT(),bR=(t,e,n,s,r=!1,a,i=4,o=4,l=4,c="f32")=>{let h=z=>{switch(z){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${c}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${z} is not supported.`)}},p=z=>{switch(z){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${z} is not supported.`)}},f=t?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,g=t?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,y=t?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",x=t?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",w=t?"row":"col",v=t?"col":"row",$=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${t?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${w} / outWidth;
    let outCol = ${w} % outWidth;

    let WRow = ${v} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${v} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${v} % inChannels;
    var resData = ${fs(i,c)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${y} && xCol >= 0 && xCol < ${x}) {
      ${f}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${h(i)}
    }
    return resData;`,T=t?e&&s?`
    let col = colIn * ${i};
    ${$}`:`
    let col = colIn * ${i};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${$}
    }
    return ${fs(i,c)}(0.0);`:s&&n?`
    let col = colIn * ${i};
    ${$}`:`
    let col = colIn * ${i};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${$}
    }
    return ${fs(i,c)}(0.0);`,C=t?s&&n?p(o):`
    let col = colIn * ${o};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${p(o)}
    }
    return ${fs(o,c)}(0.0);`:`
    let col = colIn * ${o};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${p(o)}
    }
    return ${fs(o,c)}(0.0);`,I=fs(l,c),A=fs(t?i:o,c),O=fs(t?o:i,c),B=gc(a,I,c);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${A} {
      ${t?T:C}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${O} {
      ${t?C:T}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${I}) {
      let col = colIn * ${l};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${t?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${g}
      ${QV(r)}
      ${B}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},eU=(t,e,n,s,r,a,i,o,l)=>{let c=e.format==="NHWC",h=c?t[0].dims[3]:t[0].dims[1],p=n[0],f=c?n[2]:n[3],g=c?n[1]:n[2],y=c?n[3]:n[1],x=c&&(h%4===0||h%3===0)&&y%4===0,w=c?y:f*g,v=c?f*g:y,$=[8,8,1],T=s<=8?[4,1,1]:[4,4,1],C=[Math.ceil(w/$[0]/T[0]),Math.ceil(v/$[1]/T[1]),Math.ceil(p/$[2]/T[2])];zt("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${C}`);let I=x?c&&h%4!==0?3:4:1,A=$[1]*T[1],O=$[0]*T[0],B=Math.max($[0]*I,$[1]),z=s%A===0,P=r%O===0,F=a%B===0,K=x?[I,4,4]:[1,1,1],X=[{type:6,data:s},{type:6,data:r},{type:6,data:a},{type:6,data:[e.pads[0],e.pads[1]]},{type:6,data:e.strides},{type:6,data:e.dilations}];yc(e,X),X.push(...Je(t[0].dims,t[1].dims));let te=["rank","rank"];i&&(X.push(...Je(t[2].dims)),te.push("rank")),X.push(...Je(n));let Q=q=>{let oe=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];bc(e,oe);let se=x?4:1,ee=is(t[0].dataType),U=`
      fn setOutputAtIndex(flatIndex : i32, value : ${x?`vec4<${ee}>`:ee}) {
        result[flatIndex] = ${x?`vec4<${ee}>`:ee}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${x?`vec4<${ee}>`:ee}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${x?"/ 4":""}, value);
      }`,G=Te("x",t[0].dataType,t[0].dims.length,I===3?1:I),Y=Te("w",t[1].dataType,t[1].dims.length,se),ce=[G,Y],pe=je("result",t[0].dataType,n.length,se);if(i){let J=Te("bias",t[2].dataType,t[2].dims.length,se);ce.push(J),U+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${x?`vec4<${ee}>`:ee} {
          return bias[coords.${c?"w":"y"}${x?"/ 4":""}];
        }`}return`
        ${JV("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${q.registerUniforms(oe).declareVariables(...ce,pe)}
        ${U}
        ${bR(c,z,P,F,i,e,K[0],K[1],K[2],ee)}
        ${x?_2(T,$,ee,void 0,!c,B):C2(T,$,ee,void 0,!c,B,!1,void 0,o)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${e.cacheKey};${I};${x};${z};${P};${F};${A};${O};${B}`,inputDependencies:te},getRunData:()=>({outputs:[{dims:l?l(n):n,dataType:t[0].dataType}],dispatchGroup:{x:C[0],y:C[1],z:C[2]},programUniforms:X}),getShaderSource:Q}}}),xR,Gv,Gp,wR,Hv,vR,tU,nU,kxe=ze(()=>{it(),zo(),ht(),mt(),Rc(),cT(),xR=t=>{let e=1;for(let n=0;n<t.length;n++)e*=t[n];return e},Gv=t=>typeof t=="number"?[t,t,t]:t,Gp=(t,e)=>e<=1?t:t+(t-1)*(e-1),wR=(t,e,n,s=1)=>{let r=Gp(e,s);return Math.floor((t[0]*(n-1)-n+r)/2)},Hv=(t,e,n,s,r)=>{r==null&&(r=wR(t,e[0],s[0]));let a=[0,0,0,n];for(let i=0;i<3;i++)t[i]+2*r>=e[i]&&(a[i]=Math.trunc((t[i]-e[i]+2*r)/s[i]+1));return a},vR=(t,e,n,s,r,a,i,o,l,c)=>{let h,p,f,g;if(t==="VALID"&&(t=0),typeof t=="number"){h={top:t,bottom:t,left:t,right:t,front:t,back:t};let y=Hv([e,n,s,1],[o,l,c],1,[r,a,i],t);p=y[0],f=y[1],g=y[2]}else if(Array.isArray(t)){if(!t.every((x,w,v)=>x===v[0]))throw Error(`Unsupported padding parameter: ${t}`);h={top:t[0],bottom:t[1],left:t[2],right:t[3],front:t[4],back:t[5]};let y=Hv([e,n,s,1],[o,l,c],1,[r,a,i],t[0]);p=y[0],f=y[1],g=y[2]}else if(t==="SAME_UPPER"){p=Math.ceil(e/r),f=Math.ceil(n/a),g=Math.ceil(s/i);let y=(p-1)*r+o-e,x=(f-1)*a+l-n,w=(g-1)*i+c-s,v=Math.floor(y/2),$=y-v,T=Math.floor(x/2),C=x-T,I=Math.floor(w/2),A=w-I;h={top:T,bottom:C,left:I,right:A,front:v,back:$}}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:h,outDepth:p,outHeight:f,outWidth:g}},tU=(t,e,n,s,r,a=!1,i="channelsLast")=>{let o,l,c,h,p;if(i==="channelsLast")[o,l,c,h,p]=t;else if(i==="channelsFirst")[o,p,l,c,h]=t;else throw new Error(`Unknown dataFormat ${i}`);let[f,,g,y,x]=e,[w,v,$]=Gv(n),[T,C,I]=Gv(s),A=Gp(g,T),O=Gp(y,C),B=Gp(x,I),{padInfo:z,outDepth:P,outHeight:F,outWidth:K}=vR(r,l,c,h,w,v,$,A,O,B),X=a?f*p:f,te=[0,0,0,0,0];return i==="channelsFirst"?te=[o,X,P,F,K]:i==="channelsLast"&&(te=[o,P,F,K,X]),{batchSize:o,dataFormat:i,inDepth:l,inHeight:c,inWidth:h,inChannels:p,outDepth:P,outHeight:F,outWidth:K,outChannels:X,padInfo:z,strideDepth:w,strideHeight:v,strideWidth:$,filterDepth:g,filterHeight:y,filterWidth:x,effectiveFilterDepth:A,effectiveFilterHeight:O,effectiveFilterWidth:B,dilationDepth:T,dilationHeight:C,dilationWidth:I,inShape:t,outShape:te,filterShape:e}},nU=(t,e,n,s,r,a)=>{let i=a==="channelsLast";i?t[0].dims[3]:t[0].dims[1];let o=[64,1,1],l={x:n.map((w,v)=>v)},c=[Math.ceil(xR(l.x.map(w=>n[w]))/o[0]),1,1];zt("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${c}`);let h=1,p=ve.size(n),f=[{type:12,data:p},{type:12,data:s},{type:12,data:r},{type:12,data:e.strides},{type:12,data:e.dilations}];yc(e,f),f.push(...Je(t[0].dims,t[1].dims));let g=["rank","rank"],y=t.length===3;y&&(f.push(...Je(t[2].dims)),g.push("rank")),f.push(...Je(n));let x=w=>{let v=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:s.length},{name:"pads",type:"u32",length:r.length},{name:"strides",type:"u32",length:e.strides.length},{name:"dilations",type:"u32",length:e.dilations.length}];bc(e,v);let $=1,T=is(t[0].dataType),C=Te("x",t[0].dataType,t[0].dims.length,h),I=Te("W",t[1].dataType,t[1].dims.length,$),A=[C,I],O=je("result",t[0].dataType,n.length,$),B="";if(y){let F=Te("bias",t[2].dataType,t[2].dims.length,$);A.push(F),B+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${T} {
          return bias[${i?Ke("coords",4,5):Ke("coords",1,5)}];
        }`}let z=fs(h,T),P=gc(e,z,T);return`
            ${B}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${C.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${I.getByIndices("aIndices")};
            }
          ${w.registerUniforms(v).declareVariables(...A,O)}
          ${w.mainStart()}
          ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${O.offsetToIndices("global_idx")};
              let batch = ${Ke("coords",0,C.rank)};
              let d2 = ${i?Ke("coords",C.rank-1,C.rank):Ke("coords",1,C.rank)};
              let xFRCCorner = vec3<u32>(${i?Ke("coords",1,C.rank):Ke("coords",2,C.rank)},
              ${i?Ke("coords",2,C.rank):Ke("coords",3,C.rank)},
              ${i?Ke("coords",3,C.rank):Ke("coords",4,C.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${i?Ke("uniforms.x_shape",1,C.rank):Ke("uniforms.x_shape",2,C.rank)};
              let xShapeZ = ${i?Ke("uniforms.x_shape",2,C.rank):Ke("uniforms.x_shape",3,C.rank)};
              let xShapeW = ${i?Ke("uniforms.x_shape",3,C.rank):Ke("uniforms.x_shape",4,C.rank)};
              let xShapeU = ${i?Ke("uniforms.x_shape",4,C.rank):Ke("uniforms.x_shape",1,C.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${i?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${i?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${i?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${i?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${y?"value = value + getBiasByOutputCoords(coords)":""};
              ${P}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${e.cacheKey};${i};${h};${y}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:c[0],y:c[1],z:c[2]},programUniforms:f}),getShaderSource:x}}}),sU,rU,Nxe=ze(()=>{it(),ht(),mt(),Rc(),sU=(t,e,n,s)=>{let r=t.length>2,a=r?"value += b[output_channel];":"",i=t[0].dims,o=t[1].dims,l=e.format==="NHWC",c=l?n[3]:n[1],h=c/e.group,p=l&&h>=4?bn(c):1,f=ve.size(n)/p,g=[{type:12,data:f},{type:12,data:e.dilations},{type:12,data:[e.strides[0],e.strides[1]]},{type:12,data:[e.pads[0],e.pads[1]]},{type:12,data:h}];yc(e,g),g.push(...Je(i,[o[0],o[1],o[2],o[3]/p]));let y=r?["rank","rank","rank"]:["rank","rank"];g.push(...Je([n[0],n[1],n[2],n[3]/p]));let x=w=>{let v=je("output",t[0].dataType,n.length,p),$=is(v.type.tensor),T=gc(e,v.type.value,$),C=Te("x",t[0].dataType,i.length),I=Te("w",t[1].dataType,o.length,p),A=[C,I];r&&A.push(Te("b",t[2].dataType,t[2].dims,p));let O=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:e.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];bc(e,O);let B=l?`
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${C.get("batch","xHeight","xWidth","input_channel")};
            let wVal = ${I.get("wHeight","wWidth","wInChannel","output_channel")};
            value += xVal * wVal;
          }
        }
      }
      `:`
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${C.get("batch","input_channel","xHeight","xWidth")};
            let wVal = ${I.get("output_channel","wInChannel","wHeight","wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;return`
  ${w.registerUniforms(O).declareVariables(...A,v)}

  ${w.mainStart()}
    ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${v.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${l?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l?1:2}], outputIndices[${l?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${p} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${l?2:1}];

    var value: ${v.type.value} = ${v.type.value}(0);
    ${B}
    ${a}
    ${T}
    ${v.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:`${e.cacheKey}_${p}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:s?s(n):n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:g}),getShaderSource:x}},rU=(t,e,n,s)=>{let r=t.length>2,a=bn(n[3]),i=bn(n[2]),o=ve.size(n)/a/i,l=[t[0].dims[0],t[0].dims[1],t[0].dims[2],t[0].dims[3]/a],c=[t[1].dims[0],t[1].dims[1],t[1].dims[2],t[1].dims[3]/a],h=[n[0],n[1],n[2],n[3]/a],p=[{type:12,data:o},{type:6,data:[e.strides[0],e.strides[1]]},{type:6,data:[e.pads[0],e.pads[1]]}];yc(e,p),p.push(...Je(l,c,h));let f=(i-1)*e.strides[1]+c[1],g=y=>{let x=je("output",t[0].dataType,h.length,a),w=is(x.type.tensor),v=gc(e,x.type.value,w),$=Te("x",t[0].dataType,l.length,a),T=Te("w",t[1].dataType,c.length,a),C=[$,T];r&&C.push(Te("b",t[2].dataType,t[2].dims,a));let I=r?"value += b[output_channel];":"",A=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return bc(e,A),`
  ${y.registerUniforms(A).declareVariables(...C,x)}
  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${i}u;
    let col = (index1 % width1) * ${i}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${$.type.value}, ${f}>;
    var values: array<${x.type.value}, ${i}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${c[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${f}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${$.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${$.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${c[1]}; w_width++) {
          let w_val = ${T.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${i}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${i}u; i++) {
      var value = values[i];
      ${I}
      ${v}
      ${x.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${e.cacheKey};${a};${i};${f};${c[0]};${c[1]}`,inputDependencies:r?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:s?s(n):n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:p}),getShaderSource:g}}}),$R,jy,SR,Ky,T2,qv,_R,CR,k2,Ixe=ze(()=>{ht(),Txe(),kxe(),pT(),Nxe(),Rc(),hT(),tu(),$R=(t,e,n,s,r,a)=>{let i=t[0],o=t.slice(a?1:2,a?3:4),l=o.length,c=e[0],h=e.slice(2).map((f,g)=>f+(f-1)*(n[g]-1)),p=o.map((f,g)=>f+s[g]+s[g+l]).map((f,g)=>Math.floor((f-h[g]+r[g])/r[g]));return p.splice(0,0,i),p.splice(a?3:1,0,c),p},jy=[2,3,1,0],SR=(t,e)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length>5)throw new Error("greater than 5D is not supported");if(t[0].dims.length!==t[1].dims.length)throw new Error("filter does not have same dimension as input");let n=t[0].dims[e.format==="NHWC"?t[0].dims.length-1:1],s=t[1].dims[1]*e.group;if(n!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(t.length===3&&(t[2].dims.length!==1||t[1].dims[0]!==t[2].dims[0]))throw new Error("invalid bias");let r=t[0].dims.length-2;if(e.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(e.strides.length!==r)throw new Error(`strides should be ${r}D`);if(e.pads.length!==r*2)throw new Error(`pads should be ${r*2}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape")},Ky=(t,e)=>{let n=t.kernelShape.slice();n.length<e[1].dims.length-2&&n.push(...Array(e[1].dims.length-2-n.length).fill(0));for(let a=2;a<e[1].dims.length;++a)n[a-2]===0&&(n[a-2]=e[1].dims[a]);let s=t.pads.slice();X0.adjustPadsBasedOnAutoPad(e[0].dims,t.strides,t.dilations,n,s,t.format==="NHWC",t.autoPad);let r=Object.assign({},t);return Object.assign(r,{kernelShape:n,pads:s}),r},T2=t=>{let e=uT(t),n=t.format,s=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][t.auto_pad],r=t.dilations,a=t.group,i=t.kernel_shape,o=t.pads,l=t.strides,c=t.w_is_const();return{autoPad:s,format:n,dilations:r,group:a,kernelShape:i,pads:o,strides:l,wIsConst:c,...e,cacheKey:`${t.format};${e.activation};`}},qv=(t,e,n,s)=>{let r=n.format==="NHWC",a=$R(e[0].dims,e[1].dims,n.dilations,n.pads,n.strides,r);if(n.group!==1){let A=[e[0]];if(r){let O=t.kernelCustomData.wT??t.compute(jr(e[1],jy),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=O),A.push(O)}else A.push(e[1]);e.length===3&&A.push(e[2]),!t.adapterInfo.isArchitecture("ampere")&&r&&e[1].dims[0]===n.group&&e[1].dims[1]===1&&n.dilations[0]===1&&n.dilations[1]===1?t.compute(rU(A,n,a,s),{inputs:A}):t.compute(sU(A,n,a,s),{inputs:A});return}let i=e.length===3,o=e[0].dims[r?1:2],l=e[0].dims[r?2:3],c=e[0].dims[r?3:1],h=e[1].dims[2],p=e[1].dims[3],f=a[r?1:2],g=a[r?2:3],y=a[r?3:1],x=r&&h===o&&p===l&&n.pads[0]===0&&n.pads[1]===0;if(x||h===1&&p===1&&n.dilations[0]===1&&n.dilations[1]===1&&n.strides[0]===1&&n.strides[1]===1&&n.pads[0]===0&&n.pads[1]===0){let A=a[0],O,B,z,P=[];if(r){let X=t.kernelCustomData.wT??t.compute(jr(e[1],jy),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=X),x){let te=o*l*c;O=e[0].reshape([1,A,te]),B=X.reshape([1,te,y]),z=[1,A,y]}else O=e[0].reshape([A,o*l,c]),B=X.reshape([1,c,y]),z=[A,f*g,y];P.push(O),P.push(B)}else O=e[0].reshape([A,c,o*l]),B=e[1].reshape([1,y,c]),z=[A,y,f*g],P.push(B),P.push(O);i&&P.push(e[2]);let F=z[2],K=P[0].dims[P[0].dims.length-1];F<8&&K<8?t.compute(dT(P,n,a,z,r,s),{inputs:P}):t.compute(Z0(P,n,a,z,r,s),{inputs:P});return}let w=!0,v=t.kernelCustomData.wT??t.compute(jr(e[1],jy),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=v);let $=[e[0],v];i&&$.push(e[2]);let T=r?f*g:y,C=r?y:f*g,I=h*p*c;t.compute(eU($,n,a,T,C,I,i,w,s),{inputs:$})},_R=(t,e)=>{let n=e.format==="NHWC",s=[t.inputs[0].reshape(n?[t.inputs[0].dims[0],1,t.inputs[0].dims[1],t.inputs[0].dims[2]]:[t.inputs[0].dims[0],t.inputs[0].dims[1],1,t.inputs[0].dims[2]]),t.inputs[1].reshape([t.inputs[1].dims[0],t.inputs[1].dims[1],1,t.inputs[1].dims[2]])];t.inputs.length===3&&s.push(t.inputs[2]);let r=[0,e.pads[0],0,e.pads[1]],a=[1].concat(e.strides),i=[1].concat(e.dilations),o=[1].concat(e.kernelShape),l=Ky({...e,pads:r,strides:a,dilations:i,kernelShape:o},s);qv(t,s,l,c=>n?[c[0],c[2],c[3]]:[c[0],c[1],c[3]])},CR=(t,e,n)=>{let s=n.format==="NHWC"?"channelsLast":"channelsFirst",r=Ky(n,e),a=n.autoPad==="NOTSET"?n.pads:n.autoPad,i=tU(e[0].dims,e[1].dims,n.strides,n.dilations,a,!1,s);t.compute(nU(e,r,i.outShape,[i.filterDepth,i.filterHeight,i.filterWidth],[i.padInfo.front,i.padInfo.top,i.padInfo.left],s))},k2=(t,e)=>{if(SR(t.inputs,e),t.inputs[0].dims.length===3)_R(t,e);else if(t.inputs[0].dims.length===5)CR(t,t.inputs,e);else{let n=Ky(e,t.inputs);qv(t,t.inputs,n)}}}),aU,Exe=ze(()=>{it(),zo(),ht(),mt(),aU=(t,e,n)=>{let s=t.length>2,r=e.outputShape,a=e.format==="NHWC",i=e.group,o=t[1].dims,l=o[2]/i,c=o[3],h=a?bn(l):1,p=a?bn(c):1,f=a?c===1?h:p:1,g=ve.size(r)/p,y=[Math.ceil(g/64),1,1];zt("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${y}`);let x=["rank","rank"],w=[e.strides[0],e.strides[1]],v=[e.kernelShape[a?1:2],e.kernelShape[a?2:3]],$=[e.dilations[0],e.dilations[1]],T=[v[0]+(e.dilations[0]<=1?0:(e.kernelShape[a?1:2]-1)*(e.dilations[0]-1)),v[1]+(e.dilations[1]<=1?0:(e.kernelShape[a?2:3]-1)*(e.dilations[1]-1))],C=[T[0]-1-Math.floor((e.pads[0]+e.pads[2])/2),T[1]-1-Math.floor((e.pads[1]+e.pads[3])/2)],I=[{type:12,data:g},{type:12,data:w},{type:12,data:v},{type:12,data:$},{type:12,data:T},{type:6,data:C},{type:12,data:l},{type:12,data:c},...Je(t[0].dims,t[1].dims)];s&&(I.push(...Je(t[2].dims)),x.push("rank")),I.push(...Je(r));let A=O=>{let B=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:w.length},{name:"filter_dims",type:"u32",length:v.length},{name:"dilations",type:"u32",length:v.length},{name:"effective_filter_dims",type:"u32",length:T.length},{name:"pads",type:"i32",length:C.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],z=is(t[0].dataType),P=a?1:2,F=a?2:3,K=a?3:1,X=Te("W",t[1].dataType,t[1].dims.length,f),te=Te("Dy",t[0].dataType,t[0].dims.length,h),Q=[te,X];s&&Q.push(Te("bias",t[2].dataType,[r[K]].length,p));let q=je("result",t[0].dataType,r.length,p),oe=()=>{let ee="";if(h===1)ee+=`
        let w_offset = ${X.indicesToOffset(`${X.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
        let wValue = ${X.getByOffset(`w_offset / ${f}`)};
        dotProd = dotProd + xValue * wValue;`;else if(c===1)ee+=`
          let wValue = ${X.getByOffset(`${X.indicesToOffset(`${X.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)} / ${f}`)};
          dotProd = dotProd + dot(xValue, wValue);`;else for(let U=0;U<h;U++)ee+=`
            let wValue${U} = ${X.getByOffset(`${X.indicesToOffset(`${X.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${U}, wOutChannel)`)} / ${f}`)};
            dotProd = dotProd + xValue[${U}] * wValue${U};`;return ee},se=`
            let outputIndices = ${q.offsetToIndices(`global_idx * ${p}`)};
            let batch = ${q.indicesGet("outputIndices",0)};
            let d1 = ${q.indicesGet("outputIndices",K)};
            let r = ${q.indicesGet("outputIndices",P)};
            let c = ${q.indicesGet("outputIndices",F)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${q.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${z}(dyRCorner) + ${z}(wR)) / ${z}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${z}(uniforms.Dy_shape[${P}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }

              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${z}(dyCCorner) + ${z}(wC)) / ${z}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${z}(uniforms.Dy_shape[${F}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + ${h}) {
                  let xValue = ${a?te.getByOffset(`${te.indicesToOffset(`${te.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${h}`):te.get("batch","inputChannel","idyR","idyC")};
                  ${oe()}
                  inputChannel = inputChannel + ${h};
                }
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${s?` + bias[d1 / ${p}]`:""};
            ${q.setByOffset("global_idx","value")};
          `;return`
    ${O.registerUniforms(B).declareVariables(...Q,q)}
      ${O.mainStart()}
      ${O.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${se}}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${e.cacheKey};${h}${f}${p}${c===1}`,inputDependencies:x},getRunData:()=>({dispatchGroup:{x:y[0],y:y[1],z:y[2]},outputs:[{dims:n?n(r):r,dataType:t[0].dataType}],programUniforms:I}),getShaderSource:A}}}),TR,kR,NR,jv,iU,IR,Kv,ER,oU,Axe=ze(()=>{Exe(),Rc(),tu(),TR=(t,e,n,s,r,a)=>(t-1)*e+n+(s-1)*r+1-a,kR=(t,e,n,s,r)=>{let a=Math.floor(t/2);e==="SAME_UPPER"?(n[s]=a,n[r]=t-a):e==="SAME_LOWER"&&(n[s]=t-a,n[r]=a)},NR=(t,e,n,s,r,a,i,o,l,c)=>{let h=t.length-2,p=c.length===0;l.length<h&&l.push(...Array(h-l.length).fill(0));let f=t[0],g=e[o?3:1]*r;for(let y=0,x=t.length-h-(o?1:0);y<h;++y,++x){let w=t[x],v=p?w*i[y]:c[y],$=TR(w,i[y],a[y],e[x],n[y],v);kR($,s,a,y,y+h),p&&c.push(i[y]*(w-1)+l[y]+(e[x]-1)*n[y]+1-a[y]-a[y+h])}c.splice(0,0,f),c.splice(o?3:1,0,g)},jv=(t,e)=>{let n=t.kernelShape.slice();if(t.kernelShape.length===0||t.kernelShape.reduce((p,f)=>p*f,1)===0){n.length=0;for(let p=2;p<e[1].dims.length;++p)n.push(e[1].dims[p])}let s=t.format==="NHWC";n.splice(0,0,e[1].dims[0]),n.splice(s?3:1,0,e[1].dims[1]);let r=t.pads.slice(),a=t.outputShape.slice(),i=t.outputPadding.slice(),o=e[0].dims,l=t.dilations.slice();if(l.reduce((p,f)=>p+f,0)===0){let p=e[0].dims.length-2;l=new Array(p).fill(1)}let c=t.strides.slice();if(c.reduce((p,f)=>p+f,0)===0){let p=e[0].dims.length-2;c=new Array(p).fill(1)}NR(o,n,l,t.autoPad,t.group,r,c,s,i,a);let h=Object.assign({},t);return Object.assign(h,{kernelShape:n,pads:r,outputPadding:i,outputShape:a,dilations:l,strides:c}),h},iU=t=>{let e=uT(t),n=t.format,s=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof t.autoPad>"u"?0:t.autoPad],r=t.dilations,a=t.group,i=t.kernelShape,o=t.pads,l=t.strides,c=t.wIsConst(),h=t.outputPadding,p=t.outputShape;return{autoPad:s,format:n,dilations:r,group:a,kernelShape:i,outputPadding:h,outputShape:p,pads:o,strides:l,wIsConst:c,...e,cacheKey:`${t.format};${e.activation};`}},IR=(t,e)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length!==4&&t[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(t[0].dims.length!==t[1].dims.length)throw new Error("filter does not have same dimension as input");let n=t[0].dims[e.format==="NHWC"?t[0].dims.length-1:1],s=t[1].dims[0];if(n!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let r=t[1].dims[1]*e.group;if(t.length===3&&(t[2].dims.length!==1||t[2].dims[0]!==r))throw new Error("invalid bias");let a=t[0].dims.length-2;if(e.dilations.reduce((i,o)=>i+o,0)>0&&e.dilations.length!==a)throw new Error(`dilations should be ${a}D`);if(e.strides.reduce((i,o)=>i+o,0)>0&&e.strides.length!==a)throw new Error(`strides should be ${a}D`);if(e.pads.reduce((i,o)=>i+o,0)>0&&e.pads.length!==a*2)throw new Error(`pads should be ${a*2}D`);if(e.outputPadding.length!==a&&e.outputPadding.length!==0)throw new Error(`output_padding should be ${a}D`);if(e.kernelShape.reduce((i,o)=>i+o,0)>0&&e.kernelShape.length!==0&&e.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if(e.outputShape.length!==0&&e.outputShape.length!==t[0].dims.length-2)throw new Error("invalid output shape")},Kv=(t,e,n,s)=>{let r=t.kernelCustomData.wT??t.compute(jr(e[1],[2,3,0,1]),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=r);let a=[e[0],r];e.length===3&&a.push(e[2]),t.compute(aU(a,n,s),{inputs:a})},ER=(t,e)=>{let n=e.format==="NHWC",s=[t.inputs[0].reshape(n?[t.inputs[0].dims[0],1,t.inputs[0].dims[1],t.inputs[0].dims[2]]:[t.inputs[0].dims[0],t.inputs[0].dims[1],1,t.inputs[0].dims[2]]),t.inputs[1].reshape([t.inputs[1].dims[0],t.inputs[1].dims[1],1,t.inputs[1].dims[2]])];t.inputs.length===3&&s.push(t.inputs[2]);let r=e.kernelShape;(r.length===0||r[0]===0)&&(r=[t.inputs[1].dims[2]]);let a=e.dilations;(a.length===0||a[0]===0)&&(a=[1]);let i=e.strides;(i.length===0||i[0]===0)&&(i=[1]);let o=e.pads;o.length===0&&(o=[0,0]),o=[0,o[0],0,o[1]],i=[1].concat(i),a=[1].concat(a),r=[1].concat(r);let l=e.outputPadding;l=[0].concat(l);let c=jv({...e,pads:o,strides:i,dilations:a,kernelShape:r,outputPadding:l},s);Kv(t,s,c,h=>n?[h[0],h[2],h[3]]:[h[0],h[1],h[3]])},oU=(t,e)=>{if(IR(t.inputs,e),t.inputs[0].dims.length===3)ER(t,e);else{let n=jv(e,t.inputs);Kv(t,t.inputs,n)}}}),AR,lU,uU,Rxe=ze(()=>{it(),ht(),Tn(),mt(),AR=(t,e,n,s)=>{let r=ve.size(e),a=e.length,i=Te("input",t,a),o=je("output",t,a),l=n.dataType===6?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),c=ve.normalizeAxis(l,a),h=p=>{let f=` i32(${i.indicesGet("inputIndices","uniforms.axis")}) `,g=Ke("uniforms.input_shape","uniforms.axis",a),y=s.reverse?f+(s.exclusive?" + 1":""):"0",x=s.reverse?g:f+(s.exclusive?"":" + 1");return`
                ${p.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(i,o)}
                ${p.mainStart()}
                  ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${o.offsetToIndices("global_idx")};
                  var sum = ${o.type.value}(0);
                  let first : i32 = ${y};
                  let last : i32 = ${x};
                  for (var i : i32 = first; i < last; i++) {
                    ${i.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${i.getByIndices("inputIndices")};
                  }
                  ${o.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:s.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:e,dataType:t}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:[{type:12,data:r},{type:12,data:c},...Je(e,e)]}),getShaderSource:h}},lU=(t,e)=>{let n=t.inputs[0].dims,s=t.inputs[0].dataType,r=t.inputs[1];t.compute(AR(s,n,r,e),{inputs:[0]})},uU=t=>{let e=t.exclusive===1,n=t.reverse===1;return Xt({exclusive:e,reverse:n})}}),RR,DR,OR,cU,dU,Dxe=ze(()=>{it(),ht(),Tn(),mt(),RR=t=>{if(!t||t.length!==1)throw new Error("DepthToSpace requires 1 input.");if(t[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},DR=(t,e,n,s)=>{let r=[];r.push(`fn perm(i: ${s.type.indices}) -> ${n.type.indices} {
    var a: ${n.type.indices};`);for(let a=0;a<e;++a)r.push(n.indicesSet("a",t[a],`i[${a}]`));return r.push("return a;}"),r.join(`
`)},OR=(t,e)=>{let n,s,r,a,i,o,l=e.format==="NHWC",c=e.blocksize,h=e.mode==="DCR";l?([n,s,r,a]=t.dims,i=h?[n,s,r,c,c,a/c**2]:[n,s,r,a/c**2,c,c],o=h?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([n,s,r,a]=[t.dims[0],t.dims[2],t.dims[3],t.dims[1]],i=h?[n,c,c,a/c**2,s,r]:[n,a/c**2,c,c,s,r],o=h?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let p=t.reshape(i),f=p.dims.length,g=t.dataType,y=Te("a",g,f),x=je("output",g,f),w=v=>`
  ${v.registerUniform("output_size","u32").declareVariables(y,x)}

  ${DR(o,f,y,x)}

  ${v.mainStart()}
    ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${x.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${x.setByOffset("global_idx",y.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${t.dims};${e.blocksize};${e.mode}`,inputDependencies:["rank"]},getRunData:v=>{let $=l?[n,s*c,r*c,a/c**2]:[n,a/c**2,s*c,r*c],T=ve.size($),C=p.dims,I=ve.sortBasedOnPerm(C,o);return{outputs:[{dims:$,dataType:v[0].dataType}],dispatchGroup:{x:Math.ceil(T/64)},programUniforms:[{type:12,data:T},...Je(C,I)]}},getShaderSource:w}},cU=(t,e)=>{RR(t.inputs),t.compute(OR(t.inputs[0],e))},dU=t=>Xt({blocksize:t.blocksize,mode:t.mode,format:t.format})}),Xy,Hp,Xv,zR,FR,LR,MR,Yv,BR,hU,pU,Oxe=ze(()=>{it(),ht(),Tn(),mt(),Xy="[a-zA-Z]|\\.\\.\\.",Hp="("+Xy+")+",Xv="^"+Hp+"$",zR="("+Hp+",)*"+Hp,FR="^"+zR+"$",LR=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,e){let n=this.symbolToIndices.get(t);n===void 0?n=[e]:n.push(e),this.symbolToIndices.set(t,n)}},MR=class{constructor(t,e){var r;this.equation=e,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,s]=e.includes("->")?e.split("->",2):[e,""];if(!n.match(RegExp(FR)))throw new Error("Invalid LHS term");if(n.split(",").forEach((a,i)=>{let o=t[i].dims.slice();if(!a.match(RegExp(Xv)))throw new Error("Invalid LHS term");let l=this.processTerm(a,!0,o,i);this.lhs.push(l)}),s==="")s+=[...this.symbolToInfo.entries()].filter(([a,i])=>i.count===1||a==="...").map(([a])=>a).join("");else if(!s.match(RegExp(Hp)))throw new Error("Invalid RHS");(r=s.match(RegExp(Xy,"g")))==null||r.forEach(a=>{if(a==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let i=this.symbolToInfo.get(a);if(i===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(i.dimValue)}}),this.rhs=this.processTerm(s,!1,this.outputDims)}addSymbol(t,e,n){let s=this.symbolToInfo.get(t);if(s!==void 0){if(s.dimValue!==e&&s.count!==1)throw new Error("Dimension mismatch");s.count++,s.inputIndices.push(n)}else s={count:1,dimValue:e,inputIndices:[n]};this.symbolToInfo.set(t,s)}processTerm(t,e,n,s=-1){let r=n.length,a=!1,i=[],o=0;if(!t.match(RegExp(Xv))&&!e&&t!=="")throw new Error("Invalid LHS term");let l=t.match(RegExp(Xy,"g")),c=new LR(s);return l==null||l.forEach((h,p)=>{if(h==="..."){if(a)throw new Error("Only one ellipsis is allowed per input term");a=!0;let f=r-l.length+1;if(f<0)throw new Error("Ellipsis out of bounds");if(i=n.slice(o,o+f),this.hasEllipsis){if(this.ellipsisDims.length!==i.length||this.ellipsisDims.toString()!==i.toString())throw new Error("Ellipsis dimensions mismatch")}else if(e)this.hasEllipsis=!0,this.ellipsisDims=i;else throw new Error("Ellipsis must be specified in the LHS");for(let g=0;g<i.length;g++){let y=String.fromCharCode(48+g);c.addSymbol(y,p+g),this.addSymbol(y,n[o++],s)}}else c.addSymbol(h,p+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(h,n[o++],s)}),c}},Yv=t=>t+"_max",BR=(t,e,n,s)=>{let r=t.map(c=>c.length).map((c,h)=>Te(`input${h}`,e,c)),a=ve.size(s),i=je("output",e,s.length),o=[...n.symbolToInfo.keys()].filter(c=>!n.rhs.symbolToIndices.has(c)),l=c=>{let h=[],p="var prod = 1.0;",f="var sum = 0.0;",g="sum += prod;",y=[],x=[],w=[],v=[],$=n.symbolToInfo.size===n.rhs.symbolToIndices.size;n.symbolToInfo.forEach((C,I)=>{var A;if(n.rhs.symbolToIndices.has(I)){let O=(A=n.rhs.symbolToIndices.get(I))==null?void 0:A[0];O!==void 0&&n.lhs.forEach((B,z)=>{if(C.inputIndices.includes(z)){let P=B.symbolToIndices.get(I);if(P===void 0)throw new Error("Invalid symbol error");P.forEach(F=>{h.push(`${r[z].indicesSet(`input${z}Indices`,F,i.indicesGet("outputIndices",O))}`)})}})}else n.lhs.forEach((O,B)=>{if(C.inputIndices.includes(B)){let z=O.symbolToIndices.get(I);if(z===void 0)throw new Error("Invalid symbol error");z.forEach(P=>{y.push(`${r[B].indicesSet(`input${B}Indices`,P,`${I}`)}`)}),v.push(`prod *= ${r[B].getByIndices(`input${B}Indices`)};`)}}),x.push(`for(var ${I}: u32 = 0; ${I} < uniforms.${Yv(I)}; ${I}++) {`),w.push("}")});let T=$?[...h,`let sum = ${r.map((C,I)=>C.getByIndices(`input${I}Indices`)).join(" * ")};`]:[...h,f,...x,...y,p,...v,g,...w];return`
            ${c.registerUniforms(o.map(C=>({name:`${Yv(C)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...r,i)}

            ${c.mainStart()}
            ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${i.offsetToIndices("global_idx")};
            ${r.map((C,I)=>`var input${I}Indices: ${r[I].type.indices};`).join(`
`)}
            ${T.join(`
`)};
            ${i.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:n.equation,inputDependencies:t.map(()=>"rank")},getRunData:()=>{let c=o.filter(p=>n.symbolToInfo.has(p)).map(p=>{var f;return{type:12,data:((f=n.symbolToInfo.get(p))==null?void 0:f.dimValue)||0}});c.push({type:12,data:a});let h=t.map((p,f)=>[...Je(p)]).reduce((p,f)=>p.concat(f),c);return h.push(...Je(s)),{outputs:[{dims:s,dataType:e}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:h}},getShaderSource:l}},hU=(t,e)=>{let n=new MR(t.inputs,e.equation),s=n.outputDims,r=t.inputs.map((a,i)=>a.dims);t.compute(BR(r,t.inputs[0].dataType,n,s))},pU=t=>{let e=t.equation.replace(/\s+/g,"");return Xt({equation:e})}}),PR,Zv,VR,UR,fU,zxe=ze(()=>{it(),ht(),mt(),PR=t=>{if(!t||t.length!==2)throw new Error("Expand requires 2 input.");let e=t[0].dims,n=Array.from(t[1].getBigInt64Array(),Number),s=n.length<e.length?0:n.length-e.length,r=e.length<n.length?0:e.length-n.length;for(;s<n.length&&r<e.length;++s,++r)if(n[s]!==e[r]&&n[s]!==1&&e[r]!==1)throw new Error("Expand requires shape to be broadcastable to input")},Zv=(t,e)=>{let n=t.length-e.length,s=[];for(let r=0;r<n;++r)s.push(t[r]);for(let r=0;r<e.length;++r)s.push(e[r]===1?t[r+n]:e[r]);return s},VR=(t,e)=>t.length>e.length?Zv(t,e):Zv(e,t),UR=t=>{let e=t[0].dims,n=Array.from(t[1].getBigInt64Array(),Number),s=VR(e,n),r=t[0].dataType,a=r===9||ve.size(e)===1,i=r===9||e.length>0&&e[e.length-1]%4===0?4:1,o=a||s.length>0&&s[s.length-1]%4===0?4:1,l=Math.ceil(ve.size(s)/o),c=p=>{let f=Te("input",r,e.length,i),g=je("output",r,s.length,o),y;if(r===9){let x=(w,v,$="")=>`
          let outputIndices${v} = ${g.offsetToIndices(`outputOffset + ${v}u`)};
          let offset${v} = ${f.broadcastedIndicesToOffset(`outputIndices${v}`,g)};
          let index${v} = offset${v} / 4u;
          let component${v} = offset${v} % 4u;
          ${w}[${v}] = ${$}(${f.getByOffset(`index${v}`)}[component${v}]);
        `;y=`
        let outputOffset = global_idx * ${o};
        var data = vec4<u32>(0);
        ${x("data",0,"u32")}
        ${x("data",1,"u32")}
        ${x("data",2,"u32")}
        ${x("data",3,"u32")}
        ${g.setByOffset("global_idx","data")}
      }`}else y=`
        let outputIndices = ${g.offsetToIndices(`global_idx * ${o}`)};
        let inputOffset = ${f.broadcastedIndicesToOffset("outputIndices",g)};
        let data = ${g.type.value}(${f.getByOffset(`inputOffset / ${i}`)});
        ${g.setByOffset("global_idx","data")}
      }`;return`
    ${p.registerUniform("vec_size","u32").declareVariables(f,g)}
    ${p.mainStart()}
    ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${y}`},h=[{type:12,data:l},...Je(e,s)];return{name:"Expand",shaderCache:{hint:`${s.length};${i}${o}`,inputDependencies:["rank"]},getShaderSource:c,getRunData:()=>({outputs:[{dims:s,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:h})}},fU=t=>{PR(t.inputs),t.compute(UR(t.inputs),{inputs:[0]})}}),WR,mU,Fxe=ze(()=>{it(),ht(),mt(),lT(),WR=t=>{let e=t[0].dataType,n=ve.size(t[0].dims),s=ve.size(t[1].dims),r=s%4===0,a=i=>{let o=Te("x",e,[1],4),l=Te("bias",e,[1],4),c=je("y",e,[1],4),h=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],p=g=>`
      let bias${g}_offset: u32 = (global_idx * 4 + ${g}) % uniforms.bias_size;
      let bias${g} = ${l.getByOffset(`bias${g}_offset / 4`)}[bias${g}_offset % 4];`,f=r?`
      let bias = ${l.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${p(0)}${p(1)}${p(2)}${p(3)}
      let bias = ${o.type.value}(bias0, bias1, bias2, bias3);`;return`${i.registerUniforms(h).declareVariables(o,l,c)}

    ${$2(Ps(e))}

    ${i.mainStart(Yd)}
      ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${o.getByOffset("global_idx")};
      ${f}
      let x_in = x + bias;
      ${c.setByOffset("global_idx",S2("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${r}`,inputDependencies:["type","type"]},getShaderSource:a,getRunData:i=>({outputs:[{dims:i[0].dims,dataType:i[0].dataType}],programUniforms:[{type:12,data:Math.ceil(n/4)},{type:12,data:s}],dispatchGroup:{x:Math.ceil(n/Yd/4)}})}},mU=t=>{t.inputs.length<2||ve.size(t.inputs[1].dims)===0?zV(t):t.compute(WR(t.inputs))}}),GR,HR,gU,yU,Lxe=ze(()=>{it(),ht(),Tn(),mt(),GR=t=>{if(!t||t.length!==2)throw new Error("Gather requires 2 inputs.")},HR=(t,e)=>{let n=t[0].dims,s=t[1].dims,r=n.length,a=ve.normalizeAxis(e.axis,r),i=n.slice(0);i.splice(a,1,...s);let o=n[a],l=t[0].dataType===9?4:1,c=Math.ceil(ve.size(i)/l),h=[{type:12,data:c},{type:6,data:o},{type:12,data:a},...Je(t[0].dims,t[1].dims,i)],p=f=>{let g=Te("data",t[0].dataType,t[0].dims.length,l),y=Te("inputIndices",t[1].dataType,t[1].dims.length),x=je("output",t[0].dataType,i.length,l),w=$=>{let T=s.length,C=`var indicesIndices${$}  = ${y.type.indices}(0);`;for(let I=0;I<T;I++)C+=`${T>1?`indicesIndices${$}[${I}]`:`indicesIndices${$}`} = ${i.length>1?`outputIndices${$}[uniforms.axis + ${I}]`:`outputIndices${$}`};`;C+=`
          var idx${$} = ${y.getByIndices(`indicesIndices${$}`)};
          if (idx${$} < 0) {
            idx${$} = idx${$} + uniforms.axisDimLimit;
          }
          var dataIndices${$} : ${g.type.indices};
        `;for(let I=0,A=0;I<r;I++)I===a?(C+=`${r>1?`dataIndices${$}[${I}]`:`dataIndices${$}`} = u32(idx${$});`,A+=T):(C+=`${r>1?`dataIndices${$}[${I}]`:`dataIndices${$}`} = ${i.length>1?`outputIndices${$}[${A}]`:`outputIndices${$}`};`,A++);return C},v;if(t[0].dataType===9){let $=(T,C,I="")=>`
          let outputIndices${C} = ${x.offsetToIndices(`outputOffset + ${C}u`)};
          ${w(C)};
          let offset${C} = ${g.indicesToOffset(`dataIndices${C}`)};
          let index${C} = offset${C} / 4u;
          let component${C} = offset${C} % 4u;
          ${T}[${C}] = ${I}(${g.getByOffset(`index${C}`)}[component${C}]);
        `;v=`
        let outputOffset = global_idx * ${l};
        var value = vec4<u32>(0);
        ${$("value",0,"u32")}
        ${$("value",1,"u32")}
        ${$("value",2,"u32")}
        ${$("value",3,"u32")}
        ${x.setByOffset("global_idx","value")}
      `}else v=`
      let outputIndices = ${x.offsetToIndices("global_idx")};
      ${w("")};
      let value = ${g.getByIndices("dataIndices")};
      ${x.setByOffset("global_idx","value")};
      `;return`
      ${f.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(g,y,x)}
      ${f.mainStart()}
        ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${v}
      }`};return{name:"Gather",shaderCache:{hint:e.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:i,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:h}),getShaderSource:p}},gU=t=>Xt({axis:t.axis}),yU=(t,e)=>{let n=t.inputs;GR(n),t.compute(HR(t.inputs,e))}}),qR,bU,xU,Mxe=ze(()=>{it(),ht(),mt(),qR=(t,e,n,s,r,a,i,o,l)=>{let c=[{type:12,data:a},{type:12,data:s},{type:12,data:r},{type:12,data:n},{type:12,data:i},{type:12,data:o},{type:12,data:l}],h=[a];c.push(...Je(e.dims,h));let p=f=>{let g=Te("indices_data",e.dataType,e.dims.length),y=je("input_slice_offsets_data",12,1,1),x=[g,y],w=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:r.length},{name:"sizes_from_slice_dims_data",type:"u32",length:n.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`
  ${f.registerUniforms(w).declareVariables(...x)}
  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${r.length===1?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${n.length===1?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`};return t.compute({name:"computeSliceOffsets",shaderCache:{hint:`${r.length}_${n.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:h,dataType:t.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:c}),getShaderSource:p},{inputs:[e],outputs:[-1]})[0]},bU=(t,e)=>{let n=t.inputs,s=n[0].dims,r=n[0].dataType,a=n[1].dims,i=a[a.length-1],o=ve.sizeToDimension(a,a.length-1),l=ve.sizeFromDimension(s,e.batchDims+i),c=ve.sizeToDimension(s,e.batchDims),h=ve.sizeFromDimension(s,e.batchDims),p=o/c,f=new Array(i),g=l;for(let C=0;C<i;++C)f[i-1-C]=g,g*=s[e.batchDims+i-1-C];let y=qR(t,n[1],f,e.batchDims,s,o,p,h,i),x=e.batchDims+i;if(x>s.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let w=a.slice(0,-1).concat(s.slice(x)),v=ve.size(w),$=[{type:12,data:v},{type:12,data:l},...Je(n[0].dims,y.dims,w)],T=C=>{let I=Te("data",n[0].dataType,n[0].dims.length),A=Te("slice_offsets",12,y.dims.length),O=je("output",n[0].dataType,w.length);return`
          ${C.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(I,A,O)}
            ${C.mainStart()}
            ${C.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`};t.compute({name:"GatherND",shaderCache:{hint:e.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:w,dataType:r}],dispatchGroup:{x:Math.ceil(v/64)},programUniforms:$}),getShaderSource:T},{inputs:[n[0],y]})},xU=t=>({batchDims:t.batch_dims,cacheKey:""})}),jR,KR,wU,vU,Bxe=ze(()=>{it(),ht(),Tn(),mt(),jR=(t,e)=>{if(t.length<3||t.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let n=ve.normalizeAxis(e.quantizeAxis,t[0].dims.length),s=e.blockSize,r=t[0],a=t[2],i=t.length===4?t[3]:void 0;if(a.dims.length!==r.dims.length||!r.dims.map((o,l)=>l===n?Math.ceil(o/s)===a.dims[l]:o===a.dims[l]).reduce((o,l)=>o&&l,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(i){if(i.dataType!==r.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(i.dims.length!==a.dims.length||!i.dims.map((o,l)=>o===a.dims[l]).reduce((o,l)=>o&&l,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},KR=(t,e)=>{let n=t[0].dims,s=t[1].dims,r=n.length,a=ve.normalizeAxis(e.gatherAxis,r),i=ve.normalizeAxis(e.quantizeAxis,r),o=n.slice(0);o.splice(a,1,...s);let l=ve.size(o),c=t[2].dataType,h=t[0].dataType===22,p=[{type:12,data:l},{type:12,data:i},{type:12,data:a},{type:12,data:e.blockSize},...Je(...t.map((g,y)=>g.dims),o)],f=g=>{let y=Te("data",t[0].dataType,t[0].dims.length),x=Te("inputIndices",t[1].dataType,t[1].dims.length),w=Te("scales",t[2].dataType,t[2].dims.length),v=t.length>3?Te("zeroPoint",t[3].dataType,t[3].dims.length):void 0,$=je("output",c,o.length),T=[y,x,w];v&&T.push(v);let C=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${g.registerUniforms(C).declareVariables(...T,$)}
        ${g.mainStart()}
        let output_indices = ${$.offsetToIndices("global_idx")};
        var indices_indices = ${x.type.indices}(0);
        ${s.length>1?`
          for (var i: u32 = 0; i < ${s.length}; i++) {
            let index = ${$.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${x.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${$.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${y.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${$.indicesGet("output_indices","i")};
          ${y.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${x.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${n[a]};
        }
        ${y.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${o.length}; i++) {
          let index = ${$.indicesGet("output_indices",`i + ${s.length} - 1`)};
          ${y.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${y.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${y.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${h?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${w.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${w.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${w.getByIndices("scale_indices")};
        ${v?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${v.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${v.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${h?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${Ps(c)}(quantized_data - zero_point) * scale;
        ${$.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${e.cacheKey};${t.filter((g,y)=>y!==1).map(g=>g.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:t.length},(g,y)=>"rank")},getRunData:()=>({outputs:[{dims:o,dataType:c}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:p}),getShaderSource:f}},wU=(t,e)=>{let n=t.inputs;jR(n,e),t.compute(KR(t.inputs,e))},vU=t=>Xt({blockSize:t.blockSize,gatherAxis:t.gatherAxis,quantizeAxis:t.quantizeAxis})}),XR,YR,$U,SU,Pxe=ze(()=>{it(),ht(),Tn(),mt(),XR=t=>{if(!t||t.length!==2)throw new Error("GatherElements requires 2 inputs.");if(t[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(t[0].dims.length!==t[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},YR=(t,e)=>{let n=t[0].dims,s=t[0].dataType,r=n.length,a=t[1].dims,i=t[1].dataType,o=ve.normalizeAxis(e.axis,r),l=n[o],c=a.slice(0),h=ve.size(c),p=Te("input",s,r),f=Te("indicesInput",i,a.length),g=je("output",s,c.length),y=[{type:12,data:h},{type:6,data:l},{type:12,data:o}];return y.push(...Je(n,a,c)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:c,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:y}),getShaderSource:x=>`
      ${x.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(p,f,g)}
      ${x.mainStart()}
      ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${g.offsetToIndices("global_idx")};

      var idx = ${f.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${p.type.indices}(outputIndices);
      ${p.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${p.getByIndices("inputIndices")};

      ${g.setByOffset("global_idx","value")};
  }`}},$U=t=>Xt({axis:t.axis}),SU=(t,e)=>{let n=t.inputs;XR(n),t.compute(YR(t.inputs,e))}}),ZR,QR,_U,CU,Vxe=ze(()=>{it(),ht(),mt(),ZR=t=>{if(!t)throw new Error("Input is missing");if(t.length<2||t.length>3)throw new Error("Invaid input number.");if(t.length===3&&t[2].dims.length>2)throw new Error("Invalid input shape of C");if(t[0].dataType!==t[1].dataType||t.length===3&&t[0].dataType!==t[2].dataType)throw new Error("Input types are mismatched")},QR=(t,e)=>{let n=t[0].dims.slice(),s=t[1].dims.slice(),[r,a,i]=TP.getShapeOfGemmResult(n,e.transA,s,e.transB,t.length===3?t[2].dims:void 0),o=[r,a];if(!o)throw new Error("Can't use gemm on the given tensors");let l=16,c=Math.ceil(a/l),h=Math.ceil(r/l),p=!0,f=ve.size(o),g=[{type:12,data:p?c:f},{type:12,data:r},{type:12,data:a},{type:12,data:i},{type:1,data:e.alpha},{type:1,data:e.beta}],y=["type","type"];t.length===3&&(g.push(...Je(t[2].dims)),y.push("rank")),g.push(...Je(o));let x=v=>{let $="";e.transA&&e.transB?$="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":e.transA&&!e.transB?$="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!e.transA&&e.transB?$="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!e.transA&&!e.transB&&($="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let T=e.alpha===1?"":"value *= uniforms.alpha;",C=Te("a",t[0].dataType,t[0].dims),I=Te("b",t[1].dataType,t[1].dims),A=C.type.value,O=null,B=[C,I];t.length===3&&(O=Te("c",t[2].dataType,t[2].dims.length),B.push(O));let z=je("output",t[0].dataType,o.length);B.push(z);let P=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${v.registerUniforms(P).declareVariables(...B)}

  ${v.mainStart()}
    ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${A}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${$}
    }

    ${T}
    ${O!=null?`let cOffset = ${O.broadcastedIndicesToOffset("vec2(m, n)",z)}; value += ${A}(uniforms.beta) * ${O.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`},w=v=>{let $=Te("a",t[0].dataType,t[0].dims),T=Te("b",t[1].dataType,t[1].dims),C=null,I=[$,T];t.length===3&&(C=Te("c",t[2].dataType,t[2].dims.length),I.push(C));let A=je("output",t[0].dataType,o.length);I.push(A);let O=[{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}],B="",z="";e.transA&&e.transB?(z=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${$.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);
      }
      `,B="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):e.transA&&!e.transB?(z=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${$.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);
      }
      `,B="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!e.transA&&e.transB?(z=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${$.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);
      }
      `,B="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!e.transA&&!e.transB&&(z=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${$.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);
      }
      `,B="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let P=e.alpha===1?"":"value *= uniforms.alpha;";return`
  ${v.registerUniforms(O).declareVariables(...I)}
  var<workgroup> tile_a: array<array<${$.type.storage}, ${l}>, ${l}>;
  var<workgroup> tile_b: array<array<${T.type.storage}, ${l}>, ${l}>;
  ${v.mainStart([l,l,1])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${l};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${l};
    let num_tiles = (uniforms.K - 1) / ${l} + 1;
    var k_start = 0u;
    var value = ${A.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${z}
      k_start = k_start + ${l};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${l}; k++) {
        ${B}
      }
      workgroupBarrier();
    }

    ${P}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${C!=null?`let cOffset = ${C.broadcastedIndicesToOffset("vec2(m, n)",A)}; value += ${A.type.value}(uniforms.beta) * ${C.getByOffset("cOffset")};`:""}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`};return p?{name:"GemmShared",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:c*h},programUniforms:g}),getShaderSource:w}:{name:"Gemm",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:g}),getShaderSource:x}},_U=t=>{let e=t.transA,n=t.transB,s=t.alpha,r=t.beta;return{transA:e,transB:n,alpha:s,beta:r,cacheKey:`${t.transA};${t.transB};${t.alpha===1}`}},CU=(t,e)=>{ZR(t.inputs),t.compute(QR(t.inputs,e))}}),bi,go,Bu,Pu,JR,e3,t3,n3,s3,r3,a3,i3,TU,kU,Uxe=ze(()=>{it(),ht(),Tn(),mt(),[bi,go,Bu,Pu]=[0,1,2,3],JR=t=>{if(t[0].dims.length!==4)throw new Error("only 4-D tensor is supported.");if(t[0].dims.length!==t[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(t[0].dims.length-2!==t[1].dims[t[1].dims.length-1])throw new Error(`last dimension of grid must be equal to ${t[0].dims.length-2}`);if(t[0].dims[0]!==t[1].dims[0])throw new Error("grid batch size must match input batch size")},e3=`
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`,t3=t=>`
  fn gs_bicubic_interpolate(p: mat4x4<${t}>, x: f32, y: f32) -> ${t} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${t}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`,n3=t=>`
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${t.alignCorners===0?`
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    `:`
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`,s3=t=>`
  ${t.paddingMode==="reflection"?`
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }`:""}
`,r3=(t,e,n)=>`
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${e} {
     var pixel = ${e}(0);
     var indices = vec4<u32>(0);
     indices[${bi}] = batch;
     indices[${go}] = channel;`+(()=>{switch(n.paddingMode){case"zeros":return`
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${Bu}] = u32(r);
            indices[${Pu}] = u32(c);
          }
        `;case"border":return`
          indices[${Bu}] = u32(clamp(r, 0, H - 1));
          indices[${Pu}] = u32(clamp(c, 0, W - 1));
        `;case"reflection":return`
          indices[${Bu}] = gs_reflect(r, border[1], border[3]);
          indices[${Pu}] = gs_reflect(c, border[0], border[2]);
        `;default:throw new Error(`padding mode ${n.paddingMode} is not supported`)}})()+`
    return ${t.getByIndices("indices")};
  }
`,a3=(t,e,n)=>(()=>{switch(n.mode){case"nearest":return`
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${bi}], indices[${go}], border);
        `;case"bilinear":return`
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${bi}], indices[${go}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${bi}], indices[${go}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${bi}], indices[${go}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${bi}], indices[${go}], border);

          let dx2 = ${e}(f32(x2) - x);
          let dx1 = ${e}(x - f32(x1));
          let dy2 = ${e}(f32(y2) - y);
          let dy1 = ${e}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;case"bicubic":return`
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${e}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${bi}], indices[${go}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;default:throw new Error(`mode ${n.mode} is not supported`)}})()+`${t.setByOffset("global_idx","result")}`,i3=(t,e)=>{let n=Te("x",t[0].dataType,t[0].dims.length),s=[t[1].dims[0],t[1].dims[1],t[1].dims[2]],r=Te("grid",t[1].dataType,s.length,2),a=[t[0].dims[0],t[0].dims[1],t[1].dims[1],t[1].dims[2]];e.format==="NHWC"&&(a=[t[0].dims[0],t[1].dims[1],t[1].dims[2],t[0].dims[3]],[bi,go,Bu,Pu]=[0,3,1,2]);let i=je("output",t[0].dataType,a.length),o=n.type.value,l=ve.size(a),c=[{type:12,data:l},...Je(t[0].dims,s,a)],h=p=>`
  ${p.registerUniform("output_size","u32").declareVariables(n,r,i)}
  ${e3}
  ${t3(o)}
  ${n3(e)}
  ${s3(e)}
  ${r3(n,o,e)}

  ${p.mainStart()}
    ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${Bu}]);
      let W_in = i32(uniforms.x_shape[${Pu}]);

      ${e.alignCorners===0?`
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      `:`
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${i.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${bi}], indices[${Bu}], indices[${Pu}]);
      let nxy = ${r.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${a3(i,o,e)}
  }`;return{name:"GridSample",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:["type","type"]},getRunData:p=>{let f=ve.size(a);return{outputs:[{dims:a,dataType:p[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:c}},getShaderSource:h}},TU=(t,e)=>{JR(t.inputs),t.compute(i3(t.inputs,e))},kU=t=>Xt({alignCorners:t.align_corners,mode:t.mode,paddingMode:t.padding_mode,format:t.format})}),nr,o3,NU,Qv,l3,af,IU,EU=ze(()=>{it(),ht(),Tn(),rT(),oT(),mt(),tu(),nr=(t,e)=>t.length>e&&t[e].dims.length>0?t[e]:void 0,o3=(t,e)=>{let n=t[0],s=nr(t,1),r=nr(t,2),a=nr(t,3),i=nr(t,4),o=nr(t,5),l=nr(t,6),c=nr(t,7);if(n.dims.length!==3&&n.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let h=n.dims[0],p=n.dims[1],f=n.dims.length===3?n.dims[2]:e.numHeads*n.dims[4],g=p,y=0,x=0,w=Math.floor(f/e.numHeads);if(l&&c&&ve.size(l.dims)&&ve.size(c.dims)){if(l.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(l.dims[0]!==h||l.dims[1]!==e.numHeads||l.dims[3]!==w)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(c.dims[0]!==h||c.dims[1]!==e.numHeads||c.dims[3]!==w)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(l.dims[2]!==c.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(c.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');y=l.dims[2],x=l.dims[2]}else if(l&&ve.size(l.dims)||c&&ve.size(c.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let v;if(s&&ve.size(s.dims)>0){if(n.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(s.dims.length<3||s.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==s.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(s.dims.length===3){if(s.dims[2]!==n.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');v=2,g=s.dims[1]}else if(s.dims.length===5){if(s.dims[2]!==e.numHeads||s.dims[3]!==2||s.dims[4]!==w)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(r)throw new Error('Expect "value" be none when "key" has packed kv format.');v=5,g=s.dims[1]}else{if(s.dims[1]!==e.numHeads||s.dims[3]!==w)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');v=0,g=s.dims[2]}}else{if(n.dims.length!==5)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(n.dims[2]!==e.numHeads||n.dims[3]!==3)throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');v=3}if(a&&ve.size(a.dims)>0){if(a.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(s&&s.dims.length===5&&s.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let $=y+g,T=0;if(i&&ve.size(i.dims)>0){T=8;let O=i.dims;throw O.length===1?O[0]===h?T=1:O[0]===3*h+2&&(T=3):O.length===2&&O[0]===h&&O[1]===$&&(T=5),T===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let C=!1,I=f;if(r&&ve.size(r.dims)>0){if(r.dims.length!==3&&r.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(r.dims.length===3){if(g!==r.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');I=r.dims[2]}else{if(g!==r.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');I=r.dims[1]*r.dims[3],C=!0}}let A=!1;if(i&&ve.size(i.dims)>0)throw new Error("Key padding mask is not supported");if(o&&ve.size(o.dims)>0){if(o.dims.length!==4)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(o.dims[0]!==h||o.dims[1]!==e.numHeads||o.dims[2]!==p||o.dims[3]!==$)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:h,sequenceLength:p,pastSequenceLength:y,kvSequenceLength:g,totalSequenceLength:$,maxSequenceLength:x,inputHiddenSize:0,hiddenSize:f,vHiddenSize:I,headSize:w,vHeadSize:Math.floor(I/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:T,scale:e.scale,broadcastResPosBias:A,passPastInKv:C,qkvFormat:v}},NU=t=>Xt({...t}),Qv=Xt({perm:[0,2,1,3]}),l3=(t,e,n,s,r,a,i)=>{let o=[s,r,a],l=ve.size(o),c=[{type:12,data:l},{type:12,data:i},{type:12,data:a}],h=p=>{let f=je("qkv_with_bias",e.dataType,o),g=Te("qkv",e.dataType,o),y=Te("bias",n.dataType,o),x=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${p.registerUniforms(x).declareVariables(g,y,f)}
  ${p.mainStart()}
    ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return t.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:o,dataType:e.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:c}),getShaderSource:h},{inputs:[e,n],outputs:[-1]})[0]},af=(t,e,n,s,r,a,i,o)=>{let l=a;if(i&&ve.size(i.dims)>0){if(s===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return l=l3(t,a,i,e,s,n*r,o),l=l.reshape([e,s,n,r]),n===1||s===1?l:t.compute(jr(l,Qv.perm),{inputs:[l],outputs:[-1]})[0]}else return a.dims.length===3&&(l=a.reshape([e,s,n,r])),n===1||s===1?l:t.compute(jr(l,Qv.perm),{inputs:[l],outputs:[-1]})[0]},IU=(t,e)=>{let n=o3(t.inputs,e),s=t.inputs[0],r=nr(t.inputs,1),a=nr(t.inputs,2),i=nr(t.inputs,3),o=nr(t.inputs,4),l=nr(t.inputs,5),c=nr(t.inputs,6),h=nr(t.inputs,7);if(s.dims.length===5)throw new Error("Packed QKV is not implemented");if((r==null?void 0:r.dims.length)===5)throw new Error("Packed KV is not implemented");let p=r&&a&&r.dims.length===4&&a.dims.length===4,f=af(t,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,s,i,0);if(p)return Tf(t,f,r,a,o,void 0,c,h,l,n);if(!r||!a)throw new Error("key and value must be provided");let g=af(t,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,r,i,n.hiddenSize),y=af(t,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,a,i,2*n.hiddenSize);Tf(t,f,g,y,o,void 0,c,h,l,n)}}),u3,c3,d3,h3,N2,AU,RU,DU=ze(()=>{it(),ht(),Tn(),mt(),u3=t=>{if(!t||t.length<1)throw new Error("too few inputs")},c3=(t,e)=>{let n=[],s=e.numOutputs;return t[1].dims[0]>0&&(t[1].getBigInt64Array().forEach(r=>n.push(Number(r))),s=n.length),Xt({numOutputs:s,axis:e.axis,splitSizes:n})},d3=t=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${t}u; i += 1u ) {
    if (index < ${Ke("uniforms.size_in_split_axis","i",t)}) {
        return i;
    }
    }
    return ${t}u;
}`,h3=t=>{let e=t.length,n=[];for(let s=0;s<e;++s){let r=t[s].setByIndices("indices","input[global_idx]");e===1?n.push(r):s===0?n.push(`if (output_number == ${s}u) { ${r} }`):s===e-1?n.push(`else { ${r} }`):n.push(`else if (output_number == ${s}) { ${r} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${t[0].type.indices}, global_idx: u32) {
        ${n.join(`
`)}
      }`},N2=(t,e)=>{let n=t[0].dims,s=ve.size(n),r=t[0].dataType,a=ve.normalizeAxis(e.axis,n.length),i=new Array(e.numOutputs),o=Te("input",r,n.length),l=new Array(e.numOutputs),c=[],h=[],p=0,f=[{type:12,data:s}];for(let y=0;y<e.numOutputs;y++){p+=e.splitSizes[y],l[y]=p;let x=n.slice();x[a]=e.splitSizes[y],h.push(x),i[y]=je(`output${y}`,r,x.length),c.push({dims:h[y],dataType:t[0].dataType})}f.push({type:12,data:l},...Je(n,...h));let g=y=>`
  ${y.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",l.length).declareVariables(o,...i)}
  ${d3(l.length)}
  ${h3(i)}

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${o.offsetToIndices("global_idx")};
    var index = ${o.indicesGet("indices",a)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${Ke("uniforms.size_in_split_axis","output_number - 1u",l.length)};
      ${o.indicesSet("indices",a,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:e.cacheKey,inputDependencies:["rank"]},getShaderSource:g,getRunData:()=>({outputs:c,dispatchGroup:{x:Math.ceil(s/64)},programUniforms:f})}},AU=(t,e)=>{u3(t.inputs);let n=t.inputs.length===1?e:c3(t.inputs,e);t.compute(N2(t.inputs,n),{inputs:[0]})},RU=t=>{let e=t.axis,n=t.splitSizes,s=t.numOutputs<0?n.length:t.numOutputs;if(s!==n.length)throw new Error("numOutputs and splitSizes lengh must be equal");return Xt({axis:e,numOutputs:s,splitSizes:n})}}),p3,f3,Jv,OU,Wxe=ze(()=>{Tn(),oT(),EU(),DU(),tu(),p3=(t,e)=>{if(e.doRotary)throw new Error("GroupQuerryAttention do_rotary attribute is not supported");if(e.doRotary&&t.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let n=t[0],s=t[1],r=t[2],a=t[3],i=t[4];if(e.localWindowSize!==-1)throw new Error("Local attention is not supported");if(e.softcap!==0)throw new Error("Softcap is not supported");if(e.rotaryInterleaved!==0)throw new Error("Rotary interleaved is not supported");if(e.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(n.dims.length!==3&&n.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let o=!1,l=n.dims[0],c=n.dims[1],h=n.dims.length===3?o?n.dims[2]/3:n.dims[2]:e.numHeads*n.dims[4],p=c,f=0,g=!s||s.dims.length===0,y=Math.floor(g?h/(e.numHeads+2*e.kvNumHeads):h/e.numHeads);g&&(h=y*e.numHeads);let x=a&&a.dims.length!==0,w=i&&i.dims.length!==0;if(x&&a.dims.length===4&&a.dims[0]===l&&a.dims[1]!==e.kvNumHeads&&a.dims[2]===e.kvNumHeads&&a.dims[3]===y)throw new Error("BSNH pastKey/pastValue is not supported");if(x&&w){if(a.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(i.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');f=a.dims[2]}else if(x||w)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let v=1;if(s&&s.dims.length>0){if(n.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(s.dims.length<3||s.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==s.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(s.dims.length===3){if(n.dims[2]%s.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');p=s.dims[1]}else if(s.dims.length===5){if(s.dims[2]!==e.numHeads||s.dims[3]!==2||s.dims[4]!==y)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(r)throw new Error('Expect "value" be none when "key" has packed kv format.');p=s.dims[1]}else{if(s.dims[1]!==e.numHeads||s.dims[3]!==y)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');p=s.dims[2]}}else{if(n.dims.length!==3&&n.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(n.dims.length===5&&(n.dims[2]!==e.numHeads||n.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');v=3}let $=0,T=!1,C=e.kvNumHeads?y*e.kvNumHeads:h;if(r&&r.dims.length>0){if(r.dims.length!==3&&r.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(r.dims.length===3){if(p!==r.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');C=r.dims[2]}else{if(p!==r.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');C=r.dims[1]*r.dims[3],T=!0}}let I=t.length>4?t[5]:void 0;if(I&&I.dims.length!==1&&I.dims[0]!==l)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:l,sequenceLength:c,pastSequenceLength:f,kvSequenceLength:p,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:h,vHiddenSize:C,headSize:y,vHeadSize:Math.floor(C/e.kvNumHeads),numHeads:e.numHeads,kvNumHeads:e.kvNumHeads,nReps:e.numHeads/e.kvNumHeads,pastPresentShareBuffer:!1,maskType:$,scale:e.scale,broadcastResPosBias:!1,passPastInKv:T,qkvFormat:v}},f3=Xt({perm:[0,2,1,3]}),Jv=(t,e,n)=>{let s=e,r=n.kvNumHeads;return e.dims.length===3&&n.kvSequenceLength!==0&&(s=e.reshape([n.batchSize,n.kvSequenceLength,r,n.headSize]),s=t.compute(jr(s,f3.perm),{inputs:[s],outputs:[-1]})[0]),s},OU=(t,e)=>{var w;let n=p3(t.inputs,e);if(t.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(((w=t.inputs[1])==null?void 0:w.dims.length)===5)throw new Error("Packed KV is not implemented");let s=t.inputs[0],r=t.inputs[1]&&t.inputs[1].dims.length>0?t.inputs[1]:void 0,a=t.inputs[2]&&t.inputs[2].dims.length>0?t.inputs[2]:void 0,i=t.inputs[3]&&t.inputs[3].dims.length!==0?t.inputs[3]:void 0,o=t.inputs[4]&&t.inputs[4].dims.length!==0?t.inputs[4]:void 0,l=t.inputs.length>4?t.inputs[5]:void 0,c=t.inputs.length>5?t.inputs[6]:void 0,h=n.kvNumHeads?n.kvNumHeads:n.numHeads,p=Xt({axis:2,numOutputs:3,splitSizes:[n.numHeads*n.headSize,h*n.headSize,h*n.headSize]}),[f,g,y]=!r&&!a?t.compute(N2([s],p),{inputs:[s],outputs:[-1,-1,-1]}):[s,r,a],x=af(t,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,f,void 0,0);Tf(t,x,Jv(t,g,n),Jv(t,y,n),void 0,void 0,i,o,void 0,n,l,c)}}),e$,m3,g3,zU,Gxe=ze(()=>{it(),ht(),tu(),mt(),e$=(t,e,n,s,r,a,i,o)=>{let l=bn(a),c=l===1?"f32":`vec${l}f`,h=l===1?"vec2f":`mat2x${l}f`,p=r*i,f=64;p===1&&(f=256);let g=[r,i,a/l],y=[r,i,2],x=["rank","type","type"],w=[];w.push(...Je(g,y));let v=$=>{let T=Te("x",e.dataType,3,l),C=Te("scale",n.dataType,n.dims),I=Te("bias",s.dataType,s.dims),A=je("output",1,3,2),O=[T,C,I,A];return`
  var<workgroup> workgroup_shared : array<${h}, ${f}>;
  const workgroup_size = ${f}u;
  ${$.declareVariables(...O)}
  ${$.mainStart(f)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${c}(0);
    var squared_sum = ${c}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${c}(${T.get("batch","channel","h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${h}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${Ul("workgroup_shared[0][0]",l)} / f32(hight * ${l});
      let squared_sum_final = ${Ul("workgroup_shared[0][1]",l)} / f32(hight * ${l});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${o}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`};return t.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${l};${o};${f}`,inputDependencies:x},getRunData:()=>({outputs:[{dims:y,dataType:1}],dispatchGroup:{x:p},programUniforms:w}),getShaderSource:v},{inputs:[e,n,s],outputs:[-1]})[0]},m3=(t,e,n)=>{let s=e[0].dims,r=s,a=2,i=s[0],o=s[1],l=ve.sizeFromDimension(s,a),c=bn(l),h=ve.size(r)/c,p=e$(t,e[0],e[1],e[2],i,l,o,n.epsilon),f=[i,o,l/c],g=[i,o],y=["type","none"],x=w=>{let v=Te("x",e[0].dataType,f.length,c),$=Te("scale_shift",1,g.length,2),T=je("output",e[0].dataType,f.length,c),C=[v,$,T];return`
  ${w.registerUniform("output_size","u32").declareVariables(...C)}
  ${w.mainStart()}
  ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${T.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${$.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${v.getByOffset("global_idx")} * ${T.type.value}(scale_shift.x) + ${T.type.value}(scale_shift.y);
      ${T.setByOffset("global_idx","value")};
  }`};t.compute({name:"InstanceNormalization",shaderCache:{hint:`${c}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:[{type:12,data:h},...Je(f,g,f)]}),getShaderSource:x},{inputs:[e[0],p]})},g3=(t,e,n)=>{let s=e[0].dims,r=s,a=s[0],i=s[s.length-1],o=ve.sizeFromDimension(s,1)/i,l=bn(i),c=ve.size(r)/l,h=[{type:12,data:o},{type:12,data:Math.floor(i/l)}],p=["type","type"],f=!1,g=[0,s.length-1];for(let v=0;v<s.length-2;v++)f=f||s[v+1]!==1,g.push(v+1);f=f&&s[s.length-1]!==1;let y=f?t.compute(jr(t.inputs[0],g),{inputs:[t.inputs[0]],outputs:[-1]})[0]:t.inputs[0].reshape(Array.from({length:s.length},(v,$)=>s[g[$]])),x=e$(t,y,e[1],e[2],a,o,i,n.epsilon),w=v=>{let $=is(e[0].dataType),T=l===1?"vec2f":`mat${l}x2f`,C=O=>{let B=O===0?"x":"y",z=l===1?"f32":`vec${l}f`;switch(l){case 1:return`${$}(${z}(scale.${B}))`;case 2:return`vec2<${$}>(${z}(scale[0].${B}, scale[1].${B}))`;case 4:return`vec4<${$}>(${z}(scale[0].${B}, scale[1].${B}, scale[2].${B}, scale[3].${B}))`;default:throw new Error(`Not supported compoents ${l}`)}},I=Te("input",e[0].dataType,e[0].dims,l),A=je("output",e[0].dataType,r,l);return`
  @group(0) @binding(0) var<storage, read> input : array<${I.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${T}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${A.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${v.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${C(0)}, ${C(1)});
  }`};t.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${l}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:h}),getShaderSource:w},{inputs:[e[0],x]})},zU=(t,e)=>{e.format==="NHWC"?g3(t,t.inputs,e):m3(t,t.inputs,e)}}),y3,b3,FU,Hxe=ze(()=>{it(),ht(),mt(),y3=t=>{if(!t||t.length<2)throw new Error("layerNorm requires at least 2 inputs.")},b3=(t,e,n)=>{let s=e.simplified,r=t[0].dims,a=t[1],i=!s&&t[2],o=r,l=ve.normalizeAxis(e.axis,r.length),c=ve.sizeToDimension(r,l),h=ve.sizeFromDimension(r,l),p=ve.size(a.dims),f=i?ve.size(i.dims):0;if(p!==h||i&&f!==h)throw new Error(`Size of X.shape()[axis:] == ${h}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${p} and bias size of ${f}`);let g=[];for(let I=0;I<r.length;++I)I<l?g.push(r[I]):g.push(1);let y=bn(h),x=["type","type"],w=[{type:12,data:c},{type:1,data:h},{type:12,data:Math.floor(h/y)},{type:1,data:e.epsilon}];i&&x.push("type");let v=n>1,$=n>2,T=I=>{let A=is(t[0].dataType),O=[Te("x",t[0].dataType,t[0].dims,y),Te("scale",a.dataType,a.dims,y)];i&&O.push(Te("bias",i.dataType,i.dims,y)),O.push(je("output",t[0].dataType,o,y)),v&&O.push(je("mean_data_output",1,g)),$&&O.push(je("inv_std_output",1,g));let B=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${I.registerUniforms(B).declareVariables(...O)}
  ${I.mainStart()}
    ${I.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${x2("f32",y)};
    var mean_square_vector = ${x2("f32",y)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${Id(A,y,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${Ul("mean_vector",y)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${Ul("mean_square_vector",y)} / uniforms.norm_size ${s?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${Id(A,y,"x[j + offset]")};
      let f32scale = ${Id(A,y,"scale[j]")};
      output[j + offset] = ${O[0].type.value}((f32input ${s?"":"- mean"}) * inv_std_dev * f32scale
        ${i?`+ ${Id(A,y,"bias[j]")}`:""}
      );
    }

    ${v?"mean_data_output[global_idx] = mean":""};
    ${$?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},C=[{dims:o,dataType:t[0].dataType}];return v&&C.push({dims:g,dataType:1}),$&&C.push({dims:g,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${y};${n};${s}`,inputDependencies:x},getRunData:()=>({outputs:C,dispatchGroup:{x:Math.ceil(c/64)},programUniforms:w}),getShaderSource:T}},FU=(t,e)=>{y3(t.inputs),t.compute(b3(t.inputs,e,t.outputCount))}}),x3,LU,qxe=ze(()=>{ht(),hT(),pT(),x3=t=>{if(!t||t.length!==2)throw new Error("MatMul requires 2 inputs.");if(t[0].dims[t[0].dims.length-1]!==t[1].dims[t[1].dims.length-2])throw new Error("shared dimension does not match.")},LU=t=>{x3(t.inputs);let e=Xd.calcShape(t.inputs[0].dims,t.inputs[1].dims,!0);if(!e)throw new Error("Can't use matmul on the given tensors");let n=e[e.length-1],s=t.inputs[0].dims[t.inputs[0].dims.length-1];if(n<8&&s<8)t.compute(dT(t.inputs,{activation:""},e));else{let r=e[e.length-2],a=ve.size(t.inputs[0].dims.slice(0,-2)),i=ve.size(t.inputs[1].dims.slice(0,-2));if(a!==1&&r===1&&i===1){let o=t.inputs[0].reshape([1,a,s]),l=t.inputs[1].reshape([1,s,n]),c=[1,a,n],h=[o,l];t.compute(Z0(h,{activation:""},e,c),{inputs:h})}else t.compute(Z0(t.inputs,{activation:""},e))}}}),w3,v3,$3,MU,BU,jxe=ze(()=>{it(),ht(),Tn(),mt(),w3=(t,e)=>{if(t.length<3||t.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let n=t[0],s=n.dims.length;if(n.dims[s-1]!==e.k)throw new Error("The last dim of input shape does not match the k value");let r=Math.floor((e.k+e.blockSize-1)/e.blockSize),a=e.blockSize/8*e.bits,i=t[1];if(!ve.areEqual(i.dims,[e.n,r,a]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let o=t[2].dims;if(ve.size(o)!==e.n*r)throw new Error("scales input size error.");if(t.length===4){let l=t[3].dims,c=e.bits>4?e.n*r:e.n*Math.floor((r+1)/2);if(ve.size(l)!==c)throw new Error("zeroPoints input size error.")}},v3=(t,e)=>{let n=t[0].dims,s=n.length,r=n[s-2],a=e.k,i=e.n,o=n.slice(0,s-2),l=ve.size(o),c=t[1].dims[2]/4,h=t[0].dataType,p=bn(e.k),f=bn(c),g=bn(i),y=o.concat([r,i]),x=r>1&&i/g%2===0?2:1,w=ve.size(y)/g/x,v=64,$=[],T=[l,r,a/p],C=ve.convertShape(t[1].dims).slice();C.splice(-1,1,c/f),$.push(...Je(T)),$.push(...Je(C)),$.push(...Je(t[2].dims)),t.length===4&&$.push(...Je(ve.convertShape(t[3].dims)));let I=[l,r,i/g];$.push(...Je(I));let A=O=>{let B=T.length,z=Te("a",t[0].dataType,B,p),P=Te("b",12,C.length,f),F=Te("scales",t[2].dataType,t[2].dims.length),K=[z,P,F],X=t.length===4?Te("zero_points",12,t[3].dims.length):void 0;X&&K.push(X);let te=I.length,Q=je("output",t[0].dataType,te,g),q=is(t[0].dataType),oe=(()=>{switch(p){case 1:return`array<${q}, 8>`;case 2:return`mat4x2<${q}>`;case 4:return`mat2x4<${q}>`;default:throw new Error(`${p}-component is not supported.`)}})(),se=()=>{let G=`
          // reuse a data
            var input_offset = ${z.indicesToOffset(`${z.type.indices}(batch, row, word_offset)`)};
            var a_data: ${oe};
            for (var j: u32 = 0; j < ${8/p}; j++) {
              a_data[j] = ${z.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let Y=0;Y<g*x;Y++)G+=`
            b_value = ${f===1?`b${Y}_data`:`b${Y}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${oe}(${Array.from({length:4},(ce,pe)=>`${q}(b_value_lower[${pe}]), ${q}(b_value_upper[${pe}])`).join(", ")});
            b_dequantized_values = ${p===1?`${oe}(${Array.from({length:8},(ce,pe)=>`(b_quantized_values[${pe}] - ${X?`zero_point${Y}`:"zero_point"}) * scale${Y}`).join(", ")});`:`(b_quantized_values - ${oe}(${Array(8).fill(`${X?`zero_point${Y}`:"zero_point"}`).join(",")})) * scale${Y};`};
            workgroup_shared[local_id.x * ${x} + ${Math.floor(Y/g)}]${g>1?`[${Y%g}]`:""} += ${Array.from({length:8/p},(ce,pe)=>`${p===1?`a_data[${pe}] * b_dequantized_values[${pe}]`:`dot(a_data[${pe}], b_dequantized_values[${pe}])`}`).join(" + ")};
          `;return G},ee=()=>{let G=`
            var col_index = col * ${g};
            ${X?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${q}(8);`}
            `;for(let Y=0;Y<g*x;Y++)G+=`
            let scale${Y} = ${F.getByOffset("col_index * nBlocksPerCol + block")};
            ${X?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${X.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${Y} = ${q}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return G},U=()=>{let G=`col_index = col * ${g};`;for(let Y=0;Y<g*x;Y++)G+=`
            let b${Y}_data = ${P.getByIndices(`${P.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return G+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${oe};
            var b_dequantized_values: ${oe};`,G};return`
        var<workgroup> workgroup_shared: array<${Q.type.value}, ${x*v}>;
        ${O.declareVariables(...K,Q)}
        ${O.mainStart([v,1,1])}
          let output_indices = ${Q.offsetToIndices(`(global_idx / ${v}) * ${x}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${v}) {
            //process one block
            var word_offset: u32 = block * ${e.blockSize/p};
            ${ee()}
            for (var word: u32 = 0; word < ${c}; word += ${f}) {
              ${U()}
              for (var i: u32 = 0; i < ${f}; i++) {
                ${se()}
                word_offset += ${8/p};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${x}) {
            var output_value: ${Q.type.value} = ${Q.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${v}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${x};
            }
            ${Q.setByIndices(`${Q.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${e.blockSize};${e.bits};${p};${f};${g};${x};${v}`,inputDependencies:Array(t.length).fill("rank")},getRunData:()=>({outputs:[{dims:y,dataType:h}],dispatchGroup:{x:w},programUniforms:$}),getShaderSource:A}},$3=(t,e)=>{let n=t[0].dims,s=n.length,r=n[s-2],a=e.k,i=e.n,o=n.slice(0,s-2),l=ve.size(o),c=t[1].dims[2]/4,h=t[0].dataType,p=bn(e.k),f=bn(c),g=o.concat([r,i]),y=128,x=i%8===0?8:i%4===0?4:1,w=y/x,v=w*f*8,$=v/p,T=v/e.blockSize,C=ve.size(g)/x,I=[],A=[l,r,a/p],O=ve.convertShape(t[1].dims).slice();O.splice(-1,1,c/f),I.push(...Je(A)),I.push(...Je(O)),I.push(...Je(t[2].dims)),t.length===4&&I.push(...Je(ve.convertShape(t[3].dims)));let B=[l,r,i];I.push(...Je(B));let z=P=>{let F=A.length,K=Te("a",t[0].dataType,F,p),X=Te("b",12,O.length,f),te=Te("scales",t[2].dataType,t[2].dims.length),Q=[K,X,te],q=t.length===4?Te("zero_points",12,t[3].dims.length):void 0;q&&Q.push(q);let oe=B.length,se=je("output",t[0].dataType,oe),ee=is(t[0].dataType),U=()=>{switch(p){case 1:return`
          let a_data0 = vec4<${ee}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${ee}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`
          let a_data0 = vec4<${ee}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${ee}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${p}-component is not supported.`)}};return`
        var<workgroup> sub_a: array<${K.type.value}, ${$}>;
        var<workgroup> inter_results: array<array<${se.type.value}, ${w}>, ${x}>;
        ${P.declareVariables(...Q,se)}
        ${P.mainStart([w,x,1])}
          let output_indices = ${se.offsetToIndices(`workgroup_index * ${x}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${T} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${$};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${$}; a_offset += ${y})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${K.getByIndices(`${K.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${K.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${T} + local_id.x;
            ${q?`
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${q.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${ee}((zero_point_word) & 0xFu);`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${ee}(8);`}
            let scale = ${te.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${X.getByIndices(`${X.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${e.blockSize/p};
            for (var i: u32 = 0; i < ${f}; i++) {
              ${U()}
              let b_value = ${f===1?"b_data":"b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${ee}>(${Array.from({length:4},(G,Y)=>`${ee}(b_value_lower[${Y}]), ${ee}(b_value_upper[${Y}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${ee}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(G,Y)=>`${`dot(a_data${Y}, b_dequantized_values[${Y}])`}`).join(" + ")};
              word_offset += ${8/p};
            }
            workgroupBarrier();
          }

          if (local_idx < ${x}) {
            var output_value: ${se.type.value} = ${se.type.value}(0);
            for (var b = 0u; b < ${w}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${se.setByIndices(`${se.type.indices}(batch, row, col + local_idx)`,"output_value")}
            }
          }
        }`};return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${e.blockSize};${p};${f};${w};${x}`,inputDependencies:Array(t.length).fill("rank")},getRunData:()=>({outputs:[{dims:g,dataType:h}],dispatchGroup:{x:C},programUniforms:I}),getShaderSource:z}},MU=(t,e)=>{w3(t.inputs,e),e.blockSize===32&&t.adapterInfo.isVendor("intel")&&t.adapterInfo.isArchitecture("gen-12lp")?t.compute($3(t.inputs,e)):t.compute(v3(t.inputs,e))},BU=t=>Xt(t)}),S3,_3,C3,T3,k3,N3,I3,E3,PU,Kxe=ze(()=>{it(),ht(),mt(),S3=t=>{if(!t||t.length<1)throw new Error("Too few inputs");if(t[0].dataType!==1&&t[0].dataType!==10)throw new Error("Input type must be float or float16.");if(t.length>=2){let e=t[0].dims.length*2===t[1].dims[0];if(t.length===4&&(e=t[3].dims[0]*2===t[1].dims[0]),!e)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},_3=(t,e,n)=>{let s="";for(let r=e-1;r>=0;--r)s+=`
            k = i32(${t.indicesGet("indices",r)}) - ${Ke("uniforms.pads",r,n)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${Ke("uniforms.x_shape",r,e)})) {
              break;
            }
            offset += k * i32(${Ke("uniforms.x_strides",r,e)});
        `;return`
          value = ${t.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${s}
            value = x[offset];
          }
      `},C3=(t,e,n)=>{let s="";for(let r=e-1;r>=0;--r)s+=`
                k = i32(${t.indicesGet("indices",r)}) - ${Ke("uniforms.pads",r,n)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${Ke("uniforms.x_shape",r,e)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${Ke("uniforms.x_shape",r,e)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${Ke("uniforms.x_strides",r,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},T3=(t,e,n)=>{let s="";for(let r=e-1;r>=0;--r)s+=`
                k = i32(${t.indicesGet("indices",r)}) - ${Ke("uniforms.pads",r,n)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${Ke("uniforms.x_shape",r,e)})) {
                  k = i32(${Ke("uniforms.x_shape",r,e)}) - 1;
                }
                offset += k * i32(${Ke("uniforms.x_strides",r,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},k3=(t,e,n)=>{let s="";for(let r=e-1;r>=0;--r)s+=`
                k = i32(${t.indicesGet("indices",r)}) - ${Ke("uniforms.pads",r,n)};
                if (k < 0)  {
                  k += i32(${Ke("uniforms.x_shape",r,e)}]);
                }
                if (k >= i32(${Ke("uniforms.x_shape",r,e)})) {
                  k -= i32(${Ke("uniforms.x_shape",r,e)});
                }
                offset += k * i32(${Ke("uniforms.x_strides",r,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},N3=(t,e,n)=>{switch(n.mode){case 0:return _3(t,e,n.pads.length);case 1:return C3(t,e,n.pads.length);case 2:return T3(t,e,n.pads.length);case 3:return k3(t,e,n.pads.length);default:throw new Error("Invalid mode")}},I3=(t,e)=>{let n=ve.padShape(t[0].dims.slice(),e.pads),s=t[0].dims,r=ve.size(n),a=[{type:12,data:r},{type:6,data:e.pads}],i=t.length>=3&&t[2].data;e.mode===0&&a.push({type:i?t[2].dataType:1,data:e.value}),a.push(...Je(t[0].dims,n));let o=["rank"],l=c=>{let h=je("output",t[0].dataType,n.length),p=Te("x",t[0].dataType,s.length),f=p.type.value,g=N3(h,s.length,e),y=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:e.pads.length}];return e.mode===0&&y.push({name:"constant_value",type:i?f:"f32"}),`
            ${c.registerUniforms(y).declareVariables(p,h)}
            ${c.mainStart()}
            ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${h.offsetToIndices("global_idx")};

            var value = ${f}(0);
            ${g}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${e.mode}${i}`,inputDependencies:o},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(ve.size(n)/64)},programUniforms:a}),getShaderSource:l}},E3=(t,e)=>{if(t.length>1){let n=t[1].getBigInt64Array(),s=t.length>=3&&t[2].data?t[2].dataType===10?t[2].getUint16Array()[0]:t[2].getFloat32Array()[0]:0,r=t[0].dims.length,a=new Int32Array(2*r).fill(0);if(t.length>=4){let o=t[3].getBigInt64Array();for(let l=0;l<o.length;l++)a[Number(o[l])]=Number(n[l]),a[Number(o[l])+r]=Number(n[l+o.length])}else n.forEach((o,l)=>a[Number(l)]=Number(o));let i=[];return a.forEach(o=>i.push(o)),{mode:e.mode,value:s,pads:i}}else return e},PU=(t,e)=>{S3(t.inputs);let n=E3(t.inputs,e);t.compute(I3(t.inputs,n),{inputs:[0]})}}),qp,t$,n$,s$,r$,A3,R3,a$,i$,VU,UU,o$,WU,GU,l$,HU,qU,jU,KU,Xxe=ze(()=>{ei(),it(),ht(),mt(),qp=t=>{if(hn.webgpu.validateInputContent&&(!t||t.length!==1))throw new Error("Pool ops requires 1 input.")},t$=(t,e,n)=>{let s=e.format==="NHWC",r=t.dims.slice();s&&r.splice(1,0,r.pop());let a=Object.hasOwnProperty.call(e,"dilations"),i=e.kernelShape.slice(),o=e.strides.slice(),l=a?e.dilations.slice():[],c=e.pads.slice();X0.adjustPoolAttributes(n,r,i,o,l,c);let h=X0.computePoolOutputShape(n,r,o,l,i,c,e.autoPad),p=Object.assign({},e);a?Object.assign(p,{kernelShape:i,strides:o,pads:c,dilations:l,cacheKey:e.cacheKey}):Object.assign(p,{kernelShape:i,strides:o,pads:c,cacheKey:e.cacheKey});let f=h.slice();return f.push(f.splice(1,1)[0]),[p,s?f:h]},n$=(t,e)=>{let n=e.format==="NHWC",s=ve.size(t),r=ve.size(e.kernelShape),a=[{type:12,data:s},{type:12,data:r}],i=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(e.kernelShape.length<=2){let o=e.kernelShape[e.kernelShape.length-1],l=e.strides[e.strides.length-1],c=e.pads[e.pads.length/2-1],h=e.pads[e.pads.length-1],p=!!(c+h);a.push({type:12,data:o},{type:12,data:l},{type:12,data:c},{type:12,data:h}),i.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let f=!1;if(e.kernelShape.length===2){let g=e.kernelShape[e.kernelShape.length-2],y=e.strides[e.strides.length-2],x=e.pads[e.pads.length/2-2],w=e.pads[e.pads.length-2];f=!!(x+w),a.push({type:12,data:g},{type:12,data:y},{type:12,data:x},{type:12,data:w}),i.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[a,i,!0,p,f]}else{if(n)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let o=ve.computeStrides(e.kernelShape);a.push({type:12,data:o},{type:12,data:e.pads},{type:12,data:e.strides}),i.push({name:"kernelStrides",type:"u32",length:o.length},{name:"pads",type:"u32",length:e.pads.length},{name:"strides",type:"u32",length:e.strides.length});let l=e.pads.reduce((c,h)=>c+h);return[a,i,!!l,!1,!1]}},s$=(t,e,n,s,r,a,i,o,l,c,h,p)=>{let f=r.format==="NHWC",g=e.type.value,y=je("output",e.type.tensor,s);if(r.kernelShape.length<=2){let x="",w="",v="",$=n-(f?2:1);if(h?x=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${$}] = indices[${$}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${$}] < 0 || xIndices[${$}]
                      >= uniforms.x_shape[${$}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${a}
                }`:x=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${$}] = indices[${$}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${a}
                }`,r.kernelShape.length===2){let T=n-(f?3:2);p?w=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${T}] = indices[${T}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${T}] < 0 || xIndices[${T}] >= uniforms.x_shape[${T}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:w=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${T}] = indices[${T}] * uniforms.sh - uniforms.phStart + j;
                `,v=`
              }
            `}return`
            ${t.registerUniforms(l).declareVariables(e,y)}

            ${t.mainStart()}
              ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${y.offsetToIndices("global_idx")};
              var xIndices = ${y.offsetToIndices("global_idx")};

              var value = ${g}(${o});
              var pad = 0;
              ${w}
              ${x}
              ${v}
              ${i}

              output[global_idx] = value;
            }`}else{if(f)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let x=r.kernelShape.length,w=r.pads.length,v="";return c?v=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${e.indicesToOffset("xIndices")}];
                ${a}
              }`:v=`
              }
              let x_val = x[${e.indicesToOffset("xIndices")}];
              ${a}
            `,`
            ${t.registerUniforms(l).declareVariables(e,y)}

            ${t.mainStart()}
              ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${y.offsetToIndices("global_idx")};
              var xIndices = ${y.offsetToIndices("global_idx")};

              var offsets: array<u32, ${x}>;

              var value = ${g}(${o});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${x-1}u; j++) {
                  offsets[j] = offset / ${Ke("uniforms.kernelStrides","j",x)};
                  offset -= offsets[j] * ${Ke("uniforms.kernelStrides","j",x)};
                }
                offsets[${x-1}] = offset;

                isPad = false;
                for (var j = ${n-x}u; j < ${n}u; j++) {
                  xIndices[j] = indices[j] * ${Ke("uniforms.strides",`j - ${n-x}u`,x)}
                    + offsets[j - ${n-x}u] - ${Ke("uniforms.pads","j - 2u",w)};
                  ${v}
              }
              ${i}

              output[global_idx] = value;
            }`}},r$=t=>`${t.format};${t.ceilMode};${t.autoPad};${t.kernelShape.length}`,A3=t=>`${r$(t)};${t.countIncludePad}`,R3=t=>`${r$(t)};${t.storageOrder};${t.dilations}`,a$=t=>({format:t.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][t.auto_pad],ceilMode:t.ceil_mode,kernelShape:t.kernel_shape,strides:t.strides,pads:t.pads}),i$=(t,e,n,s)=>{let[r,a]=t$(e,s,n),i=Te("x",e.dataType,e.dims.length),o=i.type.value,l="value += x_val;",c="";r.countIncludePad?c+=`value /= ${o}(uniforms.kernelSize);`:c+=`value /= ${o}(i32(uniforms.kernelSize) - pad);`;let[h,p,f,g,y]=n$(a,r);h.push(...Je(e.dims,a));let x=["rank"];return{name:t,shaderCache:{hint:`${s.cacheKey};${f};${g};${y}`,inputDependencies:x},getRunData:()=>({outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(ve.size(a)/64)},programUniforms:h}),getShaderSource:w=>s$(w,i,e.dims.length,a.length,r,l,c,0,p,f,g,y)}},VU=t=>{let e=t.count_include_pad!==0,n=a$(t);if(n.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let s={countIncludePad:e,...n,cacheKey:""};return{...s,cacheKey:A3(s)}},UU=(t,e)=>{qp(t.inputs),t.compute(i$("AveragePool",t.inputs[0],!1,e))},o$={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},WU=t=>{let e=t.format;return{format:e,...o$,cacheKey:e}},GU=(t,e)=>{qp(t.inputs),t.compute(i$("GlobalAveragePool",t.inputs[0],!0,e))},l$=(t,e,n,s)=>{let[r,a]=t$(e,s,n),i=`
      value = max(x_val, value);
    `,o="",l=Te("x",e.dataType,e.dims.length),c=["rank"],[h,p,f,g,y]=n$(a,r);return h.push(...Je(e.dims,a)),{name:t,shaderCache:{hint:`${s.cacheKey};${f};${g};${y}`,inputDependencies:c},getRunData:()=>({outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(ve.size(a)/64)},programUniforms:h}),getShaderSource:x=>s$(x,l,e.dims.length,a.length,r,i,o,e.dataType===10?-65504:-1e5,p,f,g,y)}},HU=(t,e)=>{qp(t.inputs),t.compute(l$("MaxPool",t.inputs[0],!1,e))},qU=t=>{let e=t.storage_order,n=t.dilations,s=a$(t);if(e!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(s.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let r={storageOrder:e,dilations:n,...s,cacheKey:""};return{...r,cacheKey:R3(r)}},jU=t=>{let e=t.format;return{format:e,...o$,cacheKey:e}},KU=(t,e)=>{qp(t.inputs),t.compute(l$("GlobalMaxPool",t.inputs[0],!0,e))}}),D3,O3,XU,YU,Yxe=ze(()=>{it(),ht(),Tn(),mt(),D3=(t,e)=>{if(t.length<2||t.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(t.length===3&&t[1].dims===t[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(t.length===3&&t[0].dataType!==t[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(t[0].dataType===6&&t.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(t[1].dims.length!==0&&t[1].dims.length!==1&&t[1].dims.length!==t[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(t.length>2){if(t[0].dataType!==t[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(t[1].dims.length!==t[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!t[1].dims.map((n,s)=>n===t[2].dims[s]).reduce((n,s)=>n&&s,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(e.blockSize>0){if(t[1].dims.length===0||t[1].dims.length===1&&t[1].dims[0]===1)throw new Error("blockSize must be set only for block quantization.");if(!t[1].dims.map((r,a)=>a===e.axis||r===t[0].dims[a]).reduce((r,a)=>r&&a,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(t[1].dims.length!==t[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let n=t[0].dims[e.axis],s=t[1].dims[e.axis];if(e.blockSize<Math.ceil(n/s)||e.blockSize>Math.ceil(n/(s-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},O3=(t,e)=>{let n=ve.normalizeAxis(e.axis,t[0].dims.length),s=t[0].dataType,r=s===3,a=t[0].dims,i=t[1].dataType,o=ve.size(a),l=s===3||s===2,c=l?[Math.ceil(ve.size(t[0].dims)/4)]:t[0].dims,h=t[1].dims,p=t.length>2?t[2]:void 0,f=p?l?[Math.ceil(ve.size(p.dims)/4)]:p.dims:void 0,g=h.length===0||h.length===1&&h[0]===1,y=g===!1&&h.length===1,x=bn(o),w=g&&(!l||x===4),v=w?x:1,$=w&&!l?x:1,T=Te("input",l?12:s,c.length,$),C=Te("scale",i,h.length),I=p?Te("zero_point",l?12:s,f.length):void 0,A=je("output",i,a.length,v),O=[T,C];I&&O.push(I);let B=[c,h];p&&B.push(f);let z=[{type:12,data:o/v},{type:12,data:n},{type:12,data:e.blockSize},...Je(...B,a)],P=F=>{let K=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${F.registerUniforms(K).declareVariables(...O,A)}
      ${F.mainStart()}
          ${F.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${A.offsetToIndices("global_idx")};

          // Set input x
          ${l?`
            let input = ${T.getByOffset("global_idx / 4")};
            let x_vec = ${r?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${v===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${T.getByOffset("global_idx")};`};

          // Set scale input
          ${g?`let scale_value= ${C.getByOffset("0")}`:y?`
            let scale_index = ${A.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${C.getByOffset("scale_index")};`:`
            var scale_indices: ${C.type.indices} = output_indices;
            let index = ${C.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${C.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${C.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${I?g?l?`
                let zero_point_input = ${I.getByOffset("0")};
                let zero_point_vec =  ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${I.getByOffset("0")}`:y?l?`
                let zero_point_index = ${A.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${I.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${A.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${I.getByOffset("zero_point_index")};`:l?`
                let zero_point_offset = ${C.indicesToOffset("scale_indices")};
                let zero_point_input = ${I.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${I.getByIndices("scale_indices")};`:`let zero_point_value = ${l?r?"i32":"u32":T.type.value}(0);`};
      // Compute and write output
      ${A.setByOffset("global_idx",`${A.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:e.cacheKey,inputDependencies:I?["rank","rank","rank"]:["rank","rank"]},getShaderSource:P,getRunData:()=>({outputs:[{dims:a,dataType:i}],dispatchGroup:{x:Math.ceil(o/v/64),y:1,z:1},programUniforms:z})}},XU=(t,e)=>{D3(t.inputs,e),t.compute(O3(t.inputs,e))},YU=t=>Xt({axis:t.axis,blockSize:t.blockSize})}),z3,F3,ZU,Zxe=ze(()=>{ei(),it(),mt(),z3=(t,e,n)=>{let s=t===e,r=t<e&&n<0,a=t>e&&n>0;if(s||r||a)throw new Error("Range these inputs' contents are invalid.")},F3=(t,e,n,s)=>{let r=Math.abs(Math.ceil((e-t)/n)),a=[r],i=r,o=[{type:12,data:i},{type:s,data:t},{type:s,data:n},...Je(a)],l=c=>{let h=je("output",s,a.length),p=h.type.value,f=[{name:"outputSize",type:"u32"},{name:"start",type:p},{name:"delta",type:p}];return`
        ${c.registerUniforms(f).declareVariables(h)}
        ${c.mainStart()}
        ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${p}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${s}`},getShaderSource:l,getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:o})}},ZU=t=>{let e=0,n=0,s=0;t.inputs[0].dataType===6?(e=t.inputs[0].getInt32Array()[0],n=t.inputs[1].getInt32Array()[0],s=t.inputs[2].getInt32Array()[0]):t.inputs[0].dataType===1&&(e=t.inputs[0].getFloat32Array()[0],n=t.inputs[1].getFloat32Array()[0],s=t.inputs[2].getFloat32Array()[0]),hn.webgpu.validateInputContent&&z3(e,n,s),t.compute(F3(e,n,s,t.inputs[0].dataType),{inputs:[]})}}),L3,M3,QU,JU,Qxe=ze(()=>{it(),ht(),Tn(),mt(),L3=(t,e,n,s)=>{if(t!=="none"&&s!=="i32"&&s!=="u32"&&s!=="f32")throw new Error(`Input ${s} is not supported with reduction ${t}.`);let r=`{
                var oldValue = 0;
                loop {
                  let newValueF32 =`,a=`;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${e}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;switch(t){case"none":return`${e}=${n};`;case"add":return s==="i32"||s==="u32"?`atomicAdd(&${e}, bitcast<${s}>(${n}));`:`
              ${r}bitcast<${s}>(oldValue) + (${n})${a}`;case"max":return s==="i32"||s==="u32"?`atomicMax(&${e}, bitcast<${s}>(${n}));`:`
                ${r}max(bitcast<f32>(oldValue), (${n}))${a}`;case"min":return s==="i32"||s==="u32"?`atomicMin(&${e}, bitcast<${s}>(${n}));`:`${r}min(bitcast<${s}>(oldValue), (${n}))${a}`;case"mul":return`${r}(bitcast<${s}>(oldValue) * (${n}))${a}`;default:throw new Error(`Reduction ${t} is not supported.`)}},M3=(t,e)=>{let n=t[0].dims,s=t[1].dims,r=n,a=1,i=Math.ceil(ve.size(s)/a),o=s[s.length-1],l=ve.sizeFromDimension(n,o),c=[{type:12,data:i},{type:12,data:o},{type:12,data:l},...Je(t[1].dims,t[2].dims,r)],h=p=>{let f=Te("indices",t[1].dataType,t[1].dims.length),g=Te("updates",t[2].dataType,t[2].dims.length,a),y=e.reduction!=="none"&&e.reduction!==""?IP("output",t[0].dataType,r.length):je("output",t[0].dataType,r.length,a);return`
      ${p.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(f,g,y)}
      ${p.mainStart()}
        ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var hasDuplicates = false;
  if (${e.reduction==="none"}) {
    let n = ${ve.size(s)};
    for (var i = 0; i < n; i = i + 1) {
      for (var j = i + 1; j < n; j = j + 1) {
        var index_i = i32(indices[i].x);
        var index_j = i32(indices[j].x);
        if (index_i == index_j) {
          hasDuplicates = true;
          break;
        }
      }
      if (hasDuplicates) {
        break;
      }
    }
  }

  var data_offset = 0u;
  var indices_start = uniforms.last_index_dimension * global_idx;
  if (${e.reduction==="none"} && hasDuplicates) {
    if (global_idx != 0u) {
      return;
    }
    indices_start = 0u;
  }
  let indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${t[0].dims.length===1?`
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;`:`
    let element_count_dim = uniforms.output_strides[i - indices_start];
    let dim_value = uniforms.output_shape[i - indices_start + uniforms.last_index_dimension];`}
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));
  }

  for (var i = 0u; i < uniforms.num_updates_elements; i++) {
    let value = updates[uniforms.num_updates_elements * global_idx + i];
    ${L3(e.reduction,"output[data_offset + i]","value",y.type.value)}
  }

      }`};return{name:"ScatterND",shaderCache:{hint:`${e.cacheKey}_${e.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:c}),getShaderSource:h}},QU=t=>Xt({reduction:t.reduction}),JU=(t,e)=>{t.compute(M3(t.inputs,e),{inputs:[t.inputs[1],t.inputs[2]],outputs:[]})}}),B3,P3,V3,u$,U3,W3,G3,H3,q3,j3,K3,X3,c$,Y3,Z3,Q3,J3,eD,eW,tW,Jxe=ze(()=>{it(),ht(),Tn(),mt(),B3=(t,e)=>{if(t.every(n=>n>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),t.length>0){if(e.mode==="linear"){if(!(t.length===2||t.length===3||t.length===4&&t[0]===1&&t[1]===1||t.length===4&&t[0]===1&&t[3]===1||t.length===5&&t[0]===1&&t[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(e.mode==="cubic"&&!(t.length===2||t.length===4&&t[0]===1&&t[1]===1||t.length===4&&t[0]===1&&t[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},P3=(t,e,n)=>{e.every(r=>r>=0&&r<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let s=new Array(n).fill(1);return e.forEach((r,a)=>s[r]=t[a]),s},V3=(t,e,n,s,r,a)=>{let[i,o,l]=n>10?[1,2,3]:[-1,t.length>1?1:-1,-1],c=t[0].dims.length;if(i>0&&t.length>i&&t[i].dims.length>0)t[i].getFloat32Array().forEach(h=>a.push(h));else if(e.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(o>0&&t.length>o&&t[o].dims.length===1&&t[o].dims[0]>0){if(t[o].getFloat32Array().forEach(h=>s.push(h)),s.length!==0&&s.length!==c&&n>=18&&s.length!==e.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");B3(s,e),e.axes.length>0&&P3(s,e.axes,c).forEach((h,p)=>s[p]=h)}if(l>0&&t.length>l&&t[l].dims.length===1&&t[l].dims[0]>0&&(t[l].getBigInt64Array().forEach(h=>r.push(Number(h))),r.length!==0&&r.length!==c&&n>=18&&r.length!==e.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(e.axes.length>0){if(s.length!==0&&s.length!==e.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(r.length!==0&&r.length!==e.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof s<"u"&&typeof r<"u"&&s.length>0&&r.length>c)throw new Error("Resize requires only of scales or sizes to be specified")},u$=(t,e,n,s)=>`
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${t}) * (${e});
  let whole = ${s}(big / (${n}));
  let fract = ${s}(big % (${n})) / ${s}(${n});
  return whole + fract;
`,U3=(t,e)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${e} { `+(()=>{switch(t){case"asymmetric":return`
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${e}(xResized) / ${e}(xScale);
          } else {
            ${u$("xResized","lengthOriginal","lengthResized",e)}
          }
        `;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${e}(xResized) + 0.5) / ${e}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${e}(xResized) + 0.5) / ${e}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${u$("xResized","lengthOriginal - 1","lengthResized - 1",e)}
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${e}(roiStart) * ${e}(lengthOriginal - 1) +
                        (${e}(xResized) * ${e}(roiEnd - roiStart) * ${e}(lengthOriginal - 1)) /
                        ${e}(lengthResized - 1);
                  } else {
                    return 0.5 * ${e}(roiStart + roiEnd) * ${e}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${e}xScale * ${e}(lengthResized);
                  const adjustment = ${e}(lengthResized) / outputWidth;
                  const center = ${e}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;case"half_pixel":return`return ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${t} is not supported`)}})()+"}",W3=(t,e,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(t){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(e<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${t} is not supported`)}})()+"}",G3=(t,e,n)=>{let s=new Array(n).fill(0).concat(new Array(n).fill(1)),r=t.length===0?s:t.slice();return e.length>0?(e.forEach((a,i)=>{s[a]=r[i],s[i+n]=r[e.length+i]}),s):r},H3=(t,e,n,s)=>{let r=[];if(n.length>0)if(s.length>0){if(t.forEach(a=>r.push(a)),Math.max(...s)>t.length)throw new Error("axes is out of bound");s.forEach((a,i)=>r[a]=n[i])}else n.forEach(a=>r.push(a));else{if(e.length===0)throw new Error("Resize requires either scales or sizes.");r=t.map((a,i)=>Math.round(a*e[i]))}return r},q3=(t,e,n)=>{let s=(()=>{switch(n.keepAspectRatioPolicy){case"not_larger":return n.axes.length>0?Math.min(...n.axes.map(a=>e[a]),Number.MAX_VALUE):Math.min(...e,Number.MAX_VALUE);case"not_smaller":return n.axes.length>0?Math.max(...n.axes.map(a=>e[a]),Number.MIN_VALUE):Math.max(...e,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();e.fill(1,0,e.length);let r=t.slice();return n.axes.length>0?(n.axes.forEach(a=>e[a]=s),n.axes.forEach(a=>r[a]=Math.round(t[a]*e[a]))):(e.fill(s,0,e.length),r.forEach((a,i)=>r[i]=Math.round(a*e[i]))),r},j3=(t,e,n,s,r)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> array<${t.type.value}, ${n.length}> {
      var original_indices: array<${t.type.value}, ${n.length}>;
      for (var i:u32 = 0; i < ${n.length}; i++) {
        var output_index = ${t.indicesGet("output_indices","i")};
        var scale = ${Ke("uniforms.scales","i",s)};
        var roi_low = ${Ke("uniforms.roi","i",r)};
        var roi_hi = ${Ke("uniforms.roi",`i + ${e.length}`,r)};
        if (scale == 1.0) {
          original_indices[i] = ${t.type.value}(output_index);
        } else {
          var input_shape_i = ${Ke("uniforms.input_shape","i",e.length)};
          var output_shape_i = ${Ke("uniforms.output_shape","i",n.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,K3=(t,e,n,s,r,a,i)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> ${t.type.indices} {
      var input_indices: ${t.type.indices};
      for (var i:u32 = 0; i < ${s.length}; i++) {
        var output_index = ${e.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${Ke("uniforms.scales","i",r)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${Ke("uniforms.roi","i",a)};
          var roi_hi = ${Ke("uniforms.roi",`i + ${n.length}`,a)};
          var input_shape_i = ${Ke("uniforms.input_shape","i",n.length)};
          var output_shape_i = ${Ke("uniforms.output_shape","i",s.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${i} || (original_idx >= 0 && original_idx < ${e.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${e.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${t.indicesSet("input_indices","i","input_index")}
      }
      return input_indices;
    }`,X3=(t,e)=>`
    fn checkInputIndices(input_indices: ${t.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${e.length}; i++) {
        var input_index = ${t.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${Ke("uniforms.input_shape","i",e.length)}) {
          return false;
        }
      }
      return true;
    }`,c$=(t,e,n,s)=>t.rank>s?`
    ${t.indicesSet("input_indices",e,"channel")};
    ${t.indicesSet("input_indices",n,"batch")};
`:"",Y3=(t,e,n,s,r)=>{let[a,i,o,l]=n.length===2?[-1,0,1,-1]:[0,2,3,1],c=t.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${c} {
      var input_indices: ${t.type.indices};
      ${t.indicesSet("input_indices",i,`max(0, min(row, ${n[i]} - 1))`)};
      ${t.indicesSet("input_indices",o,`max(0, min(col, ${n[o]} - 1))`)};
      ${c$(t,l,a,2)}
      return ${t.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${e.type.indices}) -> ${c} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${c} = originalIndices[${i}];
      var col:${c} = originalIndices[${o}];
      ${s?`if (row < 0 || row > (${n[i]} - 1) || col < 0 || col > (${n[o]} - 1)) {
        return ${r};
      }`:""};
      row = max(0, min(row, ${n[i]} - 1));
      col = max(0, min(col, ${n[o]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${n.length>2?`u32(originalIndices[${l}])`:"0"};
      var batch: u32 =  ${n.length>2?`u32(originalIndices[${a}])`:"0"};
      var x11: ${c} = getInputValue(batch, channel, row1, col1);
      var x12: ${c} = getInputValue(batch, channel, row1, col2);
      var x21: ${c} = getInputValue(batch, channel, row2, col1);
      var x22: ${c} = getInputValue(batch, channel, row2, col2);
      var dx1: ${c} = abs(row - ${c}(row1));
      var dx2: ${c} = abs(${c}(row2) - row);
      var dy1: ${c} = abs(col - ${c}(col1));
      var dy2: ${c} = abs(${c}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},Z3=(t,e,n,s,r,a,i,o,l,c)=>{let h=n.length===2,[p,f]=h?[0,1]:[2,3],g=t.type.value,y=x=>{let w=x===p?"row":"col";return`
      fn ${w}CubicInterpolation(input_indices: ${t.type.indices}, output_indices: ${e.type.indices}) -> ${g} {
        var output_index = ${e.indicesGet("output_indices",x)};
        var originalIdx: ${g} = getOriginalCoordinateFromResizedCoordinate(output_index, ${r[x]},
        ${s[x]}, ${n[x]}, ${a[x]}, ${a[x]} + ${n.length});
        var fractOriginalIdx: ${g} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${o} && (originalIdx < 0 || originalIdx > (${n[x]} - 1))) {
          return ${l};
        }
        var data: array<${g}, 4> = array<${g}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${w}: ${g} = originalIdx + ${g}(i);
          if (${w} < 0 || ${w} >= ${n[x]}) {
            ${c?`coefs[i + 1] = 0.0;
                        continue;`:o?`return ${l};`:`${w} = max(0, min(${w}, ${n[x]} - 1));`};
          }
        var input_indices_copy: ${t.type.indices} = input_indices;
          ${t.indicesSet("input_indices_copy",x,`u32(${w})`)};
          data[i + 1] = ${x===p?t.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${y(p)};
    ${y(f)};
  fn getCubicInterpolationCoefs(s: ${g}) -> array<${g}, 4> {
    var absS = abs(s);
    var coeffs: array<${g}, 4> = array<${g}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${g} = 1.0 - absS;
    var twoMinusAbsS: ${g} = 2.0 - absS;
    var onePlusAbsS: ${g} = 1.0 + absS;
    coeffs[0] = ((${i} * onePlusAbsS - 5 * ${i}) * onePlusAbsS + 8 * ${i}) * onePlusAbsS - 4 * ${i};
    coeffs[1] = ((${i} + 2) * absS - (${i} + 3)) * absS * absS + 1;
    coeffs[2] = ((${i} + 2) * oneMinusAbsS - (${i} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${i} * twoMinusAbsS - 5 * ${i}) * twoMinusAbsS + 8 * ${i}) * twoMinusAbsS - 4 * ${i};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${g}, 4>, coefs: array<${g}, 4>) -> ${g} {
    var coefsSum: ${g} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${e.type.indices}) -> ${g} {
    var input_indices: ${t.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},Q3=(t,e,n,s,r)=>{let[a,i,o,l,c]=n.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],h=t.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${h} {
      var input_indices: ${t.type.indices};
      ${t.indicesSet("input_indices",i,`max(0, min(depth, ${n[i]} - 1))`)};
      ${t.indicesSet("input_indices",o,`max(0, min(height, ${n[o]} - 1))`)};
      ${t.indicesSet("input_indices",l,`max(0, min(width, ${n[l]} - 1))`)};
      ${c$(t,c,a,3)}
      return ${t.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${e.type.indices}) -> ${h} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${h} = originalIndices[${i}];
      var height:${h} = originalIndices[${o}];
      var width:${h} = originalIndices[${l}];
      ${s?`if (depth < 0 || depth > (${n[i]} - 1) || height < 0 || height > (${n[o]} - 1) || width < 0 || (width > ${n[l]} - 1)) {
      return ${r};
        }`:""};

    depth = max(0, min(depth, ${n[i]} - 1));
      height = max(0, min(height, ${n[o]} - 1));
      width = max(0, min(width, ${n[l]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${n.length>3?`u32(originalIndices[${c}])`:"0"};
      var batch: u32 =  ${n.length>3?`u32(originalIndices[${a}])`:"0"};

      var x111: ${h} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${h} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${h} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${h} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${h} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${h} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${h} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${h} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${h} = abs(depth - ${h}(depth1));
      var dx2: ${h} = abs(${h}(depth2) - depth);
      var dy1: ${h} = abs(height - ${h}(height1));
      var dy2: ${h} = abs(${h}(height2) - height);
      var dz1: ${h} = abs(width - ${h}(width1));
      var dz2: ${h} = abs(${h}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},J3=(t,e,n,s,r,a)=>{let i=t.dims,o=G3(a,e.axes,i.length),l=H3(i,s,r,e.axes),c=s.slice();s.length===0&&(c=i.map(($,T)=>$===0?1:l[T]/$),e.keepAspectRatioPolicy!=="stretch"&&(l=q3(i,c,e)));let h=je("output",t.dataType,l.length),p=Te("input",t.dataType,i.length),f=ve.size(l),g=i.length===l.length&&i.every(($,T)=>$===l[T]),y=e.coordinateTransformMode==="tf_crop_and_resize",x=e.extrapolationValue,w=p.type.value,v=$=>`
      ${g?"":`
      ${U3(e.coordinateTransformMode,w)};
      ${(()=>{switch(e.mode){case"nearest":return`
              ${X3(p,i)};
              ${W3(e.nearestMode,n,w)};
              ${K3(p,h,i,l,c.length,o.length,y)};
              `;case"linear":return`
              ${j3(h,i,l,c.length,o.length)};
              ${(()=>{if(i.length===2||i.length===4)return`${Y3(p,h,i,y,x)}`;if(i.length===3||i.length===5)return`${Q3(p,h,i,y,x)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(i.length===2||i.length===4)return`${Z3(p,h,i,l,c,o,e.cubicCoeffA,y,e.extrapolationValue,e.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${$.registerUniform("output_size","u32").registerUniform("scales","f32",c.length).registerUniform("roi","f32",o.length).declareVariables(p,h)}
      ${$.mainStart()}
        ${$.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${g?"output[global_idx] = input[global_idx];":`
        let output_indices = ${h.offsetToIndices("global_idx")};
        var input_indices: ${p.type.indices};
        ${(()=>{switch(e.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${p.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${e.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${i.length===2||i.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${e.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${e.cacheKey}|${n}|${c.length>0?e.mode==="cubic"?c:c.length:""}|${r.length>0?r:""}|${o.length>0?o:""}|${g}|${e.mode==="nearest"?i.length:i}`,inputDependencies:["rank"]},getShaderSource:v,getRunData:()=>({outputs:[{dims:l,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:[{type:12,data:f},{type:1,data:c},{type:1,data:o},...Je(i,l)]})}},eD=t=>{let e=t.customDataBuffer;return new Uint32Array(e,e.byteOffset,1)[0]},eW=(t,e)=>{let n=[],s=[],r=[],a=eD(t);if(e.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");V3(t.inputs,e,a,n,s,r),t.compute(J3(t.inputs[0],e,a,n,s,r),{inputs:[0]})},tW=t=>{let e=t.antialias,n=t.axes,s=t.coordinateTransformMode,r=t.cubicCoeffA,a=t.excludeOutside!==0,i=t.extrapolationValue,o=t.keepAspectRatioPolicy,l=t.mode,c=t.nearestMode===""?"simple":t.nearestMode;return Xt({antialias:e,axes:n,coordinateTransformMode:s,cubicCoeffA:r,excludeOutside:a,extrapolationValue:i,keepAspectRatioPolicy:o,mode:l,nearestMode:c})}}),tD,nD,nW,e1e=ze(()=>{it(),ht(),Tn(),mt(),tD=(t,e)=>{let[n,s,r,a]=t,{numHeads:i,rotaryEmbeddingDim:o}=e;if(n.dims.length!==3&&n.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${n.dims.length}`);if(!ve.areEqual(s.dims,[])&&!ve.areEqual(s.dims,[1])&&s.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${s.dims.length}`);if(r.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${r.dims.length}`);if(a.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${a.dims.length}`);if(!ve.areEqual(r.dims,a.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(o>0&&i===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let l=n.dims[0],c=n.dims[n.dims.length-2],h=r.dims[0],p=ve.sizeFromDimension(n.dims,1)/c,f=o===0?r.dims[1]*2:p/i;if(o>f)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(s.dims.length===2){if(l!==s.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${s.dims[0]}`);if(c!==s.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${s.dims[1]}`)}if(f/2!==r.dims[1]&&o/2!==r.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${r.dims[1]}`);if(c>h)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},nD=(t,e)=>{let{interleaved:n,numHeads:s,rotaryEmbeddingDim:r,scale:a}=e,i=t[0].dims[0],o=ve.sizeFromDimension(t[0].dims,1),l=t[0].dims[t[0].dims.length-2],c=o/l,h=t[2].dims[1],p=r===0?h*2:c/s,f=new Array(i,l,c/p,p-h),g=ve.computeStrides(f),y=[{type:1,data:a},{type:12,data:f},{type:12,data:g},...t[0].dims.length===3?new Array({type:12,data:[o,c,p,1]}):[],...t[0].dims.length===4?new Array({type:12,data:[o,p,l*p,1]}):[],...Je(t[0].dims,t[1].dims,t[2].dims,t[3].dims,t[0].dims)],x=w=>{let v=Te("input",t[0].dataType,t[0].dims.length),$=Te("position_ids",t[1].dataType,t[1].dims.length),T=Te("cos_cache",t[2].dataType,t[2].dims.length),C=Te("sin_cache",t[3].dataType,t[3].dims.length),I=je("output",t[0].dataType,t[0].dims.length);return w.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:f.length},{name:"global_strides",type:"u32",length:g.length},{name:"input_output_strides",type:"u32",length:g.length}]),`
        ${w.declareVariables(v,$,T,C,I)}

        ${w.mainStart(Yd)}
          let half_rotary_emb_dim = uniforms.${T.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${w.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${$.broadcastedIndicesToOffset("bsnh.xy",je("",$.type.tensor,2))};
            let position_id =
                u32(${$.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${n});
            let j = i + select(half_rotary_emb_dim, 1, ${n});
            let re = ${v.getByOffset("i")} * ${T.get("position_id","bsnh[3]")} -
                ${v.getByOffset("j")} * ${C.get("position_id","bsnh[3]")};
            ${I.setByOffset("i","re")}
            let im = ${v.getByOffset("i")} * ${C.get("position_id","bsnh[3]")} +
                ${v.getByOffset("j")} * ${T.get("position_id","bsnh[3]")};
            ${I.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${I.setByOffset("k",v.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:Xt({interleaved:n}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:x,getRunData:()=>({outputs:[{dims:t[0].dims,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(ve.size(f)/Yd)},programUniforms:y})}},nW=(t,e)=>{tD(t.inputs,e),t.compute(nD(t.inputs,e))}}),sD,rD,sW,t1e=ze(()=>{it(),ht(),mt(),sD=t=>{if(!t||t.length<3)throw new Error("layerNorm requires at least 3 inputs.");let e=t[0],n=t[1],s=t[2];if(e.dataType!==n.dataType||e.dataType!==s.dataType)throw new Error("All inputs must have the same data type");if(e.dims.length!==3&&e.dims.length!==2)throw new Error("Input must be 2D or 3D");if(n.dims.length!==3&&n.dims.length!==2)throw new Error("Skip must be 2D or 3D");let r=e.dims[e.dims.length-1],a=e.dims[e.dims.length-2];if(n.dims[n.dims.length-1]!==r)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==a)throw new Error("Skip must have the same sequence length as input");if(s.dims.length!==1)throw new Error("Gamma must be 1D");if(s.dims[s.dims.length-1]!==r)throw new Error("Gamma must have the same hidden size as input");if(t.length>3){let i=t[3];if(i.dims.length!==1)throw new Error("Beta must be 1D");if(i.dims[i.dims.length-1]!==r)throw new Error("Beta must have the same hidden size as input")}if(t.length>4){let i=t[4];if(i.dims.length!==1)throw new Error("Bias must be 1D");if(i.dims[i.dims.length-1]!==r)throw new Error("Bias must have the same hidden size as input")}},rD=(t,e,n,s)=>{let r=e.simplified,a=t[0].dims,i=ve.size(a),o=a,l=i,c=a.slice(-1)[0],h=s?a.slice(0,-1).concat(1):[],p=!r&&t.length>3,f=t.length>4,g=s&&n>1,y=s&&n>2,x=n>3,w=64,v=bn(c),$=[{type:12,data:l},{type:12,data:v},{type:12,data:c},{type:1,data:e.epsilon}],T=I=>{let A=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],O=[Te("x",t[0].dataType,t[0].dims,v),Te("skip",t[1].dataType,t[1].dims,v),Te("gamma",t[2].dataType,t[2].dims,v)];p&&O.push(Te("beta",t[3].dataType,t[3].dims,v)),f&&O.push(Te("bias",t[4].dataType,t[4].dims,v)),O.push(je("output",t[0].dataType,o,v)),g&&O.push(je("mean_output",1,h)),y&&O.push(je("inv_std_output",1,h)),x&&O.push(je("input_skip_bias_sum",t[0].dataType,o,v));let B=is(t[0].dataType),z=is(1,v);return`

      ${I.registerUniforms(A).declareVariables(...O)}
      var<workgroup> sum_shared : array<${z}, ${w}>;
      var<workgroup> sum_squared_shared : array<${z}, ${w}>;

      ${I.mainStart([w,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${w};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${w};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${w-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${f?"bias[offset1d + i]":B+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${x?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${Id(B,v,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${w};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${Ul("sum",v)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${Ul("square_sum",v)} / f32(uniforms.hidden_size) ${r?"":"- mean * mean"} + uniforms.epsilon);
        ${g?"mean_output[global_idx] = mean;":""}
        ${y?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${r?"":`- ${B}(mean)`}) *
            ${B}(inv_std_dev) * gamma[offset1d + i]
            ${p?"+ beta[offset1d + i]":""};
        }
      }`},C=[{dims:o,dataType:t[0].dataType}];return n>1&&C.push({dims:h,dataType:1}),n>2&&C.push({dims:h,dataType:1}),n>3&&C.push({dims:a,dataType:t[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${v};${g};${y};${x}`,inputDependencies:t.map((I,A)=>"type")},getShaderSource:T,getRunData:()=>({outputs:C,dispatchGroup:{x:Math.ceil(l/c)},programUniforms:$})}},sW=(t,e)=>{sD(t.inputs);let n=[0];t.outputCount>1&&n.push(-3),t.outputCount>2&&n.push(-3),t.outputCount>3&&n.push(3),t.compute(rD(t.inputs,e,t.outputCount,!1),{outputs:n})}}),aD,jp,iD,d$,oD,lD,rW,aW,n1e=ze(()=>{it(),ht(),Tn(),mt(),aD=(t,e)=>{if(!t||t.length<1)throw new Error("too few inputs");if(e.axes.length!==0){if(e.axes.length!==e.starts.length||e.axes.length!==e.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(e.starts.length!==e.ends.length)throw new Error("starts and ends must have the same length");t.slice(1).forEach((n,s)=>{if(t[s+1].dataType!==6&&t[s+1].dataType!==7)throw new Error(`Input ${s} must be an array of int32 or int64`)})},jp=(t,e)=>{let n=[];if(t.length>e)if(t[e].dataType===7)t[e].getBigInt64Array().forEach(s=>n.push(Number(s)));else if(t[e].dataType===6)t[e].getInt32Array().forEach(s=>n.push(Number(s)));else throw new Error(`Input ${e} must be an array of int32 or int64`);return n},iD=(t,e)=>{if(t.length>1){let n=jp(t,1),s=jp(t,2),r=jp(t,3);return r.length===0&&(r=[...Array(t[0].dims.length).keys()]),Xt({starts:n,ends:s,axes:r})}else return e},d$=(t,e,n,s,r)=>{let a=t;return t<0&&(a+=n[s[e]]),r[e]<0?Math.max(0,Math.min(a,n[s[e]]-1)):Math.max(0,Math.min(a,n[s[e]]))},oD=(t,e,n)=>`fn calculateInputIndices(output_indices: ${e.type.indices}) -> ${t.type.indices} {
          var input_indices: ${t.type.indices};
          var carry = 0u;
          for (var i = ${n.length}; i >= 0; i--) {
            let input_shape_i = ${Ke("uniforms.input_shape","i",n.length)};
            let steps_i = ${Ke("uniforms.steps","i",n.length)};
            let signs_i = ${Ke("uniforms.signs","i",n.length)};
            let starts_i = ${Ke("uniforms.starts","i",n.length)};
            var output_index = ${e.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${t.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,lD=(t,e)=>{let n=t[0].dims,s=ve.size(n),r=e.axes.length>0?ve.normalizeAxes(e.axes,n.length):[...Array(n.length).keys()],a=jp(t,4);a.forEach(v=>v!==0||(()=>{throw new Error("step cannot be 0")})),a.length===0&&(a=Array(r.length).fill(1));let i=e.starts.map((v,$)=>d$(v,$,n,r,a)),o=e.ends.map((v,$)=>d$(v,$,n,r,a));if(r.length!==i.length||r.length!==o.length)throw new Error("start, ends and axes should have the same number of elements");if(r.length!==n.length)for(let v=0;v<n.length;++v)r.includes(v)||(i.splice(v,0,0),o.splice(v,0,n[v]),a.splice(v,0,1));let l=a.map(v=>Math.sign(v));a.forEach((v,$,T)=>{if(v<0){let C=(o[$]-i[$])/v,I=i[$],A=I+C*a[$];i[$]=A,o[$]=I,T[$]=-v}});let c=n.slice(0);r.forEach((v,$)=>{c[v]=Math.ceil((o[v]-i[v])/a[v])});let h={dims:c,dataType:t[0].dataType},p=je("output",t[0].dataType,c.length),f=Te("input",t[0].dataType,t[0].dims.length),g=ve.size(c),y=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:i.length},{name:"signs",type:"i32",length:l.length},{name:"steps",type:"u32",length:a.length}],x=[{type:12,data:g},{type:12,data:i},{type:6,data:l},{type:12,data:a},...Je(t[0].dims,c)],w=v=>`
      ${v.registerUniforms(y).declareVariables(f,p)}
        ${oD(f,p,n)}
        ${v.mainStart()}
          ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${p.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${p.setByOffset("global_idx",f.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${l.length}_${i.length}_${a.length}`,inputDependencies:["rank"]},getShaderSource:w,getRunData:()=>({outputs:[h],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:x})}},rW=(t,e)=>{aD(t.inputs,e);let n=iD(t.inputs,e);t.compute(lD(t.inputs,n),{inputs:[0]})},aW=t=>{let e=t.starts,n=t.ends,s=t.axes;return Xt({starts:e,ends:n,axes:s})}}),uD,cD,iW,oW,s1e=ze(()=>{it(),ht(),Tn(),tu(),mt(),uD=t=>{if(!t||t.length!==1)throw new Error("Softmax op requires 1 input.")},cD=(t,e)=>{let n=t.inputs[0],s=n.dims,r=ve.size(s),a=s.length,i=ve.normalizeAxis(e.axis,a),o=i<s.length-1,l,c=[];o?(c=Array.from({length:a},(O,B)=>B),c[i]=a-1,c[a-1]=i,l=t.compute(jr(n,c),{inputs:[n],outputs:[-1]})[0]):l=n;let h=l.dims,p=h[a-1],f=r/p,g=bn(p),y=p/g,x=64;f===1&&(x=256);let w=(O,B)=>B===4?`max(max(${O}.x, ${O}.y), max(${O}.z, ${O}.w))`:B===2?`max(${O}.x, ${O}.y)`:B===3?`max(max(${O}.x, ${O}.y), ${O}.z)`:O,v=Te("x",l.dataType,l.dims,g),$=je("result",l.dataType,l.dims,g),T=v.type.value,C=is(l.dataType)==="f32"?`var threadMax = ${T}(-3.402823e+38f);`:`var threadMax = ${T}(-65504.0h);`,I=O=>`
      var<workgroup> rowMaxShared : ${T};
      var<workgroup> rowSumShared : ${T};
      var<workgroup> threadShared : array<${T}, ${x}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${T} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${T}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${O.registerUniform("packedCols","i32").declareVariables(v,$)}
      ${O.mainStart(x)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${x};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${C}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${T}(${w("threadShared[0]",g)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${T}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${T}(${Ul("threadShared[0]",g)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`,A=t.compute({name:"Softmax",shaderCache:{hint:`${g};${x}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:h,dataType:l.dataType}],dispatchGroup:{x:f},programUniforms:[{type:6,data:y}]}),getShaderSource:I},{inputs:[l],outputs:[o?-1:0]})[0];o&&t.compute(jr(A,c),{inputs:[A]})},iW=(t,e)=>{uD(t.inputs),cD(t,e)},oW=t=>Xt({axis:t.axis})}),h$,dD,hD,pD,lW,r1e=ze(()=>{it(),ht(),mt(),h$=t=>Array.from(t.getBigInt64Array(),Number),dD=t=>{if(!t||t.length!==2)throw new Error("Tile requires 2 inputs.");if(t[0].dataType!==1&&t[0].dataType!==10&&t[0].dataType!==6&&t[0].dataType!==12)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(t[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(t[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(h$(t[1]).length!==t[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},hD=(t,e)=>{let n=[];for(let s=0;s<t.length;++s)n.push(t[s]*e[s]);return n},pD=(t,e)=>{let n=t[0].dims,s=e??h$(t[1]),r=hD(n,s),a=ve.size(r),i=t[0].dataType,o=Te("input",i,n.length),l=je("output",i,r.length),c=h=>`
      const inputShape = ${o.indices(...n)};
      ${h.registerUniform("output_size","u32").declareVariables(o,l)}
      ${h.mainStart()}
      ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${l.offsetToIndices("global_idx")};
      var input_indices: ${o.type.indices};
      for (var i = 0; i < ${n.length}; i++) {
        let input_dim_i = ${o.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${l.indicesGet("output_indices","i")}  % input_dim_i;

        ${o.indicesSet("input_indices","i","input_dim_value")}
      }
      ${l.setByOffset("global_idx",o.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${s}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:[{type:12,data:a},...Je(t[0].dims,r)]}),getShaderSource:c}},lW=t=>{dD(t.inputs),t.compute(pD(t.inputs),{inputs:[0]})}}),fD,mD,uW,a1e=ze(()=>{it(),ht(),mt(),fD=(t,e,n,s,r)=>{let a=je("output_data",r,n.length,4),i=Te("a_data",e[1].dataType,e[1].dims.length,4),o=Te("b_data",e[2].dataType,e[2].dims.length,4),l=Te("c_data",e[0].dataType,e[0].dims.length,4),c,h=(p,f,g)=>`select(${f}, ${p}, ${g})`;if(!s)c=a.setByOffset("global_idx",h(i.getByOffset("global_idx"),o.getByOffset("global_idx"),l.getByOffset("global_idx")));else{let p=(f,g,y="")=>{let x=`a_data[index_a${g}][component_a${g}]`,w=`b_data[index_b${g}][component_b${g}]`,v=`bool(c_data[index_c${g}] & (0xffu << (component_c${g} * 8)))`;return`
            let output_indices${g} = ${a.offsetToIndices(`global_idx * 4u + ${g}u`)};
            let offset_a${g} = ${i.broadcastedIndicesToOffset(`output_indices${g}`,a)};
            let offset_b${g} = ${o.broadcastedIndicesToOffset(`output_indices${g}`,a)};
            let offset_c${g} = ${l.broadcastedIndicesToOffset(`output_indices${g}`,a)};
            let index_a${g} = offset_a${g} / 4u;
            let index_b${g} = offset_b${g} / 4u;
            let index_c${g} = offset_c${g} / 4u;
            let component_a${g} = offset_a${g} % 4u;
            let component_b${g} = offset_b${g} % 4u;
            let component_c${g} = offset_c${g} % 4u;
            ${f}[${g}] = ${y}(${h(x,w,v)});
          `};r===9?c=`
            var data = vec4<u32>(0);
            ${p("data",0,"u32")}
            ${p("data",1,"u32")}
            ${p("data",2,"u32")}
            ${p("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:c=`
            ${p("output_data[global_idx]",0)}
            ${p("output_data[global_idx]",1)}
            ${p("output_data[global_idx]",2)}
            ${p("output_data[global_idx]",3)}
          `}return`
        ${t.registerUniform("vec_size","u32").declareVariables(l,i,o,a)}
        ${t.mainStart()}
        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${c}
      }`},mD=t=>{let e=t[1].dims,n=t[2].dims,s=t[0].dims,r=t[1].dataType,a=!(ve.areEqual(e,n)&&ve.areEqual(n,s)),i=e,o=ve.size(e);if(a){let c=Xd.calcShape(Xd.calcShape(e,n,!1),s,!1);if(!c)throw new Error("Can't perform where op on the given tensors");i=c,o=ve.size(i)}let l=Math.ceil(o/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:c=>fD(c,t,i,a,r),getRunData:()=>({outputs:[{dims:i,dataType:r}],dispatchGroup:{x:Math.ceil(o/64/4)},programUniforms:[{type:12,data:l},...Je(s,e,n,i)]})}},uW=t=>{t.compute(mD(t.inputs))}}),cW,i1e=ze(()=>{xxe(),oT(),wxe(),vxe(),$xe(),Sxe(),_xe(),Ixe(),Axe(),Rxe(),Dxe(),Oxe(),zxe(),Fxe(),Lxe(),Mxe(),Bxe(),Pxe(),Vxe(),Uxe(),Wxe(),Gxe(),Hxe(),qxe(),jxe(),EU(),Kxe(),Xxe(),Yxe(),Zxe(),Qxe(),iT(),Jxe(),e1e(),t1e(),n1e(),s1e(),DU(),r1e(),tu(),lT(),a1e(),cW=new Map([["Abs",[rV]],["Acos",[aV]],["Acosh",[iV]],["Add",[PV]],["ArgMax",[eV,v2]],["ArgMin",[JP,v2]],["Asin",[oV]],["Asinh",[lV]],["Atan",[uV]],["Atanh",[cV]],["Attention",[tV]],["AveragePool",[UU,VU]],["BatchNormalization",[nV]],["BiasAdd",[sV]],["BiasSplitGelu",[BV]],["Cast",[hV,dV]],["Ceil",[fV]],["Clip",[pV]],["Concat",[YV,ZV]],["Conv",[k2,T2]],["ConvTranspose",[oU,iU]],["Cos",[mV]],["Cosh",[gV]],["CumSum",[lU,uU]],["DepthToSpace",[cU,dU]],["DequantizeLinear",[XU,YU]],["Div",[VV]],["Einsum",[hU,pU]],["Elu",[yV,rf]],["Equal",[UV]],["Erf",[bV]],["Exp",[xV]],["Expand",[fU]],["FastGelu",[mU]],["Floor",[wV]],["FusedConv",[k2,T2]],["Gather",[yU,gU]],["GatherElements",[SU,$U]],["GatherBlockQuantized",[wU,vU]],["GatherND",[bU,xU]],["Gelu",[vV]],["Gemm",[CU,_U]],["GlobalAveragePool",[GU,WU]],["GlobalMaxPool",[KU,jU]],["Greater",[qV]],["GreaterOrEqual",[KV]],["GridSample",[TU,kU]],["GroupQueryAttention",[OU]],["HardSigmoid",[IV,NV]],["InstanceNormalization",[zU]],["LayerNormalization",[FU]],["LeakyRelu",[$V,rf]],["Less",[jV]],["LessOrEqual",[XV]],["Log",[LV]],["MatMul",[LU]],["MatMulNBits",[MU,BU]],["MaxPool",[HU,qU]],["Mul",[WV]],["MultiHeadAttention",[IU,NU]],["Neg",[_V]],["Not",[SV]],["Pad",[PU]],["Pow",[GV]],["QuickGelu",[MV,rf]],["Range",[ZU]],["Reciprocal",[CV]],["ReduceMin",[KP]],["ReduceMean",[WP]],["ReduceMax",[jP]],["ReduceSum",[YP]],["ReduceProd",[XP]],["ReduceL1",[GP]],["ReduceL2",[HP]],["ReduceLogSum",[QP]],["ReduceLogSumExp",[qP]],["ReduceSumSquare",[ZP]],["Relu",[TV]],["Resize",[eW,tW]],["RotaryEmbedding",[nW]],["ScatterND",[JU,QU]],["Sigmoid",[kV]],["Sin",[EV]],["Sinh",[AV]],["Slice",[rW,aW]],["SkipLayerNormalization",[sW]],["Split",[AU,RU]],["Sqrt",[RV]],["Softmax",[iW,oW]],["Sub",[HV]],["Tan",[DV]],["Tanh",[OV]],["ThresholdedRelu",[FV,rf]],["Tile",[lW]],["Transpose",[AP,RP]],["Where",[uW]]])}),dW,o1e=ze(()=>{ei(),zo(),mt(),dW=class{constructor(t){this.backend=t,this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,e){this.repo.set(t,e)}run(t,e,n,s,r){Di(t.programInfo.name);let a=this.backend.device,i=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let o=[];for(let c of e)o.push({binding:o.length,resource:{buffer:c.buffer}});for(let c of n)o.push({binding:o.length,resource:{buffer:c.buffer}});r&&o.push({binding:o.length,resource:r});let l=a.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:o,label:t.programInfo.name});if(this.backend.sessionStatus==="capturing"){let c={kernelId:this.backend.currentKernelId,computePipeline:t.computePipeline,bindGroup:l,dispatchGroup:s};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(c)}i.setPipeline(t.computePipeline),i.setBindGroup(0,l),i.dispatchWorkgroups(...s),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),ja(t.programInfo.name)}dispose(){}build(t,e){Di(t.name);let n=this.backend.device,s=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"},{feature:"subgroups-f16",extension:"subgroups_f16"}].forEach(c=>{n.features.has(c.feature)&&s.push(`enable ${c.extension};`)});let r=EP(e,this.backend.device.limits),a=t.getShaderSource(r),i=`${s.join(`
`)}
${r.additionalImplementations}
${a}`,o=n.createShaderModule({code:i,label:t.name});zt("verbose",()=>`[WebGPU] ${t.name} shader code: ${i}`);let l=n.createComputePipeline({compute:{module:o,entryPoint:"main"},layout:"auto",label:t.name});return ja(t.name),{programInfo:t,computePipeline:l,uniformVariablesInfo:r.variablesInfo}}normalizeDispatchGroupSize(t){let e=typeof t=="number"?t:t.x,n=typeof t=="number"?1:t.y||1,s=typeof t=="number"?1:t.z||1,r=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(e<=r&&n<=r&&s<=r)return[e,n,s];let a=e*n*s,i=Math.ceil(Math.sqrt(a));if(i>r){if(i=Math.ceil(Math.cbrt(a)),i>r)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[i,i,i]}else return[i,i,1]}}}),gD,yD,bD,xD,hW,l1e=ze(()=>{ei(),it(),zo(),_P(),yxe(),i1e(),o1e(),gD=(t,e)=>{if(e.length!==t.length)throw new Error(`inputDependencies length ${e.length} is not equal to inputTensors length ${t.length}.`);let n=[];for(let s=0;s<t.length;++s){let r=t[s].dataType;switch(e[s]){case"none":{n.push("");break}case"type":{n.push(`${r}`);break}case"rank":{let a=t[s].dims.length;n.push(`${r};${a}`);break}case"dims":{let a=t[s].dims.join(",");n.push(`${r};${a}`);break}default:throw new Error(`unsupported input dependency: ${e[s]}`)}}return n.join("|")},yD=(t,e,n)=>{var r,a;let s=t.name;return(r=t.shaderCache)!=null&&r.hint&&(s+="["+t.shaderCache.hint+"]"),s+=":"+n+`:${gD(e,((a=t.shaderCache)==null?void 0:a.inputDependencies)??new Array(e.length).fill("dims"))}`,s},bD=class{constructor(t){t&&(this.architecture=t.architecture,this.vendor=t.vendor)}isArchitecture(t){return this.architecture===t}isVendor(t){return this.vendor===t}},xD=class{constructor(t){this.subgroupsSupported=t.features.has("subgroups"),this.subgroupsF16Supported=t.features.has("subgroups");let e=t.limits;!this.subgroupsSupported||!e.minSubgroupSize||!e.maxSubgroupSize?this.subgroupSizeRange=void 0:this.subgroupSizeRange=[e.minSubgroupSize,e.maxSubgroupSize]}},hW=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t,e){this.env=t;let n=[],s={requiredLimits:{maxComputeWorkgroupStorageSize:e.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:e.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:e.limits.maxStorageBufferBindingSize,maxBufferSize:e.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:e.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:e.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:e.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:e.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n},r=a=>e.features.has(a)&&n.push(a)&&!0;r("chromium-experimental-timestamp-query-inside-passes")||r("timestamp-query"),r("shader-f16"),r("subgroups")&&r("subgroups-f16"),this.device=await e.requestDevice(s),this.deviceInfo=new xD(this.device),this.adapterInfo=new bD(e.info||await e.requestAdapterInfo()),this.gpuDataManager=CP(this),this.programManager=new dW(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,nT(t.logLevel,!!t.debug),this.device.onuncapturederror=a=>{a.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${a.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:e,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t=this.getCommandEncoder(),e={};this.queryType==="at-passes"&&(e.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=t.beginComputePass(e)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;Di(),this.endComputePass();let t;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),t=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(t,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&t.mapAsync(GPUMapMode.READ).then(()=>{var s;let e=new BigUint64Array(t.getMappedRange()),n=this.pendingQueries.get(t);for(let r=0;r<e.length/2;r++){let a=n[r],i=a.kernelId,o=this.kernels.get(i),l=o.kernelType,c=o.kernelName,h=a.programName,p=a.inputTensorViews,f=a.outputTensorViews,g=e[r*2],y=e[r*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=g);let x=Number(g-this.queryTimeBase),w=Number(y-this.queryTimeBase);if(!Number.isSafeInteger(x)||!Number.isSafeInteger(w))throw new RangeError("incorrect timestamp range");if((s=this.env.webgpu.profiling)!=null&&s.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:p.map(v=>({dims:v.dims,dataType:Xu(v.dataType)})),outputsMetadata:f.map(v=>({dims:v.dims,dataType:Xu(v.dataType)})),kernelId:i,kernelType:l,kernelName:c,programName:h,startTime:x,endTime:w});else{let v="";p.forEach((T,C)=>{v+=`input[${C}]: [${T.dims}] | ${Xu(T.dataType)}, `});let $="";f.forEach((T,C)=>{$+=`output[${C}]: [${T.dims}] | ${Xu(T.dataType)}, `}),console.log(`[profiling] kernel "${i}|${l}|${c}|${h}" ${v}${$}execution time: ${w-x} ns`)}q0("GPU",`${h}::${g}::${y}`)}t.unmap(),this.pendingQueries.delete(t)}),ja()}run(t,e,n,s,r,a){Di(t.name);let i=[];for(let $=0;$<e.length;++$){let T=e[$].data;if(T===0)continue;let C=this.gpuDataManager.get(T);if(!C)throw new Error(`no GPU data for input: ${T}`);i.push(C)}let{outputs:o,dispatchGroup:l,programUniforms:c}=t.getRunData(e),h=n.length===0?o.map(($,T)=>T):n;if(h.length!==o.length)throw new Error(`Output size ${h.length} must be equal to ${o.length}.`);let p=[],f=[];for(let $=0;$<o.length;++$){if(!Number.isInteger(h[$])||h[$]<-3||h[$]>=a)throw new Error(`Invalid output index: ${h[$]}`);if(h[$]===-3)continue;let T=h[$]===-1,C=h[$]===-2,I=T||C?r(o[$].dataType,o[$].dims):s(h[$],o[$].dataType,o[$].dims);if(p.push(I),I.data===0)continue;let A=this.gpuDataManager.get(I.data);if(!A)throw new Error(`no GPU data for output: ${I.data}`);if(T&&this.temporaryData.push(A),C){let O=this.kernelPersistentData.get(this.currentKernelId);O||(O=[],this.kernelPersistentData.set(this.currentKernelId,O)),O.push(A)}f.push(A)}if(i.length!==e.length||f.length!==p.length){if(f.length===0)return ja(t.name),p;throw new Error(`Program ${t.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let g;if(c){let $=0,T=[];c.forEach(O=>{let B=typeof O.data=="number"?[O.data]:O.data;if(B.length===0)return;let z=O.type===10?2:4,P,F;O.type===10?(F=B.length>4?16:B.length>2?8:B.length*z,P=B.length>4?16:z*B.length):(F=B.length<=2?B.length*z:16,P=16),$=Math.ceil($/F)*F,T.push($);let K=O.type===10?8:4;$+=B.length>4?Math.ceil(B.length/K)*P:B.length*z});let C=16;$=Math.ceil($/C)*C;let I=new ArrayBuffer($);c.forEach((O,B)=>{let z=T[B],P=typeof O.data=="number"?[O.data]:O.data;if(O.type===6)new Int32Array(I,z,P.length).set(P);else if(O.type===12)new Uint32Array(I,z,P.length).set(P);else if(O.type===10)new Uint16Array(I,z,P.length).set(P);else if(O.type===1)new Float32Array(I,z,P.length).set(P);else throw new Error(`Unsupported uniform type: ${Xu(O.type)}`)});let A=this.gpuDataManager.create($,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(A.buffer,0,I,0,$),this.gpuDataManager.release(A.id),g={offset:0,size:$,buffer:A.buffer}}let y=this.programManager.normalizeDispatchGroupSize(l),x=y[1]===1&&y[2]===1,w=yD(t,e,x),v=this.programManager.getArtifact(w);if(v||(v=this.programManager.build(t,y),this.programManager.setArtifact(w,v),zt("info",()=>`[artifact] key: ${w}, programName: ${t.name}`)),c&&v.uniformVariablesInfo){if(c.length!==v.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${v.uniformVariablesInfo.length}, got ${c.length} in program "${v.programInfo.name}".`);for(let $=0;$<c.length;$++){let T=c[$],C=T.type,I=typeof T.data=="number"?1:T.data.length,[A,O]=v.uniformVariablesInfo[$];if(C!==A||I!==O)throw new Error(`Uniform variable ${$} mismatch: expect type ${A} with size ${O}, got type ${C} with size ${I} in program "${v.programInfo.name}".`)}}if(zt("info",()=>`[ProgramManager] run "${t.name}" (key=${w}) with ${y[0]}x${y[1]}x${y[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let $={kernelId:this.currentKernelId,programName:v.programInfo.name,inputTensorViews:e,outputTensorViews:p};this.pendingKernels.push($),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push($)}return this.programManager.run(v,i,f,y,g),ja(t.name),p}upload(t,e){this.gpuDataManager.upload(t,e)}memcpy(t,e){this.gpuDataManager.memcpy(t,e)}async download(t,e){await this.gpuDataManager.download(t,e)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,e,n,s){let r=cW.get(t);if(!r)throw new Error(`kernel not implemented: ${t}`);let a={kernelType:t,kernelName:s,kernelEntry:r[0],attributes:[r[1],n]};this.kernels.set(e,a)}releaseKernel(t){let e=this.kernelPersistentData.get(t);if(e){for(let n of e)this.gpuDataManager.release(n.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,e,n){let s=this.kernels.get(t);if(!s)throw new Error(`kernel not created: ${t}`);let r=s.kernelType,a=s.kernelName,i=s.kernelEntry,o=s.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${r}] ${a}" is not allowed to be called recursively`);this.currentKernelId=t,o[0]&&(o[1]=o[0](o[1]),o[0]=void 0),zt("info",()=>`[WebGPU] Start to run kernel "[${r}] ${a}"...`);let l=this.env.debug;this.temporaryData=[];try{return l&&this.device.pushErrorScope("validation"),i(e,o[1]),0}catch(c){return n.push(Promise.resolve(`[WebGPU] Kernel "[${r}] ${a}" failed. ${c}`)),1}finally{l&&n.push(this.device.popErrorScope().then(c=>c?`GPU validation error for kernel "[${r}] ${a}": ${c.message}`:null));for(let c of this.temporaryData)this.gpuDataManager.release(c.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,e,n,s){let r=this.sessionExternalDataMapping.get(t);r||(r=new Map,this.sessionExternalDataMapping.set(t,r));let a=r.get(e),i=this.gpuDataManager.registerExternalBuffer(n,s,a);return r.set(e,[i,n]),i}unregisterBuffers(t){let e=this.sessionExternalDataMapping.get(t);e&&(e.forEach(n=>this.gpuDataManager.unregisterExternalBuffer(n[0])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let e=this.gpuDataManager.get(t);if(!e)throw new Error(`no GPU data for buffer: ${t}`);return e.buffer}createDownloader(t,e,n){return async()=>{let s=await b2(this,t,e);return sT(s.buffer,n)}}writeTimestamp(t){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,t)}setQueryType(){var t;this.queryType="none",(((t=this.env.webgpu.profiling)==null?void 0:t.mode)==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){zt("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){zt("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){zt("info","replay"),this.sessionStatus="replaying";let t=this.capturedCommandList.get(this.currentSessionId),e=this.capturedPendingKernels.get(this.currentSessionId),n=t.length;this.pendingKernels=[];for(let s=0;s<n;s++){let r=this.getComputePassEncoder(),a=t[s];this.writeTimestamp(this.pendingDispatchNumber*2),r.setPipeline(a.computePipeline),r.setBindGroup(0,a.bindGroup),r.dispatchWorkgroups(...a.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(e[s]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(t){this.unregisterBuffers(t),this.capturedCommandList.has(t)&&this.capturedCommandList.delete(t),this.capturedPendingKernels.has(t)&&this.capturedPendingKernels.delete(t),this.gpuDataManager.onReleaseSession(t)}onRunStart(t){this.currentSessionId=t,this.setQueryType()}}}),wD,p$,vD,f$,m$,g$,$D,pW,u1e=ze(()=>{zo(),wD=1,p$=()=>wD++,vD=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),f$=(t,e)=>{let n=vD.get(t);if(!n)throw new Error("Unsupported data type.");return e.length>0?Math.ceil(e.reduce((s,r)=>s*r)*n/8):0},m$=class{constructor(t){this.sessionId=t.sessionId,this.mlContext=t.context,this.mlTensor=t.tensor,this.dataType=t.dataType,this.tensorShape=t.shape}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return f$(this.dataType,this.tensorShape)}destroy(){zt("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(t){this.mlContext.writeTensor(this.mlTensor,t)}async read(t){return t?this.mlContext.readTensor(this.mlTensor,t):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(t,e,n){return this.mlContext===t&&this.dataType===e&&this.tensorShape.length===n.length&&this.tensorShape.every((s,r)=>s===n[r])}},g$=class{constructor(t,e){this.tensorManager=t,this.wrapper=e}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(t,e,n,s){let r=this.tensorManager.getMLContext(t);if(this.wrapper){if(this.wrapper.canReuseTensor(r,e,n))return this.wrapper.tensor;if(s){if(this.wrapper.byteLength!==f$(e,n))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let a=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(t,e,n,a,!0,!0),s&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(t){if(this.wrapper)if(t.byteLength===this.wrapper.byteLength){this.wrapper.write(t);return}else zt("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor();this.activeUpload?this.activeUpload.set(t):this.activeUpload=new Uint8Array(t)}async download(t){if(this.activeUpload)if(t){t instanceof ArrayBuffer?new Uint8Array(t).set(this.activeUpload):new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(this.activeUpload);return}else return this.activeUpload.buffer;if(!this.wrapper)throw new Error("Tensor has not been created.");return t?this.wrapper.read(t):this.wrapper.read()}},$D=class{constructor(t){this.backend=t,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(t){let e=this.backend.getMLContext(t);if(!e)throw new Error("MLContext not found for session.");return e}reserveTensorId(){let t=p$();return this.tensorTrackersById.set(t,new g$(this)),t}releaseTensorId(t){let e=this.tensorTrackersById.get(t);e&&(this.tensorTrackersById.delete(t),e.tensorWrapper&&this.releaseTensor(e.tensorWrapper))}async ensureTensor(t,e,n,s,r){zt("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${e}, dataType: ${n}, shape: ${s}, copyOld: ${r}}`);let a=this.tensorTrackersById.get(e);if(!a)throw new Error("Tensor not found.");return a.ensureTensor(t,n,s,r)}upload(t,e){let n=this.tensorTrackersById.get(t);if(!n)throw new Error("Tensor not found.");n.upload(e)}async download(t,e){zt("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${t}, dstBuffer: ${e==null?void 0:e.byteLength}}`);let n=this.tensorTrackersById.get(t);if(!n)throw new Error("Tensor not found.");return n.download(e)}releaseTensorsForSession(t){for(let e of this.freeTensors)e.sessionId===t&&e.destroy();this.freeTensors=this.freeTensors.filter(e=>e.sessionId!==t)}registerTensor(t,e,n,s){let r=this.getMLContext(t),a=p$(),i=new m$({sessionId:t,context:r,tensor:e,dataType:n,shape:s});return this.tensorTrackersById.set(a,new g$(this,i)),this.externalTensors.add(i),a}async getCachedTensor(t,e,n,s,r,a){let i=this.getMLContext(t);for(let[l,c]of this.freeTensors.entries())if(c.canReuseTensor(i,e,n)){zt("verbose",()=>`[WebNN] Reusing tensor {dataType: ${e}, shape: ${n}}`);let h=this.freeTensors.splice(l,1)[0];return h.sessionId=t,h}zt("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${e}, shape: ${n}}`);let o=await i.createTensor({dataType:e,shape:n,dimensions:n,usage:s,writable:r,readable:a});return new m$({sessionId:t,context:i,tensor:o,dataType:e,shape:n})}releaseTensor(t){this.externalTensors.has(t)&&this.externalTensors.delete(t),this.freeTensors.push(t)}},pW=(...t)=>new $D(...t)}),Yy,SD,fW,c1e=ze(()=>{it(),Ac(),_P(),u1e(),zo(),Yy=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),SD=(t,e)=>{if(t===e)return!0;if(t===void 0||e===void 0)return!1;let n=Object.keys(t).sort(),s=Object.keys(e).sort();return n.length===s.length&&n.every((r,a)=>r===s[a]&&t[r]===e[r])},fW=class{constructor(t){this.tensorManager=pW(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.temporaryGraphInputs=[],this.temporarySessionTensorIds=new Map,nT(t.logLevel,!!t.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(t){zt("verbose",()=>`[WebNN] onRunStart {sessionId: ${t}}`),this.activeSessionId=t}onRunEnd(t){zt("verbose",()=>`[WebNN] onRunEnd {sessionId: ${t}}`);let e=this.temporarySessionTensorIds.get(t);if(e){for(let n of e)zt("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${n}}`),this.tensorManager.releaseTensorId(n);this.temporarySessionTensorIds.delete(t),this.activeSessionId=void 0}}async createMLContext(t){if(t instanceof GPUDevice){let n=this.mlContextCache.findIndex(s=>s.gpuDevice===t);if(n!==-1)return this.mlContextCache[n].mlContext;{let s=await navigator.ml.createContext(t);return this.mlContextCache.push({gpuDevice:t,mlContext:s}),s}}else if(t===void 0){let n=this.mlContextCache.findIndex(s=>s.options===void 0&&s.gpuDevice===void 0);if(n!==-1)return this.mlContextCache[n].mlContext;{let s=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:s}),s}}let e=this.mlContextCache.findIndex(n=>SD(n.options,t));if(e!==-1)return this.mlContextCache[e].mlContext;{let n=await navigator.ml.createContext(t);return this.mlContextCache.push({options:t,mlContext:n}),n}}registerMLContext(t,e){this.mlContextBySessionId.set(t,e);let n=this.sessionIdsByMLContext.get(e);n||(n=new Set,this.sessionIdsByMLContext.set(e,n)),n.add(t),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(t,this.temporaryGraphInputs),this.temporaryGraphInputs=[])}onReleaseSession(t){this.sessionGraphInputs.delete(t);let e=this.mlContextBySessionId.get(t);if(!e)return;this.tensorManager.releaseTensorsForSession(t),this.mlContextBySessionId.delete(t);let n=this.sessionIdsByMLContext.get(e);if(n.delete(t),n.size===0){this.sessionIdsByMLContext.delete(e);let s=this.mlContextCache.findIndex(r=>r.mlContext===e);s!==-1&&this.mlContextCache.splice(s,1)}}getMLContext(t){return this.mlContextBySessionId.get(t)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(t){zt("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${t}}`),this.tensorManager.releaseTensorId(t)}async ensureTensor(t,e,n,s,r){let a=Yy.get(n);if(!a)throw new Error(`Unsupported ONNX data type: ${n}`);return this.tensorManager.ensureTensor(t??this.currentSessionId,e,a,s,r)}async createTemporaryTensor(t,e,n){zt("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${e}, shape: ${n}}`);let s=Yy.get(e);if(!s)throw new Error(`Unsupported ONNX data type: ${e}`);let r=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(t,r,s,n,!1);let a=this.temporarySessionTensorIds.get(t);return a?a.push(r):this.temporarySessionTensorIds.set(t,[r]),r}uploadTensor(t,e){if(!ts().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");zt("verbose",()=>`[WebNN] uploadTensor {tensorId: ${t}, data: ${e.byteLength}}`),this.tensorManager.upload(t,e)}async downloadTensor(t,e){return this.tensorManager.download(t,e)}createMLTensorDownloader(t,e){return async()=>{let n=await this.tensorManager.download(t);return sT(n,e)}}registerMLTensor(t,e,n,s){let r=Yy.get(n);if(!r)throw new Error(`Unsupported ONNX data type: ${n}`);let a=this.tensorManager.registerTensor(t,e,r,s);return zt("verbose",()=>`[WebNN] registerMLTensor {tensor: ${e}, dataType: ${r}, dimensions: ${s}} -> {tensorId: ${a}}`),a}registerMLConstant(t,e,n,s,r,a){if(!a)throw new Error("External mounted files are not available.");let i=t;t.startsWith("./")&&(i=t.substring(2));let o=a.get(i);if(!o)throw new Error(`File with name ${i} not found in preloaded files.`);if(e+n>o.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let l=o.slice(e,e+n).buffer,c;switch(r.dataType){case"float32":c=new Float32Array(l);break;case"float16":c=new Uint16Array(l);break;case"int32":c=new Int32Array(l);break;case"uint32":c=new Uint32Array(l);break;case"int64":c=new BigInt64Array(l);break;case"uint64":c=new BigUint64Array(l);break;case"int8":c=new Int8Array(l);break;case"int4":case"uint4":case"uint8":c=new Uint8Array(l);break;default:throw new Error(`Unsupported data type: ${r.dataType} in creating WebNN Constant from external data.`)}return zt("verbose",()=>`[WebNN] registerMLConstant {dataType: ${r.dataType}, shape: ${r.shape}}}`),s.constant(r,c)}registerGraphInput(t){this.temporaryGraphInputs.push(t)}isGraphInput(t,e){let n=this.sessionGraphInputs.get(t);return n?n.includes(e):!1}flush(){}}}),mW={};Zm(mW,{init:()=>gW});var Zy,_D,gW,d1e=ze(()=>{it(),l1e(),zo(),ht(),c1e(),Zy=class yW{constructor(e,n,s,r){this.module=e,this.dataType=n,this.data=s,this.dims=r}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let e=ve.size(this.dims);return e===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let e=ve.size(this.dims);return e===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let e=ve.size(this.dims);return e===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error("Invalid data type");let e=ve.size(this.dims);return e===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,e)}reshape(e){if(ve.size(e)!==ve.size(this.dims))throw new Error("Invalid new shape");return new yW(this.module,this.dataType,this.data,e)}},_D=class{constructor(t,e,n){this.module=t,this.backend=e,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=e.adapterInfo,this.deviceInfo=e.deviceInfo;let s=t.PTR_SIZE,r=n/t.PTR_SIZE,a=s===4?"i32":"i64";this.opKernelContext=Number(t.getValue(s*r++,a));let i=Number(t.getValue(s*r++,a));this.outputCount=Number(t.getValue(s*r++,a)),this.customDataOffset=Number(t.getValue(s*r++,"*")),this.customDataSize=Number(t.getValue(s*r++,a));let o=[];for(let l=0;l<i;l++){let c=Number(t.getValue(s*r++,a)),h=Number(t.getValue(s*r++,"*")),p=Number(t.getValue(s*r++,a)),f=[];for(let g=0;g<p;g++)f.push(Number(t.getValue(s*r++,a)));o.push(new Zy(t,c,h,f))}this.inputs=o}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,e){var i;let n=((i=e==null?void 0:e.inputs)==null?void 0:i.map(o=>typeof o=="number"?this.inputs[o]:o))??this.inputs,s=(e==null?void 0:e.outputs)??[],r=(o,l,c)=>new Zy(this.module,l,this.output(o,c),c),a=(o,l)=>{let c=Yu(o,l);if(!c)throw new Error(`Unsupported data type: ${o}`);let h=c>0?this.backend.gpuDataManager.create(c).id:0;return new Zy(this.module,o,h,l)};return this.backend.run(t,n,s,r,a,this.outputCount)}output(t,e){let n=this.module.stackSave();try{let s=this.module.PTR_SIZE,r=s===4?"i32":"i64",a=this.module.stackAlloc((1+e.length)*s);this.module.setValue(a,e.length,r);for(let i=0;i<e.length;i++)this.module.setValue(a+s*(i+1),e[i],r);return this.module._JsepOutput(this.opKernelContext,t,a)}catch(s){throw new Error(`Failed to generate kernel's output[${t}] with dims [${e}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${s}`)}finally{this.module.stackRestore(n)}}},gW=async(t,e,n,s)=>{let r=e.jsepInit;if(!r)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(t==="webgpu"){let a=new hW;await a.initialize(n,s),r("webgpu",[a,i=>a.alloc(Number(i)),i=>a.free(i),(i,o,l,c=!1)=>{if(c)zt("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(i)}, dst=${Number(o)}, size=${Number(l)}`),a.memcpy(Number(i),Number(o));else{zt("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(i)}, gpuDataId=${Number(o)}, size=${Number(l)}`);let h=e.HEAPU8.subarray(Number(i>>>0),Number(i>>>0)+Number(l));a.upload(Number(o),h)}},async(i,o,l)=>{zt("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${i}, dataOffset=${o}, size=${l}`),await a.download(Number(i),()=>e.HEAPU8.subarray(Number(o)>>>0,Number(o+l)>>>0))},(i,o,l)=>a.createKernel(i,Number(o),l,e.UTF8ToString(e._JsepGetNodeName(Number(o)))),i=>a.releaseKernel(i),(i,o,l,c)=>{zt("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${l}, kernel=${i}, contextDataOffset=${o}`);let h=new _D(e,a,Number(o));return a.computeKernel(Number(i),h,c)},()=>a.captureBegin(),()=>a.captureEnd(),()=>a.replay()])}else{let a=new fW(n);r("webnn",[a,()=>a.reserveTensorId(),i=>a.releaseTensorId(i),async(i,o,l,c,h)=>a.ensureTensor(i,o,l,c,h),(i,o)=>{a.uploadTensor(i,o)},async(i,o)=>a.downloadTensor(i,o)])}}}),CD,fT,mT,$l,TD,Q0,gT,yT,y$,bT,xT,wT,bW=ze(()=>{mxe(),gxe(),it(),Ac(),ZC(),SP(),CD=(t,e)=>{ts()._OrtInit(t,e)!==0&&qt("Can't initialize onnxruntime.")},fT=async t=>{CD(t.wasm.numThreads,K0(t.logLevel))},mT=async(t,e)=>{{let n=(d1e(),H0(mW)).init;if(e==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let s=t.webgpu.adapter;if(s){if(typeof s.limits!="object"||typeof s.features!="object"||typeof s.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let r=t.webgpu.powerPreference;if(r!==void 0&&r!=="low-power"&&r!=="high-performance")throw new Error(`Invalid powerPreference setting: "${r}"`);let a=t.webgpu.forceFallbackAdapter;if(a!==void 0&&typeof a!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${a}"`);if(s=await navigator.gpu.requestAdapter({powerPreference:r,forceFallbackAdapter:a}),!s)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}await n("webgpu",ts(),t,s)}if(e==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await n("webnn",ts(),t)}}},$l=new Map,TD=t=>{let e=ts(),n=e.stackSave();try{let s=e.PTR_SIZE,r=e.stackAlloc(2*s);e._OrtGetInputOutputCount(t,r,r+s)!==0&&qt("Can't get session input/output count.");let a=s===4?"i32":"i64";return[Number(e.getValue(r,a)),Number(e.getValue(r+s,a))]}finally{e.stackRestore(n)}},Q0=t=>{let e=ts(),n=e._malloc(t.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${t.byteLength}.`);return e.HEAPU8.set(t,n),[n,t.byteLength]},gT=async(t,e)=>{var p,f,g;let n,s,r=ts();Array.isArray(t)?[n,s]=t:t.buffer===r.HEAPU8.buffer?[n,s]=[t.byteOffset,t.byteLength]:[n,s]=Q0(t);let a=0,i=0,o=0,l=[],c=[],h=[];try{if([i,l]=$P(e),(e==null?void 0:e.externalData)&&r.mountExternalData){let I=[];for(let A of e.externalData){let O=typeof A=="string"?A:A.path;I.push(tT(typeof A=="string"?A:A.data).then(B=>{r.mountExternalData(O,B)}))}await Promise.all(I)}for(let I of(e==null?void 0:e.executionProviders)??[])if((typeof I=="string"?I:I.name)==="webnn"){if(r.shouldTransferToMLTensor=!1,typeof I!="string"){let A=I,O=A==null?void 0:A.context,B=A==null?void 0:A.gpuDevice,z=A==null?void 0:A.deviceType,P=A==null?void 0:A.powerPreference;O?r.currentContext=O:B?r.currentContext=await r.jsepCreateMLContext(B):r.currentContext=await r.jsepCreateMLContext({deviceType:z,powerPreference:P})}else r.currentContext=await r.jsepCreateMLContext();break}a=await r._OrtCreateSession(n,s,i),a===0&&qt("Can't create a session."),(p=r.jsepOnCreateSession)==null||p.call(r),r.currentContext&&(r.jsepRegisterMLContext(a,r.currentContext),r.currentContext=void 0,r.shouldTransferToMLTensor=!0);let[y,x]=TD(a),w=!!(e!=null&&e.enableGraphCapture),v=[],$=[],T=[];for(let I=0;I<y;I++){let A=r._OrtGetInputName(a,I);A===0&&qt("Can't get an input name."),c.push(A),v.push(r.UTF8ToString(A))}for(let I=0;I<x;I++){let A=r._OrtGetOutputName(a,I);A===0&&qt("Can't get an output name."),h.push(A);let O=r.UTF8ToString(A);$.push(O);{if(w&&(e==null?void 0:e.preferredOutputLocation)===void 0){T.push("gpu-buffer");continue}let B=typeof(e==null?void 0:e.preferredOutputLocation)=="string"?e.preferredOutputLocation:((f=e==null?void 0:e.preferredOutputLocation)==null?void 0:f[O])??"cpu";if(B!=="cpu"&&B!=="cpu-pinned"&&B!=="gpu-buffer"&&B!=="ml-tensor")throw new Error(`Not supported preferred output location: ${B}.`);if(w&&B!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${B}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);T.push(B)}}let C=null;return T.some(I=>I==="gpu-buffer"||I==="ml-tensor")&&(o=r._OrtCreateBinding(a),o===0&&qt("Can't create IO binding."),C={handle:o,outputPreferredLocations:T,outputPreferredLocationsEncoded:T.map(I=>y2(I))}),$l.set(a,[a,c,h,C,w,!1]),[a,v,$]}catch(y){throw c.forEach(x=>r._OrtFree(x)),h.forEach(x=>r._OrtFree(x)),o!==0&&r._OrtReleaseBinding(o)!==0&&qt("Can't release IO binding."),a!==0&&r._OrtReleaseSession(a)!==0&&qt("Can't release session."),y}finally{r._free(n),i!==0&&r._OrtReleaseSessionOptions(i)!==0&&qt("Can't release session options."),l.forEach(y=>r._free(y)),(g=r.unmountExternalData)==null||g.call(r)}},yT=t=>{var l;let e=ts(),n=$l.get(t);if(!n)throw new Error(`cannot release session. invalid session id: ${t}`);let[s,r,a,i,o]=n;i&&(o&&e._OrtClearBoundOutputs(i.handle)!==0&&qt("Can't clear bound outputs."),e._OrtReleaseBinding(i.handle)!==0&&qt("Can't release IO binding.")),(l=e.jsepOnReleaseSession)==null||l.call(e,t),r.forEach(c=>e._OrtFree(c)),a.forEach(c=>e._OrtFree(c)),e._OrtReleaseSession(s)!==0&&qt("Can't release session."),$l.delete(t)},y$=async(t,e,n,s,r,a=!1)=>{if(!t){e.push(0);return}let i=ts(),o=i.PTR_SIZE,l=t[0],c=t[1],h=t[3],p=h,f,g;if(l==="string"&&(h==="gpu-buffer"||h==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(a&&h!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${r} when enableGraphCapture is true.`);if(h==="gpu-buffer"){let w=t[2].gpuBuffer;g=Yu(kd(l),c);let v=i.jsepRegisterBuffer;if(!v)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');f=v(s,r,w,g)}else if(h==="ml-tensor"){let w=t[2].mlTensor;g=Yu(kd(l),c);let v=i.jsepRegisterMLTensor;if(!v)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');f=v(s,w,kd(l),c)}else{let w=t[2];if(Array.isArray(w)){g=o*w.length,f=i._malloc(g),n.push(f);for(let v=0;v<w.length;v++){if(typeof w[v]!="string")throw new TypeError(`tensor data at index ${v} is not a string`);i.setValue(f+v*o,Es(w[v],n),"*")}}else{let v=i.jsepIsGraphInput;if(l!=="string"&&v){let $=i._OrtGetInputName(s,r),T=i.UTF8ToString($);if(v(s,T)){let C=kd(l);g=Yu(C,c),p="ml-tensor";let I=i.jsepCreateTemporaryTensor,A=i.jsepUploadTensor;if(!I||!A)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let O=await I(s,C,c);A(O,new Uint8Array(w.buffer,w.byteOffset,w.byteLength)),f=O}else g=w.byteLength,f=i._malloc(g),n.push(f),i.HEAPU8.set(new Uint8Array(w.buffer,w.byteOffset,g),f)}else g=w.byteLength,f=i._malloc(g),n.push(f),i.HEAPU8.set(new Uint8Array(w.buffer,w.byteOffset,g),f)}}let y=i.stackSave(),x=i.stackAlloc(4*c.length);try{c.forEach((v,$)=>i.setValue(x+$*o,v,o===4?"i32":"i64"));let w=i._OrtCreateTensor(kd(l),f,g,x,c.length,y2(p));w===0&&qt(`Can't create tensor for input/output. session=${s}, index=${r}.`),e.push(w)}finally{i.stackRestore(y)}},bT=async(t,e,n,s,r,a)=>{var F,K,X;let i=ts(),o=i.PTR_SIZE,l=$l.get(t);if(!l)throw new Error(`cannot run inference. invalid session id: ${t}`);let c=l[0],h=l[1],p=l[2],f=l[3],g=l[4],y=l[5],x=e.length,w=s.length,v=0,$=[],T=[],C=[],I=[],A=i.stackSave(),O=i.stackAlloc(x*o),B=i.stackAlloc(x*o),z=i.stackAlloc(w*o),P=i.stackAlloc(w*o);try{[v,$]=vP(a);for(let q=0;q<x;q++)await y$(n[q],T,I,t,e[q],g);for(let q=0;q<w;q++)await y$(r[q],C,I,t,x+s[q],g);for(let q=0;q<x;q++)i.setValue(O+q*o,T[q],"*"),i.setValue(B+q*o,h[e[q]],"*");for(let q=0;q<w;q++)i.setValue(z+q*o,C[q],"*"),i.setValue(P+q*o,p[s[q]],"*");if(f&&!y){let{handle:q,outputPreferredLocations:oe,outputPreferredLocationsEncoded:se}=f;if(h.length!==x)throw new Error(`input count from feeds (${x}) is expected to be always equal to model's input count (${h.length}).`);for(let ee=0;ee<x;ee++){let U=e[ee];await i._OrtBindInput(q,h[U],T[ee])!==0&&qt(`Can't bind input[${ee}] for session=${t}.`)}for(let ee=0;ee<w;ee++){let U=s[ee];(F=r[ee])!=null&&F[3]?i._OrtBindOutput(q,p[U],C[ee],0)!==0&&qt(`Can't bind pre-allocated output[${ee}] for session=${t}.`):i._OrtBindOutput(q,p[U],0,se[U])!==0&&qt(`Can't bind output[${ee}] to ${oe[ee]} for session=${t}.`)}$l.set(t,[c,h,p,f,g,!0])}(K=i.jsepOnRunStart)==null||K.call(i,c);let te;f?te=await i._OrtRunWithBinding(c,f.handle,w,z,v):te=await i._OrtRun(c,B,O,x,P,w,z,v),te!==0&&qt("failed to call OrtRun().");let Q=[];for(let q=0;q<w;q++){let oe=Number(i.getValue(z+q*o,"*"));if(oe===C[q]){Q.push(r[q]);continue}let se=i.stackSave(),ee=i.stackAlloc(4*o),U=!1,G,Y=0;try{i._OrtGetTensorData(oe,ee,ee+o,ee+2*o,ee+3*o)!==0&&qt(`Can't access output tensor data on index ${q}.`);let ce=o===4?"i32":"i64",pe=Number(i.getValue(ee,ce));Y=i.getValue(ee+o,"*");let J=i.getValue(ee+o*2,"*"),we=Number(i.getValue(ee+o*3,ce)),Be=[];for(let Me=0;Me<we;Me++)Be.push(Number(i.getValue(J+Me*o,ce)));i._OrtFree(J)!==0&&qt("Can't free memory for tensor dims.");let Fe=Be.reduce((Me,Pe)=>Me*Pe,1);G=Xu(pe);let Ve=f==null?void 0:f.outputPreferredLocations[s[q]];if(G==="string"){if(Ve==="gpu-buffer"||Ve==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let Me=[];for(let Pe=0;Pe<Fe;Pe++){let pt=i.getValue(Y+Pe*o,"*"),yt=i.getValue(Y+(Pe+1)*o,"*"),Dt=Pe===Fe-1?void 0:yt-pt;Me.push(i.UTF8ToString(pt,Dt))}Q.push([G,Be,Me,"cpu"])}else if(Ve==="gpu-buffer"&&Fe>0){let Me=i.jsepGetBuffer;if(!Me)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let Pe=Me(Y),pt=Yu(pe,Fe);if(pt===void 0||!JC(G))throw new Error(`Unsupported data type: ${G}`);U=!0,Q.push([G,Be,{gpuBuffer:Pe,download:i.jsepCreateDownloader(Pe,pt,G),dispose:()=>{i._OrtReleaseTensor(oe)!==0&&qt("Can't release tensor.")}},"gpu-buffer"])}else if(Ve==="ml-tensor"&&Fe>0){let Me=i.jsepEnsureTensor;if(!Me)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(Yu(pe,Fe)===void 0||!eT(G))throw new Error(`Unsupported data type: ${G}`);let Pe=await Me(t,Y,pe,Be,!1);U=!0,Q.push([G,Be,{mlTensor:Pe,download:i.jsepCreateMLTensorDownloader(Y,G),dispose:()=>{i.jsepReleaseTensorId(Y),i._OrtReleaseTensor(oe)}},"ml-tensor"])}else{let Me=QC(G),Pe=new Me(Fe);new Uint8Array(Pe.buffer,Pe.byteOffset,Pe.byteLength).set(i.HEAPU8.subarray(Y,Y+Pe.byteLength)),Q.push([G,Be,Pe,"cpu"])}}finally{i.stackRestore(se),G==="string"&&Y&&i._free(Y),U||i._OrtReleaseTensor(oe),(X=i.jsepOnRunEnd)==null||X.call(i,c)}}return f&&!g&&(i._OrtClearBoundOutputs(f.handle)!==0&&qt("Can't clear bound outputs."),$l.set(t,[c,h,p,f,g,!1])),Q}finally{i.stackRestore(A),T.forEach(te=>i._OrtReleaseTensor(te)),C.forEach(te=>i._OrtReleaseTensor(te)),I.forEach(te=>i._free(te)),v!==0&&i._OrtReleaseRunOptions(v),$.forEach(te=>i._free(te))}},xT=t=>{let e=ts(),n=$l.get(t);if(!n)throw new Error("invalid session id");let s=n[0],r=e._OrtEndProfiling(s);r===0&&qt("Can't get an profile file name."),e._OrtFree(r)},wT=t=>{let e=[];for(let n of t){let s=n[2];!Array.isArray(s)&&"buffer"in s&&e.push(s.buffer)}return e}}),Sl,xr,$d,Kp,Xp,Qy,b$,Jy,Vu,Uu,kD,xW,wW,vW,$W,SW,_W,CW,TW=ze(()=>{ei(),bW(),Ac(),XC(),Sl=()=>!!hn.wasm.proxy&&typeof document<"u",$d=!1,Kp=!1,Xp=!1,Jy=new Map,Vu=(t,e)=>{let n=Jy.get(t);n?n.push(e):Jy.set(t,[e])},Uu=()=>{if($d||!Kp||Xp||!xr)throw new Error("worker not ready")},kD=t=>{switch(t.data.type){case"init-wasm":$d=!1,t.data.err?(Xp=!0,b$[1](t.data.err)):(Kp=!0,b$[0]()),Qy&&(URL.revokeObjectURL(Qy),Qy=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let e=Jy.get(t.data.type);t.data.err?e.shift()[1](t.data.err):e.shift()[0](t.data.out);break}}},xW=async()=>{if(!Kp){if($d)throw new Error("multiple calls to 'initWasm()' detected.");if(Xp)throw new Error("previous call to 'initWasm()' failed.");if($d=!0,Sl())return new Promise((t,e)=>{xr==null||xr.terminate(),xP().then(([n,s])=>{var r;try{xr=s,xr.onerror=i=>e(i),xr.onmessage=kD,b$=[t,e];let a={type:"init-wasm",in:hn};!a.in.wasm.wasmPaths&&(n||(r=import.meta.url)!=null&&r.startsWith("file:"))&&(a.in.wasm.wasmPaths={wasm:new URL("/test-onnnx/assets/ort-wasm-simd-threaded.jsep-D5Jk56-t.wasm",import.meta.url).href}),xr.postMessage(a),Qy=n}catch(a){e(a)}},e)});try{await YC(hn.wasm),await fT(hn),Kp=!0}catch(t){throw Xp=!0,t}finally{$d=!1}}},wW=async t=>{if(Sl())return Uu(),new Promise((e,n)=>{Vu("init-ep",[e,n]);let s={type:"init-ep",in:{epName:t,env:hn}};xr.postMessage(s)});await mT(hn,t)},vW=async t=>Sl()?(Uu(),new Promise((e,n)=>{Vu("copy-from",[e,n]);let s={type:"copy-from",in:{buffer:t}};xr.postMessage(s,[t.buffer])})):Q0(t),$W=async(t,e)=>{if(Sl()){if(e!=null&&e.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Uu(),new Promise((n,s)=>{Vu("create",[n,s]);let r={type:"create",in:{model:t,options:{...e}}},a=[];t instanceof Uint8Array&&a.push(t.buffer),xr.postMessage(r,a)})}else return gT(t,e)},SW=async t=>{if(Sl())return Uu(),new Promise((e,n)=>{Vu("release",[e,n]);let s={type:"release",in:t};xr.postMessage(s)});yT(t)},_W=async(t,e,n,s,r,a)=>{if(Sl()){if(n.some(i=>i[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(r.some(i=>i))throw new Error("pre-allocated output tensor is not supported for proxy.");return Uu(),new Promise((i,o)=>{Vu("run",[i,o]);let l=n,c={type:"run",in:{sessionId:t,inputIndices:e,inputs:l,outputIndices:s,options:a}};xr.postMessage(c,wT(l))})}else return bT(t,e,n,s,r,a)},CW=async t=>{if(Sl())return Uu(),new Promise((e,n)=>{Vu("end-profiling",[e,n]);let s={type:"end-profiling",in:t};xr.postMessage(s)});xT(t)}}),x$,ND,kW,h1e=ze(()=>{ei(),TW(),it(),KC(),SP(),x$=(t,e)=>{switch(t.location){case"cpu":return[t.type,t.dims,t.data,"cpu"];case"gpu-buffer":return[t.type,t.dims,{gpuBuffer:t.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[t.type,t.dims,{mlTensor:t.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${t.location} for ${e()}`)}},ND=t=>{switch(t[3]){case"cpu":return new Hr(t[0],t[2],t[1]);case"gpu-buffer":{let e=t[0];if(!JC(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:n,download:s,dispose:r}=t[2];return Hr.fromGpuBuffer(n,{dataType:e,dims:t[1],download:s,dispose:r})}case"ml-tensor":{let e=t[0];if(!eT(e))throw new Error(`not supported data type: ${e} for deserializing MLTensor tensor`);let{mlTensor:n,download:s,dispose:r}=t[2];return Hr.fromMLTensor(n,{dataType:e,dims:t[1],download:s,dispose:r})}default:throw new Error(`invalid data location: ${t[3]}`)}},kW=class{async fetchModelAndCopyToWasmMemory(t){return vW(await tT(t))}async loadModel(t,e){Di();let n;typeof t=="string"?n=await this.fetchModelAndCopyToWasmMemory(t):n=t,[this.sessionId,this.inputNames,this.outputNames]=await $W(n,e),ja()}async dispose(){return SW(this.sessionId)}async run(t,e,n){Di();let s=[],r=[];Object.entries(t).forEach(p=>{let f=p[0],g=p[1],y=this.inputNames.indexOf(f);if(y===-1)throw new Error(`invalid input '${f}'`);s.push(g),r.push(y)});let a=[],i=[];Object.entries(e).forEach(p=>{let f=p[0],g=p[1],y=this.outputNames.indexOf(f);if(y===-1)throw new Error(`invalid output '${f}'`);a.push(g),i.push(y)});let o=s.map((p,f)=>x$(p,()=>`input "${this.inputNames[r[f]]}"`)),l=a.map((p,f)=>p?x$(p,()=>`output "${this.outputNames[i[f]]}"`):null),c=await _W(this.sessionId,r,o,i,l,n),h={};for(let p=0;p<c.length;p++)h[this.outputNames[i[p]]]=a[p]??ND(c[p]);return ja(),h}startProfiling(){}endProfiling(){CW(this.sessionId)}}}),NW={};Zm(NW,{OnnxruntimeWebAssemblyBackend:()=>E2,initializeFlags:()=>I2,wasmBackend:()=>IW});var I2,E2,IW,p1e=ze(()=>{ei(),TW(),h1e(),I2=()=>{if((typeof hn.wasm.initTimeout!="number"||hn.wasm.initTimeout<0)&&(hn.wasm.initTimeout=0),hn.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof hn.wasm.proxy!="boolean"&&(hn.wasm.proxy=!1),typeof hn.wasm.trace!="boolean"&&(hn.wasm.trace=!1),typeof hn.wasm.numThreads!="number"||!Number.isInteger(hn.wasm.numThreads)||hn.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)hn.wasm.numThreads=1;else{let t=typeof navigator>"u"?Zbe("node:os").cpus().length:navigator.hardwareConcurrency;hn.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}},E2=class{async init(t){I2(),await xW(),await wW(t)}async createInferenceSessionHandler(t,e){let n=new kW;return await n.loadModel(t,e),Promise.resolve(n)}},IW=new E2});ei();ei();ei();var f1e="1.21.0";{let t=(p1e(),H0(NW)).wasmBackend;Nd("webgpu",t,5),Nd("webnn",t,5),Nd("cpu",t,10),Nd("wasm",t,10)}Object.defineProperty(hn.versions,"web",{value:f1e,enumerable:!0});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function m1e(){return await Xx.create("https://dmitriywolf.github.io/test-onnnx/models/detector_documents_leyolo_n.onnx",{executionProviders:["wasm"]})}const g1e=t=>new Promise(e=>setTimeout(e,t)),y1e=()=>performance.memory?+(performance.memory.usedJSHeapSize/1024/1024).toFixed(2):null;function b1e(){const t=Ce.useRef(null),e=Ce.useRef(new Float32Array(1*3*320*320)),n=Ce.useRef(!1),s=Ce.useRef(null),[r,a]=Ce.useState(0),[i,o]=Ce.useState(0),[l,c]=Ce.useState(0);return Ce.useEffect(()=>{n.current=!1;async function h(){if(!(n.current||!t.current)){try{const f=new Hr("float32",e.current,[1,3,320,320]),g=performance.now();let y=await t.current.run({images:f});const x=performance.now();for(const $ in y)y[$]=null;y=null;const w=+(x-g).toFixed(2),v=y1e();a($=>$+1),o(w),v!==null&&c(v)}catch(f){console.error("Inference error:",f)}await g1e(200),s.current=requestAnimationFrame(h)}}async function p(){t.current=await m1e(),n.current||h()}return p(),()=>{n.current=!0,s.current&&cancelAnimationFrame(s.current),t.current=null}},[]),Kt.jsxs("div",{children:[Kt.jsx("p",{children:"ONNX MODEL TEST"}),Kt.jsxs("p",{children:["Inference #: ",r]}),Kt.jsxs("p",{children:["Last Inference Time: ",i," ms"]}),Kt.jsxs("p",{children:["Used JS Heap: ",l," MB"]})]})}async function x1e(){return await Xx.create("https://dmitriywolf.github.io/test-onnnx/models/model.onnx",{executionProviders:["wasm"]})}const w1e=t=>new Promise(e=>setTimeout(e,t)),v1e=()=>performance.memory?+(performance.memory.usedJSHeapSize/1024/1024).toFixed(2):null;function $1e(){const t=Ce.useRef(null),e=Ce.useRef(Float32Array.from([1,2,3,4,5,6,7,8,9,10,11,12])),n=Ce.useRef(Float32Array.from([1,2,3,4,5,6,7,8,9,10,11,12])),s=Ce.useRef(!1),r=Ce.useRef(null),[a,i]=Ce.useState(0),[o,l]=Ce.useState(0),[c,h]=Ce.useState(0);return Ce.useEffect(()=>{s.current=!1;async function p(){if(!(s.current||!t.current)){try{const g=new Hr("float32",e.current,[3,4]),y=new Hr("float32",n.current,[4,3]),x={a:g,b:y},w=performance.now();let v=await t.current.run(x);const $=performance.now();for(const I in v)v[I]=null;v=null;const T=+($-w).toFixed(2),C=v1e();i(I=>I+1),l(T),C!==null&&h(C)}catch(g){console.error("Inference error:",g)}await w1e(200),r.current=requestAnimationFrame(p)}}async function f(){t.current=await x1e(),s.current||p()}return f(),()=>{s.current=!0,r.current&&cancelAnimationFrame(r.current),t.current=null}},[]),Kt.jsxs("div",{children:[Kt.jsx("p",{children:"ONNX LIGHT MODEL TEST"}),Kt.jsxs("p",{children:["Inference #: ",a]}),Kt.jsxs("p",{children:["Last Inference Time: ",o," ms"]}),Kt.jsxs("p",{children:["Used JS Heap: ",c," MB"]})]})}function S1e(){const[t,e]=Ce.useState("home"),n=()=>{switch(t){case"home":return Kt.jsx(sI,{});case"tensor":return Kt.jsx(jbe,{});case"onnx":return Kt.jsx(b1e,{});case"onnx-light":return Kt.jsx($1e,{});default:return Kt.jsx(sI,{})}};return Kt.jsxs("div",{children:[Kt.jsxs("nav",{style:{display:"flex",gap:"1rem",marginBottom:"1rem"},children:[Kt.jsx("button",{onClick:()=>e("home"),children:"Home"}),Kt.jsx("button",{onClick:()=>e("tensor"),children:"TensorFlow"}),Kt.jsx("button",{onClick:()=>e("onnx"),children:"ONNX"}),Kt.jsx("button",{onClick:()=>e("onnx-light"),children:"ONNX LIGHT FROM DOC"})]}),Kt.jsx("div",{children:n()})]})}ZG.createRoot(document.getElementById("root")).render(Kt.jsx(c6,{children:Kt.jsx(S1e,{})}));
